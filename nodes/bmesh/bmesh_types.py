# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

import bpy,bmesh,mathutils
from bpy.props import EnumProperty, FloatProperty
from sverchok.node_tree import SverchCustomTreeNode
from sverchok.data_structure import (updateNode, enum_item as e, second_as_first_cycle as safc,match_long_repeat)

dict_bmesh ={"Base Mesh Type": {"bmesh.types.BMesh": ["The BMesh data structure\n", {"calc_loop_triangles()": ["Calculate triangle tessellation from quads/ngons.\n", [], [], "Returns\nThe triangulated faces.\nReturn type\nlist of BMLoop tuples\n"], "calc_volume()": ["Calculate mesh volume based on face normals.\n", ["signed"], ["signed (bool) \u2013 when signed is true, negative values may be returned.\n"], "Returns\nThe volume of the mesh.\nReturn type\nfloat\n"], "clear()": ["Clear all mesh data.\n", [], [], "None"], "copy()": ["", [], [], "Returns\nA copy of this BMesh.\nReturn type\nBMesh\n"], "free()": ["Explicitly free the BMesh data from memory, causing exceptions on further access.\nNote\nThe BMesh is freed automatically, typically when the script finishes executing. However in some cases its hard to predict when this will be and its useful to explicitly free the data.\n", [], [], "None"], "from_mesh()": ["Initialize this bmesh from existing mesh datablock.\n", ["mesh", "face_normals", "vertex_normals", "use_shape_key", "shape_key_index"], ["mesh (Mesh) \u2013 The mesh data to load.\n", "None", "None", "use_shape_key (boolean) \u2013 Use the locations from a shape key.\n", "shape_key_index (int) \u2013 The shape key index to use.\n"], "None"], "from_object()": ["Initialize this bmesh from existing object data-block (only meshes are currently supported).\n", ["object", "depsgraph", "cage", "face_normals", "vertex_normals"], ["object (Object) \u2013 The object data to load.\n", "None", "cage (boolean) \u2013 Get the mesh as a deformed cage.\n", "face_normals (boolean) \u2013 Calculate face normals.\n", "vertex_normals (boolean) \u2013 Calculate vertex normals.\n"], "None"], "normal_update()": ["Update normals of mesh faces and verts.\nNote\nThe normal of any vertex where is_wire is True will be a zero vector.\n", [], [], "None"], "select_flush()": ["Flush selection, independent of the current selection mode.\n", ["select"], ["select (boolean) \u2013 flush selection or de-selected elements.\n"], "None"], "select_flush_mode()": ["flush selection based on the current mode current BMesh.select_mode.\n", [], [], "None"], "to_mesh()": ["Writes this BMesh data into an existing Mesh datablock.\n", ["mesh"], ["mesh (Mesh) \u2013 The mesh data to write into.\n"], "None"], "transform()": ["Transform the mesh (optionally filtering flagged data only).\n", ["matrix", "filter"], ["matrix (4x4 mathutils.Matrix) \u2013 transform matrix.\n", "filter (set) \u2013 set of values in (\u2018SELECT\u2019, \u2018HIDE\u2019, \u2018SEAM\u2019, \u2018SMOOTH\u2019, \u2018TAG\u2019).\n"], "None"], "edges": ["This meshes edge sequence (read-only).\n", [], [], "Type\nBMEdgeSeq\n"], "faces": ["This meshes face sequence (read-only).\n", [], [], "Type\nBMFaceSeq\n"], "is_valid": ["True when this element is valid (hasn\u2019t been removed).\n", [], [], "Type\nboolean\n"], "is_wrapped": ["True when this mesh is owned by blender (typically the editmode BMesh).\n", [], [], "Type\nboolean\n"], "loops": ["This meshes loops (read-only).\n", [], [], "Type\nBMLoopSeq\nNote\nLoops must be accessed via faces, this is only exposed for layer access.\n"], "select_history": ["Sequence of selected items (the last is displayed as active).\n", [], [], "Type\nBMEditSelSeq\n"], "select_mode": ["The selection mode, values can be {\u2018VERT\u2019, \u2018EDGE\u2019, \u2018FACE\u2019}, can\u2019t be assigned an empty set.\n", [], [], "Type\nset\n"], "verts": ["This meshes vert sequence (read-only).\n", [], [], "Type\nBMVertSeq\n"]}]}, "Mesh Elements": {"bmesh.types.BMVert": ["The BMesh vertex type\n", {"calc_edge_angle()": ["Return the angle between this vert\u2019s two connected edges.\n", ["fallback"], ["fallback (any) \u2013 return this when the vert doesn\u2019t have 2 edges (instead of raising a ValueError).\n"], "Returns\nAngle between edges in radians.\nReturn type\nfloat\n"], "calc_shell_factor()": ["Return a multiplier calculated based on the sharpness of the vertex. Where a flat surface gives 1.0, and higher values sharper edges. This is used to maintain shell thickness when offsetting verts along their normals.\n", [], [], "Returns\noffset multiplier\nReturn type\nfloat\n"], "copy_from()": ["Copy values from another element of matching type.\n", ["other"], [], "None"], "copy_from_face_interp()": ["Interpolate the customdata from a face onto this loop (the loops vert should overlap the face).\n", ["face"], ["face (BMFace) \u2013 The face to interpolate data from.\n"], "None"], "copy_from_vert_interp()": ["Interpolate the customdata from a vert between 2 other verts.\n", ["vert_pair", "fac"], ["vert_pair (BMVert) \u2013 The vert to interpolate data from.\n", "None"], "None"], "hide_set()": ["Set the hide state. This is different from the hide attribute because it updates the selection and hide state of associated geometry.\n", ["hide"], ["hide (boolean) \u2013 Hidden or visible.\n"], "None"], "normal_update()": ["Update vertex normal. This does not update the normals of adjoining faces.\nNote\nThe vertex normal will be a zero vector if vertex is_wire is True.\n", [], [], "None"], "select_set()": ["Set the selection. This is different from the select attribute because it updates the selection state of associated geometry.\n", ["select"], ["select (boolean) \u2013 Select or de-select.\n"], "None"], "co": ["The coordinates for this vertex as a 3D, wrapped vector.\n", [], [], "Type\nmathutils.Vector\n"], "hide": ["Hidden state of this element.\n", [], [], "Type\nboolean\n"], "index": ["Index of this element.\n", [], [], "Type\nint\nNote\nThis value is not necessarily valid, while editing the mesh it can become dirty.\nIt\u2019s also possible to assign any number to this attribute for a scripts internal logic.\nTo ensure the value is up to date - see BMElemSeq.index_update.\n"], "is_boundary": ["True when this vertex is connected to boundary edges (read-only).\n", [], [], "Type\nboolean\n"], "is_manifold": ["True when this vertex is manifold (read-only).\n", [], [], "Type\nboolean\n"], "is_valid": ["True when this element is valid (hasn\u2019t been removed).\n", [], [], "Type\nboolean\n"], "is_wire": ["True when this vertex is not connected to any faces (read-only).\n", [], [], "Type\nboolean\n"], "link_edges": ["Edges connected to this vertex (read-only).\n", [], [], "Type\nBMElemSeq of BMEdge\n"], "link_faces": ["Faces connected to this vertex (read-only).\n", [], [], "Type\nBMElemSeq of BMFace\n"], "link_loops": ["Loops that use this vertex (read-only).\n", [], [], "Type\nBMElemSeq of BMLoop\n"], "normal": ["The normal for this vertex as a 3D, wrapped vector.\n", [], [], "Type\nmathutils.Vector\n"], "select": ["Selected state of this element.\n", [], [], "Type\nboolean\n"], "tag": ["Generic attribute scripts can use for own logic\n", [], [], "Type\nboolean\n"]}], "bmesh.types.BMEdge": ["The BMesh edge connecting 2 verts\n", {"calc_face_angle()": ["None", ["fallback"], ["fallback (any) \u2013 return this when the edge doesn\u2019t have 2 faces (instead of raising a ValueError).\n"], "Returns\nThe angle between 2 connected faces in radians.\nReturn type\nfloat\n"], "calc_face_angle_signed()": ["None", ["fallback"], ["fallback (any) \u2013 return this when the edge doesn\u2019t have 2 faces (instead of raising a ValueError).\n"], "Returns\nThe angle between 2 connected faces in radians (negative for concave join).\nReturn type\nfloat\n"], "calc_length()": ["", [], [], "Returns\nThe length between both verts.\nReturn type\nfloat\n"], "calc_tangent()": ["Return the tangent at this edge relative to a face (pointing inward into the face). This uses the face normal for calculation.\n", ["loop"], ["loop (BMLoop) \u2013 The loop used for tangent calculation.\n"], "Returns\na normalized vector.\nReturn type\nmathutils.Vector\n"], "copy_from()": ["Copy values from another element of matching type.\n", ["other"], [], "None"], "hide_set()": ["Set the hide state. This is different from the hide attribute because it updates the selection and hide state of associated geometry.\n", ["hide"], ["hide (boolean) \u2013 Hidden or visible.\n"], "None"], "normal_update()": ["Update normals of all connected faces and the edge verts.\nNote\nThe normal of edge vertex will be a zero vector if vertex is_wire is True.\n", [], [], "None"], "other_vert()": ["Return the other vertex on this edge or None if the vertex is not used by this edge.\n", ["vert"], ["vert (BMVert) \u2013 a vert in this edge.\n"], "Returns\nThe edges other vert.\nReturn type\nBMVert or None\n"], "select_set()": ["Set the selection. This is different from the select attribute because it updates the selection state of associated geometry.\n", ["select"], ["select (boolean) \u2013 Select or de-select.\n"], "None"], "hide": ["Hidden state of this element.\n", [], [], "Type\nboolean\n"], "index": ["Index of this element.\n", [], [], "Type\nint\nNote\nThis value is not necessarily valid, while editing the mesh it can become dirty.\nIt\u2019s also possible to assign any number to this attribute for a scripts internal logic.\nTo ensure the value is up to date - see BMElemSeq.index_update.\n"], "is_boundary": ["True when this edge is at the boundary of a face (read-only).\n", [], [], "Type\nboolean\n"], "is_contiguous": ["True when this edge is manifold, between two faces with the same winding (read-only).\n", [], [], "Type\nboolean\n"], "is_convex": ["True when this edge joins two convex faces, depends on a valid face normal (read-only).\n", [], [], "Type\nboolean\n"], "is_manifold": ["True when this edge is manifold (read-only).\n", [], [], "Type\nboolean\n"], "is_valid": ["True when this element is valid (hasn\u2019t been removed).\n", [], [], "Type\nboolean\n"], "is_wire": ["True when this edge is not connected to any faces (read-only).\n", [], [], "Type\nboolean\n"], "link_faces": ["Faces connected to this edge, (read-only).\n", [], [], "Type\nBMElemSeq of BMFace\n"], "link_loops": ["Loops connected to this edge, (read-only).\n", [], [], "Type\nBMElemSeq of BMLoop\n"], "seam": ["Seam for UV unwrapping.\n", [], [], "Type\nboolean\n"], "select": ["Selected state of this element.\n", [], [], "Type\nboolean\n"], "smooth": ["Smooth state of this element.\n", [], [], "Type\nboolean\n"], "tag": ["Generic attribute scripts can use for own logic\n", [], [], "Type\nboolean\n"], "verts": ["Verts this edge uses (always 2), (read-only).\n", [], [], "Type\nBMElemSeq of BMVert\n"]}], "bmesh.types.BMFace": ["The BMesh face with 3 or more sides\n", {"calc_area()": ["Return the area of the face.\n", [], [], "Returns\nReturn the area of the face.\nReturn type\nfloat\n"], "calc_center_bounds()": ["Return bounds center of the face.\n", [], [], "Returns\na 3D vector.\nReturn type\nmathutils.Vector\n"], "calc_center_median()": ["Return median center of the face.\n", [], [], "Returns\na 3D vector.\nReturn type\nmathutils.Vector\n"], "calc_center_median_weighted()": ["Return median center of the face weighted by edge lengths.\n", [], [], "Returns\na 3D vector.\nReturn type\nmathutils.Vector\n"], "calc_perimeter()": ["Return the perimeter of the face.\n", [], [], "Returns\nReturn the perimeter of the face.\nReturn type\nfloat\n"], "calc_tangent_edge()": ["Return face tangent based on longest edge.\n", [], [], "Returns\na normalized vector.\nReturn type\nmathutils.Vector\n"], "calc_tangent_edge_diagonal()": ["Return face tangent based on the edge farthest from any vertex.\n", [], [], "Returns\na normalized vector.\nReturn type\nmathutils.Vector\n"], "calc_tangent_edge_pair()": ["Return face tangent based on the two longest disconnected edges.\nTris: Use the edge pair with the most similar lengths.\nQuads: Use the longest edge pair.\nNGons: Use the two longest disconnected edges.\n", [], [], "Returns\na normalized vector.\nReturn type\nmathutils.Vector\n"], "calc_tangent_vert_diagonal()": ["Return face tangent based on the two most distant vertices.\n", [], [], "Returns\na normalized vector.\nReturn type\nmathutils.Vector\n"], "copy()": ["Make a copy of this face.\n", ["verts", "edges"], ["verts (boolean) \u2013 When set, the faces verts will be duplicated too.\n", "edges (boolean) \u2013 When set, the faces edges will be duplicated too.\n"], "Returns\nThe newly created face.\nReturn type\nBMFace\n"], "copy_from()": ["Copy values from another element of matching type.\n", ["other"], [], "None"], "copy_from_face_interp()": ["Interpolate the customdata from another face onto this one (faces should overlap).\n", ["face", "vert"], ["face (BMFace) \u2013 The face to interpolate data from.\n", "vert (boolean) \u2013 When True, also copy vertex data.\n"], "None"], "hide_set()": ["Set the hide state. This is different from the hide attribute because it updates the selection and hide state of associated geometry.\n", ["hide"], ["hide (boolean) \u2013 Hidden or visible.\n"], "None"], "normal_flip()": ["Reverses winding of a face, which flips its normal.\n", [], [], "None"], "normal_update()": ["Update face normal based on the positions of the face verts. This does not update the normals of face verts.\n", [], [], "None"], "select_set()": ["Set the selection. This is different from the select attribute because it updates the selection state of associated geometry.\n", ["select"], ["select (boolean) \u2013 Select or de-select.\n"], "None"], "edges": ["Edges of this face, (read-only).\n", [], [], "Type\nBMElemSeq of BMEdge\n"], "hide": ["Hidden state of this element.\n", [], [], "Type\nboolean\n"], "index": ["Index of this element.\n", [], [], "Type\nint\nNote\nThis value is not necessarily valid, while editing the mesh it can become dirty.\nIt\u2019s also possible to assign any number to this attribute for a scripts internal logic.\nTo ensure the value is up to date - see BMElemSeq.index_update.\n"], "is_valid": ["True when this element is valid (hasn\u2019t been removed).\n", [], [], "Type\nboolean\n"], "loops": ["Loops of this face, (read-only).\n", [], [], "Type\nBMElemSeq of BMLoop\n"], "material_index": ["The face\u2019s material index.\n", [], [], "Type\nint\n"], "normal": ["The normal for this face as a 3D, wrapped vector.\n", [], [], "Type\nmathutils.Vector\n"], "select": ["Selected state of this element.\n", [], [], "Type\nboolean\n"], "smooth": ["Smooth state of this element.\n", [], [], "Type\nboolean\n"], "tag": ["Generic attribute scripts can use for own logic\n", [], [], "Type\nboolean\n"], "verts": ["Verts of this face, (read-only).\n", [], [], "Type\nBMElemSeq of BMVert\n"]}], "bmesh.types.BMLoop": ["This is normally accessed from BMFace.loops where each face loop represents a corner of the face.\n", {"calc_angle()": ["Return the angle at this loops corner of the face. This is calculated so sharper corners give lower angles.\n", [], [], "Returns\nThe angle in radians.\nReturn type\nfloat\n"], "calc_normal()": ["Return normal at this loops corner of the face. Falls back to the face normal for straight lines.\n", [], [], "Returns\na normalized vector.\nReturn type\nmathutils.Vector\n"], "calc_tangent()": ["Return the tangent at this loops corner of the face (pointing inward into the face). Falls back to the face normal for straight lines.\n", [], [], "Returns\na normalized vector.\nReturn type\nmathutils.Vector\n"], "copy_from()": ["Copy values from another element of matching type.\n", ["other"], [], "None"], "copy_from_face_interp()": ["Interpolate the customdata from a face onto this loop (the loops vert should overlap the face).\n", ["face", "vert", "multires"], ["face (BMFace) \u2013 The face to interpolate data from.\n", "vert (boolean) \u2013 When enabled, interpolate the loops vertex data (optional).\n", "multires (boolean) \u2013 When enabled, interpolate the loops multires data (optional).\n"], "None"], "edge": ["The loop\u2019s edge (between this loop and the next), (read-only).\n", [], [], "Type\nBMEdge\n"], "face": ["The face this loop makes (read-only).\n", [], [], "Type\nBMFace\n"], "index": ["Index of this element.\n", [], [], "Type\nint\nNote\nThis value is not necessarily valid, while editing the mesh it can become dirty.\nIt\u2019s also possible to assign any number to this attribute for a scripts internal logic.\nTo ensure the value is up to date - see BMElemSeq.index_update.\n"], "is_convex": ["True when this loop is at the convex corner of a face, depends on a valid face normal (read-only).\n", [], [], "Type\nboolean\n"], "is_valid": ["True when this element is valid (hasn\u2019t been removed).\n", [], [], "Type\nboolean\n"], "link_loop_next": ["The next face corner (read-only).\n", [], [], "Type\nBMLoop\n"], "link_loop_prev": ["The previous face corner (read-only).\n", [], [], "Type\nBMLoop\n"], "link_loop_radial_next": ["The next loop around the edge (read-only).\n", [], [], "Type\nBMLoop\n"], "link_loop_radial_prev": ["The previous loop around the edge (read-only).\n", [], [], "Type\nBMLoop\n"], "link_loops": ["Loops connected to this loop, (read-only).\n", [], [], "Type\nBMElemSeq of BMLoop\n"], "tag": ["Generic attribute scripts can use for own logic\n", [], [], "Type\nboolean\n"], "vert": ["The loop\u2019s vertex (read-only).\n", [], [], "Type\nBMVert\n"]}]}, "Sequence Accessors": {"bmesh.types.BMElemSeq": ["General sequence type used for accessing any sequence of BMVert, BMEdge, BMFace, BMLoop.\nWhen accessed via BMesh.verts, BMesh.edges, BMesh.faces there are also functions to create/remove items.\n", {"index_update()": ["Initialize the index values of this sequence.\nThis is the equivalent of looping over all elements and assigning the index values.\nfor index, ele in enumerate(sequence):\n    ele.index = index\nNote\nRunning this on sequences besides BMesh.verts, BMesh.edges, BMesh.faces works but won\u2019t result in each element having a valid index, instead its order in the sequence will be set.\n", [], [], "None"]}], "bmesh.types.BMVertSeq": ["", {"ensure_lookup_table()": ["Ensure internal data needed for int subscription is initialized with verts/edges/faces, eg bm.verts[index].\nThis needs to be called again after adding/removing data in this sequence.\n", [], [], "None"], "index_update()": ["Initialize the index values of this sequence.\nThis is the equivalent of looping over all elements and assigning the index values.\nfor index, ele in enumerate(sequence):\n    ele.index = index\nNote\nRunning this on sequences besides BMesh.verts, BMesh.edges, BMesh.faces works but won\u2019t result in each element having a valid index, instead its order in the sequence will be set.\n", [], [], "None"], "new()": ["Create a new vertex.\n", ["co", "0.0", "0.0"], ["co (float triplet) \u2013 The initial location of the vertex (optional argument).\n", "None", "None"], "Returns\nThe newly created edge.\nReturn type\nBMVert\n"], "remove()": ["Remove a vert.\n", ["vert"], [], "None"], "sort()": ["Sort the elements of this sequence, using an optional custom sort key. Indices of elements are not changed, BMElemeSeq.index_update() can be used for that.\n", ["key", "reverse"], ["key \u2013 The key that sets the ordering of the elements.\n", "reverse \u2013 Reverse the order of the elements\n"], "None"], "layers": ["custom-data layers (read-only).\n", [], [], "Type\nBMLayerAccessVert\n"]}], "bmesh.types.BMEdgeSeq": ["", {"ensure_lookup_table()": ["Ensure internal data needed for int subscription is initialized with verts/edges/faces, eg bm.verts[index].\nThis needs to be called again after adding/removing data in this sequence.\n", [], [], "None"], "get()": ["Return an edge which uses the verts passed.\n", ["verts", "fallback"], ["verts (BMVert) \u2013 Sequence of verts.\n", "fallback \u2013 Return this value if nothing is found.\n"], "Returns\nThe edge found or None\nReturn type\nBMEdge\n"], "index_update()": ["Initialize the index values of this sequence.\nThis is the equivalent of looping over all elements and assigning the index values.\nfor index, ele in enumerate(sequence):\n    ele.index = index\nNote\nRunning this on sequences besides BMesh.verts, BMesh.edges, BMesh.faces works but won\u2019t result in each element having a valid index, instead its order in the sequence will be set.\n", [], [], "None"], "new()": ["Create a new edge from a given pair of verts.\n", ["verts", "example"], ["verts (pair of BMVert) \u2013 Vertex pair.\n", "example (BMEdge) \u2013 Existing edge to initialize settings (optional argument).\n"], "Returns\nThe newly created edge.\nReturn type\nBMEdge\n"], "remove()": ["Remove an edge.\n", ["edge"], [], "None"], "sort()": ["Sort the elements of this sequence, using an optional custom sort key. Indices of elements are not changed, BMElemeSeq.index_update() can be used for that.\n", ["key", "reverse"], ["key \u2013 The key that sets the ordering of the elements.\n", "reverse \u2013 Reverse the order of the elements\n"], "None"], "layers": ["custom-data layers (read-only).\n", [], [], "Type\nBMLayerAccessEdge\n"]}], "bmesh.types.BMFaceSeq": ["", {"ensure_lookup_table()": ["Ensure internal data needed for int subscription is initialized with verts/edges/faces, eg bm.verts[index].\nThis needs to be called again after adding/removing data in this sequence.\n", [], [], "None"], "get()": ["Return a face which uses the verts passed.\n", ["verts", "fallback"], ["verts (BMVert) \u2013 Sequence of verts.\n", "fallback \u2013 Return this value if nothing is found.\n"], "Returns\nThe face found or None\nReturn type\nBMFace\n"], "index_update()": ["Initialize the index values of this sequence.\nThis is the equivalent of looping over all elements and assigning the index values.\nfor index, ele in enumerate(sequence):\n    ele.index = index\nNote\nRunning this on sequences besides BMesh.verts, BMesh.edges, BMesh.faces works but won\u2019t result in each element having a valid index, instead its order in the sequence will be set.\n", [], [], "None"], "new()": ["Create a new face from a given set of verts.\n", ["verts", "example"], ["verts (BMVert) \u2013 Sequence of 3 or more verts.\n", "example (BMFace) \u2013 Existing face to initialize settings (optional argument).\n"], "Returns\nThe newly created face.\nReturn type\nBMFace\n"], "remove()": ["Remove a face.\n", ["face"], [], "None"], "sort()": ["Sort the elements of this sequence, using an optional custom sort key. Indices of elements are not changed, BMElemeSeq.index_update() can be used for that.\n", ["key", "reverse"], ["key \u2013 The key that sets the ordering of the elements.\n", "reverse \u2013 Reverse the order of the elements\n"], "None"], "active": ["active face.\n", [], [], "Type\nBMFace or None\n"], "layers": ["custom-data layers (read-only).\n", [], [], "Type\nBMLayerAccessFace\n"]}], "bmesh.types.BMLoopSeq": ["", {"layers": ["custom-data layers (read-only).\n", [], [], "Type\nBMLayerAccessLoop\n"]}], "bmesh.types.BMIter": ["None", {}]}, "Selection History": {"bmesh.types.BMEditSelSeq": ["", {"add()": ["Add an element to the selection history (no action taken if its already added).\n", ["element"], [], "None"], "clear()": ["Empties the selection history.\n", [], [], "None"], "discard()": ["Discard an element from the selection history.\nLike remove but doesn\u2019t raise an error when the elements not in the selection list.\n", ["element"], [], "None"], "remove()": ["Remove an element from the selection history.\n", ["element"], [], "None"], "validate()": ["Ensures all elements in the selection history are selected.\n", [], [], "None"], "active": ["The last selected element or None (read-only).\n", [], [], "Type\nBMVert, BMEdge or BMFace\n"]}], "bmesh.types.BMEditSelIter": ["None", {}]}, "Custom-Data Layer Access": {"bmesh.types.BMLayerAccessVert": ["Exposes custom-data layer attributes.\n", {"bevel_weight": ["Bevel weight float in [0 - 1].\n", [], [], "Type\nBMLayerCollection\n"], "color\uf0c1()": ["Generic RGBA color with 8-bit precision custom-data layer.\ntype: BMLayerCollection\n", ["color\uf0c1"], [], "None"], "crease": ["Crease for subdivision surface - float in [0 - 1].\n", [], [], "Type\nBMLayerCollection\n"], "deform\uf0c1()": ["Vertex deform weight BMDeformVert (TODO).\ntype: BMLayerCollection\n", ["deform\uf0c1"], [], "None"], "float\uf0c1()": ["Generic float custom-data layer.\ntype: BMLayerCollection\n", ["float\uf0c1"], [], "None"], "float_color\uf0c1()": ["Generic RGBA color with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_color\uf0c1"], [], "None"], "float_vector\uf0c1()": ["Generic 3D vector with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_vector\uf0c1"], [], "None"], "int\uf0c1()": ["Generic int custom-data layer.\ntype: BMLayerCollection\n", ["int\uf0c1"], [], "None"], "paint_mask\uf0c1()": ["Accessor for paint mask layer.\ntype: BMLayerCollection\n", ["paint_mask\uf0c1"], [], "None"], "shape": ["Vertex shapekey absolute location (as a 3D Vector).\n", [], [], "Type\nBMLayerCollection\n"], "skin\uf0c1()": ["Accessor for skin layer.\ntype: BMLayerCollection\n", ["skin\uf0c1"], [], "None"], "string\uf0c1()": ["Generic string custom-data layer (exposed as bytes, 255 max length).\ntype: BMLayerCollection\n", ["string\uf0c1"], [], "None"]}], "bmesh.types.BMLayerAccessEdge": ["Exposes custom-data layer attributes.\n", {"bevel_weight": ["Bevel weight float in [0 - 1].\n", [], [], "Type\nBMLayerCollection\n"], "color\uf0c1()": ["Generic RGBA color with 8-bit precision custom-data layer.\ntype: BMLayerCollection\n", ["color\uf0c1"], [], "None"], "crease": ["Crease for subdivision surface - float in [0 - 1].\n", [], [], "Type\nBMLayerCollection\n"], "float\uf0c1()": ["Generic float custom-data layer.\ntype: BMLayerCollection\n", ["float\uf0c1"], [], "None"], "float_color\uf0c1()": ["Generic RGBA color with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_color\uf0c1"], [], "None"], "float_vector\uf0c1()": ["Generic 3D vector with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_vector\uf0c1"], [], "None"], "freestyle\uf0c1()": ["Accessor for Freestyle edge layer.\ntype: BMLayerCollection\n", ["freestyle\uf0c1"], [], "None"], "int\uf0c1()": ["Generic int custom-data layer.\ntype: BMLayerCollection\n", ["int\uf0c1"], [], "None"], "string\uf0c1()": ["Generic string custom-data layer (exposed as bytes, 255 max length).\ntype: BMLayerCollection\n", ["string\uf0c1"], [], "None"]}], "bmesh.types.BMLayerAccessFace": ["Exposes custom-data layer attributes.\n", {"color\uf0c1()": ["Generic RGBA color with 8-bit precision custom-data layer.\ntype: BMLayerCollection\n", ["color\uf0c1"], [], "None"], "face_map\uf0c1()": ["FaceMap custom-data layer.\ntype: BMLayerCollection\n", ["face_map\uf0c1"], [], "None"], "float\uf0c1()": ["Generic float custom-data layer.\ntype: BMLayerCollection\n", ["float\uf0c1"], [], "None"], "float_color\uf0c1()": ["Generic RGBA color with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_color\uf0c1"], [], "None"], "float_vector\uf0c1()": ["Generic 3D vector with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_vector\uf0c1"], [], "None"], "freestyle\uf0c1()": ["Accessor for Freestyle face layer.\ntype: BMLayerCollection\n", ["freestyle\uf0c1"], [], "None"], "int\uf0c1()": ["Generic int custom-data layer.\ntype: BMLayerCollection\n", ["int\uf0c1"], [], "None"], "string\uf0c1()": ["Generic string custom-data layer (exposed as bytes, 255 max length).\ntype: BMLayerCollection\n", ["string\uf0c1"], [], "None"]}], "bmesh.types.BMLayerAccessLoop": ["Exposes custom-data layer attributes.\n", {"color\uf0c1()": ["Generic RGBA color with 8-bit precision custom-data layer.\ntype: BMLayerCollection\n", ["color\uf0c1"], [], "None"], "float\uf0c1()": ["Generic float custom-data layer.\ntype: BMLayerCollection\n", ["float\uf0c1"], [], "None"], "float_color\uf0c1()": ["Generic RGBA color with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_color\uf0c1"], [], "None"], "float_vector\uf0c1()": ["Generic 3D vector with float precision custom-data layer.\ntype: BMLayerCollection\n", ["float_vector\uf0c1"], [], "None"], "int\uf0c1()": ["Generic int custom-data layer.\ntype: BMLayerCollection\n", ["int\uf0c1"], [], "None"], "string\uf0c1()": ["Generic string custom-data layer (exposed as bytes, 255 max length).\ntype: BMLayerCollection\n", ["string\uf0c1"], [], "None"], "uv\uf0c1()": ["Accessor for BMLoopUV UV (as a 2D Vector).\ntype: BMLayerCollection\n", ["uv\uf0c1"], [], "None"]}], "bmesh.types.BMLayerCollection": ["Gives access to a collection of custom-data layers of the same type and behaves like python dictionaries, except for the ability to do list like index access.\n", {"get()": ["Returns the value of the layer matching the key or default when not found (matches pythons dictionary function of the same name).\n", ["key", "default"], ["key (string) \u2013 The key associated with the layer.\n", "default (Undefined) \u2013 Optional argument for the value to return if key is not found.\n"], "None"], "items()": ["Return the identifiers of collection members (matching pythons dict.items() functionality).\n", [], [], "Returns\n(key, value) pairs for each member of this collection.\nReturn type\nlist of tuples\n"], "keys()": ["Return the identifiers of collection members (matching pythons dict.keys() functionality).\n", [], [], "Returns\nthe identifiers for each member of this collection.\nReturn type\nlist of strings\n"], "new()": ["Create a new layer\n", ["name"], ["name (string) \u2013 Optional name argument (will be made unique).\n"], "Returns\nThe newly created layer.\nReturn type\nBMLayerItem\n"], "remove()": ["Remove a layer\n", ["layer"], ["layer (BMLayerItem) \u2013 The layer to remove.\n"], "None"], "values()": ["Return the values of collection (matching pythons dict.values() functionality).\n", [], [], "Returns\nthe members of this collection.\nReturn type\nlist\n"], "verify()": ["Create a new layer or return an existing active layer\n", [], [], "Returns\nThe newly verified layer.\nReturn type\nBMLayerItem\n"], "active": ["The active layer of this type (read-only).\n", [], [], "Type\nBMLayerItem\n"], "is_singleton": ["True if there can exists only one layer of this type (read-only).\n", [], [], "Type\nboolean\n"]}], "bmesh.types.BMLayerItem": ["Exposes a single custom data layer, their main purpose is for use as item accessors to custom-data when used with vert/edge/face/loop data.\n", {"copy_from()": ["Return a copy of the layer\n", ["other"], ["other \u2013 BMLayerItem\n"], "None"], "name": ["The layers unique name (read-only).\n", [], [], "Type\nstring\n"]}]}, "Custom-Data Layer Types": {"bmesh.types.BMLoopUV": ["", {"pin_uv": ["UV pin state.\n", [], [], "Type\nboolean\n"], "select": ["UV select state.\n", [], [], "Type\nboolean\n"], "select_edge": ["UV edge select state.\n", [], [], "Type\nboolean\n"], "uv": ["Loops UV (as a 2D Vector).\n", [], [], "Type\nmathutils.Vector\n"]}], "bmesh.types.BMDeformVert": ["", {"clear()": ["Clears all weights.\n", [], [], "None"], "get()": ["Returns the deform weight matching the key or default when not found (matches pythons dictionary function of the same name).\n", ["key", "default"], ["key (int) \u2013 The key associated with deform weight.\n", "default (Undefined) \u2013 Optional argument for the value to return if key is not found.\n"], "None"], "items()": ["Return (group, weight) pairs for this vertex (matching pythons dict.items() functionality).\n", [], [], "Returns\n(key, value) pairs for each deform weight of this vertex.\nReturn type\nlist of tuples\n"], "keys()": ["Return the group indices used by this vertex (matching pythons dict.keys() functionality).\n", [], [], "Returns\nthe deform group this vertex uses\nReturn type\nlist of ints\n"], "values()": ["Return the weights of the deform vertex (matching pythons dict.values() functionality).\n", [], [], "Returns\nThe weights that influence this vertex\nReturn type\nlist of floats"]}]}}

types = []
for i,type in enumerate(dict_bmesh.keys()):
    types.append((type,type,'None',i))

class SvBMTypesNode(SverchCustomTreeNode, bpy.types.Node):
    '''The most basic types of operators in bmesh, which are the cornerstone of bmesh'''
    bl_idname = 'SvBMTypesNode'
    bl_label = 'BMesh Types'
    bl_icon = 'OUTLINER_OB_EMPTY'
    sv_icon = 'SV_ALPHA'  # 'SV_BMESH_OPS'
    
    def updata_oper(self,context):
        for key in self.inputs.keys():
            if key == 'input':
                continue
            self.safe_socket_remove('inputs',key)
        
        for i,p in enumerate(dict_bmesh[self.typ][self.clas][1][self.oper][1]):
            pras = dict_bmesh[self.typ][self.clas][1][self.oper][2]
            if pras:
                des = pras[i]
            else:
                des = 'None'
            self.inputs.new('SvStringsSocket',p).description = des
        self.outputs['return'].description = dict_bmesh[self.typ][self.clas][1][self.oper][-1]
        updateNode(self,context)
    
    typ:EnumProperty(
        name='Types',
        description='Most basic type',
        items=types,
        update=updata_oper)

    def class_enu(self,context):
        Class = []
        type_dict = dict_bmesh[self.typ]
        for i,c in enumerate(type_dict):
            Class.append((c,c,type_dict[c][0],i))
        return Class

    clas:EnumProperty(
        name='Class',
        description='Subclass object of this type',
        items= class_enu,
        update=updata_oper)

    def oper_enu(self,context):
        opers = []
        class_dict = dict_bmesh[self.typ][self.clas][1]
        for i,o in enumerate(class_dict):
            opers.append((o,o,class_dict[o][0],i))
        return opers

    oper: EnumProperty(
        name='Operators',
        description = 'Operator of the most basic type element',
        items= oper_enu,
        update=updata_oper)
    
    def draw_buttons(self, context, layout):
        layout.prop(self,'typ',text='')
        layout.prop(self,'clas',text='')
        layout.prop(self,'oper',text='')

    def sv_init(self, context):
        self.inputs.new('SvStringsSocket','input').description = 'Input element data'
        for i,p in enumerate(dict_bmesh[self.typ][self.clas][1][self.oper][1]):
            des = dict_bmesh[self.typ][self.clas][1][self.oper][2][i]
            self.inputs.new('SvStringsSocket',p).description = des
        self.outputs.new('SvStringsSocket','return').description = dict_bmesh[self.typ][self.clas][1][self.oper][-1]
    def process(self):
        input = []
        for p in self.inputs.keys():
            value = self.inputs[p].sv_get(default=[[None]])
            input.append(value)
        input = match_long_repeat(input)

        if self.inputs[0].is_linked:
            return_ = self.proce(input)
        else:
            return_ = []
        self.outputs['return'].sv_set(return_)

    def proce(self, input):
        return_ = []
        for pars in zip(*input):
            seq = ['Base Mesh Type','Sequence Accessors']
            if self.typ in seq:
                if len(pars) == 1:
                    fun = 'pars[0]'+ '.' + self.oper
                else:
                    for i in range(len(pars)-1):
                        name_p = dict_bmesh[self.typ][self.clas][1][self.oper][1][i]
                        value = name_p
                        exec(value + '=pars[i+1]')
                        if i == 0:
                            parameters = name_p + '=' + value
                        else:
                            parameters += ',' + name_p + '=' + value
                    fun = 'pars[0]' + '.' + self.oper[:-2] +'(' + parameters +')'
                return_.append(eval(fun))
            else :
                result = []
                for p in zip(*pars):
                    if len(pars) == 1:
                        fun = 'p[0]'+ '.' + self.oper
                    else:
                        for i in range(len(pars)-1):
                            name_p = dict_bmesh[self.typ][self.clas][1][self.oper][1][i]
                            value = name_p
                            exec(value + '=p[i+1]')
                            if i == 0:
                                parameters = name_p + '=' + value
                            else:
                                parameters += ',' + name_p + '=' + value
                        fun = 'p[0]' + '.' + self.oper[:-2] +'(' + parameters +')'
                    result.append(eval(fun))
                return_.append(result)
        return return_

def register():
    bpy.utils.register_class(SvBMTypesNode)


def unregister():
    bpy.utils.unregister_class(SvBMTypesNode)