# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

import bpy,bmesh,mathutils
from bpy.props import EnumProperty, FloatProperty,BoolProperty
from sverchok.node_tree import SverchCustomTreeNode
from sverchok.data_structure import (updateNode, enum_item as e, second_as_first_cycle as safc,match_long_repeat)

dict_bmesh = {"smooth_vert": ["Vertex Smooth.\nSmooths vertices by using a basic vertex averaging scheme.\n", ["bm", "verts", "factor", "mirror_clip_x", "mirror_clip_y", "mirror_clip_z", "clip_dist", "use_axis_x", "use_axis_y", "use_axis_z"], ["bm", "bm.verts", "0", "False", "False", "False", "0", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "factor (float) \u2013 smoothing factor\n", "mirror_clip_x (bool) \u2013 set vertices close to the x axis before the operation to 0\n", "mirror_clip_y (bool) \u2013 set vertices close to the y axis before the operation to 0\n", "mirror_clip_z (bool) \u2013 set vertices close to the z axis before the operation to 0\n", "clip_dist (float) \u2013 clipping threshold for the above three slots\n", "use_axis_x (bool) \u2013 smooth vertices along X axis\n", "use_axis_y (bool) \u2013 smooth vertices along Y axis\n", "use_axis_z (bool) \u2013 smooth vertices along Z axis\n"], "None"], "smooth_laplacian_vert": ["Vertex Smooth Laplacian.\nSmooths vertices by using Laplacian smoothing propose by. Desbrun, et al. Implicit Fairing of Irregular Meshes using Diffusion and Curvature Flow.\n", ["bm", "verts", "lambda_factor", "lambda_border", "use_x", "use_y", "use_z", "preserve_volume"], ["bm", "bm.verts", "0", "0", "False", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "lambda_factor (float) \u2013 lambda param\n", "lambda_border (float) \u2013 lambda param in border\n", "use_x (bool) \u2013 Smooth object along X axis\n", "use_y (bool) \u2013 Smooth object along Y axis\n", "use_z (bool) \u2013 Smooth object along Z axis\n", "preserve_volume (bool) \u2013 Apply volume preservation after smooth\n"], "None"], "recalc_face_normals": ["Right-Hand Faces.\nComputes an \u201coutside\u201d normal for the specified input faces.\n", ["bm", "faces"], ["bm", "bm.faces"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n"], "None"], "planar_faces": ["Planar Faces.\nIteratively flatten faces.\n", ["bm", "faces", "iterations", "factor"], ["bm", "bm.faces", "0", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input geometry.\n", "iterations (int) \u2013 Number of times to flatten faces (for when connected faces are used)\n", "factor (float) \u2013 Influence for making planar each iteration\n"], "Returns\ngeom: output slot, computed boundary geometry.\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "region_extend": ["Region Extend.\nused to implement the select more/less tools. this puts some geometry surrounding regions of geometry in geom into geom.out.\nif use_faces is 0 then geom.out spits out verts and edges, otherwise it spits out faces.\n", ["bm", "geom", "use_contract", "use_faces", "use_face_step"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "use_contract (bool) \u2013 find boundary inside the regions, not outside.\n", "use_faces (bool) \u2013 extend from faces instead of edges\n", "use_face_step (bool) \u2013 step over connected faces\n"], "Returns\ngeom: output slot, computed boundary geometry.\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "rotate_edges": ["Edge Rotate.\nRotates edges topologically. Also known as \u201cspin edge\u201d to some people. Simple example: [/] becomes [|] then [].\n", ["bm", "edges", "use_ccw"], ["bm", "bm.edges", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "use_ccw (bool) \u2013 rotate edge counter-clockwise if true, otherwise clockwise\n"], "Returns\nedges: newly spun edges\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "reverse_faces": ["Reverse Faces.\nReverses the winding (vertex order) of faces. This has the effect of flipping the normal.\n", ["bm", "faces", "flip_multires"], ["bm", "bm.faces", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "flip_multires (bool) \u2013 maintain multi-res offset\n"], "None"], "bisect_edges": ["Edge Bisect.\nSplits input edges (but doesn\u2019t do anything else). This creates a 2-valence vert.\n", ["bm", "edges", "cuts", "edge_percents"], ["bm", "bm.edges", "0", "{}"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "cuts (int) \u2013 number of cuts\n", "edge_percents (dict mapping vert/edge/face types to float) \u2013 Undocumented.\n"], "Returns\ngeom_split: newly created vertices and edges\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "mirror": ["Mirror.\nMirrors geometry along an axis. The resulting geometry is welded on using merge_dist. Pairs of original/mirrored vertices are welded using the merge_dist parameter (which defines the minimum distance for welding to happen).\n", ["bm", "geom", "matrix", "merge_dist", "axis", "mirror_u", "mirror_v", "mirror_udim", "use_shapekey"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "mathutils.Matrix.Translation((0,0,0))", "0", "'X'", "False", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "matrix (mathutils.Matrix) \u2013 matrix defining the mirror transformation\n", "merge_dist (float) \u2013 maximum distance for merging. does no merging if 0.\n", "axis (enum in ['X', 'Y', 'Z'], default 'X') \u2013 the axis to use.\n", "mirror_u (bool) \u2013 mirror UVs across the u axis\n", "mirror_v (bool) \u2013 mirror UVs across the v axis\n", "mirror_udim (bool) \u2013 mirror UVs in each tile\n", "use_shapekey (bool) \u2013 Transform shape keys too.\n"], "Returns\ngeom: output geometry, mirrored\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "find_doubles": ["Find Doubles.\nTakes input verts and find vertices they should weld to. Outputs a mapping slot suitable for use with the weld verts bmop.\nIf keep_verts is used, vertices outside that set can only be merged with vertices in that set.\n", ["bm", "verts", "keep_verts", "dist"], ["bm", "bm.verts", "bm.verts", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "keep_verts (list of (bmesh.types.BMVert)) \u2013 list of verts to keep\n", "dist (float) \u2013 maximum distance\n"], "Returns\ntargetmap:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nReturn type\ndict with string keys\n"], "remove_doubles": ["Remove Doubles.\nFinds groups of vertices closer than dist and merges them together, using the weld verts bmop.\n", ["bm", "verts", "dist"], ["bm", "bm.verts", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input verts\n", "dist (float) \u2013 minimum distance\n"], "None"], "collapse": ["Collapse Connected.\nCollapses connected vertices\n", ["bm", "edges", "uvs"], ["bm", "bm.edges", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "uvs (bool) \u2013 also collapse UVs and such\n"], "None"], "pointmerge_facedata": ["Face-Data Point Merge.\nMerge uv/vcols at a specific vertex.\n", ["bm", "verts", "vert_snap"], ["bm", "bm.verts", "bm.verts[0]"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "vert_snap (bmesh.types.BMVert) \u2013 snap vertex\n"], "None"], "average_vert_facedata": ["Average Vertices Facevert Data.\nMerge uv/vcols associated with the input vertices at the bounding box center. (I know, it\u2019s not averaging but the vert_snap_to_bb_center is just too long).\n", ["bm", "verts"], ["bm", "bm.verts"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n"], "None"], "pointmerge": ["Point Merge.\nMerge verts together at a point.\n", ["bm", "verts", "merge_co"], ["bm", "bm.verts", "(0,0,0)"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices (all verts will be merged into the first).\n", "merge_co (mathutils.Vector or any sequence of 3 floats) \u2013 Position to merge at.\n"], "None"], "collapse_uvs": ["Collapse Connected UV\u2019s.\nCollapses connected UV vertices.\n", ["bm", "edges"], ["bm", "bm.edges"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n"], "None"], "weld_verts": ["Weld Verts.\nWelds verts together (kind-of like remove doubles, merge, etc, all of which use or will use this bmop). You pass in mappings from vertices to the vertices they weld with.\n", ["bm", "targetmap"], ["bm", "{}"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "targetmap (dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace) \u2013 maps welded vertices to verts they should weld to\n"], "None"], "create_vert": ["Make Vertex.\nCreates a single vertex; this bmop was necessary for click-create-vertex.\n", ["bm", "co"], ["bm", "(0,0,0)"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "co (mathutils.Vector or any sequence of 3 floats) \u2013 the coordinate of the new vert\n"], "Returns\nvert: the new vert\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "join_triangles": ["Join Triangles.\nTries to intelligently join triangles according to angle threshold and delimiters.\n", ["bm", "faces", "cmp_seam", "cmp_sharp", "cmp_uvs", "cmp_vcols", "cmp_materials", "angle_face_threshold", "angle_shape_threshold"], ["bm", "bm.faces", "False", "False", "False", "False", "False", "0", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input geometry.\n", "cmp_seam (bool) \u2013 Compare seam\n", "cmp_sharp (bool) \u2013 Compare sharp\n", "cmp_uvs (bool) \u2013 Compare UVs\n", "cmp_vcols (bool) \u2013 compare VCols\n", "cmp_materials (bool) \u2013 compare materials\n", "angle_face_threshold (float) \u2013 Undocumented.\n", "angle_shape_threshold (float) \u2013 Undocumented.\n"], "Returns\nfaces: joined faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "contextual_create": ["Contextual Create.\nThis is basically F-key, it creates new faces from vertices, makes stuff from edge nets, makes wire edges, etc. It also dissolves faces.\nThree verts become a triangle, four become a quad. Two become a wire edge.\n", ["bm", "geom", "mat_nr", "use_smooth"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "0", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry.\n", "mat_nr (int) \u2013 material to use\n", "use_smooth (bool) \u2013 smooth to use\n"], "Returns\nfaces: newly-made face(s)\ntype list of (bmesh.types.BMFace)\nedges: newly-made edge(s)\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "bridge_loops": ["Bridge edge loops with faces.\n", ["bm", "edges", "use_pairs", "use_cyclic", "use_merge", "merge_factor", "twist_offset"], ["bm", "bm.edges", "False", "False", "False", "0", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "use_pairs (bool) \u2013 Undocumented.\n", "use_cyclic (bool) \u2013 Undocumented.\n", "use_merge (bool) \u2013 merge rather than creating faces\n", "merge_factor (float) \u2013 merge factor\n", "twist_offset (int) \u2013 twist offset for closed loops\n"], "Returns\nfaces: new faces\ntype list of (bmesh.types.BMFace)\nedges: new edges\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "grid_fill": ["Grid Fill.\nCreate faces defined by 2 disconnected edge loops (which share edges).\n", ["bm", "edges", "mat_nr", "use_smooth", "use_interp_simple"], ["bm", "bm.edges", "0", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "mat_nr (int) \u2013 material to use\n", "use_smooth (bool) \u2013 smooth state to use\n", "use_interp_simple (bool) \u2013 use simple interpolation\n"], "Returns\nfaces: new faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "holes_fill": ["Fill Holes.\nFill boundary edges with faces, copying surrounding customdata.\n", ["bm", "edges", "sides"], ["bm", "bm.edges", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "sides (int) \u2013 number of face sides to fill\n"], "Returns\nfaces: new faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "face_attribute_fill": ["Face Attribute Fill.\nFill in faces with data from adjacent faces.\n", ["bm", "faces", "use_normals", "use_data"], ["bm", "bm.faces", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "use_normals (bool) \u2013 copy face winding\n", "use_data (bool) \u2013 copy face data\n"], "Returns\nfaces_fail: faces that could not be handled\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "edgeloop_fill": ["Edge Loop Fill.\nCreate faces defined by one or more non overlapping edge loops.\n", ["bm", "edges", "mat_nr", "use_smooth"], ["bm", "bm.edges", "0", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "mat_nr (int) \u2013 material to use\n", "use_smooth (bool) \u2013 smooth state to use\n"], "Returns\nfaces: new faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "edgenet_fill": ["Edge Net Fill.\nCreate faces defined by enclosed edges.\n", ["bm", "edges", "mat_nr", "use_smooth", "sides"], ["bm", "bm.edges", "0", "False", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "mat_nr (int) \u2013 material to use\n", "use_smooth (bool) \u2013 smooth state to use\n", "sides (int) \u2013 number of sides\n"], "Returns\nfaces: new faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "edgenet_prepare": ["Edge-net Prepare.\nIdentifies several useful edge loop cases and modifies them so they\u2019ll become a face when edgenet_fill is called. The cases covered are:\nOne single loop; an edge is added to connect the ends\nTwo loops; two edges are added to connect the endpoints (based on the shortest distance between each endpoint).\n", ["bm", "edges"], ["bm", "bm.edges"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n"], "Returns\nedges: new edges\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "rotate": ["Rotate.\nRotate vertices around a center, using a 3x3 rotation matrix.\n", ["bm", "cent", "matrix", "verts", "space", "use_shapekey"], ["bm", "(0,0,0)", "mathutils.Matrix.Translation((0,0,0))", "bm.verts", "mathutils.Matrix.Translation((0,0,0))", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "cent (mathutils.Vector or any sequence of 3 floats) \u2013 center of rotation\n", "matrix (mathutils.Matrix) \u2013 matrix defining rotation\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "space (mathutils.Matrix) \u2013 matrix to define the space (typically object matrix)\n", "use_shapekey (bool) \u2013 Transform shape keys too.\n"], "None"], "translate": ["Translate.\nTranslate vertices by an offset.\n", ["bm", "vec", "space", "verts", "use_shapekey"], ["bm", "(0,0,0)", "mathutils.Matrix.Translation((0,0,0))", "bm.verts", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "vec (mathutils.Vector or any sequence of 3 floats) \u2013 translation offset\n", "space (mathutils.Matrix) \u2013 matrix to define the space (typically object matrix)\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "use_shapekey (bool) \u2013 Transform shape keys too.\n"], "None"], "scale": ["Scale.\nScales vertices by an offset.\n", ["bm", "vec", "space", "verts", "use_shapekey"], ["bm", "(0,0,0)", "mathutils.Matrix.Translation((0,0,0))", "bm.verts", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "vec (mathutils.Vector or any sequence of 3 floats) \u2013 scale factor\n", "space (mathutils.Matrix) \u2013 matrix to define the space (typically object matrix)\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "use_shapekey (bool) \u2013 Transform shape keys too.\n"], "None"], "transform": ["Transform.\nTransforms a set of vertices by a matrix. Multiplies the vertex coordinates with the matrix.\n", ["bm", "matrix", "space", "verts", "use_shapekey"], ["bm", "mathutils.Matrix.Translation((0,0,0))", "mathutils.Matrix.Translation((0,0,0))", "bm.verts", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "matrix (mathutils.Matrix) \u2013 transform matrix\n", "space (mathutils.Matrix) \u2013 matrix to define the space (typically object matrix)\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "use_shapekey (bool) \u2013 Transform shape keys too.\n"], "None"], "object_load_bmesh": ["Object Load BMesh.\nLoads a bmesh into an object/mesh. This is a \u201cprivate\u201d bmop.\n", ["bm", "scene", "object"], ["bm", "None", "None"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "scene (bpy.types.Scene) \u2013 pointer to an scene structure\n", "object (bpy.types.Object) \u2013 pointer to an object structure\n"], "None"], "bmesh_to_mesh": ["BMesh to Mesh.\nConverts a bmesh to a Mesh. This is reserved for exiting editmode.\n", ["bm", "mesh", "object"], ["bm", "None", "None"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "mesh (bpy.types.Mesh) \u2013 pointer to a mesh structure to fill in\n", "object (bpy.types.Object) \u2013 pointer to an object structure\n"], "None"], "mesh_to_bmesh": ["Mesh to BMesh.\nLoad the contents of a mesh into the bmesh. this bmop is private, it\u2019s reserved exclusively for entering editmode.\n", ["bm", "mesh", "object", "use_shapekey"], ["bm", "None", "None", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "mesh (bpy.types.Mesh) \u2013 pointer to a Mesh structure\n", "object (bpy.types.Object) \u2013 pointer to an Object structure\n", "use_shapekey (bool) \u2013 load active shapekey coordinates into verts\n"], "None"], "extrude_discrete_faces": ["Individual Face Extrude.\nExtrudes faces individually.\n", ["bm", "faces", "use_normal_flip", "use_select_history"], ["bm", "bm.faces", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "use_normal_flip (bool) \u2013 Create faces with reversed direction.\n", "use_select_history (bool) \u2013 pass to duplicate\n"], "Returns\nfaces: output faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "extrude_edge_only": ["Extrude Only Edges.\nExtrudes Edges into faces, note that this is very simple, there\u2019s no fancy winged extrusion.\n", ["bm", "edges", "use_normal_flip", "use_select_history"], ["bm", "bm.edges", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input vertices\n", "use_normal_flip (bool) \u2013 Create faces with reversed direction.\n", "use_select_history (bool) \u2013 pass to duplicate\n"], "Returns\ngeom: output geometry\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "extrude_vert_indiv": ["Individual Vertex Extrude.\nExtrudes wire edges from vertices.\n", ["bm", "verts", "use_select_history"], ["bm", "bm.verts", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "use_select_history (bool) \u2013 pass to duplicate\n"], "Returns\nedges: output wire edges\ntype list of (bmesh.types.BMEdge)\nverts: output vertices\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "connect_verts": ["Connect Verts.\nSplit faces by adding edges that connect verts.\n", ["bm", "verts", "faces_exclude", "check_degenerate"], ["bm", "bm.verts", "bm.faces", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "faces_exclude (list of (bmesh.types.BMFace)) \u2013 input faces to explicitly exclude from connecting\n", "check_degenerate (bool) \u2013 prevent splits with overlaps & intersections\n"], "Returns\nedges:\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "connect_verts_concave": ["Connect Verts to form Convex Faces.\nEnsures all faces are convex faces.\n", ["bm", "faces"], ["bm", "bm.faces"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n"], "Returns\nedges:\ntype list of (bmesh.types.BMEdge)\nfaces:\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "connect_verts_nonplanar": ["Connect Verts Across non Planer Faces.\nSplit faces by connecting edges along non planer faces.\n", ["bm", "angle_limit", "faces"], ["bm", "0", "bm.faces"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "angle_limit (float) \u2013 total rotation angle (radians)\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n"], "Returns\nedges:\ntype list of (bmesh.types.BMEdge)\nfaces:\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "connect_vert_pair": ["Connect Verts.\nSplit faces by adding edges that connect verts.\n", ["bm", "verts", "verts_exclude", "faces_exclude"], ["bm", "bm.verts", "bm.verts", "bm.faces"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "verts_exclude (list of (bmesh.types.BMVert)) \u2013 input vertices to explicitly exclude from connecting\n", "faces_exclude (list of (bmesh.types.BMFace)) \u2013 input faces to explicitly exclude from connecting\n"], "Returns\nedges:\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "extrude_face_region": ["Extrude Faces.\nExtrude operator (does not transform)\n", ["bm", "geom", "edges_exclude", "use_keep_orig", "use_normal_flip", "use_normal_from_adjacent", "use_dissolve_ortho_edges", "use_select_history"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "set()", "False", "False", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 edges and faces\n", "edges_exclude (set of vert/edge/face type) \u2013 input edges to explicitly exclude from extrusion\n", "use_keep_orig (bool) \u2013 keep original geometry (requires geom to include edges).\n", "use_normal_flip (bool) \u2013 Create faces with reversed direction.\n", "use_normal_from_adjacent (bool) \u2013 Use winding from surrounding faces instead of this region.\n", "use_dissolve_ortho_edges (bool) \u2013 Dissolve edges whose faces form a flat surface.\n", "use_select_history (bool) \u2013 pass to duplicate\n"], "Returns\ngeom:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "dissolve_verts": ["Dissolve Verts.\n", ["bm", "verts", "use_face_split", "use_boundary_tear"], ["bm", "bm.verts", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "use_face_split (bool) \u2013 split off face corners to maintain surrounding geometry\n", "use_boundary_tear (bool) \u2013 split off face corners instead of merging faces\n"], "None"], "dissolve_edges": ["Dissolve Edges.\n", ["bm", "edges", "use_verts", "use_face_split"], ["bm", "bm.edges", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "use_verts (bool) \u2013 dissolve verts left between only 2 edges.\n", "use_face_split (bool) \u2013 split off face corners to maintain surrounding geometry\n"], "Returns\nregion:\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "dissolve_faces": ["Dissolve Faces.\n", ["bm", "faces", "use_verts"], ["bm", "bm.faces", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "use_verts (bool) \u2013 dissolve verts left between only 2 edges.\n"], "Returns\nregion:\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "dissolve_limit": ["Limited Dissolve.\nDissolve planar faces and co-linear edges.\n", ["bm", "angle_limit", "use_dissolve_boundaries", "verts", "edges", "delimit"], ["bm", "0", "False", "bm.verts", "bm.edges", "set()"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "angle_limit (float) \u2013 total rotation angle (radians)\n", "use_dissolve_boundaries (bool) \u2013 dissolve all vertices in between face boundaries\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "delimit (set of flags from ['NORMAL', 'MATERIAL', 'SEAM', 'SHARP', 'UV'], default {}) \u2013 delimit dissolve operation\n"], "Returns\nregion:\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "dissolve_degenerate": ["Degenerate Dissolve.\nDissolve edges with no length, faces with no area.\n", ["bm", "dist", "edges"], ["bm", "0", "bm.edges"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "dist (float) \u2013 maximum distance to consider degenerate\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n"], "None"], "triangulate": ["Triangulate.\n", ["bm", "faces", "quad_method", "ngon_method"], ["bm", "bm.faces", "'BEAUTY'", "'BEAUTY'"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "quad_method (enum in ['BEAUTY', 'FIXED', 'ALTERNATE', 'SHORT_EDGE', 'LONG_EDGE'], default 'BEAUTY') \u2013 method for splitting the quads into triangles\n", "ngon_method (enum in ['BEAUTY', 'EAR_CLIP'], default 'BEAUTY') \u2013 method for splitting the polygons into triangles\n"], "Returns\nedges:\ntype list of (bmesh.types.BMEdge)\nfaces:\ntype list of (bmesh.types.BMFace)\nface_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nface_map_double: duplicate faces\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nReturn type\ndict with string keys\n"], "unsubdivide": ["Un-Subdivide.\nReduce detail in geometry containing grids.\n", ["bm", "verts", "iterations"], ["bm", "bm.verts", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "verts (list of (bmesh.types.BMVert)) \u2013 input vertices\n", "iterations (int) \u2013 number of times to unsubdivide\n"], "None"], "subdivide_edges": ["Subdivide Edges.\nAdvanced operator for subdividing edges with options for face patterns, smoothing and randomization.\n", ["bm", "edges", "smooth", "smooth_falloff", "fractal", "along_normal", "cuts", "seed", "custom_patterns", "edge_percents", "quad_corner_type", "use_grid_fill", "use_single_edge", "use_only_quads", "use_sphere", "use_smooth_even"], ["bm", "bm.edges", "0", "'SMOOTH'", "0", "0", "0", "0", "{}", "{}", "'STRAIGHT_CUT'", "False", "False", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "smooth (float) \u2013 smoothness factor\n", "smooth_falloff (enum in ['SMOOTH', 'SPHERE', 'ROOT', 'SHARP', 'LINEAR', 'INVERSE_SQUARE'], default 'SMOOTH') \u2013 smooth falloff type\n", "fractal (float) \u2013 fractal randomness factor\n", "along_normal (float) \u2013 apply fractal displacement along normal only\n", "cuts (int) \u2013 number of cuts\n", "seed (int) \u2013 seed for the random number generator\n", "custom_patterns (dict mapping vert/edge/face types to unknown internal data, not compatible with python) \u2013 uses custom pointers\n", "edge_percents (dict mapping vert/edge/face types to float) \u2013 Undocumented.\n", "quad_corner_type (enum in ['STRAIGHT_CUT', 'INNER_VERT', 'PATH', 'FAN'], default 'STRAIGHT_CUT') \u2013 quad corner type\n", "use_grid_fill (bool) \u2013 fill in fully-selected faces with a grid\n", "use_single_edge (bool) \u2013 tessellate the case of one edge selected in a quad or triangle\n", "use_only_quads (bool) \u2013 Only subdivide quads (for loop-cut).\n", "use_sphere (bool) \u2013 for making new primitives only\n", "use_smooth_even (bool) \u2013 maintain even offset when smoothing\n"], "Returns\ngeom_inner:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\ngeom_split:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\ngeom: contains all output geometry\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "subdivide_edgering": ["Subdivide Edge-Ring.\nTake an edge-ring, and subdivide with interpolation options.\n", ["bm", "edges", "interp_mode", "smooth", "cuts", "profile_shape", "profile_shape_factor"], ["bm", "bm.edges", "'LINEAR'", "0", "0", "'SMOOTH'", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input vertices\n", "interp_mode (enum in ['LINEAR', 'PATH', 'SURFACE'], default 'LINEAR') \u2013 interpolation method\n", "smooth (float) \u2013 smoothness factor\n", "cuts (int) \u2013 number of cuts\n", "profile_shape (enum in ['SMOOTH', 'SPHERE', 'ROOT', 'SHARP', 'LINEAR', 'INVERSE_SQUARE'], default 'SMOOTH') \u2013 profile shape type\n", "profile_shape_factor (float) \u2013 how much intermediary new edges are shrunk/expanded\n"], "Returns\nfaces: output faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "bisect_plane": ["Bisect Plane.\nBisects the mesh by a plane (cut the mesh in half).\n", ["bm", "geom", "dist", "plane_co", "plane_no", "use_snap_center", "clear_outer", "clear_inner"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "0", "(0,0,0)", "(0,0,0)", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "dist (float) \u2013 minimum distance when testing if a vert is exactly on the plane\n", "plane_co (mathutils.Vector or any sequence of 3 floats) \u2013 point on the plane\n", "plane_no (mathutils.Vector or any sequence of 3 floats) \u2013 direction of the plane\n", "use_snap_center (bool) \u2013 snap axis aligned verts to the center\n", "clear_outer (bool) \u2013 when enabled. remove all geometry on the positive side of the plane\n", "clear_inner (bool) \u2013 when enabled. remove all geometry on the negative side of the plane\n"], "Returns\ngeom_cut: output geometry aligned with the plane (new and existing)\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge)\ngeom: input and output geometry (result of cut).\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "delete": ["Delete Geometry.\nUtility operator to delete geometry.\n", ["bm", "geom", "context"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "bm.verts[:] + bm.edges[:] + bm.faces[:]"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "context (enum in ['VERTS', 'EDGES', 'FACES_ONLY', 'EDGES_FACES', 'FACES', 'FACES_KEEP_BOUNDARY', 'TAGGED_ONLY'], default 'VERTS') \u2013 geometry types to delete\n"], "None"], "duplicate": ["Duplicate Geometry.\nUtility operator to duplicate geometry, optionally into a destination mesh.\n", ["bm", "geom", "dest", "use_select_history", "use_edge_flip_from_face"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "bm", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "dest (bmesh.types.BMesh) \u2013 destination bmesh, if NULL will use current on\n", "use_select_history (bool) \u2013 Undocumented.\n", "use_edge_flip_from_face (bool) \u2013 Undocumented.\n"], "Returns\ngeom_orig:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\ngeom:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nvert_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nedge_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nface_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nboundary_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nisovert_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nReturn type\ndict with string keys\n"], "split": ["Split Off Geometry.\nDisconnect geometry from adjacent edges and faces, optionally into a destination mesh.\n", ["bm", "geom", "dest", "use_only_faces"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "bm", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "dest (bmesh.types.BMesh) \u2013 destination bmesh, if NULL will use current one\n", "use_only_faces (bool) \u2013 when enabled. don\u2019t duplicate loose verts/edges\n"], "Returns\ngeom:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nboundary_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nisovert_map:\ntype dict mapping vert/edge/face types to bmesh.types.BMVert/bmesh.types.BMEdge/bmesh.types.BMFace\nReturn type\ndict with string keys\n"], "spin": ["Spin.\nExtrude or duplicate geometry a number of times, rotating and possibly translating after each step\n", ["bm", "geom", "cent", "axis", "dvec", "angle", "space", "steps", "use_merge", "use_normal_flip", "use_duplicate"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "(0,0,0)", "(0,0,0)", "(0,0,0)", "0", "mathutils.Matrix.Translation((0,0,0))", "0", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "cent (mathutils.Vector or any sequence of 3 floats) \u2013 rotation center\n", "axis (mathutils.Vector or any sequence of 3 floats) \u2013 rotation axis\n", "dvec (mathutils.Vector or any sequence of 3 floats) \u2013 translation delta per step\n", "angle (float) \u2013 total rotation angle (radians)\n", "space (mathutils.Matrix) \u2013 matrix to define the space (typically object matrix)\n", "steps (int) \u2013 number of steps\n", "use_merge (bool) \u2013 Merge first/last when the angle is a full revolution.\n", "use_normal_flip (bool) \u2013 Create faces with reversed direction.\n", "use_duplicate (bool) \u2013 duplicate or extrude?\n"], "Returns\ngeom_last: result of last step\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "rotate_uvs": ["UV Rotation.\nCycle the loop UV\u2019s\n", ["bm", "faces", "use_ccw"], ["bm", "bm.faces", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "use_ccw (bool) \u2013 rotate counter-clockwise if true, otherwise clockwise\n"], "None"], "reverse_uvs": ["UV Reverse.\nReverse the UV\u2019s\n", ["bm", "faces"], ["bm", "bm.faces"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n"], "None"], "rotate_colors": ["Color Rotation.\nCycle the loop colors\n", ["bm", "faces", "use_ccw", "color_index"], ["bm", "bm.faces", "False", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "use_ccw (bool) \u2013 rotate counter-clockwise if true, otherwise clockwise\n", "color_index (int) \u2013 index into color attribute list\n"], "None"], "reverse_colors": ["Color Reverse\nReverse the loop colors.\n", ["bm", "faces", "color_index"], ["bm", "bm.faces", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "color_index (int) \u2013 index into color attribute list\n"], "None"], "split_edges": ["Edge Split.\nDisconnects faces along input edges.\n", ["bm", "edges", "verts", "use_verts"], ["bm", "bm.edges", "bm.verts", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "verts (list of (bmesh.types.BMVert)) \u2013 optional tag verts, use to have greater control of splits\n", "use_verts (bool) \u2013 use \u2018verts\u2019 for splitting, else just find verts to split from edges\n"], "Returns\nedges: old output disconnected edges\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "create_grid": ["Create Grid.\nCreates a grid with a variable number of subdivisions\n", ["bm", "x_segments", "y_segments", "size", "matrix", "calc_uvs"], ["bm", "0", "0", "0", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "x_segments (int) \u2013 number of x segments\n", "y_segments (int) \u2013 number of y segments\n", "size (float) \u2013 size of the grid\n", "matrix (mathutils.Matrix) \u2013 matrix to multiply the new geometry with\n", "calc_uvs (bool) \u2013 calculate default UVs\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "create_uvsphere": ["Create UV Sphere.\nCreates a grid with a variable number of subdivisions\n", ["bm", "u_segments", "v_segments", "radius", "matrix", "calc_uvs"], ["bm", "0", "0", "0", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "u_segments (int) \u2013 number of u segments\n", "v_segments (int) \u2013 number of v segment\n", "radius (float) \u2013 radius\n", "matrix (mathutils.Matrix) \u2013 matrix to multiply the new geometry with\n", "calc_uvs (bool) \u2013 calculate default UVs\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "create_icosphere": ["Create Ico-Sphere.\nCreates a grid with a variable number of subdivisions\n", ["bm", "subdivisions", "radius", "matrix", "calc_uvs"], ["bm", "0", "0", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "subdivisions (int) \u2013 how many times to recursively subdivide the sphere\n", "radius (float) \u2013 radius\n", "matrix (mathutils.Matrix) \u2013 matrix to multiply the new geometry with\n", "calc_uvs (bool) \u2013 calculate default UVs\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "create_monkey": ["Create Suzanne.\nCreates a monkey (standard blender primitive).\n", ["bm", "matrix", "calc_uvs"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "matrix (mathutils.Matrix) \u2013 matrix to multiply the new geometry with\n", "calc_uvs (bool) \u2013 calculate default UVs\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "create_cone": ["Create Cone.\nCreates a cone with variable depth at both ends\n", ["bm", "cap_ends", "cap_tris", "segments", "radius1", "radius2", "depth", "matrix", "calc_uvs"], ["bm", "False", "False", "0", "0", "0", "0", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "cap_ends (bool) \u2013 whether or not to fill in the ends with faces\n", "cap_tris (bool) \u2013 fill ends with triangles instead of ngons\n", "segments (int) \u2013 number of vertices in the base circle\n", "radius1 (float) \u2013 radius of one end\n", "radius2 (float) \u2013 radius of the opposite\n", "depth (float) \u2013 distance between ends\n", "matrix (mathutils.Matrix) \u2013 matrix to multiply the new geometry with\n", "calc_uvs (bool) \u2013 calculate default UVs\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "create_circle": ["Creates a Circle.\n", ["bm", "cap_ends", "cap_tris", "segments", "radius", "matrix", "calc_uvs"], ["bm", "False", "False", "0", "0", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "cap_ends (bool) \u2013 whether or not to fill in the ends with faces\n", "cap_tris (bool) \u2013 fill ends with triangles instead of ngons\n", "segments (int) \u2013 number of vertices in the circle\n", "radius (float) \u2013 Radius of the circle.\n", "matrix (mathutils.Matrix) \u2013 matrix to multiply the new geometry with\n", "calc_uvs (bool) \u2013 calculate default UVs\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "create_cube": ["Create Cube\nCreates a cube.\n", ["bm", "size", "matrix", "calc_uvs"], ["bm", "0", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "size (float) \u2013 size of the cube\n", "matrix (mathutils.Matrix) \u2013 matrix to multiply the new geometry with\n", "calc_uvs (bool) \u2013 calculate default UVs\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "bevel": ["Bevel.\nBevels edges and vertices\n", ["bm", "geom", "offset", "offset_type", "profile_type", "segments", "profile", "affect", "clamp_overlap", "material", "loop_slide", "mark_seam", "mark_sharp", "harden_normals", "face_strength_mode", "miter_outer", "miter_inner", "spread", "smoothresh", "custom_profile", "vmesh_method"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "0", "'OFFSET'", "'SUPERELLIPSE'", "0", "0", "'VERTICES'", "False", "0", "False", "False", "False", "False", "'NONE'", "'SHARP'", "'SHARP'", "0", "0", "None", "'ADJ'"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input edges and vertices\n", "offset (float) \u2013 amount to offset beveled edge\n", "offset_type (enum in ['OFFSET', 'WIDTH', 'DEPTH', 'PERCENT', 'ABSOLUTE'], default 'OFFSET') \u2013 how to measure the offset\n", "profile_type (enum in ['SUPERELLIPSE', 'CUSTOM'], default 'SUPERELLIPSE') \u2013 The profile type to use for bevel.\n", "segments (int) \u2013 number of segments in bevel\n", "profile (float) \u2013 profile shape, 0->1 (.5=>round)\n", "affect (enum in ['VERTICES', 'EDGES'], default 'VERTICES') \u2013 Whether to bevel vertices or edges.\n", "clamp_overlap (bool) \u2013 do not allow beveled edges/vertices to overlap each other\n", "material (int) \u2013 material for bevel faces, -1 means get from adjacent faces\n", "loop_slide (bool) \u2013 prefer to slide along edges to having even widths\n", "mark_seam (bool) \u2013 extend edge data to allow seams to run across bevels\n", "mark_sharp (bool) \u2013 extend edge data to allow sharp edges to run across bevels\n", "harden_normals (bool) \u2013 harden normals\n", "face_strength_mode (enum in ['NONE', 'NEW', 'AFFECTED', 'ALL'], default 'NONE') \u2013 whether to set face strength, and which faces to set if so\n", "miter_outer (enum in ['SHARP', 'PATCH', 'ARC'], default 'SHARP') \u2013 outer miter kind\n", "miter_inner (enum in ['SHARP', 'PATCH', 'ARC'], default 'SHARP') \u2013 outer miter kind\n", "spread (float) \u2013 amount to offset beveled edge\n", "smoothresh (float) \u2013 for passing mesh\u2019s smoothresh, used in hardening\n", "custom_profile (bpy.types.bpy_struct) \u2013 CurveProfile\n", "vmesh_method (enum in ['ADJ', 'CUTOFF'], default 'ADJ') \u2013 The method to use to create meshes at intersections.\n"], "Returns\nfaces: output faces\ntype list of (bmesh.types.BMFace)\nedges: output edges\ntype list of (bmesh.types.BMEdge)\nverts: output verts\ntype list of (bmesh.types.BMVert)\nReturn type\ndict with string keys\n"], "beautify_fill": ["Beautify Fill.\nRotate edges to create more evenly spaced triangles.\n", ["bm", "faces", "edges", "use_restrict_tag", "method"], ["bm", "bm.faces", "bm.edges", "False", "'AREA'"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "edges (list of (bmesh.types.BMEdge)) \u2013 edges that can be flipped\n", "use_restrict_tag (bool) \u2013 restrict edge rotation to mixed tagged vertices\n", "method (enum in ['AREA', 'ANGLE'], default 'AREA') \u2013 method to define what is beautiful\n"], "Returns\ngeom: new flipped faces and edges\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "triangle_fill": ["Triangle Fill.\nFill edges with triangles\n", ["bm", "use_beauty", "use_dissolve", "edges", "normal"], ["bm", "False", "False", "bm.edges", "(0,0,0)"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "use_beauty (bool) \u2013 use best triangulation division\n", "use_dissolve (bool) \u2013 dissolve resulting faces\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "normal (mathutils.Vector or any sequence of 3 floats) \u2013 optionally pass the fill normal to use\n"], "Returns\ngeom: new faces and edges\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "solidify": ["Solidify.\nTurns a mesh into a shell with thickness\n", ["bm", "geom", "thickness"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "geom (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "thickness (float) \u2013 thickness\n"], "Returns\ngeom:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "inset_individual": ["Face Inset (Individual).\nInsets individual faces.\n", ["bm", "faces", "thickness", "depth", "use_even_offset", "use_interpolate", "use_relative_offset"], ["bm", "bm.faces", "0", "0", "False", "False", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "thickness (float) \u2013 thickness\n", "depth (float) \u2013 depth\n", "use_even_offset (bool) \u2013 scale the offset to give more even thickness\n", "use_interpolate (bool) \u2013 blend face data across the inset\n", "use_relative_offset (bool) \u2013 scale the offset by surrounding geometry\n"], "Returns\nfaces: output faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "inset_region": ["Face Inset (Regions).\nInset or outset face regions.\n", ["bm", "faces", "faces_exclude", "use_boundary", "use_even_offset", "use_interpolate", "use_relative_offset", "use_edge_rail", "thickness", "depth", "use_outset"], ["bm", "bm.faces", "bm.faces", "False", "False", "False", "False", "False", "0", "0", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "faces_exclude (list of (bmesh.types.BMFace)) \u2013 input faces to explicitly exclude from inset\n", "use_boundary (bool) \u2013 inset face boundaries\n", "use_even_offset (bool) \u2013 scale the offset to give more even thickness\n", "use_interpolate (bool) \u2013 blend face data across the inset\n", "use_relative_offset (bool) \u2013 scale the offset by surrounding geometry\n", "use_edge_rail (bool) \u2013 inset the region along existing edges\n", "thickness (float) \u2013 thickness\n", "depth (float) \u2013 depth\n", "use_outset (bool) \u2013 outset rather than inset\n"], "Returns\nfaces: output faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "offset_edgeloops": ["Edge-loop Offset.\nCreates edge loops based on simple edge-outset method.\n", ["bm", "edges", "use_cap_endpoint"], ["bm", "bm.edges", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "edges (list of (bmesh.types.BMEdge)) \u2013 input edges\n", "use_cap_endpoint (bool) \u2013 extend loop around end-points\n"], "Returns\nedges: output edges\ntype list of (bmesh.types.BMEdge)\nReturn type\ndict with string keys\n"], "wireframe": ["Wire Frame.\nMakes a wire-frame copy of faces.\n", ["bm", "faces", "thickness", "offset", "use_replace", "use_boundary", "use_even_offset", "use_crease", "crease_weight", "use_relative_offset", "material_offset"], ["bm", "bm.faces", "0", "0", "False", "False", "False", "False", "0", "False", "0"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "thickness (float) \u2013 thickness\n", "offset (float) \u2013 offset the thickness from the center\n", "use_replace (bool) \u2013 remove original geometry\n", "use_boundary (bool) \u2013 inset face boundaries\n", "use_even_offset (bool) \u2013 scale the offset to give more even thickness\n", "use_crease (bool) \u2013 crease hub edges for improved subdivision surface\n", "crease_weight (float) \u2013 the mean crease weight for resulting edges\n", "use_relative_offset (bool) \u2013 scale the offset by surrounding geometry\n", "material_offset (int) \u2013 offset material index of generated faces\n"], "Returns\nfaces: output faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "poke": ["Pokes a face.\nSplits a face into a triangle fan.\n", ["bm", "faces", "offset", "center_mode", "use_relative_offset"], ["bm", "bm.faces", "0", "'MEAN_WEIGHTED'", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "faces (list of (bmesh.types.BMFace)) \u2013 input faces\n", "offset (float) \u2013 center vertex offset along normal\n", "center_mode (enum in ['MEAN_WEIGHTED', 'MEAN', 'BOUNDS'], default 'MEAN_WEIGHTED') \u2013 calculation mode for center vertex\n", "use_relative_offset (bool) \u2013 apply offset\n"], "Returns\nverts: output verts\ntype list of (bmesh.types.BMVert)\nfaces: output faces\ntype list of (bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "convex_hull": ["Convex Hull\nBuilds a convex hull from the vertices in \u2018input\u2019.\nIf \u2018use_existing_faces\u2019 is true, the hull will not output triangles that are covered by a pre-existing face.\nAll hull vertices, faces, and edges are added to \u2018geom.out\u2019. Any input elements that end up inside the hull (i.e. are not used by an output face) are added to the \u2018interior_geom\u2019 slot. The \u2018unused_geom\u2019 slot will contain all interior geometry that is completely unused. Lastly, \u2018holes_geom\u2019 contains edges and faces that were in the input and are part of the hull.\n", ["bm", "input", "use_existing_faces"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "input (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "use_existing_faces (bool) \u2013 skip hull triangles that are covered by a pre-existing face\n"], "Returns\ngeom:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\ngeom_interior:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\ngeom_unused:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\ngeom_holes:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys\n"], "symmetrize": ["Symmetrize.\nMakes the mesh elements in the \u201cinput\u201d slot symmetrical. Unlike normal mirroring, it only copies in one direction, as specified by the \u201cdirection\u201d slot. The edges and faces that cross the plane of symmetry are split as needed to enforce symmetry.\nAll new vertices, edges, and faces are added to the \u201cgeom.out\u201d slot.\n", ["bm", "input", "direction", "dist", "use_shapekey"], ["bm", "bm.verts[:] + bm.edges[:] + bm.faces[:]", "'-X'", "0", "False"], ["bm (bmesh.types.BMesh) \u2013 The bmesh to operate on.\n", "input (list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)) \u2013 input geometry\n", "direction (enum in ['-X', '-Y', '-Z', 'X', 'Y', 'Z'], default '-X') \u2013 axis to use\n", "dist (float) \u2013 minimum distance\n", "use_shapekey (bool) \u2013 Transform shape keys too.\n"], "Returns\ngeom:\ntype list of (bmesh.types.BMVert, bmesh.types.BMEdge, bmesh.types.BMFace)\nReturn type\ndict with string keys"]}

operators = []
for i,ops in enumerate(dict_bmesh.keys()):
    operators.append((ops,ops+"()",dict_bmesh[ops][0],i))

class SvBMOpsNode(SverchCustomTreeNode, bpy.types.Node):
    ''' Operators for handling bmesh objects'''
    bl_idname = 'SvBMOpsNode'
    bl_label = 'BMesh Ops'
    bl_icon = 'OUTLINER_OB_EMPTY'
    sv_icon = 'SV_ALPHA'  # 'SV_BMESH_OPS'
    def updata_oper(self,context):
        for key in self.inputs.keys():
            self.safe_socket_remove('inputs',key)
        
        for i,p in enumerate(dict_bmesh[self.oper][1]):
            des = dict_bmesh[self.oper][3][i]
            self.inputs.new('SvStringsSocket',p).description = des
        self.outputs['return'].description = dict_bmesh[self.oper][-1]
        updateNode(self,context)

    oper: EnumProperty(
        name='Operators',
        description = 'Operators for handling bmesh objects',
        default=operators[0][0],
        items=operators,
        update=updata_oper)
    copy : BoolProperty(
        name = "Copy Bmesh",
        description="Copy the input bmesh and apply the function on this basis. Disabling it will save performance, but the operation cannot be rolled back",
        default = True,
        update = updateNode)

    def draw_buttons(self, context, layout):
        layout.prop(self,'oper',text='')
        layout.prop(self,'copy')

    def sv_init(self, context):
        for i,p in enumerate(dict_bmesh[operators[0][0]][1]):
            des = dict_bmesh[operators[0][0]][3][i]
            self.inputs.new('SvStringsSocket',p).description = des
        self.outputs.new('SvStringsSocket','Bmesh').description = 'out bmesh'
        self.outputs.new('SvStringsSocket','return').description = 'None'

    def process(self):
        input = []
        for i,p in enumerate(dict_bmesh[self.oper][1]):
            if i == 0 and self.copy :
                value = self.inputs[p].sv_get()
                value = [bm.copy() for bm in value]
            else:
                default = dict_bmesh[self.oper][2][i]
                value = self.inputs[p].sv_get(default=[default])
            input.append(value)
        input = match_long_repeat(input)

        if self.inputs['bm'].is_linked :
            return_= self.ops(input)
        else:
            return_ = []
        
        self.outputs[0].sv_set(input[0])
        self.outputs[1].sv_set(return_)

    def ops(self, input):
        return_ = []
        for p in zip(*input):
            bm = p[0]
            for i in range(len(p)):
                if i == 0 :
                    parameters = 'bm'
                else:
                    name_p = dict_bmesh[self.oper][1][i]
                    if self.inputs[name_p].is_linked :
                        value = dict_bmesh[self.oper][1][i]
                        exec(value + '= p[i]')
                        parameters = parameters + ',' + name_p + '=' + value
                    else:
                        parameters = parameters + ',' + name_p + '=' + p[i]      
            fun = 'bmesh.ops.' + self.oper + '(' + parameters +')'
            return_.append(eval(fun))
        return return_
        
def register():
    bpy.utils.register_class(SvBMOpsNode)

def unregister():
    bpy.utils.unregister_class(SvBMOpsNode)
