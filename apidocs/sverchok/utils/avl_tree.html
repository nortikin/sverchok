<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sverchok.utils.avl_tree API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.avl_tree</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.avl_tree.AVLTree"><code class="flex name class">
<span>class <span class="ident">AVLTree</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AVLTree:
    &#34;&#34;&#34;
    https://en.wikipedia.org/wiki/AVL_tree
    https://www.cs.usfca.edu/~galles/visualization/AVLtree.html
    can be used in conditions like this: if AVLTree(): - if is empty returns false
    &#34;&#34;&#34;
    def __init__(self, *args):
        self.rootNode = None
        self.elements_count = 0
        self.rebalance_count = 0
        if len(args) == 1:
            for i in args[0]:
                self.insert(i)

    def __bool__(self):
        return bool(self.rootNode)

    def height(self):
        if self.rootNode:
            return self.rootNode.height
        else:
            return 0

    def max_len(self):
        # returns approximate number of elements of a tree based on information about tree height
        return sum([2 ** i for i in range(1, self.height())]) + 1

    def rebalance(self, node_to_rebalance):
        self.rebalance_count += 1
        A = node_to_rebalance
        F = A.parent  # allowed to be NULL
        if node_to_rebalance.balance() == -2:
            if node_to_rebalance.rightChild.balance() &lt;= 0:
                &#34;&#34;&#34;Rebalance, case RRC &#34;&#34;&#34;
                B = A.rightChild
                C = B.rightChild
                assert (not A is None and not B is None and not C is None)
                A.rightChild = B.leftChild
                if A.rightChild:
                    A.rightChild.parent = A
                B.leftChild = A
                A.parent = B
                if F is None:
                    self.rootNode = B
                    self.rootNode.parent = None
                else:
                    if F.rightChild == A:
                        F.rightChild = B
                    else:
                        F.leftChild = B
                    B.parent = F
                self.recompute_heights(A)
                self.recompute_heights(B.parent)
            else:
                &#34;&#34;&#34;Rebalance, case RLC &#34;&#34;&#34;
                B = A.rightChild
                C = B.leftChild
                assert (not A is None and not B is None and not C is None)
                B.leftChild = C.rightChild
                if B.leftChild:
                    B.leftChild.parent = B
                A.rightChild = C.leftChild
                if A.rightChild:
                    A.rightChild.parent = A
                C.rightChild = B
                B.parent = C
                C.leftChild = A
                A.parent = C
                if F is None:
                    self.rootNode = C
                    self.rootNode.parent = None
                else:
                    if F.rightChild == A:
                        F.rightChild = C
                    else:
                        F.leftChild = C
                    C.parent = F
                self.recompute_heights(A)
                self.recompute_heights(B)
        else:
            assert (node_to_rebalance.balance() == +2)
            if node_to_rebalance.leftChild.balance() &gt;= 0:
                B = A.leftChild
                C = B.leftChild
                &#34;&#34;&#34;Rebalance, case LLC &#34;&#34;&#34;
                assert (not A is None and not B is None and not C is None)
                A.leftChild = B.rightChild
                if (A.leftChild):
                    A.leftChild.parent = A
                B.rightChild = A
                A.parent = B
                if F is None:
                    self.rootNode = B
                    self.rootNode.parent = None
                else:
                    if F.rightChild == A:
                        F.rightChild = B
                    else:
                        F.leftChild = B
                    B.parent = F
                self.recompute_heights(A)
                self.recompute_heights(B.parent)
            else:
                B = A.leftChild
                C = B.rightChild
                &#34;&#34;&#34;Rebalance, case LRC &#34;&#34;&#34;
                assert (not A is None and not B is None and not C is None)
                A.leftChild = C.rightChild
                if A.leftChild:
                    A.leftChild.parent = A
                B.rightChild = C.leftChild
                if B.rightChild:
                    B.rightChild.parent = B
                C.leftChild = B
                B.parent = C
                C.rightChild = A
                A.parent = C
                if F is None:
                    self.rootNode = C
                    self.rootNode.parent = None
                else:
                    if (F.rightChild == A):
                        F.rightChild = C
                    else:
                        F.leftChild = C
                    C.parent = F
                self.recompute_heights(A)
                self.recompute_heights(B)

    def sanity_check(self, *args):
        if len(args) == 0:
            node = self.rootNode
        else:
            node = args[0]
        if (node is None) or (node.is_leaf() and node.parent is None):
            # trivial - no sanity check needed, as either the tree is empty or there is only one node in the tree
            pass
        else:
            if node.height != node.max_children_height() + 1:
                raise Exception(&#34;Invalid height for node &#34; + str(node) + &#34;: &#34; + str(node.height) + &#34; instead of &#34; + str(
                    node.max_children_height() + 1) + &#34;!&#34;)

            balFactor = node.balance()
            # Test the balance factor
            if not (balFactor &gt;= -1 and balFactor &lt;= 1):
                raise Exception(&#34;Balance factor for node &#34; + str(node) + &#34; is &#34; + str(balFactor) + &#34;!&#34;)
            # Make sure we have no circular references
            if not (node.leftChild != node):
                raise Exception(&#34;Circular reference for node &#34; + str(node) + &#34;: node.leftChild is node!&#34;)
            if not (node.rightChild != node):
                raise Exception(&#34;Circular reference for node &#34; + str(node) + &#34;: node.rightChild is node!&#34;)

            if (node.leftChild):
                if not (node.leftChild.parent == node):
                    raise Exception(&#34;Left child of node &#34; + str(node) + &#34; doesn&#39;t know who his father is!&#34;)
                if not (node.leftChild.key &lt;= node.key):
                    raise Exception(&#34;Key of left child of node &#34; + str(node) + &#34; is greater than key of his parent!&#34;)
                self.sanity_check(node.leftChild)

            if (node.rightChild):
                if not (node.rightChild.parent == node):
                    raise Exception(&#34;Right child of node &#34; + str(node) + &#34; doesn&#39;t know who his father is!&#34;)
                if not (node.rightChild.key &gt;= node.key):
                    raise Exception(&#34;Key of right child of node &#34; + str(node) + &#34; is less than key of his parent!&#34;)
                self.sanity_check(node.rightChild)

    def recompute_heights(self, start_from_node):
        changed = True
        node = start_from_node
        while node and changed:
            old_height = node.height
            node.height = (node.max_children_height() + 1 if (node.rightChild or node.leftChild) else 0)
            changed = node.height != old_height
            node = node.parent

    def add_as_child(self, parent_node, child_node):
        node_to_rebalance = None
        if child_node.key &lt; parent_node.key:
            if not parent_node.leftChild:
                parent_node.leftChild = child_node
                child_node.parent = parent_node
                if parent_node.height == 0:
                    node = parent_node
                    while node:
                        node.height = node.max_children_height() + 1
                        if not node.balance() in [-1, 0, 1]:
                            node_to_rebalance = node
                            break  # we need the one that is furthest from the root
                        node = node.parent
            else:
                child_node = self.add_as_child(parent_node.leftChild, child_node)
        else:
            if not parent_node.rightChild:
                parent_node.rightChild = child_node
                child_node.parent = parent_node
                if parent_node.height == 0:
                    node = parent_node
                    while node:
                        node.height = node.max_children_height() + 1
                        if not node.balance() in [-1, 0, 1]:
                            node_to_rebalance = node
                            break  # we need the one that is furthest from the root
                        node = node.parent
            else:
                child_node = self.add_as_child(parent_node.rightChild, child_node)

        if node_to_rebalance:
            self.rebalance(node_to_rebalance)

        return child_node

    def insert(self, key):
        # inserts new element to a tree, does not make warnings if element with equal value already was inserted
        # returns node any way
        new_node = Node(key)
        if not self.rootNode:
            self.rootNode = new_node
            return new_node
        else:
            exist_node = self.find(key)
            if not exist_node:
                self.elements_count += 1
                new_node = self.add_as_child(self.rootNode, new_node)
                return new_node
            else:
                return exist_node

    def find_biggest(self, start_node=None):
        # returns node with biggest value
        if not start_node:
            node = self.rootNode
        else:
            node = start_node
        while node.rightChild:
            node = node.rightChild
        return node

    def find_smallest(self, start_node=None):
        # returns node with smallest value
        if not start_node:
            node = self.rootNode
        else:
            node = start_node
        while node.leftChild:
            node = node.leftChild
        return node

    def inorder_non_recursive(self):
        node = self.rootNode
        retlst = []
        while node.leftChild:
            node = node.leftChild
        while (node):
            retlst += [node.key]
            if (node.rightChild):
                node = node.rightChild
                while node.leftChild:
                    node = node.leftChild
            else:
                while ((node.parent) and (node == node.parent.rightChild)):
                    node = node.parent
                node = node.parent
        return retlst

    def preorder(self, node, retlst=None):
        if retlst is None:
            retlst = []
        retlst += [node.key]
        if node.leftChild:
            retlst = self.preorder(node.leftChild, retlst)
        if node.rightChild:
            retlst = self.preorder(node.rightChild, retlst)
        return retlst

    def inorder(self, node, retlst=None):
        if retlst is None:
            retlst = []
        if node.leftChild:
            retlst = self.inorder(node.leftChild, retlst)
        retlst += [node.key]
        if node.rightChild:
            retlst = self.inorder(node.rightChild, retlst)
        return retlst

    def postorder(self, node, retlst=None):
        if retlst is None:
            retlst = []
        if node.leftChild:
            retlst = self.postorder(node.leftChild, retlst)
        if node.rightChild:
            retlst = self.postorder(node.rightChild, retlst)
        retlst += [node.key]
        return retlst

    def as_list(self, pre_in_post):
        if not self.rootNode:
            return []
        if pre_in_post == 0:
            return self.preorder(self.rootNode)
        elif pre_in_post == 1:
            return self.inorder(self.rootNode)
        elif pre_in_post == 2:
            return self.postorder(self.rootNode)
        elif pre_in_post == 3:
            return self.inorder_non_recursive()

    def find(self, key):
        # returns node or None if node with such value does not exist
        return self.find_in_subtree(self.rootNode, key)

    def find_in_subtree(self, node, key):
        if node is None:
            return None  # key not found
        if key &lt; node.key:
            return self.find_in_subtree(node.leftChild, key)
        elif key &gt; node.key:
            return self.find_in_subtree(node.rightChild, key)
        else:  # key is equal to node key
            return node

    def find_nearest_left(self, key):
        # returns next smaller to input value node
        if not self.rootNode:
            return None
        elif not self.rootNode.rightChild and self.rootNode.key &lt; key:
            return self.rootNode
        else:
            return self.find_nearest_in_subtree(self.rootNode, key)

    def find_nearest_in_subtree(self, node, key):
        if key &lt; node.key:
            if node.leftChild:
                return self.find_nearest_in_subtree(node.leftChild, key)
            else:
                return node.last
        elif key &gt; node.key:
            if node.rightChild:
                return self.find_nearest_in_subtree(node.rightChild, key)
            else:
                return node  # without last because the node already is left neighbour
        else:
            return node  # probably node.last ???

    def remove(self, key):
        # removes node from a tree equal to input value if such node exists
        # first find
        node = self.find(key)

        if not node is None:
            self.elements_count -= 1

            #     There are three cases:
            #
            #     1) The node is a leaf.  Remove it and return.
            #
            #     2) The node is a branch (has only 1 child). Make the pointer to this node
            #        point to the child of this node.
            #
            #     3) The node has two children. Swap items with the successor
            #        of the node (the smallest item in its right subtree) and
            #        delete the successor from the right subtree of the node.
            if node.is_leaf():
                self.remove_leaf(node)
            elif (bool(node.leftChild)) ^ (bool(node.rightChild)):
                self.remove_branch(node)
            else:
                assert (node.leftChild) and (node.rightChild)
                self.swap_with_successor_and_remove(node)

    def remove_node(self, node):
        # removes node from a tree
        if node.is_leaf():
            self.remove_leaf(node)
        elif (bool(node.leftChild)) ^ (bool(node.rightChild)):
            self.remove_branch(node)
        else:
            assert (node.leftChild) and (node.rightChild)
            self.swap_with_successor_and_remove(node)

    def remove_leaf(self, node):
        parent = node.parent
        if (parent):
            if parent.leftChild == node:
                parent.leftChild = None
            else:
                assert (parent.rightChild == node)
                parent.rightChild = None
            self.recompute_heights(parent)
        else:
            self.rootNode = None
        del node
        # rebalance
        node = parent
        while (node):
            if not node.balance() in [-1, 0, 1]:
                self.rebalance(node)
            node = node.parent

    def remove_branch(self, node):
        parent = node.parent
        leftChild = node.leftChild
        rightChild = node.rightChild

        if (parent):
            if parent.leftChild == node:
                parent.leftChild = node.rightChild or node.leftChild
            else:
                assert (parent.rightChild == node)
                parent.rightChild = node.rightChild or node.leftChild
            if node.leftChild:
                node.leftChild.parent = parent
            else:
                assert (node.rightChild)
                node.rightChild.parent = parent
            self.recompute_heights(parent)
        del node
        # rebalance
        node = parent
        if node:
            while node:
                if not node.balance() in [-1, 0, 1]:
                    self.rebalance(node)
                node = node.parent
        else:
            if leftChild:
                self.rootNode = leftChild
            else:
                self.rootNode = rightChild

            self.rootNode.parent = None

    def swap_with_successor_and_remove(self, node):
        successor = self.find_smallest(node.rightChild)
        self.swap_nodes(node, successor)
        assert (node.leftChild is None)
        if node.height == 0:
            self.remove_leaf(node)
        else:
            self.remove_branch(node)

    def swap_nodes(self, node1, node2):
        assert (node1.height &gt; node2.height)
        parent1 = node1.parent
        leftChild1 = node1.leftChild
        rightChild1 = node1.rightChild
        parent2 = node2.parent
        assert (not parent2 is None)
        assert (parent2.leftChild == node2 or parent2 == node1)
        leftChild2 = node2.leftChild
        assert (leftChild2 is None)
        rightChild2 = node2.rightChild

        # swap heights
        tmp = node1.height
        node1.height = node2.height
        node2.height = tmp

        if parent1:
            if parent1.leftChild == node1:
                parent1.leftChild = node2
            else:
                assert (parent1.rightChild == node1)
                parent1.rightChild = node2
            node2.parent = parent1
        else:
            self.rootNode = node2
            node2.parent = None

        node2.leftChild = leftChild1
        leftChild1.parent = node2
        node1.leftChild = leftChild2  # None
        node1.rightChild = rightChild2
        if rightChild2:
            rightChild2.parent = node1
        if not (parent2 == node1):
            node2.rightChild = rightChild1
            rightChild1.parent = node2

            parent2.leftChild = node1
            node1.parent = parent2
        else:
            node2.rightChild = node1
            node1.parent = node2

            # use for debug only and only with small trees

    def out(self, start_node=None):
        # prints a tree in suitable for reading form
        if start_node == None:
            start_node = self.rootNode
        space_symbol = &#34;*&#34;
        spaces_count = 80
        out_string = &#34;&#34;
        initial_spaces_string = space_symbol * spaces_count + &#34;\n&#34;
        if not start_node:
            return &#34;AVLTree is empty&#34;
        else:
            level = [start_node]
            while (len([i for i in level if (not i is None)]) &gt; 0):
                level_string = initial_spaces_string
                for i in range(len(level)):
                    j = int((i + 1) * spaces_count / (len(level) + 1))
                    level_string = level_string[:j] + (str(level[i]) if level[i] else space_symbol) + level_string[
                                                                                                      j + 1:]
                level_next = []
                for i in level:
                    level_next += ([i.leftChild, i.rightChild] if i else [None, None])
                level = level_next
                out_string += level_string
        return out_string</code></pre>
</details>
<div class="desc"><p><a href="https://en.wikipedia.org/wiki/AVL_tree">https://en.wikipedia.org/wiki/AVL_tree</a>
<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a>
can be used in conditions like this: if AVLTree(): - if is empty returns false</p></div>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.avl_tree.AVLTree.add_as_child"><code class="name flex">
<span>def <span class="ident">add_as_child</span></span>(<span>self, parent_node, child_node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_as_child(self, parent_node, child_node):
    node_to_rebalance = None
    if child_node.key &lt; parent_node.key:
        if not parent_node.leftChild:
            parent_node.leftChild = child_node
            child_node.parent = parent_node
            if parent_node.height == 0:
                node = parent_node
                while node:
                    node.height = node.max_children_height() + 1
                    if not node.balance() in [-1, 0, 1]:
                        node_to_rebalance = node
                        break  # we need the one that is furthest from the root
                    node = node.parent
        else:
            child_node = self.add_as_child(parent_node.leftChild, child_node)
    else:
        if not parent_node.rightChild:
            parent_node.rightChild = child_node
            child_node.parent = parent_node
            if parent_node.height == 0:
                node = parent_node
                while node:
                    node.height = node.max_children_height() + 1
                    if not node.balance() in [-1, 0, 1]:
                        node_to_rebalance = node
                        break  # we need the one that is furthest from the root
                    node = node.parent
        else:
            child_node = self.add_as_child(parent_node.rightChild, child_node)

    if node_to_rebalance:
        self.rebalance(node_to_rebalance)

    return child_node</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.as_list"><code class="name flex">
<span>def <span class="ident">as_list</span></span>(<span>self, pre_in_post)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_list(self, pre_in_post):
    if not self.rootNode:
        return []
    if pre_in_post == 0:
        return self.preorder(self.rootNode)
    elif pre_in_post == 1:
        return self.inorder(self.rootNode)
    elif pre_in_post == 2:
        return self.postorder(self.rootNode)
    elif pre_in_post == 3:
        return self.inorder_non_recursive()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, key):
    # returns node or None if node with such value does not exist
    return self.find_in_subtree(self.rootNode, key)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.find_biggest"><code class="name flex">
<span>def <span class="ident">find_biggest</span></span>(<span>self, start_node=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_biggest(self, start_node=None):
    # returns node with biggest value
    if not start_node:
        node = self.rootNode
    else:
        node = start_node
    while node.rightChild:
        node = node.rightChild
    return node</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.find_in_subtree"><code class="name flex">
<span>def <span class="ident">find_in_subtree</span></span>(<span>self, node, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_in_subtree(self, node, key):
    if node is None:
        return None  # key not found
    if key &lt; node.key:
        return self.find_in_subtree(node.leftChild, key)
    elif key &gt; node.key:
        return self.find_in_subtree(node.rightChild, key)
    else:  # key is equal to node key
        return node</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.find_nearest_in_subtree"><code class="name flex">
<span>def <span class="ident">find_nearest_in_subtree</span></span>(<span>self, node, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_nearest_in_subtree(self, node, key):
    if key &lt; node.key:
        if node.leftChild:
            return self.find_nearest_in_subtree(node.leftChild, key)
        else:
            return node.last
    elif key &gt; node.key:
        if node.rightChild:
            return self.find_nearest_in_subtree(node.rightChild, key)
        else:
            return node  # without last because the node already is left neighbour
    else:
        return node  # probably node.last ???</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.find_nearest_left"><code class="name flex">
<span>def <span class="ident">find_nearest_left</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_nearest_left(self, key):
    # returns next smaller to input value node
    if not self.rootNode:
        return None
    elif not self.rootNode.rightChild and self.rootNode.key &lt; key:
        return self.rootNode
    else:
        return self.find_nearest_in_subtree(self.rootNode, key)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.find_smallest"><code class="name flex">
<span>def <span class="ident">find_smallest</span></span>(<span>self, start_node=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_smallest(self, start_node=None):
    # returns node with smallest value
    if not start_node:
        node = self.rootNode
    else:
        node = start_node
    while node.leftChild:
        node = node.leftChild
    return node</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def height(self):
    if self.rootNode:
        return self.rootNode.height
    else:
        return 0</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.inorder"><code class="name flex">
<span>def <span class="ident">inorder</span></span>(<span>self, node, retlst=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inorder(self, node, retlst=None):
    if retlst is None:
        retlst = []
    if node.leftChild:
        retlst = self.inorder(node.leftChild, retlst)
    retlst += [node.key]
    if node.rightChild:
        retlst = self.inorder(node.rightChild, retlst)
    return retlst</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.inorder_non_recursive"><code class="name flex">
<span>def <span class="ident">inorder_non_recursive</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inorder_non_recursive(self):
    node = self.rootNode
    retlst = []
    while node.leftChild:
        node = node.leftChild
    while (node):
        retlst += [node.key]
        if (node.rightChild):
            node = node.rightChild
            while node.leftChild:
                node = node.leftChild
        else:
            while ((node.parent) and (node == node.parent.rightChild)):
                node = node.parent
            node = node.parent
    return retlst</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, key):
    # inserts new element to a tree, does not make warnings if element with equal value already was inserted
    # returns node any way
    new_node = Node(key)
    if not self.rootNode:
        self.rootNode = new_node
        return new_node
    else:
        exist_node = self.find(key)
        if not exist_node:
            self.elements_count += 1
            new_node = self.add_as_child(self.rootNode, new_node)
            return new_node
        else:
            return exist_node</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.max_len"><code class="name flex">
<span>def <span class="ident">max_len</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_len(self):
    # returns approximate number of elements of a tree based on information about tree height
    return sum([2 ** i for i in range(1, self.height())]) + 1</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.out"><code class="name flex">
<span>def <span class="ident">out</span></span>(<span>self, start_node=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def out(self, start_node=None):
    # prints a tree in suitable for reading form
    if start_node == None:
        start_node = self.rootNode
    space_symbol = &#34;*&#34;
    spaces_count = 80
    out_string = &#34;&#34;
    initial_spaces_string = space_symbol * spaces_count + &#34;\n&#34;
    if not start_node:
        return &#34;AVLTree is empty&#34;
    else:
        level = [start_node]
        while (len([i for i in level if (not i is None)]) &gt; 0):
            level_string = initial_spaces_string
            for i in range(len(level)):
                j = int((i + 1) * spaces_count / (len(level) + 1))
                level_string = level_string[:j] + (str(level[i]) if level[i] else space_symbol) + level_string[
                                                                                                  j + 1:]
            level_next = []
            for i in level:
                level_next += ([i.leftChild, i.rightChild] if i else [None, None])
            level = level_next
            out_string += level_string
    return out_string</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.postorder"><code class="name flex">
<span>def <span class="ident">postorder</span></span>(<span>self, node, retlst=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postorder(self, node, retlst=None):
    if retlst is None:
        retlst = []
    if node.leftChild:
        retlst = self.postorder(node.leftChild, retlst)
    if node.rightChild:
        retlst = self.postorder(node.rightChild, retlst)
    retlst += [node.key]
    return retlst</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.preorder"><code class="name flex">
<span>def <span class="ident">preorder</span></span>(<span>self, node, retlst=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preorder(self, node, retlst=None):
    if retlst is None:
        retlst = []
    retlst += [node.key]
    if node.leftChild:
        retlst = self.preorder(node.leftChild, retlst)
    if node.rightChild:
        retlst = self.preorder(node.rightChild, retlst)
    return retlst</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.rebalance"><code class="name flex">
<span>def <span class="ident">rebalance</span></span>(<span>self, node_to_rebalance)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebalance(self, node_to_rebalance):
    self.rebalance_count += 1
    A = node_to_rebalance
    F = A.parent  # allowed to be NULL
    if node_to_rebalance.balance() == -2:
        if node_to_rebalance.rightChild.balance() &lt;= 0:
            &#34;&#34;&#34;Rebalance, case RRC &#34;&#34;&#34;
            B = A.rightChild
            C = B.rightChild
            assert (not A is None and not B is None and not C is None)
            A.rightChild = B.leftChild
            if A.rightChild:
                A.rightChild.parent = A
            B.leftChild = A
            A.parent = B
            if F is None:
                self.rootNode = B
                self.rootNode.parent = None
            else:
                if F.rightChild == A:
                    F.rightChild = B
                else:
                    F.leftChild = B
                B.parent = F
            self.recompute_heights(A)
            self.recompute_heights(B.parent)
        else:
            &#34;&#34;&#34;Rebalance, case RLC &#34;&#34;&#34;
            B = A.rightChild
            C = B.leftChild
            assert (not A is None and not B is None and not C is None)
            B.leftChild = C.rightChild
            if B.leftChild:
                B.leftChild.parent = B
            A.rightChild = C.leftChild
            if A.rightChild:
                A.rightChild.parent = A
            C.rightChild = B
            B.parent = C
            C.leftChild = A
            A.parent = C
            if F is None:
                self.rootNode = C
                self.rootNode.parent = None
            else:
                if F.rightChild == A:
                    F.rightChild = C
                else:
                    F.leftChild = C
                C.parent = F
            self.recompute_heights(A)
            self.recompute_heights(B)
    else:
        assert (node_to_rebalance.balance() == +2)
        if node_to_rebalance.leftChild.balance() &gt;= 0:
            B = A.leftChild
            C = B.leftChild
            &#34;&#34;&#34;Rebalance, case LLC &#34;&#34;&#34;
            assert (not A is None and not B is None and not C is None)
            A.leftChild = B.rightChild
            if (A.leftChild):
                A.leftChild.parent = A
            B.rightChild = A
            A.parent = B
            if F is None:
                self.rootNode = B
                self.rootNode.parent = None
            else:
                if F.rightChild == A:
                    F.rightChild = B
                else:
                    F.leftChild = B
                B.parent = F
            self.recompute_heights(A)
            self.recompute_heights(B.parent)
        else:
            B = A.leftChild
            C = B.rightChild
            &#34;&#34;&#34;Rebalance, case LRC &#34;&#34;&#34;
            assert (not A is None and not B is None and not C is None)
            A.leftChild = C.rightChild
            if A.leftChild:
                A.leftChild.parent = A
            B.rightChild = C.leftChild
            if B.rightChild:
                B.rightChild.parent = B
            C.leftChild = B
            B.parent = C
            C.rightChild = A
            A.parent = C
            if F is None:
                self.rootNode = C
                self.rootNode.parent = None
            else:
                if (F.rightChild == A):
                    F.rightChild = C
                else:
                    F.leftChild = C
                C.parent = F
            self.recompute_heights(A)
            self.recompute_heights(B)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.recompute_heights"><code class="name flex">
<span>def <span class="ident">recompute_heights</span></span>(<span>self, start_from_node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recompute_heights(self, start_from_node):
    changed = True
    node = start_from_node
    while node and changed:
        old_height = node.height
        node.height = (node.max_children_height() + 1 if (node.rightChild or node.leftChild) else 0)
        changed = node.height != old_height
        node = node.parent</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, key):
    # removes node from a tree equal to input value if such node exists
    # first find
    node = self.find(key)

    if not node is None:
        self.elements_count -= 1

        #     There are three cases:
        #
        #     1) The node is a leaf.  Remove it and return.
        #
        #     2) The node is a branch (has only 1 child). Make the pointer to this node
        #        point to the child of this node.
        #
        #     3) The node has two children. Swap items with the successor
        #        of the node (the smallest item in its right subtree) and
        #        delete the successor from the right subtree of the node.
        if node.is_leaf():
            self.remove_leaf(node)
        elif (bool(node.leftChild)) ^ (bool(node.rightChild)):
            self.remove_branch(node)
        else:
            assert (node.leftChild) and (node.rightChild)
            self.swap_with_successor_and_remove(node)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.remove_branch"><code class="name flex">
<span>def <span class="ident">remove_branch</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_branch(self, node):
    parent = node.parent
    leftChild = node.leftChild
    rightChild = node.rightChild

    if (parent):
        if parent.leftChild == node:
            parent.leftChild = node.rightChild or node.leftChild
        else:
            assert (parent.rightChild == node)
            parent.rightChild = node.rightChild or node.leftChild
        if node.leftChild:
            node.leftChild.parent = parent
        else:
            assert (node.rightChild)
            node.rightChild.parent = parent
        self.recompute_heights(parent)
    del node
    # rebalance
    node = parent
    if node:
        while node:
            if not node.balance() in [-1, 0, 1]:
                self.rebalance(node)
            node = node.parent
    else:
        if leftChild:
            self.rootNode = leftChild
        else:
            self.rootNode = rightChild

        self.rootNode.parent = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.remove_leaf"><code class="name flex">
<span>def <span class="ident">remove_leaf</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_leaf(self, node):
    parent = node.parent
    if (parent):
        if parent.leftChild == node:
            parent.leftChild = None
        else:
            assert (parent.rightChild == node)
            parent.rightChild = None
        self.recompute_heights(parent)
    else:
        self.rootNode = None
    del node
    # rebalance
    node = parent
    while (node):
        if not node.balance() in [-1, 0, 1]:
            self.rebalance(node)
        node = node.parent</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node(self, node):
    # removes node from a tree
    if node.is_leaf():
        self.remove_leaf(node)
    elif (bool(node.leftChild)) ^ (bool(node.rightChild)):
        self.remove_branch(node)
    else:
        assert (node.leftChild) and (node.rightChild)
        self.swap_with_successor_and_remove(node)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.sanity_check"><code class="name flex">
<span>def <span class="ident">sanity_check</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sanity_check(self, *args):
    if len(args) == 0:
        node = self.rootNode
    else:
        node = args[0]
    if (node is None) or (node.is_leaf() and node.parent is None):
        # trivial - no sanity check needed, as either the tree is empty or there is only one node in the tree
        pass
    else:
        if node.height != node.max_children_height() + 1:
            raise Exception(&#34;Invalid height for node &#34; + str(node) + &#34;: &#34; + str(node.height) + &#34; instead of &#34; + str(
                node.max_children_height() + 1) + &#34;!&#34;)

        balFactor = node.balance()
        # Test the balance factor
        if not (balFactor &gt;= -1 and balFactor &lt;= 1):
            raise Exception(&#34;Balance factor for node &#34; + str(node) + &#34; is &#34; + str(balFactor) + &#34;!&#34;)
        # Make sure we have no circular references
        if not (node.leftChild != node):
            raise Exception(&#34;Circular reference for node &#34; + str(node) + &#34;: node.leftChild is node!&#34;)
        if not (node.rightChild != node):
            raise Exception(&#34;Circular reference for node &#34; + str(node) + &#34;: node.rightChild is node!&#34;)

        if (node.leftChild):
            if not (node.leftChild.parent == node):
                raise Exception(&#34;Left child of node &#34; + str(node) + &#34; doesn&#39;t know who his father is!&#34;)
            if not (node.leftChild.key &lt;= node.key):
                raise Exception(&#34;Key of left child of node &#34; + str(node) + &#34; is greater than key of his parent!&#34;)
            self.sanity_check(node.leftChild)

        if (node.rightChild):
            if not (node.rightChild.parent == node):
                raise Exception(&#34;Right child of node &#34; + str(node) + &#34; doesn&#39;t know who his father is!&#34;)
            if not (node.rightChild.key &gt;= node.key):
                raise Exception(&#34;Key of right child of node &#34; + str(node) + &#34; is less than key of his parent!&#34;)
            self.sanity_check(node.rightChild)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.swap_nodes"><code class="name flex">
<span>def <span class="ident">swap_nodes</span></span>(<span>self, node1, node2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_nodes(self, node1, node2):
    assert (node1.height &gt; node2.height)
    parent1 = node1.parent
    leftChild1 = node1.leftChild
    rightChild1 = node1.rightChild
    parent2 = node2.parent
    assert (not parent2 is None)
    assert (parent2.leftChild == node2 or parent2 == node1)
    leftChild2 = node2.leftChild
    assert (leftChild2 is None)
    rightChild2 = node2.rightChild

    # swap heights
    tmp = node1.height
    node1.height = node2.height
    node2.height = tmp

    if parent1:
        if parent1.leftChild == node1:
            parent1.leftChild = node2
        else:
            assert (parent1.rightChild == node1)
            parent1.rightChild = node2
        node2.parent = parent1
    else:
        self.rootNode = node2
        node2.parent = None

    node2.leftChild = leftChild1
    leftChild1.parent = node2
    node1.leftChild = leftChild2  # None
    node1.rightChild = rightChild2
    if rightChild2:
        rightChild2.parent = node1
    if not (parent2 == node1):
        node2.rightChild = rightChild1
        rightChild1.parent = node2

        parent2.leftChild = node1
        node1.parent = parent2
    else:
        node2.rightChild = node1
        node1.parent = node2

        # use for debug only and only with small trees</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.AVLTree.swap_with_successor_and_remove"><code class="name flex">
<span>def <span class="ident">swap_with_successor_and_remove</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_with_successor_and_remove(self, node):
    successor = self.find_smallest(node.rightChild)
    self.swap_nodes(node, successor)
    assert (node.leftChild is None)
    if node.height == 0:
        self.remove_leaf(node)
    else:
        self.remove_branch(node)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.avl_tree.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node:
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.leftChild = None
        self.rightChild = None
        self.height = 0

    def __str__(self):
        return str(self.key) + &#34;(&#34; + str(self.height) + &#34;)&#34;

    @property
    def next(self):
        # returns next greater element or None if such does not exist
        if self.rightChild:
            node = self.rightChild
            while node.leftChild:
                node = node.leftChild
            return node
        elif self.parent:
            parent = self.parent
            child = self
            while True:
                if parent.leftChild and not any([parent.leftChild.key &lt; child.key, parent.leftChild.key &gt; child.key]):  # &lt;-fix??
                    return parent
                elif parent.parent:
                    child = parent
                    parent = parent.parent
                else:
                    return None

    @property
    def last(self):
        # returns next smaller element or None if such does not exist
        if self.leftChild:
            node = self.leftChild
            while node.rightChild:
                node = node.rightChild
            return node
        elif self.parent:
            parent = self.parent
            child = self
            while True:
                if parent.rightChild and not any([parent.rightChild.key &lt; child.key, parent.rightChild.key &gt; child.key]):  # &lt;-fix??
                    return parent
                elif parent.parent:
                    child = parent
                    parent = parent.parent
                else:
                    return None

    def is_leaf(self):
        return (self.height == 0)

    def max_children_height(self):
        if self.leftChild and self.rightChild:
            return max(self.leftChild.height, self.rightChild.height)
        elif self.leftChild and not self.rightChild:
            return self.leftChild.height
        elif not self.leftChild and self.rightChild:
            return self.rightChild.height
        else:
            return -1

    def balance(self):
        return (self.leftChild.height if self.leftChild else -1) - (self.rightChild.height if self.rightChild else -1)</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.avl_tree.Node.last"><code class="name">prop <span class="ident">last</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last(self):
    # returns next smaller element or None if such does not exist
    if self.leftChild:
        node = self.leftChild
        while node.rightChild:
            node = node.rightChild
        return node
    elif self.parent:
        parent = self.parent
        child = self
        while True:
            if parent.rightChild and not any([parent.rightChild.key &lt; child.key, parent.rightChild.key &gt; child.key]):  # &lt;-fix??
                return parent
            elif parent.parent:
                child = parent
                parent = parent.parent
            else:
                return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.Node.next"><code class="name">prop <span class="ident">next</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next(self):
    # returns next greater element or None if such does not exist
    if self.rightChild:
        node = self.rightChild
        while node.leftChild:
            node = node.leftChild
        return node
    elif self.parent:
        parent = self.parent
        child = self
        while True:
            if parent.leftChild and not any([parent.leftChild.key &lt; child.key, parent.leftChild.key &gt; child.key]):  # &lt;-fix??
                return parent
            elif parent.parent:
                child = parent
                parent = parent.parent
            else:
                return None</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.avl_tree.Node.balance"><code class="name flex">
<span>def <span class="ident">balance</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def balance(self):
    return (self.leftChild.height if self.leftChild else -1) - (self.rightChild.height if self.rightChild else -1)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.Node.is_leaf"><code class="name flex">
<span>def <span class="ident">is_leaf</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_leaf(self):
    return (self.height == 0)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.avl_tree.Node.max_children_height"><code class="name flex">
<span>def <span class="ident">max_children_height</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_children_height(self):
    if self.leftChild and self.rightChild:
        return max(self.leftChild.height, self.rightChild.height)
    elif self.leftChild and not self.rightChild:
        return self.leftChild.height
    elif not self.leftChild and self.rightChild:
        return self.rightChild.height
    else:
        return -1</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.avl_tree.AVLTree" href="#sverchok.utils.avl_tree.AVLTree">AVLTree</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.avl_tree.AVLTree.add_as_child" href="#sverchok.utils.avl_tree.AVLTree.add_as_child">add_as_child</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.as_list" href="#sverchok.utils.avl_tree.AVLTree.as_list">as_list</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.find" href="#sverchok.utils.avl_tree.AVLTree.find">find</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.find_biggest" href="#sverchok.utils.avl_tree.AVLTree.find_biggest">find_biggest</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.find_in_subtree" href="#sverchok.utils.avl_tree.AVLTree.find_in_subtree">find_in_subtree</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.find_nearest_in_subtree" href="#sverchok.utils.avl_tree.AVLTree.find_nearest_in_subtree">find_nearest_in_subtree</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.find_nearest_left" href="#sverchok.utils.avl_tree.AVLTree.find_nearest_left">find_nearest_left</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.find_smallest" href="#sverchok.utils.avl_tree.AVLTree.find_smallest">find_smallest</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.height" href="#sverchok.utils.avl_tree.AVLTree.height">height</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.inorder" href="#sverchok.utils.avl_tree.AVLTree.inorder">inorder</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.inorder_non_recursive" href="#sverchok.utils.avl_tree.AVLTree.inorder_non_recursive">inorder_non_recursive</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.insert" href="#sverchok.utils.avl_tree.AVLTree.insert">insert</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.max_len" href="#sverchok.utils.avl_tree.AVLTree.max_len">max_len</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.out" href="#sverchok.utils.avl_tree.AVLTree.out">out</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.postorder" href="#sverchok.utils.avl_tree.AVLTree.postorder">postorder</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.preorder" href="#sverchok.utils.avl_tree.AVLTree.preorder">preorder</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.rebalance" href="#sverchok.utils.avl_tree.AVLTree.rebalance">rebalance</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.recompute_heights" href="#sverchok.utils.avl_tree.AVLTree.recompute_heights">recompute_heights</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.remove" href="#sverchok.utils.avl_tree.AVLTree.remove">remove</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.remove_branch" href="#sverchok.utils.avl_tree.AVLTree.remove_branch">remove_branch</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.remove_leaf" href="#sverchok.utils.avl_tree.AVLTree.remove_leaf">remove_leaf</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.remove_node" href="#sverchok.utils.avl_tree.AVLTree.remove_node">remove_node</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.sanity_check" href="#sverchok.utils.avl_tree.AVLTree.sanity_check">sanity_check</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.swap_nodes" href="#sverchok.utils.avl_tree.AVLTree.swap_nodes">swap_nodes</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.AVLTree.swap_with_successor_and_remove" href="#sverchok.utils.avl_tree.AVLTree.swap_with_successor_and_remove">swap_with_successor_and_remove</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.avl_tree.Node" href="#sverchok.utils.avl_tree.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.avl_tree.Node.balance" href="#sverchok.utils.avl_tree.Node.balance">balance</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.Node.is_leaf" href="#sverchok.utils.avl_tree.Node.is_leaf">is_leaf</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.Node.last" href="#sverchok.utils.avl_tree.Node.last">last</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.Node.max_children_height" href="#sverchok.utils.avl_tree.Node.max_children_height">max_children_height</a></code></li>
<li><code><a title="sverchok.utils.avl_tree.Node.next" href="#sverchok.utils.avl_tree.Node.next">next</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
