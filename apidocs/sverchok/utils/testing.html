<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>sverchok.utils.testing API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.testing</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.testing.batch_only"><code class="name flex">
<span>def <span class="ident">batch_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for tests that are to be executed in batch mode only
(i.e. when tests are run from command line, either locally or in CI
environment). Usage:</p>
<pre><code>@batch_only
def test_something(self):
    ...
</code></pre></div>
</dd>
<dt id="sverchok.utils.testing.branches_only"><code class="name flex">
<span>def <span class="ident">branches_only</span></span>(<span>*branches)</span>
</code></dt>
<dd>
<div class="desc"><p>This test should be only executed for specified branches:</p>
<pre><code>@branches_only("master")
def test_something(self):
    ...
</code></pre>
<p>Please note that this applies only for Travis CI builds,
in manual mode this test will be ran anyway.</p></div>
</dd>
<dt id="sverchok.utils.testing.coverage_report"><code class="name flex">
<span>def <span class="ident">coverage_report</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.create_node"><code class="name flex">
<span>def <span class="ident">create_node</span></span>(<span>node_type, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create Sverchok node by it's bl_idname.</p></div>
</dd>
<dt id="sverchok.utils.testing.create_node_tree"><code class="name flex">
<span>def <span class="ident">create_node_tree</span></span>(<span>name=None, must_not_exist=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create new Sverchok node tree in the scene.
If must_not_exist == True (default), then it is checked that
the tree with such name did not exist before. If it exists,
an exception is raised.
If must_not_exist == False, then new tree will be created anyway,
but it can be created with another name (standard Blender's renaming).</p></div>
</dd>
<dt id="sverchok.utils.testing.generate_node_definition"><code class="name flex">
<span>def <span class="ident">generate_node_definition</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate code that programmatically creates specified node.
This works only for simple cases.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_ci_branch"><code class="name flex">
<span>def <span class="ident">get_ci_branch</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>If we are running inside an integration server build, return
the name of git branch which we are checking.
Otherwise, return None.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_node"><code class="name flex">
<span>def <span class="ident">get_node</span></span>(<span>node_name, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return existing node.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_node_editor_context"><code class="name flex">
<span>def <span class="ident">get_node_editor_context</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare context override for bpy operators that need context.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_node_tree"><code class="name flex">
<span>def <span class="ident">get_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return existing node tree, or raise an exception if there is no such.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_or_create_node_tree"><code class="name flex">
<span>def <span class="ident">get_or_create_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create new Sverchok node tree or reuse existing one.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_tests_path"><code class="name flex">
<span>def <span class="ident">get_tests_path</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return path to all test cases (tests/ directory).</p></div>
</dd>
<dt id="sverchok.utils.testing.interactive_only"><code class="name flex">
<span>def <span class="ident">interactive_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for tests that are to be executed in interactive mode only
(i.e. when tests are run from Blender's UI with "Run all tests" button).</p>
<h2 id="usage">Usage</h2>
<p>@interactive_only
def test_something(self):
&hellip;</p></div>
</dd>
<dt id="sverchok.utils.testing.is_integration_server"><code class="name flex">
<span>def <span class="ident">is_integration_server</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if we a running inside an integration server (Travis CI) build.</p></div>
</dd>
<dt id="sverchok.utils.testing.is_pull_request"><code class="name flex">
<span>def <span class="ident">is_pull_request</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if we are running a build for pull-request check on Travis CI.</p></div>
</dd>
<dt id="sverchok.utils.testing.link_node_tree"><code class="name flex">
<span>def <span class="ident">link_node_tree</span></span>(<span>reference_blend_path, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Link node tree from specified .blend file.</p></div>
</dd>
<dt id="sverchok.utils.testing.link_text_block"><code class="name flex">
<span>def <span class="ident">link_text_block</span></span>(<span>reference_blend_path, block_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Link text block from specified .blend file.</p></div>
</dd>
<dt id="sverchok.utils.testing.make_skip_decorator"><code class="name flex">
<span>def <span class="ident">make_skip_decorator</span></span>(<span>condition, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.manual_only"><code class="name flex">
<span>def <span class="ident">manual_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.only_test_logs"><code class="name flex">
<span>def <span class="ident">only_test_logs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.pull_requests_only"><code class="name flex">
<span>def <span class="ident">pull_requests_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.remove_all_trees"><code class="name flex">
<span>def <span class="ident">remove_all_trees</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all trees</p></div>
</dd>
<dt id="sverchok.utils.testing.remove_node_tree"><code class="name flex">
<span>def <span class="ident">remove_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove existing Sverchok node tree.</p></div>
</dd>
<dt id="sverchok.utils.testing.requires"><code class="name flex">
<span>def <span class="ident">requires</span></span>(<span>module)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.run_all_tests"><code class="name flex">
<span>def <span class="ident">run_all_tests</span></span>(<span>pattern=None, log_file='sverchok_tests.log', log_level=None, verbosity=2, failfast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run all existing test cases.
Test cases are looked up under tests/ directory.</p></div>
</dd>
<dt id="sverchok.utils.testing.run_test_from_file"><code class="name flex">
<span>def <span class="ident">run_test_from_file</span></span>(<span>file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Run test from file given by name. File should be places in tests folder
:param file_name: string like avl_tree_tests.py
:return: result</p></div>
</dd>
<dt id="sverchok.utils.testing.skip_pull_requests"><code class="name flex">
<span>def <span class="ident">skip_pull_requests</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.testing.EmptyTreeTestCase"><code class="flex name class">
<span>class <span class="ident">EmptyTreeTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for test cases, that work on empty node tree.
At setup, it creates new node tree (it becomes available as self.tree).
At teardown, it removes created node tree.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that work on empty node tree.
    At setup, it creates new node tree (it becomes available as self.tree).
    At teardown, it removes created node tree.
    &#34;&#34;&#34;

    def setUp(self):
        super().setUp()
        self.tree = get_or_create_node_tree()

    def tearDown(self):
        remove_node_tree()
        super().tearDown()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.NodeProcessTestCase" href="#sverchok.utils.testing.NodeProcessTestCase">NodeProcessTestCase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.EmptyTreeTestCase.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase"><code class="flex name class">
<span>class <span class="ident">NodeProcessTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for test cases that test process() function
of one single node.
At setup, this class creates an empty node tree and one
node in it. bl_idname of tested node must be specified in
`node_bl_idname' property of child test case class.
Optionally, some simple nodes can be created (by default
a Note node) and connected to some outputs of tested node.
This is useful for nodes that return from process() if they
see that nothing is linked to outputs.</p>
<p>In actual test_xxx() method, the test case should call
self.node.process(), and after that examine output of the
node by either self.get_output_data() or self.assert_output_data_equals().</p>
<p>At teardown, the whole tested node tree is deleted.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeProcessTestCase(EmptyTreeTestCase):
    &#34;&#34;&#34;
    Base class for test cases that test process() function
    of one single node.
    At setup, this class creates an empty node tree and one
    node in it. bl_idname of tested node must be specified in
    `node_bl_idname&#39; property of child test case class.
    Optionally, some simple nodes can be created (by default
    a Note node) and connected to some outputs of tested node.
    This is useful for nodes that return from process() if they
    see that nothing is linked to outputs.

    In actual test_xxx() method, the test case should call
    self.node.process(), and after that examine output of the
    node by either self.get_output_data() or self.assert_output_data_equals().

    At teardown, the whole tested node tree is deleted.
    &#34;&#34;&#34;

    node_bl_idname = None
    connect_output_sockets = None
    output_node_bl_idname = &#34;NoteNode&#34;

    def get_output_data(self, output_name):
        &#34;&#34;&#34;
        Return data that tested node has written to named output socket.
        Returns None if it hasn&#39;t written any data.
        &#34;&#34;&#34;
        try:
            return get_output_socket_data(self.node, output_name)
        except SvNoDataError:
            return None
    
    def assert_output_data_equals(self, output_name, expected_data, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected_data to
        output socket output_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        self.assertEquals(data, expected_data, message)

    def assert_output_data_equals_file(self, output_name, expected_data_file_name, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected data to
        output socket output_name.
        Expected data is stored in reference file expected_data_file_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        self.assert_sverchok_data_equal(data, expected_data, message=message)

    def setUp(self):
        super().setUp()

        if self.node_bl_idname is None:
            raise Exception(&#34;NodeProcessTestCase subclass must have `node_bl_idname&#39; set&#34;)

        self.node = create_node(self.node_bl_idname)

        if self.connect_output_sockets and self.output_node_bl_idname:
            for output_name in self.connect_output_sockets:
                out_node = create_node(self.output_node_bl_idname)
                self.tree.links.new(self.node.outputs[output_name], out_node.inputs[0])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></li>
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets"><code class="name">var <span class="ident">connect_output_sockets</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.node_bl_idname"><code class="name">var <span class="ident">node_bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname"><code class="name">var <span class="ident">output_node_bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals"><code class="name flex">
<span>def <span class="ident">assert_output_data_equals</span></span>(<span>self, output_name, expected_data, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that tested node has written expected_data to
output socket output_name.</p></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file"><code class="name flex">
<span>def <span class="ident">assert_output_data_equals_file</span></span>(<span>self, output_name, expected_data_file_name, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that tested node has written expected data to
output socket output_name.
Expected data is stored in reference file expected_data_file_name.</p></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.get_output_data"><code class="name flex">
<span>def <span class="ident">get_output_data</span></span>(<span>self, output_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return data that tested node has written to named output socket.
Returns None if it hasn't written any data.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.tearDown" href="#sverchok.utils.testing.EmptyTreeTestCase.tearDown">tearDown</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase"><code class="flex name class">
<span>class <span class="ident">ReferenceTreeTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for test cases, that require existing node tree
for their work.
At setup, this class links a node tree from specified .blend
file into current scene. Name of .blend (or better .blend.gz)
file must be specified in <code>reference_file_name</code> property
of inherited class. Name of linked tree can be specified
in <code>reference_tree_name' property, by default it is "TestingTree".
The linked node tree is available as</code>self.tree'.
At teardown, this class removes that tree from scene.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferenceTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that require existing node tree
    for their work.
    At setup, this class links a node tree from specified .blend
    file into current scene. Name of .blend (or better .blend.gz)
    file must be specified in `reference_file_name` property
    of inherited class. Name of linked tree can be specified
    in `reference_tree_name&#39; property, by default it is &#34;TestingTree&#34;.
    The linked node tree is available as `self.tree&#39;.
    At teardown, this class removes that tree from scene.
    &#34;&#34;&#34;

    reference_file_name = None
    reference_tree_name = None

    def get_reference_file_path(self, file_name=None):
        if file_name is None:
            file_name = self.reference_file_name
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def link_node_tree(self, tree_name=None):
        if tree_name is None:
            tree_name = self.reference_tree_name
        path = self.get_reference_file_path()
        link_node_tree(path, tree_name)
        return get_node_tree(tree_name)

    def link_text_block(self, block_name):
        link_text_block(self.get_reference_file_path(), block_name)

    def setUp(self):
        super().setUp()
        if self.reference_file_name is None:
            raise Exception(&#34;ReferenceTreeTestCase subclass must have `reference_file_name&#39; set&#34;)
        if self.reference_tree_name is None:
            self.reference_tree_name = &#34;TestingTree&#34;

        with self.assert_logs_no_errors():
            self.tree = self.link_node_tree()

    def tearDown(self):
        remove_all_trees()  # node trees can include references to many other trees
        super().tearDown()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name"><code class="name">var <span class="ident">reference_file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name"><code class="name">var <span class="ident">reference_tree_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path"><code class="name flex">
<span>def <span class="ident">get_reference_file_path</span></span>(<span>self, file_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree"><code class="name flex">
<span>def <span class="ident">link_node_tree</span></span>(<span>self, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.link_text_block"><code class="name flex">
<span>def <span class="ident">link_text_block</span></span>(<span>self, block_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase"><code class="flex name class">
<span>class <span class="ident">SverchokTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for Sverchok test cases.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SverchokTestCase(unittest.TestCase):
    &#34;&#34;&#34;
    Base class for Sverchok test cases.
    &#34;&#34;&#34;

    def setUp(self):
        sv_logger.debug(&#34;Starting test: %s&#34;, self.id())

    @contextmanager
    def temporary_node_tree(self, new_tree_name):
        &#34;&#34;&#34;
        Context manager for dealing with new temporary node tree.
        The tree is created on entering context and removed when
        exiting context. Example of usage:

        with self.temporary_node_tree(&#34;TempTree&#34;) as tmp:
            do_something(tree)
        &#34;&#34;&#34;
        new_tree = create_node_tree(new_tree_name)
        try:
            yield new_tree
        finally:
            remove_node_tree(new_tree_name)

    @contextmanager
    def tree_from_file(self, file_name: str, tree_name: str) -&gt; Iterator[NodeTree]:
        path = join(get_tests_path(), &#34;references&#34;, file_name)
        link_node_tree(path, tree_name)
        try:
            yield get_node_tree(tree_name)
        finally:
            remove_node_tree(tree_name)

    def getLogger(self):
        return logging.getLogger(self.__class__.__name__)

    def debug(self, *args):
        self.getLogger().debug(*args)

    def info(self, *args):
        self.getLogger().info(*args)

    def serialize_json(self, data):
        &#34;&#34;&#34;
        Serialize JSON object in standard format.
        &#34;&#34;&#34;
        return json.dumps(data, sort_keys=True, indent=2)

    def store_reference_json(self, file_name, json_data):
        &#34;&#34;&#34;
        Store JSON data for further reference.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;wb&#39;) as f:
            data = json.dumps(json_data).encode(&#39;utf8&#39;)
            f.write(data)

    def get_reference_file_path(self, file_name):
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def load_reference_sverchok_data(self, file_name):
        &#34;&#34;&#34;
        Load reference data in Sverchok format
        (plain Python syntax of nested lists).
        Returns: Sverchok data (nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;r&#39;) as f:
            data = f.read()
            return ast.literal_eval(data)

    def store_reference_sverchok_data(self, file_name, data):
        &#34;&#34;&#34;
        Store reference data in Sverchok format
        (plain Python syntax of nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;w&#39;) as f:
            f.write(repr(data))

    def assert_json_equals(self, actual_json, expected_json):
        &#34;&#34;&#34;
        Assert that two JSON objects are equal.
        Comparison is done by serializing both objects.
        &#34;&#34;&#34;
        actual_data = self.serialize_json(actual_json)
        expected_data = self.serialize_json(expected_json)
        self.assertEquals(actual_data, expected_data)

    def assert_json_equals_file(self, actual_json, expected_json_file_name):
        &#34;&#34;&#34;
        Assert that actual_json equals to JSON stored in expected_json_file_name.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(expected_json_file_name), &#39;rb&#39;) as f:
            data = f.read().decode(&#39;utf8&#39;)
            expected_result = json.loads(data)
            self.assert_json_equals(actual_json, expected_result)

    def assert_node_property_equals(self, tree_name, node_name, property_name, expected_value):
        &#34;&#34;&#34;
        Assert that named property of the node equals to specified value.
        &#34;&#34;&#34;
        node = get_node(node_name, tree_name)
        actual_value = getattr(node, property_name)
        self.assertEqual(actual_value, expected_value)

    def assert_node_input_equals(self, tree_name, node_name, input_name, expected_value):
        node = get_node(node_name, tree_name)
        actual_value = node.inputs[input_name].sv_get()
        self.assertEqual(actual_value, expected_value)

    def assert_nodes_linked(self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name):
        &#34;&#34;&#34;
        Assert that certain output of node1 is linked to certain input of node2.
        &#34;&#34;&#34;
        node1 = get_node(node1_name, tree_name)
        node2 = get_node(node2_name, tree_name)

        if node1_output_name not in node1.outputs:
            raise AssertionError(&#34;Node `{}&#39; does not have output named `{}&#39;&#34;.format(node1_name, node1_output_name))
        if node2_input_name not in node2.inputs:
            raise AssertionError(&#34;Node `{}&#39; does not have input named `{}&#39;&#34;.format(node2_name, node2_input_name))

        if not node1.outputs[node1_output_name].is_linked:
            raise AssertionError(&#34;Output `{}&#39; of node `{}&#39; is not linked to anything&#34;, node1_output_name, node1_name)
        if not node2.inputs[node2_input_name].is_linked:
            raise AssertionError(&#34;Input `{}&#39; of node `{}&#39; is not linked to anything&#34;, node2_input_name, node2_name)

        self.assertEquals(node1.outputs[node1_output_name].other, node2.inputs[node2_input_name])

    def assert_nodes_are_equal(self, actual, reference):
        &#34;&#34;&#34;
        Assert that two nodes have the same settings.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if actual.bl_idname != reference.bl_idname:
            raise AssertionError(&#34;Actual node {} has bl_idname `{}&#39;, but reference has `{}&#39;&#34;.format(actual, actual.bl_idname, reference.bl_idname))
        for k, v in actual.items():
            if k not in reference:
                raise AssertionError(&#34;Property `{}&#39; is present is actual node {}, but is not present in reference&#34;.format(k, actual))
            if v != reference[k] and k != &#39;n_id&#39;:
                raise AssertionError(&#34;Property `{}&#39; has value `{}&#39; in actual node {}, but in reference it has value `{}&#39;&#34;.format(k, v, actual, reference[k]))

        for k in reference.keys():
            if k not in actual:
                raise AssertionError(&#34;Property `{}&#39; is present in reference node, but is not present in actual node {}&#34;.format(k, actual))

    def assert_node_equals_file(self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None):
        &#34;&#34;&#34;
        Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if imported_tree_name is None:
            imported_tree_name = &#34;ImportedTree&#34;

        try:
            new_tree = get_or_create_node_tree(imported_tree_name)
            importer = JSONImporter.init_from_path(self.get_reference_file_path(reference_file_name))
            importer.import_into_tree(new_tree, print_log=False)
            self.assert_nodes_are_equal(actual_node, get_node(reference_node_name, imported_tree_name))
        finally:
            remove_node_tree(imported_tree_name)

    def assert_numpy_arrays_equal(self, arr1, arr2, precision=None, fail_fast=True):
        &#34;&#34;&#34;
        Assert that two numpy arrays are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        if arr1.shape != arr2.shape:
            raise AssertionError(&#34;Shape of 1st array {} != shape of 2nd array {}&#34;.format(arr1.shape, arr2.shape))
        shape = list(arr1.shape)
        fails = []

        def compare(prev_indicies):
            step = len(prev_indicies) 
            if step == arr1.ndim:
                ind = tuple(prev_indicies)
                if precision is None:
                    a1 = arr1[ind]
                    a2 = arr2[ind]
                else:
                    a1 = round(arr1[ind], precision)
                    a2 = round(arr2[ind], precision)

                if fail_fast:
                    self.assertEqual(a1, a2, &#34;Array 1 [{}] != Array 2 [{}]&#34;.format(ind, ind))
                else:
                    if a1 != a2:
                        fails.append((a1, a2, ind))
            else:
                for idx in range(shape[step]):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(idx)
                    compare(new_indicies)

        compare([])
        if not fail_fast and fails:
            messages = []
            for a1, a2, ind in fails:
                message = f&#34;{a1} != {a2}: Array 1 [{ind}] != Array 2 [{ind}]&#34;
                messages.append(message)
            header = f&#34;{len(fails)} fails of {arr1.size} comparisons:\n&#34;
            message = header + &#34;\n&#34;.join(messages)
            self.fail(message)

    def assert_sverchok_data_equal(self, data1, data2, precision=None, message=None):
        &#34;&#34;&#34;
        Assert that two arrays of Sverchok data (nested tuples or lists)
        are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        def format_message(text):
            if message is None:
                return text
            else:
                return f&#34;{text}: {message}&#34;

        level1 = get_data_nesting_level(data1)
        level2 = get_data_nesting_level(data2)
        if level1 != level2:
            raise AssertionError(format_message(f&#34;Nesting level of 1st data {level1} != nesting level of 2nd data {level2}&#34;))
        
        def do_assert(d1, d2, idxs):
            if precision is not None:
                d1 = round(d1, precision)
                d2 = round(d2, precision)
            self.assertEqual(d1, d2, format_message(f&#34;Data 1 [{idxs}] != Data 2 [{idxs}]&#34;))

        if level1 == 0:
            do_assert(data1, data2, [])
            return

        def compare(prev_indicies, item1, item2):
            step = len(prev_indicies)
            index = prev_indicies[-1]
            if step == level1:
                if index &gt;= len(item1):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 1: {item1}&#34;))
                if index &gt;= len(item2):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 2: {item2}&#34;))
                do_assert(item1[index], item2[index], prev_indicies)
            else:
                l1 = len(item1)
                l2 = len(item2)
                self.assertEquals(l1, l2, format_message(f&#34;Size of data 1 at level {step} != size of data 2&#34;))
                for next_idx in range(len(item1[index])):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(next_idx)
                    compare(new_indicies, item1[index], item2[index])

        for idx in range(len(data1)):
            compare([idx], data1, data2)

    def assert_sverchok_data_equals_file(self, data, expected_data_file_name, precision=None):
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        # sv_logger.info(&#34;Data: %s&#34;, data)
        # sv_logger.info(&#34;Expected data: %s&#34;, expected_data)
        self.assert_sverchok_data_equal(data, expected_data, precision=precision)
        #self.assertEquals(data, expected_data)
    
    def assert_dicts_equal(self, first, second, precision=None):
        keys1 = set(first.keys())
        keys2 = set(second.keys())
        if keys1 != keys2:
            raise AssertionError(f&#34;Keys of first dictionary {keys1} do not match to keys of the second dictionary {keys2}&#34;)
        for key in first.keys():
            value1 = first[key]
            value2 = second[key]
            self.assert_sverchok_data_equal(value1, value2, precision=precision, message=f&#34;Values for dictionary key {key} do not match&#34;)


    @contextmanager
    def assert_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code prints something matching regexp to stdout.
        Usage:

            with self.assert_prints_stdout(&#34;hello&#34;):
                print(&#34;hello world&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_not_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code does not print anything matching regexp to stdout.
        Usage:

            with self.assert_not_prints_stdout(&#34;hello&#34;):
                print(&#34;goodbye&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertNotRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_logs_no_errors(self):
        &#34;&#34;&#34;
        Assert that the code does not write any ERROR to the log.
        Usage:

            with self.assert_logs_no_errors():
                sv_logger.info(&#34;this is just an information, not error&#34;)

        &#34;&#34;&#34;

        has_errors = False

        class Handler(logging.Handler):
            def emit(self, record):
                nonlocal has_errors
                if record.levelno &gt;= logging.ERROR:
                    has_errors = True

        handler = Handler()
        logging.getLogger().addHandler(handler)

        try:
            sv_logger.debug(&#34;=== \/ === [%s] Here should be no errors === \/ ===&#34;, self.__class__.__name__)
            yield handler
            self.assertFalse(has_errors, &#34;There were some errors logged&#34;)
        finally:
            sv_logger.debug(&#34;=== /\ === [%s] There should be no errors === /\ ===&#34;, self.__class__.__name__)
            logging.getLogger().handlers.remove(handler)

    def subtest_assert_equals(self, value1, value2, message=None):
        &#34;&#34;&#34;
        The same as assertEquals(), but within subtest.
        Use this to do several assertions per test method,
        for case test execution not to be stopped at
        the first failure.
        &#34;&#34;&#34;

        with self.subTest():
            self.assertEquals(value1, value2, message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></li>
<li><a title="sverchok.utils.testing.ReferenceTreeTestCase" href="#sverchok.utils.testing.ReferenceTreeTestCase">ReferenceTreeTestCase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_dicts_equal"><code class="name flex">
<span>def <span class="ident">assert_dicts_equal</span></span>(<span>self, first, second, precision=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_json_equals"><code class="name flex">
<span>def <span class="ident">assert_json_equals</span></span>(<span>self, actual_json, expected_json)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two JSON objects are equal.
Comparison is done by serializing both objects.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file"><code class="name flex">
<span>def <span class="ident">assert_json_equals_file</span></span>(<span>self, actual_json, expected_json_file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that actual_json equals to JSON stored in expected_json_file_name.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors"><code class="name flex">
<span>def <span class="ident">assert_logs_no_errors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that the code does not write any ERROR to the log.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_logs_no_errors():
sv_logger.info("this is just an information, not error")</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file"><code class="name flex">
<span>def <span class="ident">assert_node_equals_file</span></span>(<span>self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
This works only for simple nodes.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_input_equals"><code class="name flex">
<span>def <span class="ident">assert_node_input_equals</span></span>(<span>self, tree_name, node_name, input_name, expected_value)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals"><code class="name flex">
<span>def <span class="ident">assert_node_property_equals</span></span>(<span>self, tree_name, node_name, property_name, expected_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that named property of the node equals to specified value.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal"><code class="name flex">
<span>def <span class="ident">assert_nodes_are_equal</span></span>(<span>self, actual, reference)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two nodes have the same settings.
This works only for simple nodes.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked"><code class="name flex">
<span>def <span class="ident">assert_nodes_linked</span></span>(<span>self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that certain output of node1 is linked to certain input of node2.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout"><code class="name flex">
<span>def <span class="ident">assert_not_prints_stdout</span></span>(<span>self, regexp)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that the code does not print anything matching regexp to stdout.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_not_prints_stdout("hello"):
print("goodbye")</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal"><code class="name flex">
<span>def <span class="ident">assert_numpy_arrays_equal</span></span>(<span>self, arr1, arr2, precision=None, fail_fast=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two numpy arrays are equal.
Floating-point numbers are compared with specified precision.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout"><code class="name flex">
<span>def <span class="ident">assert_prints_stdout</span></span>(<span>self, regexp)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that the code prints something matching regexp to stdout.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_prints_stdout("hello"):
print("hello world")</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal"><code class="name flex">
<span>def <span class="ident">assert_sverchok_data_equal</span></span>(<span>self, data1, data2, precision=None, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two arrays of Sverchok data (nested tuples or lists)
are equal.
Floating-point numbers are compared with specified precision.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file"><code class="name flex">
<span>def <span class="ident">assert_sverchok_data_equals_file</span></span>(<span>self, data, expected_data_file_name, precision=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the test without collecting errors in a TestResult</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.getLogger"><code class="name flex">
<span>def <span class="ident">getLogger</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.get_reference_file_path"><code class="name flex">
<span>def <span class="ident">get_reference_file_path</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data"><code class="name flex">
<span>def <span class="ident">load_reference_sverchok_data</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Load reference data in Sverchok format
(plain Python syntax of nested lists).
Returns: Sverchok data (nested lists).</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.serialize_json"><code class="name flex">
<span>def <span class="ident">serialize_json</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize JSON object in standard format.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.store_reference_json"><code class="name flex">
<span>def <span class="ident">store_reference_json</span></span>(<span>self, file_name, json_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Store JSON data for further reference.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data"><code class="name flex">
<span>def <span class="ident">store_reference_sverchok_data</span></span>(<span>self, file_name, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Store reference data in Sverchok format
(plain Python syntax of nested lists).</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals"><code class="name flex">
<span>def <span class="ident">subtest_assert_equals</span></span>(<span>self, value1, value2, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The same as assertEquals(), but within subtest.
Use this to do several assertions per test method,
for case test execution not to be stopped at
the first failure.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.temporary_node_tree"><code class="name flex">
<span>def <span class="ident">temporary_node_tree</span></span>(<span>self, new_tree_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager for dealing with new temporary node tree.
The tree is created on entering context and removed when
exiting context. Example of usage:</p>
<p>with self.temporary_node_tree("TempTree") as tmp:
do_something(tree)</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.tree_from_file"><code class="name flex">
<span>def <span class="ident">tree_from_file</span></span>(<span>self, file_name: str, tree_name: str) ‑> Iterator[bpy_types.NodeTree]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.testing.batch_only" href="#sverchok.utils.testing.batch_only">batch_only</a></code></li>
<li><code><a title="sverchok.utils.testing.branches_only" href="#sverchok.utils.testing.branches_only">branches_only</a></code></li>
<li><code><a title="sverchok.utils.testing.coverage_report" href="#sverchok.utils.testing.coverage_report">coverage_report</a></code></li>
<li><code><a title="sverchok.utils.testing.create_node" href="#sverchok.utils.testing.create_node">create_node</a></code></li>
<li><code><a title="sverchok.utils.testing.create_node_tree" href="#sverchok.utils.testing.create_node_tree">create_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.generate_node_definition" href="#sverchok.utils.testing.generate_node_definition">generate_node_definition</a></code></li>
<li><code><a title="sverchok.utils.testing.get_ci_branch" href="#sverchok.utils.testing.get_ci_branch">get_ci_branch</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node" href="#sverchok.utils.testing.get_node">get_node</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node_editor_context" href="#sverchok.utils.testing.get_node_editor_context">get_node_editor_context</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node_tree" href="#sverchok.utils.testing.get_node_tree">get_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.get_or_create_node_tree" href="#sverchok.utils.testing.get_or_create_node_tree">get_or_create_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.get_tests_path" href="#sverchok.utils.testing.get_tests_path">get_tests_path</a></code></li>
<li><code><a title="sverchok.utils.testing.interactive_only" href="#sverchok.utils.testing.interactive_only">interactive_only</a></code></li>
<li><code><a title="sverchok.utils.testing.is_integration_server" href="#sverchok.utils.testing.is_integration_server">is_integration_server</a></code></li>
<li><code><a title="sverchok.utils.testing.is_pull_request" href="#sverchok.utils.testing.is_pull_request">is_pull_request</a></code></li>
<li><code><a title="sverchok.utils.testing.link_node_tree" href="#sverchok.utils.testing.link_node_tree">link_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.link_text_block" href="#sverchok.utils.testing.link_text_block">link_text_block</a></code></li>
<li><code><a title="sverchok.utils.testing.make_skip_decorator" href="#sverchok.utils.testing.make_skip_decorator">make_skip_decorator</a></code></li>
<li><code><a title="sverchok.utils.testing.manual_only" href="#sverchok.utils.testing.manual_only">manual_only</a></code></li>
<li><code><a title="sverchok.utils.testing.only_test_logs" href="#sverchok.utils.testing.only_test_logs">only_test_logs</a></code></li>
<li><code><a title="sverchok.utils.testing.pull_requests_only" href="#sverchok.utils.testing.pull_requests_only">pull_requests_only</a></code></li>
<li><code><a title="sverchok.utils.testing.remove_all_trees" href="#sverchok.utils.testing.remove_all_trees">remove_all_trees</a></code></li>
<li><code><a title="sverchok.utils.testing.remove_node_tree" href="#sverchok.utils.testing.remove_node_tree">remove_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.requires" href="#sverchok.utils.testing.requires">requires</a></code></li>
<li><code><a title="sverchok.utils.testing.run_all_tests" href="#sverchok.utils.testing.run_all_tests">run_all_tests</a></code></li>
<li><code><a title="sverchok.utils.testing.run_test_from_file" href="#sverchok.utils.testing.run_test_from_file">run_test_from_file</a></code></li>
<li><code><a title="sverchok.utils.testing.skip_pull_requests" href="#sverchok.utils.testing.skip_pull_requests">skip_pull_requests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.tearDown" href="#sverchok.utils.testing.EmptyTreeTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.NodeProcessTestCase" href="#sverchok.utils.testing.NodeProcessTestCase">NodeProcessTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals" href="#sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals">assert_output_data_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file" href="#sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file">assert_output_data_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets" href="#sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets">connect_output_sockets</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.get_output_data" href="#sverchok.utils.testing.NodeProcessTestCase.get_output_data">get_output_data</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.node_bl_idname" href="#sverchok.utils.testing.NodeProcessTestCase.node_bl_idname">node_bl_idname</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname" href="#sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname">output_node_bl_idname</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.ReferenceTreeTestCase" href="#sverchok.utils.testing.ReferenceTreeTestCase">ReferenceTreeTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path" href="#sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path">get_reference_file_path</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree" href="#sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree">link_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.link_text_block" href="#sverchok.utils.testing.ReferenceTreeTestCase.link_text_block">link_text_block</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name" href="#sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name">reference_file_name</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name" href="#sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name">reference_tree_name</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.tearDown" href="#sverchok.utils.testing.ReferenceTreeTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_dicts_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_dicts_equal">assert_dicts_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_input_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_input_equals">assert_node_input_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file">assert_sverchok_data_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.getLogger" href="#sverchok.utils.testing.SverchokTestCase.getLogger">getLogger</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.get_reference_file_path" href="#sverchok.utils.testing.SverchokTestCase.get_reference_file_path">get_reference_file_path</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.info" href="#sverchok.utils.testing.SverchokTestCase.info">info</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.tree_from_file" href="#sverchok.utils.testing.SverchokTestCase.tree_from_file">tree_from_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
