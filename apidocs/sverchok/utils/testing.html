<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.testing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.testing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path
from typing import Iterator

import bpy
from bpy.types import NodeTree
import os
from os.path import dirname, basename, join
import unittest
import unittest.mock
import json
from io import StringIO
import logging
from contextlib import contextmanager
import ast

import sverchok
from sverchok import old_nodes
from sverchok.data_structure import get_data_nesting_level
from sverchok.core.socket_data import get_output_socket_data
from sverchok.core.sv_custom_exceptions import SvNoDataError
from sverchok.utils.sv_json_import import JSONImporter


sv_logger = logging.getLogger(&#39;sverchok.testing&#39;)


@contextmanager
def only_test_logs():
    def filter_test_logs(record: logging.LogRecord):
        &#34;&#34;&#34;Turnoff all other than test logs&#34;&#34;&#34;
        return record.name.startswith(&#39;sverchok.testing&#39;)

    root_loger = logging.getLogger(&#39;sverchok&#39;)
    for handler in root_loger.handlers:
        handler.addFilter(filter_test_logs)
    try:
        yield
    finally:
        for handler in root_loger.handlers:
            handler.removeFilter(filter_test_logs)


try:
    import coverage
    coverage_available = True
except ImportError:
    # sv_logger.info(&#34;Coverage module is not installed&#34;)
    coverage_available = False

##########################################
# Utility methods
##########################################

@contextmanager
def coverage_report():
    if not coverage_available:
        yield None
    else:
        try:
            cov = coverage.Coverage()
            cov.start()
            yield cov
        finally:
            cov.stop()
            cov.save()
            cov.html_report()

def generate_node_definition(node):
    &#34;&#34;&#34;
    Generate code that programmatically creates specified node.
    This works only for simple cases.
    &#34;&#34;&#34;

    result = &#34;&#34;&#34;
tree = get_or_create_node_tree()
node = create_node(&#34;{}&#34;, tree.name)
&#34;&#34;&#34;.format(node.bl_idname)
    
    for k, v in node.items():
        result += &#34;node.{} = {}\n&#34;.format(k, v)

    return result

def get_node_editor_context():
    &#34;&#34;&#34;
    Prepare context override for bpy operators that need context.
    &#34;&#34;&#34;
    win      = bpy.context.window
    scr      = win.screen
    areas  = [area for area in scr.areas if area.type == &#39;NODE_EDITOR&#39;]
    region   = [region for region in areas[0].regions if region.type == &#39;WINDOW&#39;]

    context = {&#39;window&#39;:win,
                &#39;screen&#39;:scr,
                &#39;area&#39;  :areas[0],
                &#39;region&#39;:region,
                &#39;scene&#39; :bpy.context.scene,
                &#39;space&#39;: areas[0].spaces[0]
                }
    return context

def create_node_tree(name=None, must_not_exist=True):
    &#34;&#34;&#34;
    Create new Sverchok node tree in the scene.
    If must_not_exist == True (default), then it is checked that
    the tree with such name did not exist before. If it exists,
    an exception is raised.
    If must_not_exist == False, then new tree will be created anyway,
    but it can be created with another name (standard Blender&#39;s renaming).
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if must_not_exist:
        if name in bpy.data.node_groups:
            raise Exception(&#34;Will not create tree `{}&#39;: it already exists&#34;.format(name))
    sv_logger.debug(&#34;Creating tree: %s&#34;, name)
    tree = bpy.data.node_groups.new(name=name, type=&#34;SverchCustomTreeType&#34;)
    tree.sv_process = False  # turn off auto processing tree by default
    return tree

def get_or_create_node_tree(name=None):
    &#34;&#34;&#34;
    Create new Sverchok node tree or reuse existing one.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        sv_logger.debug(&#34;Using existing tree: %s&#34;, name)
        return bpy.data.node_groups[name]
    else:
        return create_node_tree(name)

def get_node_tree(name=None):
    &#34;&#34;&#34;
    Return existing node tree, or raise an exception if there is no such.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        sv_logger.debug(&#34;Using existing tree: %s&#34;, name)
        return bpy.data.node_groups[name]
    else:
        raise Exception(&#34;There is no node tree named `{}&#39;&#34;.format(name))

def remove_node_tree(name=None):
    &#34;&#34;&#34;
    Remove existing Sverchok node tree.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        win      = bpy.context.window
        scr      = win.screen
        areas  = [area for area in scr.areas if area.type == &#39;NODE_EDITOR&#39;]
        if len(areas):
            space = areas[0].spaces[0]
            space.node_tree = None
        sv_logger.debug(&#34;Removing tree: %s&#34;, name)
        tree = bpy.data.node_groups[name]
        bpy.data.node_groups.remove(tree)


def remove_all_trees():
    &#34;&#34;&#34;Remove all trees&#34;&#34;&#34;
    while True:
        try:
            bpy.data.node_groups.remove(bpy.data.node_groups[0])
        except IndexError:
            break


def link_node_tree(reference_blend_path, tree_name=None):
    &#34;&#34;&#34;
    Link node tree from specified .blend file.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    if tree_name in bpy.data.node_groups:
        raise Exception(&#34;Tree named `{}&#39; already exists in current scene&#34;.format(tree_name))
    with bpy.data.libraries.load(reference_blend_path, link=True) as (data_src, data_dst):
        sv_logger.debug(f&#34;---- Linked node tree: {basename(reference_blend_path)}&#34;)
        data_dst.node_groups = [tree_name]
    # right here the update method of the imported tree will be called
    # sverchok does not have a way of preventing this update
    # make sure that all old nodes was registered


def link_text_block(reference_blend_path, block_name):
    &#34;&#34;&#34;
    Link text block from specified .blend file.
    &#34;&#34;&#34;

    with bpy.data.libraries.load(reference_blend_path, link=True) as (data_src, data_dst):
        sv_logger.debug(f&#34;---- Linked text block: {basename(reference_blend_path)}&#34;)
        data_dst.texts = [block_name]

def create_node(node_type, tree_name=None):
    &#34;&#34;&#34;
    Create Sverchok node by it&#39;s bl_idname.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    sv_logger.debug(&#34;Creating node of type %s&#34;, node_type)
    return bpy.data.node_groups[tree_name].nodes.new(type=node_type)

def get_node(node_name, tree_name=None):
    &#34;&#34;&#34;
    Return existing node.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    if tree_name not in bpy.data.node_groups:
        raise Exception(&#34;There is no node tree named `{}&#39;&#34;.format(tree_name))
    return bpy.data.node_groups[tree_name].nodes[node_name]

def get_tests_path():
    &#34;&#34;&#34;
    Return path to all test cases (tests/ directory).
    &#34;&#34;&#34;
    sv_init = sverchok.__file__
    tests_dir = join(dirname(sv_init), &#34;tests&#34;)
    return tests_dir

def run_all_tests(pattern=None, log_file = &#39;sverchok_tests.log&#39;, log_level = None, verbosity=2, failfast=False):
    &#34;&#34;&#34;
    Run all existing test cases.
    Test cases are looked up under tests/ directory.
    &#34;&#34;&#34;
    
    if pattern is None:
        pattern = &#34;*_tests.py&#34;

    if log_level is not None:
        sv_logger.setLevel(log_level)

    tests_path = get_tests_path()
    log_handler = logging.FileHandler(join(tests_path, log_file), mode=&#39;w&#39;)
    logging.getLogger().addHandler(log_handler)
    try:
        loader = unittest.TestLoader()
        suite = loader.discover(start_dir = tests_path, pattern = pattern)
        buffer = StringIO()
        runner = unittest.TextTestRunner(stream = buffer, verbosity=verbosity, failfast=failfast)
        old_nodes.register_all()
        with coverage_report(), only_test_logs():
            sv_logger.warning(&#34;Run all tests with log level=[%s]&#34;,
                              logging.getLevelName(sv_logger.getEffectiveLevel()))
            result = runner.run(suite)
            sv_logger.info(&#34;Test cases result:\n%s&#34;, buffer.getvalue())
            return result
    finally:
        logging.getLogger().removeHandler(log_handler)


def run_test_from_file(file_name):
    &#34;&#34;&#34;
    Run test from file given by name. File should be places in tests folder
    :param file_name: string like avl_tree_tests.py
    :return: result
    &#34;&#34;&#34;
    tests_path = get_tests_path()
    log_handler = logging.FileHandler(join(tests_path, &#34;sverchok_tests.log&#34;), mode=&#39;w&#39;)
    logging.getLogger().addHandler(log_handler)
    buffer = None
    try:
        loader = unittest.TestLoader()
        suite = loader.discover(start_dir=tests_path, pattern=file_name)
        buffer = StringIO()
        runner = unittest.TextTestRunner(stream=buffer, verbosity=2)
        old_nodes.register_all()
        result = runner.run(suite)
        sv_logger.info(&#34;Test cases result:\n%s&#34;, buffer.getvalue())
        return result
    finally:
        logging.getLogger().removeHandler(log_handler)
        return buffer.getvalue().split(&#39;\n&#39;)[-2] if buffer else &#34;Global error&#34;


&#34;&#34;&#34; using:
from sverchok.utils.testing import run_test_from_file
run_test_from_file(&#34;avl_tree_tests.py&#34;)
&#34;&#34;&#34;


##############################################
# Base test case classes
##############################################

class SverchokTestCase(unittest.TestCase):
    &#34;&#34;&#34;
    Base class for Sverchok test cases.
    &#34;&#34;&#34;

    def setUp(self):
        sv_logger.debug(&#34;Starting test: %s&#34;, self.id())

    @contextmanager
    def temporary_node_tree(self, new_tree_name):
        &#34;&#34;&#34;
        Context manager for dealing with new temporary node tree.
        The tree is created on entering context and removed when
        exiting context. Example of usage:

        with self.temporary_node_tree(&#34;TempTree&#34;) as tmp:
            do_something(tree)
        &#34;&#34;&#34;
        new_tree = create_node_tree(new_tree_name)
        try:
            yield new_tree
        finally:
            remove_node_tree(new_tree_name)

    @contextmanager
    def tree_from_file(self, file_name: str, tree_name: str) -&gt; Iterator[NodeTree]:
        path = join(get_tests_path(), &#34;references&#34;, file_name)
        link_node_tree(path, tree_name)
        try:
            yield get_node_tree(tree_name)
        finally:
            remove_node_tree(tree_name)

    def getLogger(self):
        return logging.getLogger(self.__class__.__name__)

    def debug(self, *args):
        self.getLogger().debug(*args)

    def info(self, *args):
        self.getLogger().info(*args)

    def serialize_json(self, data):
        &#34;&#34;&#34;
        Serialize JSON object in standard format.
        &#34;&#34;&#34;
        return json.dumps(data, sort_keys=True, indent=2)

    def store_reference_json(self, file_name, json_data):
        &#34;&#34;&#34;
        Store JSON data for further reference.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;wb&#39;) as f:
            data = json.dumps(json_data).encode(&#39;utf8&#39;)
            f.write(data)

    def get_reference_file_path(self, file_name):
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def load_reference_sverchok_data(self, file_name):
        &#34;&#34;&#34;
        Load reference data in Sverchok format
        (plain Python syntax of nested lists).
        Returns: Sverchok data (nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;r&#39;) as f:
            data = f.read()
            return ast.literal_eval(data)

    def store_reference_sverchok_data(self, file_name, data):
        &#34;&#34;&#34;
        Store reference data in Sverchok format
        (plain Python syntax of nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;w&#39;) as f:
            f.write(repr(data))

    def assert_json_equals(self, actual_json, expected_json):
        &#34;&#34;&#34;
        Assert that two JSON objects are equal.
        Comparison is done by serializing both objects.
        &#34;&#34;&#34;
        actual_data = self.serialize_json(actual_json)
        expected_data = self.serialize_json(expected_json)
        self.assertEquals(actual_data, expected_data)

    def assert_json_equals_file(self, actual_json, expected_json_file_name):
        &#34;&#34;&#34;
        Assert that actual_json equals to JSON stored in expected_json_file_name.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(expected_json_file_name), &#39;rb&#39;) as f:
            data = f.read().decode(&#39;utf8&#39;)
            expected_result = json.loads(data)
            self.assert_json_equals(actual_json, expected_result)

    def assert_node_property_equals(self, tree_name, node_name, property_name, expected_value):
        &#34;&#34;&#34;
        Assert that named property of the node equals to specified value.
        &#34;&#34;&#34;
        node = get_node(node_name, tree_name)
        actual_value = getattr(node, property_name)
        self.assertEqual(actual_value, expected_value)

    def assert_node_input_equals(self, tree_name, node_name, input_name, expected_value):
        node = get_node(node_name, tree_name)
        actual_value = node.inputs[input_name].sv_get()
        self.assertEqual(actual_value, expected_value)

    def assert_nodes_linked(self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name):
        &#34;&#34;&#34;
        Assert that certain output of node1 is linked to certain input of node2.
        &#34;&#34;&#34;
        node1 = get_node(node1_name, tree_name)
        node2 = get_node(node2_name, tree_name)

        if node1_output_name not in node1.outputs:
            raise AssertionError(&#34;Node `{}&#39; does not have output named `{}&#39;&#34;.format(node1_name, node1_output_name))
        if node2_input_name not in node2.inputs:
            raise AssertionError(&#34;Node `{}&#39; does not have input named `{}&#39;&#34;.format(node2_name, node2_input_name))

        if not node1.outputs[node1_output_name].is_linked:
            raise AssertionError(&#34;Output `{}&#39; of node `{}&#39; is not linked to anything&#34;, node1_output_name, node1_name)
        if not node2.inputs[node2_input_name].is_linked:
            raise AssertionError(&#34;Input `{}&#39; of node `{}&#39; is not linked to anything&#34;, node2_input_name, node2_name)

        self.assertEquals(node1.outputs[node1_output_name].other, node2.inputs[node2_input_name])

    def assert_nodes_are_equal(self, actual, reference):
        &#34;&#34;&#34;
        Assert that two nodes have the same settings.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if actual.bl_idname != reference.bl_idname:
            raise AssertionError(&#34;Actual node {} has bl_idname `{}&#39;, but reference has `{}&#39;&#34;.format(actual, actual.bl_idname, reference.bl_idname))
        for k, v in actual.items():
            if k not in reference:
                raise AssertionError(&#34;Property `{}&#39; is present is actual node {}, but is not present in reference&#34;.format(k, actual))
            if v != reference[k] and k != &#39;n_id&#39;:
                raise AssertionError(&#34;Property `{}&#39; has value `{}&#39; in actual node {}, but in reference it has value `{}&#39;&#34;.format(k, v, actual, reference[k]))

        for k in reference.keys():
            if k not in actual:
                raise AssertionError(&#34;Property `{}&#39; is present in reference node, but is not present in actual node {}&#34;.format(k, actual))

    def assert_node_equals_file(self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None):
        &#34;&#34;&#34;
        Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if imported_tree_name is None:
            imported_tree_name = &#34;ImportedTree&#34;

        try:
            new_tree = get_or_create_node_tree(imported_tree_name)
            importer = JSONImporter.init_from_path(self.get_reference_file_path(reference_file_name))
            importer.import_into_tree(new_tree, print_log=False)
            self.assert_nodes_are_equal(actual_node, get_node(reference_node_name, imported_tree_name))
        finally:
            remove_node_tree(imported_tree_name)

    def assert_numpy_arrays_equal(self, arr1, arr2, precision=None, fail_fast=True):
        &#34;&#34;&#34;
        Assert that two numpy arrays are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        if arr1.shape != arr2.shape:
            raise AssertionError(&#34;Shape of 1st array {} != shape of 2nd array {}&#34;.format(arr1.shape, arr2.shape))
        shape = list(arr1.shape)
        fails = []

        def compare(prev_indicies):
            step = len(prev_indicies) 
            if step == arr1.ndim:
                ind = tuple(prev_indicies)
                if precision is None:
                    a1 = arr1[ind]
                    a2 = arr2[ind]
                else:
                    a1 = round(arr1[ind], precision)
                    a2 = round(arr2[ind], precision)

                if fail_fast:
                    self.assertEqual(a1, a2, &#34;Array 1 [{}] != Array 2 [{}]&#34;.format(ind, ind))
                else:
                    if a1 != a2:
                        fails.append((a1, a2, ind))
            else:
                for idx in range(shape[step]):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(idx)
                    compare(new_indicies)

        compare([])
        if not fail_fast and fails:
            messages = []
            for a1, a2, ind in fails:
                message = f&#34;{a1} != {a2}: Array 1 [{ind}] != Array 2 [{ind}]&#34;
                messages.append(message)
            header = f&#34;{len(fails)} fails of {arr1.size} comparisons:\n&#34;
            message = header + &#34;\n&#34;.join(messages)
            self.fail(message)

    def assert_sverchok_data_equal(self, data1, data2, precision=None, message=None):
        &#34;&#34;&#34;
        Assert that two arrays of Sverchok data (nested tuples or lists)
        are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        def format_message(text):
            if message is None:
                return text
            else:
                return f&#34;{text}: {message}&#34;

        level1 = get_data_nesting_level(data1)
        level2 = get_data_nesting_level(data2)
        if level1 != level2:
            raise AssertionError(format_message(f&#34;Nesting level of 1st data {level1} != nesting level of 2nd data {level2}&#34;))
        
        def do_assert(d1, d2, idxs):
            if precision is not None:
                d1 = round(d1, precision)
                d2 = round(d2, precision)
            self.assertEqual(d1, d2, format_message(f&#34;Data 1 [{idxs}] != Data 2 [{idxs}]&#34;))

        if level1 == 0:
            do_assert(data1, data2, [])
            return

        def compare(prev_indicies, item1, item2):
            step = len(prev_indicies)
            index = prev_indicies[-1]
            if step == level1:
                if index &gt;= len(item1):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 1: {item1}&#34;))
                if index &gt;= len(item2):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 2: {item2}&#34;))
                do_assert(item1[index], item2[index], prev_indicies)
            else:
                l1 = len(item1)
                l2 = len(item2)
                self.assertEquals(l1, l2, format_message(f&#34;Size of data 1 at level {step} != size of data 2&#34;))
                for next_idx in range(len(item1[index])):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(next_idx)
                    compare(new_indicies, item1[index], item2[index])

        for idx in range(len(data1)):
            compare([idx], data1, data2)

    def assert_sverchok_data_equals_file(self, data, expected_data_file_name, precision=None):
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        # sv_logger.info(&#34;Data: %s&#34;, data)
        # sv_logger.info(&#34;Expected data: %s&#34;, expected_data)
        self.assert_sverchok_data_equal(data, expected_data, precision=precision)
        #self.assertEquals(data, expected_data)
    
    def assert_dicts_equal(self, first, second, precision=None):
        keys1 = set(first.keys())
        keys2 = set(second.keys())
        if keys1 != keys2:
            raise AssertionError(f&#34;Keys of first dictionary {keys1} do not match to keys of the second dictionary {keys2}&#34;)
        for key in first.keys():
            value1 = first[key]
            value2 = second[key]
            self.assert_sverchok_data_equal(value1, value2, precision=precision, message=f&#34;Values for dictionary key {key} do not match&#34;)


    @contextmanager
    def assert_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code prints something matching regexp to stdout.
        Usage:

            with self.assert_prints_stdout(&#34;hello&#34;):
                print(&#34;hello world&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_not_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code does not print anything matching regexp to stdout.
        Usage:

            with self.assert_not_prints_stdout(&#34;hello&#34;):
                print(&#34;goodbye&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertNotRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_logs_no_errors(self):
        &#34;&#34;&#34;
        Assert that the code does not write any ERROR to the log.
        Usage:

            with self.assert_logs_no_errors():
                sv_logger.info(&#34;this is just an information, not error&#34;)

        &#34;&#34;&#34;

        has_errors = False

        class Handler(logging.Handler):
            def emit(self, record):
                nonlocal has_errors
                if record.levelno &gt;= logging.ERROR:
                    has_errors = True

        handler = Handler()
        logging.getLogger().addHandler(handler)

        try:
            sv_logger.debug(&#34;=== \/ === [%s] Here should be no errors === \/ ===&#34;, self.__class__.__name__)
            yield handler
            self.assertFalse(has_errors, &#34;There were some errors logged&#34;)
        finally:
            sv_logger.debug(&#34;=== /\ === [%s] There should be no errors === /\ ===&#34;, self.__class__.__name__)
            logging.getLogger().handlers.remove(handler)

    def subtest_assert_equals(self, value1, value2, message=None):
        &#34;&#34;&#34;
        The same as assertEquals(), but within subtest.
        Use this to do several assertions per test method,
        for case test execution not to be stopped at
        the first failure.
        &#34;&#34;&#34;

        with self.subTest():
            self.assertEquals(value1, value2, message)


class EmptyTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that work on empty node tree.
    At setup, it creates new node tree (it becomes available as self.tree).
    At teardown, it removes created node tree.
    &#34;&#34;&#34;

    def setUp(self):
        super().setUp()
        self.tree = get_or_create_node_tree()

    def tearDown(self):
        remove_node_tree()
        super().tearDown()

class ReferenceTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that require existing node tree
    for their work.
    At setup, this class links a node tree from specified .blend
    file into current scene. Name of .blend (or better .blend.gz)
    file must be specified in `reference_file_name` property
    of inherited class. Name of linked tree can be specified
    in `reference_tree_name&#39; property, by default it is &#34;TestingTree&#34;.
    The linked node tree is available as `self.tree&#39;.
    At teardown, this class removes that tree from scene.
    &#34;&#34;&#34;

    reference_file_name = None
    reference_tree_name = None

    def get_reference_file_path(self, file_name=None):
        if file_name is None:
            file_name = self.reference_file_name
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def link_node_tree(self, tree_name=None):
        if tree_name is None:
            tree_name = self.reference_tree_name
        path = self.get_reference_file_path()
        link_node_tree(path, tree_name)
        return get_node_tree(tree_name)

    def link_text_block(self, block_name):
        link_text_block(self.get_reference_file_path(), block_name)

    def setUp(self):
        super().setUp()
        if self.reference_file_name is None:
            raise Exception(&#34;ReferenceTreeTestCase subclass must have `reference_file_name&#39; set&#34;)
        if self.reference_tree_name is None:
            self.reference_tree_name = &#34;TestingTree&#34;

        with self.assert_logs_no_errors():
            self.tree = self.link_node_tree()

    def tearDown(self):
        remove_all_trees()  # node trees can include references to many other trees
        super().tearDown()

class NodeProcessTestCase(EmptyTreeTestCase):
    &#34;&#34;&#34;
    Base class for test cases that test process() function
    of one single node.
    At setup, this class creates an empty node tree and one
    node in it. bl_idname of tested node must be specified in
    `node_bl_idname&#39; property of child test case class.
    Optionally, some simple nodes can be created (by default
    a Note node) and connected to some outputs of tested node.
    This is useful for nodes that return from process() if they
    see that nothing is linked to outputs.

    In actual test_xxx() method, the test case should call
    self.node.process(), and after that examine output of the
    node by either self.get_output_data() or self.assert_output_data_equals().

    At teardown, the whole tested node tree is deleted.
    &#34;&#34;&#34;

    node_bl_idname = None
    connect_output_sockets = None
    output_node_bl_idname = &#34;NoteNode&#34;

    def get_output_data(self, output_name):
        &#34;&#34;&#34;
        Return data that tested node has written to named output socket.
        Returns None if it hasn&#39;t written any data.
        &#34;&#34;&#34;
        try:
            return get_output_socket_data(self.node, output_name)
        except SvNoDataError:
            return None
    
    def assert_output_data_equals(self, output_name, expected_data, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected_data to
        output socket output_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        self.assertEquals(data, expected_data, message)

    def assert_output_data_equals_file(self, output_name, expected_data_file_name, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected data to
        output socket output_name.
        Expected data is stored in reference file expected_data_file_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        self.assert_sverchok_data_equal(data, expected_data, message=message)

    def setUp(self):
        super().setUp()

        if self.node_bl_idname is None:
            raise Exception(&#34;NodeProcessTestCase subclass must have `node_bl_idname&#39; set&#34;)

        self.node = create_node(self.node_bl_idname)

        if self.connect_output_sockets and self.output_node_bl_idname:
            for output_name in self.connect_output_sockets:
                out_node = create_node(self.output_node_bl_idname)
                self.tree.links.new(self.node.outputs[output_name], out_node.inputs[0])

######################################################
# Test running conditionals
######################################################

def is_pull_request():
    &#34;&#34;&#34;
    Return True if we are running a build for pull-request check on Travis CI.
    &#34;&#34;&#34;
    pull_request = os.environ.get(&#34;TRAVIS_PULL_REQUEST&#34;, None)
    return (pull_request is not None and pull_request != &#34;false&#34;)

def is_integration_server():
    &#34;&#34;&#34;
    Return True if we a running inside an integration server (Travis CI) build.
    &#34;&#34;&#34;
    ci = os.environ.get(&#34;CI&#34;, None)
    return (ci == &#34;true&#34;)

def get_ci_branch():
    &#34;&#34;&#34;
    If we are running inside an integration server build, return
    the name of git branch which we are checking.
    Otherwise, return None.
    &#34;&#34;&#34;
    branch = os.environ.get(&#34;TRAVIS_BRANCH&#34;, None)
    print(&#34;Branch:&#34;, branch)
    return branch

def make_skip_decorator(condition, message):
    def decorator(func):
        if condition():
            return unittest.skip(message)(func)
        else:
            return func

    return decorator

# Here go decorators used to mark test to be executed only in certain conditions.
# Example usage:
#       
#       @manual_only
#       def test_something(self):
#           # This test will not be running on Travis CI, only in manual mode.
#

pull_requests_only = make_skip_decorator(is_pull_request, &#34;Applies only to PR builds&#34;)
skip_pull_requests = make_skip_decorator(lambda: not is_pull_request(), &#34;Does not apply to PR builds&#34;)
manual_only = make_skip_decorator(lambda: not is_integration_server(), &#34;Applies for manual builds only&#34;)

def branches_only(*branches):
    &#34;&#34;&#34;
    This test should be only executed for specified branches:

        @branches_only(&#34;master&#34;)
        def test_something(self):
            ...

    Please note that this applies only for Travis CI builds,
    in manual mode this test will be ran anyway.
    &#34;&#34;&#34;
    return make_skip_decorator(lambda: get_ci_branch() not in branches, &#34;Does not apply to this branch&#34;)

def batch_only(func):
    &#34;&#34;&#34;
    Decorator for tests that are to be executed in batch mode only
    (i.e. when tests are run from command line, either locally or in CI
    environment). Usage:

        @batch_only
        def test_something(self):
            ...
    &#34;&#34;&#34;
    if bpy.app.background:
        return func
    else:
        return unittest.skip(&#34;This test is intended for batch mode only&#34;)(func)

def interactive_only(func):
    &#34;&#34;&#34;
    Decorator for tests that are to be executed in interactive mode only
    (i.e. when tests are run from Blender&#39;s UI with &#34;Run all tests&#34; button).
    Usage:

        @interactive_only
        def test_something(self):
            ...
    &#34;&#34;&#34;
    if not bpy.app.background:
        return func
    else:
        return unittest.skip(&#34;This test is intended for interactive mode only&#34;)(func)

def requires(module):
    return unittest.skipIf(module is None, &#34;This test requires a module which is not currently available&#34;)


if __name__ == &#34;__main__&#34;:
    import sys
    import argparse
    try:
        #register()
        argv = sys.argv
        if bpy.app.binary_path:
            argv = argv[argv.index(&#34;--&#34;)+1:]
        else:
            argv = argv[1:]

        parser = argparse.ArgumentParser(prog = &#34;testing.py&#34;, description = &#34;Run Sverchok tests&#34;)
        parser.add_argument(&#39;pattern&#39;, metavar=&#39;*.PY&#39;, nargs=&#39;?&#39;, default = &#39;*_tests.py&#39;, help=&#34;Test case files pattern&#34;)
        #parser.add_argument(&#39;-t&#39;, &#39;--test&#39;, nargs=&#39;+&#39;, default = argparse.SUPPRESS)
        parser.add_argument(&#39;-o&#39;, &#39;--output&#39;, metavar=&#39;FILE.log&#39;, default=&#39;sverchok_tests.log&#39;, help=&#34;Path to output log file&#34;)
        parser.add_argument(&#39;-f&#39;, &#39;--fail-fast&#39;, action=&#39;store_true&#39;, help=&#34;Stop after first failing test&#34;)
        parser.add_argument(&#39;-v&#39;, &#39;--verbose&#39;, action=&#39;count&#39;, default=2, help=&#34;Set the verbosity level&#34;)
        parser.add_argument(&#39;-q&#39;, &#39;--quiet&#39;, dest=&#39;verbose&#39;, action=&#39;store_const&#39;, const=0, help=&#34;Be quiet&#34;)
        parser.add_argument(&#39;--debug&#39;, dest=&#39;log_level&#39;, action=&#39;store_const&#39;, const=&#39;DEBUG&#39;, help=&#34;Enable debug logging&#34;)
        parser.add_argument(&#39;--info&#39;, dest=&#39;log_level&#39;, action=&#39;store_const&#39;, const=&#39;INFO&#39;, help=&#34;Log only information messages&#34;)

        args = parser.parse_args(argv)
        #print(args)

        if not bpy.app.binary_path:
            bpy.ops.wm.read_userpref()

        log_level = getattr(args, &#39;log_level&#39;, None)
        result = run_all_tests(pattern = args.pattern,
                    log_file = args.output,
                    log_level = log_level,
                    verbosity = args.verbose,
                    failfast = args.fail_fast)
        if not result.wasSuccessful():
            # We have to raise an exception for Blender to exit with specified exit code.
            raise Exception(&#34;Some tests failed&#34;)
        sys.exit(0)
    except Exception as e:
        sv_logger.exception(e)
        sys.exit(1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.testing.batch_only"><code class="name flex">
<span>def <span class="ident">batch_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for tests that are to be executed in batch mode only
(i.e. when tests are run from command line, either locally or in CI
environment). Usage:</p>
<pre><code>@batch_only
def test_something(self):
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch_only(func):
    &#34;&#34;&#34;
    Decorator for tests that are to be executed in batch mode only
    (i.e. when tests are run from command line, either locally or in CI
    environment). Usage:

        @batch_only
        def test_something(self):
            ...
    &#34;&#34;&#34;
    if bpy.app.background:
        return func
    else:
        return unittest.skip(&#34;This test is intended for batch mode only&#34;)(func)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.branches_only"><code class="name flex">
<span>def <span class="ident">branches_only</span></span>(<span>*branches)</span>
</code></dt>
<dd>
<div class="desc"><p>This test should be only executed for specified branches:</p>
<pre><code>@branches_only("master")
def test_something(self):
    ...
</code></pre>
<p>Please note that this applies only for Travis CI builds,
in manual mode this test will be ran anyway.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def branches_only(*branches):
    &#34;&#34;&#34;
    This test should be only executed for specified branches:

        @branches_only(&#34;master&#34;)
        def test_something(self):
            ...

    Please note that this applies only for Travis CI builds,
    in manual mode this test will be ran anyway.
    &#34;&#34;&#34;
    return make_skip_decorator(lambda: get_ci_branch() not in branches, &#34;Does not apply to this branch&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.coverage_report"><code class="name flex">
<span>def <span class="ident">coverage_report</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def coverage_report():
    if not coverage_available:
        yield None
    else:
        try:
            cov = coverage.Coverage()
            cov.start()
            yield cov
        finally:
            cov.stop()
            cov.save()
            cov.html_report()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.create_node"><code class="name flex">
<span>def <span class="ident">create_node</span></span>(<span>node_type, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create Sverchok node by it's bl_idname.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_node(node_type, tree_name=None):
    &#34;&#34;&#34;
    Create Sverchok node by it&#39;s bl_idname.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    sv_logger.debug(&#34;Creating node of type %s&#34;, node_type)
    return bpy.data.node_groups[tree_name].nodes.new(type=node_type)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.create_node_tree"><code class="name flex">
<span>def <span class="ident">create_node_tree</span></span>(<span>name=None, must_not_exist=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create new Sverchok node tree in the scene.
If must_not_exist == True (default), then it is checked that
the tree with such name did not exist before. If it exists,
an exception is raised.
If must_not_exist == False, then new tree will be created anyway,
but it can be created with another name (standard Blender's renaming).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_node_tree(name=None, must_not_exist=True):
    &#34;&#34;&#34;
    Create new Sverchok node tree in the scene.
    If must_not_exist == True (default), then it is checked that
    the tree with such name did not exist before. If it exists,
    an exception is raised.
    If must_not_exist == False, then new tree will be created anyway,
    but it can be created with another name (standard Blender&#39;s renaming).
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if must_not_exist:
        if name in bpy.data.node_groups:
            raise Exception(&#34;Will not create tree `{}&#39;: it already exists&#34;.format(name))
    sv_logger.debug(&#34;Creating tree: %s&#34;, name)
    tree = bpy.data.node_groups.new(name=name, type=&#34;SverchCustomTreeType&#34;)
    tree.sv_process = False  # turn off auto processing tree by default
    return tree</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.generate_node_definition"><code class="name flex">
<span>def <span class="ident">generate_node_definition</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate code that programmatically creates specified node.
This works only for simple cases.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_node_definition(node):
    &#34;&#34;&#34;
    Generate code that programmatically creates specified node.
    This works only for simple cases.
    &#34;&#34;&#34;

    result = &#34;&#34;&#34;
tree = get_or_create_node_tree()
node = create_node(&#34;{}&#34;, tree.name)
&#34;&#34;&#34;.format(node.bl_idname)
    
    for k, v in node.items():
        result += &#34;node.{} = {}\n&#34;.format(k, v)

    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.get_ci_branch"><code class="name flex">
<span>def <span class="ident">get_ci_branch</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>If we are running inside an integration server build, return
the name of git branch which we are checking.
Otherwise, return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ci_branch():
    &#34;&#34;&#34;
    If we are running inside an integration server build, return
    the name of git branch which we are checking.
    Otherwise, return None.
    &#34;&#34;&#34;
    branch = os.environ.get(&#34;TRAVIS_BRANCH&#34;, None)
    print(&#34;Branch:&#34;, branch)
    return branch</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.get_node"><code class="name flex">
<span>def <span class="ident">get_node</span></span>(<span>node_name, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return existing node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node(node_name, tree_name=None):
    &#34;&#34;&#34;
    Return existing node.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    if tree_name not in bpy.data.node_groups:
        raise Exception(&#34;There is no node tree named `{}&#39;&#34;.format(tree_name))
    return bpy.data.node_groups[tree_name].nodes[node_name]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.get_node_editor_context"><code class="name flex">
<span>def <span class="ident">get_node_editor_context</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare context override for bpy operators that need context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_editor_context():
    &#34;&#34;&#34;
    Prepare context override for bpy operators that need context.
    &#34;&#34;&#34;
    win      = bpy.context.window
    scr      = win.screen
    areas  = [area for area in scr.areas if area.type == &#39;NODE_EDITOR&#39;]
    region   = [region for region in areas[0].regions if region.type == &#39;WINDOW&#39;]

    context = {&#39;window&#39;:win,
                &#39;screen&#39;:scr,
                &#39;area&#39;  :areas[0],
                &#39;region&#39;:region,
                &#39;scene&#39; :bpy.context.scene,
                &#39;space&#39;: areas[0].spaces[0]
                }
    return context</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.get_node_tree"><code class="name flex">
<span>def <span class="ident">get_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return existing node tree, or raise an exception if there is no such.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_tree(name=None):
    &#34;&#34;&#34;
    Return existing node tree, or raise an exception if there is no such.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        sv_logger.debug(&#34;Using existing tree: %s&#34;, name)
        return bpy.data.node_groups[name]
    else:
        raise Exception(&#34;There is no node tree named `{}&#39;&#34;.format(name))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.get_or_create_node_tree"><code class="name flex">
<span>def <span class="ident">get_or_create_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create new Sverchok node tree or reuse existing one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_node_tree(name=None):
    &#34;&#34;&#34;
    Create new Sverchok node tree or reuse existing one.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        sv_logger.debug(&#34;Using existing tree: %s&#34;, name)
        return bpy.data.node_groups[name]
    else:
        return create_node_tree(name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.get_tests_path"><code class="name flex">
<span>def <span class="ident">get_tests_path</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return path to all test cases (tests/ directory).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tests_path():
    &#34;&#34;&#34;
    Return path to all test cases (tests/ directory).
    &#34;&#34;&#34;
    sv_init = sverchok.__file__
    tests_dir = join(dirname(sv_init), &#34;tests&#34;)
    return tests_dir</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.interactive_only"><code class="name flex">
<span>def <span class="ident">interactive_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for tests that are to be executed in interactive mode only
(i.e. when tests are run from Blender's UI with "Run all tests" button).</p>
<h2 id="usage">Usage</h2>
<p>@interactive_only
def test_something(self):
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interactive_only(func):
    &#34;&#34;&#34;
    Decorator for tests that are to be executed in interactive mode only
    (i.e. when tests are run from Blender&#39;s UI with &#34;Run all tests&#34; button).
    Usage:

        @interactive_only
        def test_something(self):
            ...
    &#34;&#34;&#34;
    if not bpy.app.background:
        return func
    else:
        return unittest.skip(&#34;This test is intended for interactive mode only&#34;)(func)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.is_integration_server"><code class="name flex">
<span>def <span class="ident">is_integration_server</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if we a running inside an integration server (Travis CI) build.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_integration_server():
    &#34;&#34;&#34;
    Return True if we a running inside an integration server (Travis CI) build.
    &#34;&#34;&#34;
    ci = os.environ.get(&#34;CI&#34;, None)
    return (ci == &#34;true&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.is_pull_request"><code class="name flex">
<span>def <span class="ident">is_pull_request</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if we are running a build for pull-request check on Travis CI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_pull_request():
    &#34;&#34;&#34;
    Return True if we are running a build for pull-request check on Travis CI.
    &#34;&#34;&#34;
    pull_request = os.environ.get(&#34;TRAVIS_PULL_REQUEST&#34;, None)
    return (pull_request is not None and pull_request != &#34;false&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.link_node_tree"><code class="name flex">
<span>def <span class="ident">link_node_tree</span></span>(<span>reference_blend_path, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Link node tree from specified .blend file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_node_tree(reference_blend_path, tree_name=None):
    &#34;&#34;&#34;
    Link node tree from specified .blend file.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    if tree_name in bpy.data.node_groups:
        raise Exception(&#34;Tree named `{}&#39; already exists in current scene&#34;.format(tree_name))
    with bpy.data.libraries.load(reference_blend_path, link=True) as (data_src, data_dst):
        sv_logger.debug(f&#34;---- Linked node tree: {basename(reference_blend_path)}&#34;)
        data_dst.node_groups = [tree_name]
    # right here the update method of the imported tree will be called
    # sverchok does not have a way of preventing this update
    # make sure that all old nodes was registered</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.link_text_block"><code class="name flex">
<span>def <span class="ident">link_text_block</span></span>(<span>reference_blend_path, block_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Link text block from specified .blend file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_text_block(reference_blend_path, block_name):
    &#34;&#34;&#34;
    Link text block from specified .blend file.
    &#34;&#34;&#34;

    with bpy.data.libraries.load(reference_blend_path, link=True) as (data_src, data_dst):
        sv_logger.debug(f&#34;---- Linked text block: {basename(reference_blend_path)}&#34;)
        data_dst.texts = [block_name]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.make_skip_decorator"><code class="name flex">
<span>def <span class="ident">make_skip_decorator</span></span>(<span>condition, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_skip_decorator(condition, message):
    def decorator(func):
        if condition():
            return unittest.skip(message)(func)
        else:
            return func

    return decorator</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.manual_only"><code class="name flex">
<span>def <span class="ident">manual_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(func):
    if condition():
        return unittest.skip(message)(func)
    else:
        return func</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.only_test_logs"><code class="name flex">
<span>def <span class="ident">only_test_logs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def only_test_logs():
    def filter_test_logs(record: logging.LogRecord):
        &#34;&#34;&#34;Turnoff all other than test logs&#34;&#34;&#34;
        return record.name.startswith(&#39;sverchok.testing&#39;)

    root_loger = logging.getLogger(&#39;sverchok&#39;)
    for handler in root_loger.handlers:
        handler.addFilter(filter_test_logs)
    try:
        yield
    finally:
        for handler in root_loger.handlers:
            handler.removeFilter(filter_test_logs)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.pull_requests_only"><code class="name flex">
<span>def <span class="ident">pull_requests_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(func):
    if condition():
        return unittest.skip(message)(func)
    else:
        return func</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.remove_all_trees"><code class="name flex">
<span>def <span class="ident">remove_all_trees</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all trees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_all_trees():
    &#34;&#34;&#34;Remove all trees&#34;&#34;&#34;
    while True:
        try:
            bpy.data.node_groups.remove(bpy.data.node_groups[0])
        except IndexError:
            break</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.remove_node_tree"><code class="name flex">
<span>def <span class="ident">remove_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove existing Sverchok node tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node_tree(name=None):
    &#34;&#34;&#34;
    Remove existing Sverchok node tree.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        win      = bpy.context.window
        scr      = win.screen
        areas  = [area for area in scr.areas if area.type == &#39;NODE_EDITOR&#39;]
        if len(areas):
            space = areas[0].spaces[0]
            space.node_tree = None
        sv_logger.debug(&#34;Removing tree: %s&#34;, name)
        tree = bpy.data.node_groups[name]
        bpy.data.node_groups.remove(tree)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.requires"><code class="name flex">
<span>def <span class="ident">requires</span></span>(<span>module)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires(module):
    return unittest.skipIf(module is None, &#34;This test requires a module which is not currently available&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.run_all_tests"><code class="name flex">
<span>def <span class="ident">run_all_tests</span></span>(<span>pattern=None, log_file='sverchok_tests.log', log_level=None, verbosity=2, failfast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run all existing test cases.
Test cases are looked up under tests/ directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_all_tests(pattern=None, log_file = &#39;sverchok_tests.log&#39;, log_level = None, verbosity=2, failfast=False):
    &#34;&#34;&#34;
    Run all existing test cases.
    Test cases are looked up under tests/ directory.
    &#34;&#34;&#34;
    
    if pattern is None:
        pattern = &#34;*_tests.py&#34;

    if log_level is not None:
        sv_logger.setLevel(log_level)

    tests_path = get_tests_path()
    log_handler = logging.FileHandler(join(tests_path, log_file), mode=&#39;w&#39;)
    logging.getLogger().addHandler(log_handler)
    try:
        loader = unittest.TestLoader()
        suite = loader.discover(start_dir = tests_path, pattern = pattern)
        buffer = StringIO()
        runner = unittest.TextTestRunner(stream = buffer, verbosity=verbosity, failfast=failfast)
        old_nodes.register_all()
        with coverage_report(), only_test_logs():
            sv_logger.warning(&#34;Run all tests with log level=[%s]&#34;,
                              logging.getLevelName(sv_logger.getEffectiveLevel()))
            result = runner.run(suite)
            sv_logger.info(&#34;Test cases result:\n%s&#34;, buffer.getvalue())
            return result
    finally:
        logging.getLogger().removeHandler(log_handler)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.run_test_from_file"><code class="name flex">
<span>def <span class="ident">run_test_from_file</span></span>(<span>file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Run test from file given by name. File should be places in tests folder
:param file_name: string like avl_tree_tests.py
:return: result</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_test_from_file(file_name):
    &#34;&#34;&#34;
    Run test from file given by name. File should be places in tests folder
    :param file_name: string like avl_tree_tests.py
    :return: result
    &#34;&#34;&#34;
    tests_path = get_tests_path()
    log_handler = logging.FileHandler(join(tests_path, &#34;sverchok_tests.log&#34;), mode=&#39;w&#39;)
    logging.getLogger().addHandler(log_handler)
    buffer = None
    try:
        loader = unittest.TestLoader()
        suite = loader.discover(start_dir=tests_path, pattern=file_name)
        buffer = StringIO()
        runner = unittest.TextTestRunner(stream=buffer, verbosity=2)
        old_nodes.register_all()
        result = runner.run(suite)
        sv_logger.info(&#34;Test cases result:\n%s&#34;, buffer.getvalue())
        return result
    finally:
        logging.getLogger().removeHandler(log_handler)
        return buffer.getvalue().split(&#39;\n&#39;)[-2] if buffer else &#34;Global error&#34;</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.skip_pull_requests"><code class="name flex">
<span>def <span class="ident">skip_pull_requests</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(func):
    if condition():
        return unittest.skip(message)(func)
    else:
        return func</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.testing.EmptyTreeTestCase"><code class="flex name class">
<span>class <span class="ident">EmptyTreeTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for test cases, that work on empty node tree.
At setup, it creates new node tree (it becomes available as self.tree).
At teardown, it removes created node tree.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that work on empty node tree.
    At setup, it creates new node tree (it becomes available as self.tree).
    At teardown, it removes created node tree.
    &#34;&#34;&#34;

    def setUp(self):
        super().setUp()
        self.tree = get_or_create_node_tree()

    def tearDown(self):
        remove_node_tree()
        super().tearDown()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.NodeProcessTestCase" href="#sverchok.utils.testing.NodeProcessTestCase">NodeProcessTestCase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.EmptyTreeTestCase.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self):
    remove_node_tree()
    super().tearDown()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase"><code class="flex name class">
<span>class <span class="ident">NodeProcessTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for test cases that test process() function
of one single node.
At setup, this class creates an empty node tree and one
node in it. bl_idname of tested node must be specified in
`node_bl_idname' property of child test case class.
Optionally, some simple nodes can be created (by default
a Note node) and connected to some outputs of tested node.
This is useful for nodes that return from process() if they
see that nothing is linked to outputs.</p>
<p>In actual test_xxx() method, the test case should call
self.node.process(), and after that examine output of the
node by either self.get_output_data() or self.assert_output_data_equals().</p>
<p>At teardown, the whole tested node tree is deleted.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeProcessTestCase(EmptyTreeTestCase):
    &#34;&#34;&#34;
    Base class for test cases that test process() function
    of one single node.
    At setup, this class creates an empty node tree and one
    node in it. bl_idname of tested node must be specified in
    `node_bl_idname&#39; property of child test case class.
    Optionally, some simple nodes can be created (by default
    a Note node) and connected to some outputs of tested node.
    This is useful for nodes that return from process() if they
    see that nothing is linked to outputs.

    In actual test_xxx() method, the test case should call
    self.node.process(), and after that examine output of the
    node by either self.get_output_data() or self.assert_output_data_equals().

    At teardown, the whole tested node tree is deleted.
    &#34;&#34;&#34;

    node_bl_idname = None
    connect_output_sockets = None
    output_node_bl_idname = &#34;NoteNode&#34;

    def get_output_data(self, output_name):
        &#34;&#34;&#34;
        Return data that tested node has written to named output socket.
        Returns None if it hasn&#39;t written any data.
        &#34;&#34;&#34;
        try:
            return get_output_socket_data(self.node, output_name)
        except SvNoDataError:
            return None
    
    def assert_output_data_equals(self, output_name, expected_data, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected_data to
        output socket output_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        self.assertEquals(data, expected_data, message)

    def assert_output_data_equals_file(self, output_name, expected_data_file_name, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected data to
        output socket output_name.
        Expected data is stored in reference file expected_data_file_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        self.assert_sverchok_data_equal(data, expected_data, message=message)

    def setUp(self):
        super().setUp()

        if self.node_bl_idname is None:
            raise Exception(&#34;NodeProcessTestCase subclass must have `node_bl_idname&#39; set&#34;)

        self.node = create_node(self.node_bl_idname)

        if self.connect_output_sockets and self.output_node_bl_idname:
            for output_name in self.connect_output_sockets:
                out_node = create_node(self.output_node_bl_idname)
                self.tree.links.new(self.node.outputs[output_name], out_node.inputs[0])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></li>
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets"><code class="name">var <span class="ident">connect_output_sockets</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.node_bl_idname"><code class="name">var <span class="ident">node_bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname"><code class="name">var <span class="ident">output_node_bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals"><code class="name flex">
<span>def <span class="ident">assert_output_data_equals</span></span>(<span>self, output_name, expected_data, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that tested node has written expected_data to
output socket output_name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_output_data_equals(self, output_name, expected_data, message=None):
    &#34;&#34;&#34;
    Assert that tested node has written expected_data to
    output socket output_name.
    &#34;&#34;&#34;
    data = self.get_output_data(output_name)
    self.assertEquals(data, expected_data, message)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file"><code class="name flex">
<span>def <span class="ident">assert_output_data_equals_file</span></span>(<span>self, output_name, expected_data_file_name, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that tested node has written expected data to
output socket output_name.
Expected data is stored in reference file expected_data_file_name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_output_data_equals_file(self, output_name, expected_data_file_name, message=None):
    &#34;&#34;&#34;
    Assert that tested node has written expected data to
    output socket output_name.
    Expected data is stored in reference file expected_data_file_name.
    &#34;&#34;&#34;
    data = self.get_output_data(output_name)
    expected_data = self.load_reference_sverchok_data(expected_data_file_name)
    self.assert_sverchok_data_equal(data, expected_data, message=message)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.get_output_data"><code class="name flex">
<span>def <span class="ident">get_output_data</span></span>(<span>self, output_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return data that tested node has written to named output socket.
Returns None if it hasn't written any data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_data(self, output_name):
    &#34;&#34;&#34;
    Return data that tested node has written to named output socket.
    Returns None if it hasn&#39;t written any data.
    &#34;&#34;&#34;
    try:
        return get_output_socket_data(self.node, output_name)
    except SvNoDataError:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.tearDown" href="#sverchok.utils.testing.EmptyTreeTestCase.tearDown">tearDown</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase"><code class="flex name class">
<span>class <span class="ident">ReferenceTreeTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for test cases, that require existing node tree
for their work.
At setup, this class links a node tree from specified .blend
file into current scene. Name of .blend (or better .blend.gz)
file must be specified in <code>reference_file_name</code> property
of inherited class. Name of linked tree can be specified
in <code>reference_tree_name' property, by default it is "TestingTree".
The linked node tree is available as</code>self.tree'.
At teardown, this class removes that tree from scene.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferenceTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that require existing node tree
    for their work.
    At setup, this class links a node tree from specified .blend
    file into current scene. Name of .blend (or better .blend.gz)
    file must be specified in `reference_file_name` property
    of inherited class. Name of linked tree can be specified
    in `reference_tree_name&#39; property, by default it is &#34;TestingTree&#34;.
    The linked node tree is available as `self.tree&#39;.
    At teardown, this class removes that tree from scene.
    &#34;&#34;&#34;

    reference_file_name = None
    reference_tree_name = None

    def get_reference_file_path(self, file_name=None):
        if file_name is None:
            file_name = self.reference_file_name
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def link_node_tree(self, tree_name=None):
        if tree_name is None:
            tree_name = self.reference_tree_name
        path = self.get_reference_file_path()
        link_node_tree(path, tree_name)
        return get_node_tree(tree_name)

    def link_text_block(self, block_name):
        link_text_block(self.get_reference_file_path(), block_name)

    def setUp(self):
        super().setUp()
        if self.reference_file_name is None:
            raise Exception(&#34;ReferenceTreeTestCase subclass must have `reference_file_name&#39; set&#34;)
        if self.reference_tree_name is None:
            self.reference_tree_name = &#34;TestingTree&#34;

        with self.assert_logs_no_errors():
            self.tree = self.link_node_tree()

    def tearDown(self):
        remove_all_trees()  # node trees can include references to many other trees
        super().tearDown()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name"><code class="name">var <span class="ident">reference_file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name"><code class="name">var <span class="ident">reference_tree_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path"><code class="name flex">
<span>def <span class="ident">get_reference_file_path</span></span>(<span>self, file_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_file_path(self, file_name=None):
    if file_name is None:
        file_name = self.reference_file_name
    return join(get_tests_path(), &#34;references&#34;, file_name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree"><code class="name flex">
<span>def <span class="ident">link_node_tree</span></span>(<span>self, tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_node_tree(self, tree_name=None):
    if tree_name is None:
        tree_name = self.reference_tree_name
    path = self.get_reference_file_path()
    link_node_tree(path, tree_name)
    return get_node_tree(tree_name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.link_text_block"><code class="name flex">
<span>def <span class="ident">link_text_block</span></span>(<span>self, block_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_text_block(self, block_name):
    link_text_block(self.get_reference_file_path(), block_name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self):
    remove_all_trees()  # node trees can include references to many other trees
    super().tearDown()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase"><code class="flex name class">
<span>class <span class="ident">SverchokTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for Sverchok test cases.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SverchokTestCase(unittest.TestCase):
    &#34;&#34;&#34;
    Base class for Sverchok test cases.
    &#34;&#34;&#34;

    def setUp(self):
        sv_logger.debug(&#34;Starting test: %s&#34;, self.id())

    @contextmanager
    def temporary_node_tree(self, new_tree_name):
        &#34;&#34;&#34;
        Context manager for dealing with new temporary node tree.
        The tree is created on entering context and removed when
        exiting context. Example of usage:

        with self.temporary_node_tree(&#34;TempTree&#34;) as tmp:
            do_something(tree)
        &#34;&#34;&#34;
        new_tree = create_node_tree(new_tree_name)
        try:
            yield new_tree
        finally:
            remove_node_tree(new_tree_name)

    @contextmanager
    def tree_from_file(self, file_name: str, tree_name: str) -&gt; Iterator[NodeTree]:
        path = join(get_tests_path(), &#34;references&#34;, file_name)
        link_node_tree(path, tree_name)
        try:
            yield get_node_tree(tree_name)
        finally:
            remove_node_tree(tree_name)

    def getLogger(self):
        return logging.getLogger(self.__class__.__name__)

    def debug(self, *args):
        self.getLogger().debug(*args)

    def info(self, *args):
        self.getLogger().info(*args)

    def serialize_json(self, data):
        &#34;&#34;&#34;
        Serialize JSON object in standard format.
        &#34;&#34;&#34;
        return json.dumps(data, sort_keys=True, indent=2)

    def store_reference_json(self, file_name, json_data):
        &#34;&#34;&#34;
        Store JSON data for further reference.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;wb&#39;) as f:
            data = json.dumps(json_data).encode(&#39;utf8&#39;)
            f.write(data)

    def get_reference_file_path(self, file_name):
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def load_reference_sverchok_data(self, file_name):
        &#34;&#34;&#34;
        Load reference data in Sverchok format
        (plain Python syntax of nested lists).
        Returns: Sverchok data (nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;r&#39;) as f:
            data = f.read()
            return ast.literal_eval(data)

    def store_reference_sverchok_data(self, file_name, data):
        &#34;&#34;&#34;
        Store reference data in Sverchok format
        (plain Python syntax of nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;w&#39;) as f:
            f.write(repr(data))

    def assert_json_equals(self, actual_json, expected_json):
        &#34;&#34;&#34;
        Assert that two JSON objects are equal.
        Comparison is done by serializing both objects.
        &#34;&#34;&#34;
        actual_data = self.serialize_json(actual_json)
        expected_data = self.serialize_json(expected_json)
        self.assertEquals(actual_data, expected_data)

    def assert_json_equals_file(self, actual_json, expected_json_file_name):
        &#34;&#34;&#34;
        Assert that actual_json equals to JSON stored in expected_json_file_name.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(expected_json_file_name), &#39;rb&#39;) as f:
            data = f.read().decode(&#39;utf8&#39;)
            expected_result = json.loads(data)
            self.assert_json_equals(actual_json, expected_result)

    def assert_node_property_equals(self, tree_name, node_name, property_name, expected_value):
        &#34;&#34;&#34;
        Assert that named property of the node equals to specified value.
        &#34;&#34;&#34;
        node = get_node(node_name, tree_name)
        actual_value = getattr(node, property_name)
        self.assertEqual(actual_value, expected_value)

    def assert_node_input_equals(self, tree_name, node_name, input_name, expected_value):
        node = get_node(node_name, tree_name)
        actual_value = node.inputs[input_name].sv_get()
        self.assertEqual(actual_value, expected_value)

    def assert_nodes_linked(self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name):
        &#34;&#34;&#34;
        Assert that certain output of node1 is linked to certain input of node2.
        &#34;&#34;&#34;
        node1 = get_node(node1_name, tree_name)
        node2 = get_node(node2_name, tree_name)

        if node1_output_name not in node1.outputs:
            raise AssertionError(&#34;Node `{}&#39; does not have output named `{}&#39;&#34;.format(node1_name, node1_output_name))
        if node2_input_name not in node2.inputs:
            raise AssertionError(&#34;Node `{}&#39; does not have input named `{}&#39;&#34;.format(node2_name, node2_input_name))

        if not node1.outputs[node1_output_name].is_linked:
            raise AssertionError(&#34;Output `{}&#39; of node `{}&#39; is not linked to anything&#34;, node1_output_name, node1_name)
        if not node2.inputs[node2_input_name].is_linked:
            raise AssertionError(&#34;Input `{}&#39; of node `{}&#39; is not linked to anything&#34;, node2_input_name, node2_name)

        self.assertEquals(node1.outputs[node1_output_name].other, node2.inputs[node2_input_name])

    def assert_nodes_are_equal(self, actual, reference):
        &#34;&#34;&#34;
        Assert that two nodes have the same settings.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if actual.bl_idname != reference.bl_idname:
            raise AssertionError(&#34;Actual node {} has bl_idname `{}&#39;, but reference has `{}&#39;&#34;.format(actual, actual.bl_idname, reference.bl_idname))
        for k, v in actual.items():
            if k not in reference:
                raise AssertionError(&#34;Property `{}&#39; is present is actual node {}, but is not present in reference&#34;.format(k, actual))
            if v != reference[k] and k != &#39;n_id&#39;:
                raise AssertionError(&#34;Property `{}&#39; has value `{}&#39; in actual node {}, but in reference it has value `{}&#39;&#34;.format(k, v, actual, reference[k]))

        for k in reference.keys():
            if k not in actual:
                raise AssertionError(&#34;Property `{}&#39; is present in reference node, but is not present in actual node {}&#34;.format(k, actual))

    def assert_node_equals_file(self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None):
        &#34;&#34;&#34;
        Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if imported_tree_name is None:
            imported_tree_name = &#34;ImportedTree&#34;

        try:
            new_tree = get_or_create_node_tree(imported_tree_name)
            importer = JSONImporter.init_from_path(self.get_reference_file_path(reference_file_name))
            importer.import_into_tree(new_tree, print_log=False)
            self.assert_nodes_are_equal(actual_node, get_node(reference_node_name, imported_tree_name))
        finally:
            remove_node_tree(imported_tree_name)

    def assert_numpy_arrays_equal(self, arr1, arr2, precision=None, fail_fast=True):
        &#34;&#34;&#34;
        Assert that two numpy arrays are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        if arr1.shape != arr2.shape:
            raise AssertionError(&#34;Shape of 1st array {} != shape of 2nd array {}&#34;.format(arr1.shape, arr2.shape))
        shape = list(arr1.shape)
        fails = []

        def compare(prev_indicies):
            step = len(prev_indicies) 
            if step == arr1.ndim:
                ind = tuple(prev_indicies)
                if precision is None:
                    a1 = arr1[ind]
                    a2 = arr2[ind]
                else:
                    a1 = round(arr1[ind], precision)
                    a2 = round(arr2[ind], precision)

                if fail_fast:
                    self.assertEqual(a1, a2, &#34;Array 1 [{}] != Array 2 [{}]&#34;.format(ind, ind))
                else:
                    if a1 != a2:
                        fails.append((a1, a2, ind))
            else:
                for idx in range(shape[step]):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(idx)
                    compare(new_indicies)

        compare([])
        if not fail_fast and fails:
            messages = []
            for a1, a2, ind in fails:
                message = f&#34;{a1} != {a2}: Array 1 [{ind}] != Array 2 [{ind}]&#34;
                messages.append(message)
            header = f&#34;{len(fails)} fails of {arr1.size} comparisons:\n&#34;
            message = header + &#34;\n&#34;.join(messages)
            self.fail(message)

    def assert_sverchok_data_equal(self, data1, data2, precision=None, message=None):
        &#34;&#34;&#34;
        Assert that two arrays of Sverchok data (nested tuples or lists)
        are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        def format_message(text):
            if message is None:
                return text
            else:
                return f&#34;{text}: {message}&#34;

        level1 = get_data_nesting_level(data1)
        level2 = get_data_nesting_level(data2)
        if level1 != level2:
            raise AssertionError(format_message(f&#34;Nesting level of 1st data {level1} != nesting level of 2nd data {level2}&#34;))
        
        def do_assert(d1, d2, idxs):
            if precision is not None:
                d1 = round(d1, precision)
                d2 = round(d2, precision)
            self.assertEqual(d1, d2, format_message(f&#34;Data 1 [{idxs}] != Data 2 [{idxs}]&#34;))

        if level1 == 0:
            do_assert(data1, data2, [])
            return

        def compare(prev_indicies, item1, item2):
            step = len(prev_indicies)
            index = prev_indicies[-1]
            if step == level1:
                if index &gt;= len(item1):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 1: {item1}&#34;))
                if index &gt;= len(item2):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 2: {item2}&#34;))
                do_assert(item1[index], item2[index], prev_indicies)
            else:
                l1 = len(item1)
                l2 = len(item2)
                self.assertEquals(l1, l2, format_message(f&#34;Size of data 1 at level {step} != size of data 2&#34;))
                for next_idx in range(len(item1[index])):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(next_idx)
                    compare(new_indicies, item1[index], item2[index])

        for idx in range(len(data1)):
            compare([idx], data1, data2)

    def assert_sverchok_data_equals_file(self, data, expected_data_file_name, precision=None):
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        # sv_logger.info(&#34;Data: %s&#34;, data)
        # sv_logger.info(&#34;Expected data: %s&#34;, expected_data)
        self.assert_sverchok_data_equal(data, expected_data, precision=precision)
        #self.assertEquals(data, expected_data)
    
    def assert_dicts_equal(self, first, second, precision=None):
        keys1 = set(first.keys())
        keys2 = set(second.keys())
        if keys1 != keys2:
            raise AssertionError(f&#34;Keys of first dictionary {keys1} do not match to keys of the second dictionary {keys2}&#34;)
        for key in first.keys():
            value1 = first[key]
            value2 = second[key]
            self.assert_sverchok_data_equal(value1, value2, precision=precision, message=f&#34;Values for dictionary key {key} do not match&#34;)


    @contextmanager
    def assert_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code prints something matching regexp to stdout.
        Usage:

            with self.assert_prints_stdout(&#34;hello&#34;):
                print(&#34;hello world&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_not_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code does not print anything matching regexp to stdout.
        Usage:

            with self.assert_not_prints_stdout(&#34;hello&#34;):
                print(&#34;goodbye&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertNotRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_logs_no_errors(self):
        &#34;&#34;&#34;
        Assert that the code does not write any ERROR to the log.
        Usage:

            with self.assert_logs_no_errors():
                sv_logger.info(&#34;this is just an information, not error&#34;)

        &#34;&#34;&#34;

        has_errors = False

        class Handler(logging.Handler):
            def emit(self, record):
                nonlocal has_errors
                if record.levelno &gt;= logging.ERROR:
                    has_errors = True

        handler = Handler()
        logging.getLogger().addHandler(handler)

        try:
            sv_logger.debug(&#34;=== \/ === [%s] Here should be no errors === \/ ===&#34;, self.__class__.__name__)
            yield handler
            self.assertFalse(has_errors, &#34;There were some errors logged&#34;)
        finally:
            sv_logger.debug(&#34;=== /\ === [%s] There should be no errors === /\ ===&#34;, self.__class__.__name__)
            logging.getLogger().handlers.remove(handler)

    def subtest_assert_equals(self, value1, value2, message=None):
        &#34;&#34;&#34;
        The same as assertEquals(), but within subtest.
        Use this to do several assertions per test method,
        for case test execution not to be stopped at
        the first failure.
        &#34;&#34;&#34;

        with self.subTest():
            self.assertEquals(value1, value2, message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></li>
<li><a title="sverchok.utils.testing.ReferenceTreeTestCase" href="#sverchok.utils.testing.ReferenceTreeTestCase">ReferenceTreeTestCase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_dicts_equal"><code class="name flex">
<span>def <span class="ident">assert_dicts_equal</span></span>(<span>self, first, second, precision=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_dicts_equal(self, first, second, precision=None):
    keys1 = set(first.keys())
    keys2 = set(second.keys())
    if keys1 != keys2:
        raise AssertionError(f&#34;Keys of first dictionary {keys1} do not match to keys of the second dictionary {keys2}&#34;)
    for key in first.keys():
        value1 = first[key]
        value2 = second[key]
        self.assert_sverchok_data_equal(value1, value2, precision=precision, message=f&#34;Values for dictionary key {key} do not match&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_json_equals"><code class="name flex">
<span>def <span class="ident">assert_json_equals</span></span>(<span>self, actual_json, expected_json)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two JSON objects are equal.
Comparison is done by serializing both objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_json_equals(self, actual_json, expected_json):
    &#34;&#34;&#34;
    Assert that two JSON objects are equal.
    Comparison is done by serializing both objects.
    &#34;&#34;&#34;
    actual_data = self.serialize_json(actual_json)
    expected_data = self.serialize_json(expected_json)
    self.assertEquals(actual_data, expected_data)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file"><code class="name flex">
<span>def <span class="ident">assert_json_equals_file</span></span>(<span>self, actual_json, expected_json_file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that actual_json equals to JSON stored in expected_json_file_name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_json_equals_file(self, actual_json, expected_json_file_name):
    &#34;&#34;&#34;
    Assert that actual_json equals to JSON stored in expected_json_file_name.
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(expected_json_file_name), &#39;rb&#39;) as f:
        data = f.read().decode(&#39;utf8&#39;)
        expected_result = json.loads(data)
        self.assert_json_equals(actual_json, expected_result)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors"><code class="name flex">
<span>def <span class="ident">assert_logs_no_errors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that the code does not write any ERROR to the log.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_logs_no_errors():
sv_logger.info("this is just an information, not error")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def assert_logs_no_errors(self):
    &#34;&#34;&#34;
    Assert that the code does not write any ERROR to the log.
    Usage:

        with self.assert_logs_no_errors():
            sv_logger.info(&#34;this is just an information, not error&#34;)

    &#34;&#34;&#34;

    has_errors = False

    class Handler(logging.Handler):
        def emit(self, record):
            nonlocal has_errors
            if record.levelno &gt;= logging.ERROR:
                has_errors = True

    handler = Handler()
    logging.getLogger().addHandler(handler)

    try:
        sv_logger.debug(&#34;=== \/ === [%s] Here should be no errors === \/ ===&#34;, self.__class__.__name__)
        yield handler
        self.assertFalse(has_errors, &#34;There were some errors logged&#34;)
    finally:
        sv_logger.debug(&#34;=== /\ === [%s] There should be no errors === /\ ===&#34;, self.__class__.__name__)
        logging.getLogger().handlers.remove(handler)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file"><code class="name flex">
<span>def <span class="ident">assert_node_equals_file</span></span>(<span>self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
This works only for simple nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_node_equals_file(self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None):
    &#34;&#34;&#34;
    Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
    This works only for simple nodes.
    &#34;&#34;&#34;
    if imported_tree_name is None:
        imported_tree_name = &#34;ImportedTree&#34;

    try:
        new_tree = get_or_create_node_tree(imported_tree_name)
        importer = JSONImporter.init_from_path(self.get_reference_file_path(reference_file_name))
        importer.import_into_tree(new_tree, print_log=False)
        self.assert_nodes_are_equal(actual_node, get_node(reference_node_name, imported_tree_name))
    finally:
        remove_node_tree(imported_tree_name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_input_equals"><code class="name flex">
<span>def <span class="ident">assert_node_input_equals</span></span>(<span>self, tree_name, node_name, input_name, expected_value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_node_input_equals(self, tree_name, node_name, input_name, expected_value):
    node = get_node(node_name, tree_name)
    actual_value = node.inputs[input_name].sv_get()
    self.assertEqual(actual_value, expected_value)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals"><code class="name flex">
<span>def <span class="ident">assert_node_property_equals</span></span>(<span>self, tree_name, node_name, property_name, expected_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that named property of the node equals to specified value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_node_property_equals(self, tree_name, node_name, property_name, expected_value):
    &#34;&#34;&#34;
    Assert that named property of the node equals to specified value.
    &#34;&#34;&#34;
    node = get_node(node_name, tree_name)
    actual_value = getattr(node, property_name)
    self.assertEqual(actual_value, expected_value)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal"><code class="name flex">
<span>def <span class="ident">assert_nodes_are_equal</span></span>(<span>self, actual, reference)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two nodes have the same settings.
This works only for simple nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_nodes_are_equal(self, actual, reference):
    &#34;&#34;&#34;
    Assert that two nodes have the same settings.
    This works only for simple nodes.
    &#34;&#34;&#34;
    if actual.bl_idname != reference.bl_idname:
        raise AssertionError(&#34;Actual node {} has bl_idname `{}&#39;, but reference has `{}&#39;&#34;.format(actual, actual.bl_idname, reference.bl_idname))
    for k, v in actual.items():
        if k not in reference:
            raise AssertionError(&#34;Property `{}&#39; is present is actual node {}, but is not present in reference&#34;.format(k, actual))
        if v != reference[k] and k != &#39;n_id&#39;:
            raise AssertionError(&#34;Property `{}&#39; has value `{}&#39; in actual node {}, but in reference it has value `{}&#39;&#34;.format(k, v, actual, reference[k]))

    for k in reference.keys():
        if k not in actual:
            raise AssertionError(&#34;Property `{}&#39; is present in reference node, but is not present in actual node {}&#34;.format(k, actual))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked"><code class="name flex">
<span>def <span class="ident">assert_nodes_linked</span></span>(<span>self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that certain output of node1 is linked to certain input of node2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_nodes_linked(self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name):
    &#34;&#34;&#34;
    Assert that certain output of node1 is linked to certain input of node2.
    &#34;&#34;&#34;
    node1 = get_node(node1_name, tree_name)
    node2 = get_node(node2_name, tree_name)

    if node1_output_name not in node1.outputs:
        raise AssertionError(&#34;Node `{}&#39; does not have output named `{}&#39;&#34;.format(node1_name, node1_output_name))
    if node2_input_name not in node2.inputs:
        raise AssertionError(&#34;Node `{}&#39; does not have input named `{}&#39;&#34;.format(node2_name, node2_input_name))

    if not node1.outputs[node1_output_name].is_linked:
        raise AssertionError(&#34;Output `{}&#39; of node `{}&#39; is not linked to anything&#34;, node1_output_name, node1_name)
    if not node2.inputs[node2_input_name].is_linked:
        raise AssertionError(&#34;Input `{}&#39; of node `{}&#39; is not linked to anything&#34;, node2_input_name, node2_name)

    self.assertEquals(node1.outputs[node1_output_name].other, node2.inputs[node2_input_name])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout"><code class="name flex">
<span>def <span class="ident">assert_not_prints_stdout</span></span>(<span>self, regexp)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that the code does not print anything matching regexp to stdout.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_not_prints_stdout("hello"):
print("goodbye")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def assert_not_prints_stdout(self, regexp):
    &#34;&#34;&#34;
    Assert that the code does not print anything matching regexp to stdout.
    Usage:

        with self.assert_not_prints_stdout(&#34;hello&#34;):
            print(&#34;goodbye&#34;)

    &#34;&#34;&#34;
    with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
        yield fake_stdout
        self.assertNotRegex(fake_stdout.getvalue(), regexp)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal"><code class="name flex">
<span>def <span class="ident">assert_numpy_arrays_equal</span></span>(<span>self, arr1, arr2, precision=None, fail_fast=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two numpy arrays are equal.
Floating-point numbers are compared with specified precision.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_numpy_arrays_equal(self, arr1, arr2, precision=None, fail_fast=True):
    &#34;&#34;&#34;
    Assert that two numpy arrays are equal.
    Floating-point numbers are compared with specified precision.
    &#34;&#34;&#34;
    if arr1.shape != arr2.shape:
        raise AssertionError(&#34;Shape of 1st array {} != shape of 2nd array {}&#34;.format(arr1.shape, arr2.shape))
    shape = list(arr1.shape)
    fails = []

    def compare(prev_indicies):
        step = len(prev_indicies) 
        if step == arr1.ndim:
            ind = tuple(prev_indicies)
            if precision is None:
                a1 = arr1[ind]
                a2 = arr2[ind]
            else:
                a1 = round(arr1[ind], precision)
                a2 = round(arr2[ind], precision)

            if fail_fast:
                self.assertEqual(a1, a2, &#34;Array 1 [{}] != Array 2 [{}]&#34;.format(ind, ind))
            else:
                if a1 != a2:
                    fails.append((a1, a2, ind))
        else:
            for idx in range(shape[step]):
                new_indicies = prev_indicies[:]
                new_indicies.append(idx)
                compare(new_indicies)

    compare([])
    if not fail_fast and fails:
        messages = []
        for a1, a2, ind in fails:
            message = f&#34;{a1} != {a2}: Array 1 [{ind}] != Array 2 [{ind}]&#34;
            messages.append(message)
        header = f&#34;{len(fails)} fails of {arr1.size} comparisons:\n&#34;
        message = header + &#34;\n&#34;.join(messages)
        self.fail(message)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout"><code class="name flex">
<span>def <span class="ident">assert_prints_stdout</span></span>(<span>self, regexp)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that the code prints something matching regexp to stdout.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_prints_stdout("hello"):
print("hello world")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def assert_prints_stdout(self, regexp):
    &#34;&#34;&#34;
    Assert that the code prints something matching regexp to stdout.
    Usage:

        with self.assert_prints_stdout(&#34;hello&#34;):
            print(&#34;hello world&#34;)

    &#34;&#34;&#34;
    with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
        yield fake_stdout
        self.assertRegex(fake_stdout.getvalue(), regexp)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal"><code class="name flex">
<span>def <span class="ident">assert_sverchok_data_equal</span></span>(<span>self, data1, data2, precision=None, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that two arrays of Sverchok data (nested tuples or lists)
are equal.
Floating-point numbers are compared with specified precision.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_sverchok_data_equal(self, data1, data2, precision=None, message=None):
    &#34;&#34;&#34;
    Assert that two arrays of Sverchok data (nested tuples or lists)
    are equal.
    Floating-point numbers are compared with specified precision.
    &#34;&#34;&#34;
    def format_message(text):
        if message is None:
            return text
        else:
            return f&#34;{text}: {message}&#34;

    level1 = get_data_nesting_level(data1)
    level2 = get_data_nesting_level(data2)
    if level1 != level2:
        raise AssertionError(format_message(f&#34;Nesting level of 1st data {level1} != nesting level of 2nd data {level2}&#34;))
    
    def do_assert(d1, d2, idxs):
        if precision is not None:
            d1 = round(d1, precision)
            d2 = round(d2, precision)
        self.assertEqual(d1, d2, format_message(f&#34;Data 1 [{idxs}] != Data 2 [{idxs}]&#34;))

    if level1 == 0:
        do_assert(data1, data2, [])
        return

    def compare(prev_indicies, item1, item2):
        step = len(prev_indicies)
        index = prev_indicies[-1]
        if step == level1:
            if index &gt;= len(item1):
                raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 1: {item1}&#34;))
            if index &gt;= len(item2):
                raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 2: {item2}&#34;))
            do_assert(item1[index], item2[index], prev_indicies)
        else:
            l1 = len(item1)
            l2 = len(item2)
            self.assertEquals(l1, l2, format_message(f&#34;Size of data 1 at level {step} != size of data 2&#34;))
            for next_idx in range(len(item1[index])):
                new_indicies = prev_indicies[:]
                new_indicies.append(next_idx)
                compare(new_indicies, item1[index], item2[index])

    for idx in range(len(data1)):
        compare([idx], data1, data2)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file"><code class="name flex">
<span>def <span class="ident">assert_sverchok_data_equals_file</span></span>(<span>self, data, expected_data_file_name, precision=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_sverchok_data_equals_file(self, data, expected_data_file_name, precision=None):
    expected_data = self.load_reference_sverchok_data(expected_data_file_name)
    # sv_logger.info(&#34;Data: %s&#34;, data)
    # sv_logger.info(&#34;Expected data: %s&#34;, expected_data)
    self.assert_sverchok_data_equal(data, expected_data, precision=precision)
    #self.assertEquals(data, expected_data)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the test without collecting errors in a TestResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(self, *args):
    self.getLogger().debug(*args)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.getLogger"><code class="name flex">
<span>def <span class="ident">getLogger</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogger(self):
    return logging.getLogger(self.__class__.__name__)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.get_reference_file_path"><code class="name flex">
<span>def <span class="ident">get_reference_file_path</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_file_path(self, file_name):
    return join(get_tests_path(), &#34;references&#34;, file_name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, *args):
    self.getLogger().info(*args)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data"><code class="name flex">
<span>def <span class="ident">load_reference_sverchok_data</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Load reference data in Sverchok format
(plain Python syntax of nested lists).
Returns: Sverchok data (nested lists).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_reference_sverchok_data(self, file_name):
    &#34;&#34;&#34;
    Load reference data in Sverchok format
    (plain Python syntax of nested lists).
    Returns: Sverchok data (nested lists).
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(file_name), &#39;r&#39;) as f:
        data = f.read()
        return ast.literal_eval(data)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.serialize_json"><code class="name flex">
<span>def <span class="ident">serialize_json</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize JSON object in standard format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_json(self, data):
    &#34;&#34;&#34;
    Serialize JSON object in standard format.
    &#34;&#34;&#34;
    return json.dumps(data, sort_keys=True, indent=2)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
    sv_logger.debug(&#34;Starting test: %s&#34;, self.id())</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.store_reference_json"><code class="name flex">
<span>def <span class="ident">store_reference_json</span></span>(<span>self, file_name, json_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Store JSON data for further reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_reference_json(self, file_name, json_data):
    &#34;&#34;&#34;
    Store JSON data for further reference.
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(file_name), &#39;wb&#39;) as f:
        data = json.dumps(json_data).encode(&#39;utf8&#39;)
        f.write(data)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data"><code class="name flex">
<span>def <span class="ident">store_reference_sverchok_data</span></span>(<span>self, file_name, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Store reference data in Sverchok format
(plain Python syntax of nested lists).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_reference_sverchok_data(self, file_name, data):
    &#34;&#34;&#34;
    Store reference data in Sverchok format
    (plain Python syntax of nested lists).
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(file_name), &#39;w&#39;) as f:
        f.write(repr(data))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals"><code class="name flex">
<span>def <span class="ident">subtest_assert_equals</span></span>(<span>self, value1, value2, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The same as assertEquals(), but within subtest.
Use this to do several assertions per test method,
for case test execution not to be stopped at
the first failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtest_assert_equals(self, value1, value2, message=None):
    &#34;&#34;&#34;
    The same as assertEquals(), but within subtest.
    Use this to do several assertions per test method,
    for case test execution not to be stopped at
    the first failure.
    &#34;&#34;&#34;

    with self.subTest():
        self.assertEquals(value1, value2, message)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.temporary_node_tree"><code class="name flex">
<span>def <span class="ident">temporary_node_tree</span></span>(<span>self, new_tree_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager for dealing with new temporary node tree.
The tree is created on entering context and removed when
exiting context. Example of usage:</p>
<p>with self.temporary_node_tree("TempTree") as tmp:
do_something(tree)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def temporary_node_tree(self, new_tree_name):
    &#34;&#34;&#34;
    Context manager for dealing with new temporary node tree.
    The tree is created on entering context and removed when
    exiting context. Example of usage:

    with self.temporary_node_tree(&#34;TempTree&#34;) as tmp:
        do_something(tree)
    &#34;&#34;&#34;
    new_tree = create_node_tree(new_tree_name)
    try:
        yield new_tree
    finally:
        remove_node_tree(new_tree_name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.tree_from_file"><code class="name flex">
<span>def <span class="ident">tree_from_file</span></span>(<span>self, file_name: str, tree_name: str) ‑> Iterator[bpy_types.NodeTree]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def tree_from_file(self, file_name: str, tree_name: str) -&gt; Iterator[NodeTree]:
    path = join(get_tests_path(), &#34;references&#34;, file_name)
    link_node_tree(path, tree_name)
    try:
        yield get_node_tree(tree_name)
    finally:
        remove_node_tree(tree_name)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.testing.batch_only" href="#sverchok.utils.testing.batch_only">batch_only</a></code></li>
<li><code><a title="sverchok.utils.testing.branches_only" href="#sverchok.utils.testing.branches_only">branches_only</a></code></li>
<li><code><a title="sverchok.utils.testing.coverage_report" href="#sverchok.utils.testing.coverage_report">coverage_report</a></code></li>
<li><code><a title="sverchok.utils.testing.create_node" href="#sverchok.utils.testing.create_node">create_node</a></code></li>
<li><code><a title="sverchok.utils.testing.create_node_tree" href="#sverchok.utils.testing.create_node_tree">create_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.generate_node_definition" href="#sverchok.utils.testing.generate_node_definition">generate_node_definition</a></code></li>
<li><code><a title="sverchok.utils.testing.get_ci_branch" href="#sverchok.utils.testing.get_ci_branch">get_ci_branch</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node" href="#sverchok.utils.testing.get_node">get_node</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node_editor_context" href="#sverchok.utils.testing.get_node_editor_context">get_node_editor_context</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node_tree" href="#sverchok.utils.testing.get_node_tree">get_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.get_or_create_node_tree" href="#sverchok.utils.testing.get_or_create_node_tree">get_or_create_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.get_tests_path" href="#sverchok.utils.testing.get_tests_path">get_tests_path</a></code></li>
<li><code><a title="sverchok.utils.testing.interactive_only" href="#sverchok.utils.testing.interactive_only">interactive_only</a></code></li>
<li><code><a title="sverchok.utils.testing.is_integration_server" href="#sverchok.utils.testing.is_integration_server">is_integration_server</a></code></li>
<li><code><a title="sverchok.utils.testing.is_pull_request" href="#sverchok.utils.testing.is_pull_request">is_pull_request</a></code></li>
<li><code><a title="sverchok.utils.testing.link_node_tree" href="#sverchok.utils.testing.link_node_tree">link_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.link_text_block" href="#sverchok.utils.testing.link_text_block">link_text_block</a></code></li>
<li><code><a title="sverchok.utils.testing.make_skip_decorator" href="#sverchok.utils.testing.make_skip_decorator">make_skip_decorator</a></code></li>
<li><code><a title="sverchok.utils.testing.manual_only" href="#sverchok.utils.testing.manual_only">manual_only</a></code></li>
<li><code><a title="sverchok.utils.testing.only_test_logs" href="#sverchok.utils.testing.only_test_logs">only_test_logs</a></code></li>
<li><code><a title="sverchok.utils.testing.pull_requests_only" href="#sverchok.utils.testing.pull_requests_only">pull_requests_only</a></code></li>
<li><code><a title="sverchok.utils.testing.remove_all_trees" href="#sverchok.utils.testing.remove_all_trees">remove_all_trees</a></code></li>
<li><code><a title="sverchok.utils.testing.remove_node_tree" href="#sverchok.utils.testing.remove_node_tree">remove_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.requires" href="#sverchok.utils.testing.requires">requires</a></code></li>
<li><code><a title="sverchok.utils.testing.run_all_tests" href="#sverchok.utils.testing.run_all_tests">run_all_tests</a></code></li>
<li><code><a title="sverchok.utils.testing.run_test_from_file" href="#sverchok.utils.testing.run_test_from_file">run_test_from_file</a></code></li>
<li><code><a title="sverchok.utils.testing.skip_pull_requests" href="#sverchok.utils.testing.skip_pull_requests">skip_pull_requests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.tearDown" href="#sverchok.utils.testing.EmptyTreeTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.NodeProcessTestCase" href="#sverchok.utils.testing.NodeProcessTestCase">NodeProcessTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals" href="#sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals">assert_output_data_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file" href="#sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file">assert_output_data_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets" href="#sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets">connect_output_sockets</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.get_output_data" href="#sverchok.utils.testing.NodeProcessTestCase.get_output_data">get_output_data</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.node_bl_idname" href="#sverchok.utils.testing.NodeProcessTestCase.node_bl_idname">node_bl_idname</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname" href="#sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname">output_node_bl_idname</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.ReferenceTreeTestCase" href="#sverchok.utils.testing.ReferenceTreeTestCase">ReferenceTreeTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path" href="#sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path">get_reference_file_path</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree" href="#sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree">link_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.link_text_block" href="#sverchok.utils.testing.ReferenceTreeTestCase.link_text_block">link_text_block</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name" href="#sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name">reference_file_name</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name" href="#sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name">reference_tree_name</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.tearDown" href="#sverchok.utils.testing.ReferenceTreeTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_dicts_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_dicts_equal">assert_dicts_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_input_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_input_equals">assert_node_input_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file">assert_sverchok_data_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.getLogger" href="#sverchok.utils.testing.SverchokTestCase.getLogger">getLogger</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.get_reference_file_path" href="#sverchok.utils.testing.SverchokTestCase.get_reference_file_path">get_reference_file_path</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.info" href="#sverchok.utils.testing.SverchokTestCase.info">info</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.tree_from_file" href="#sverchok.utils.testing.SverchokTestCase.tree_from_file">tree_from_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>