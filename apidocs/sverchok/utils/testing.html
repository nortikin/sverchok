<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sverchok.utils.testing API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.testing</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.testing.batch_only"><code class="name flex">
<span>def <span class="ident">batch_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch_only(func):
    &#34;&#34;&#34;
    Decorator for tests that are to be executed in batch mode only
    (i.e. when tests are run from command line, either locally or in CI
    environment). Usage:

        @batch_only
        def test_something(self):
            ...
    &#34;&#34;&#34;
    if bpy.app.background:
        return func
    else:
        return unittest.skip(&#34;This test is intended for batch mode only&#34;)(func)</code></pre>
</details>
<div class="desc"><p>Decorator for tests that are to be executed in batch mode only
(i.e. when tests are run from command line, either locally or in CI
environment). Usage:</p>
<pre><code>@batch_only
def test_something(self):
    ...
</code></pre></div>
</dd>
<dt id="sverchok.utils.testing.branches_only"><code class="name flex">
<span>def <span class="ident">branches_only</span></span>(<span>*branches)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def branches_only(*branches):
    &#34;&#34;&#34;
    This test should be only executed for specified branches:

        @branches_only(&#34;master&#34;)
        def test_something(self):
            ...

    Please note that this applies only for Travis CI builds,
    in manual mode this test will be ran anyway.
    &#34;&#34;&#34;
    return make_skip_decorator(lambda: get_ci_branch() not in branches, &#34;Does not apply to this branch&#34;)</code></pre>
</details>
<div class="desc"><p>This test should be only executed for specified branches:</p>
<pre><code>@branches_only("master")
def test_something(self):
    ...
</code></pre>
<p>Please note that this applies only for Travis CI builds,
in manual mode this test will be ran anyway.</p></div>
</dd>
<dt id="sverchok.utils.testing.coverage_report"><code class="name flex">
<span>def <span class="ident">coverage_report</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def coverage_report():
    if not coverage_available:
        yield None
    else:
        try:
            cov = coverage.Coverage()
            cov.start()
            yield cov
        finally:
            cov.stop()
            cov.save()
            cov.html_report()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.create_node"><code class="name flex">
<span>def <span class="ident">create_node</span></span>(<span>node_type, tree_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_node(node_type, tree_name=None):
    &#34;&#34;&#34;
    Create Sverchok node by it&#39;s bl_idname.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    sv_logger.debug(&#34;Creating node of type %s&#34;, node_type)
    return bpy.data.node_groups[tree_name].nodes.new(type=node_type)</code></pre>
</details>
<div class="desc"><p>Create Sverchok node by it's bl_idname.</p></div>
</dd>
<dt id="sverchok.utils.testing.create_node_tree"><code class="name flex">
<span>def <span class="ident">create_node_tree</span></span>(<span>name=None, must_not_exist=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_node_tree(name=None, must_not_exist=True):
    &#34;&#34;&#34;
    Create new Sverchok node tree in the scene.
    If must_not_exist == True (default), then it is checked that
    the tree with such name did not exist before. If it exists,
    an exception is raised.
    If must_not_exist == False, then new tree will be created anyway,
    but it can be created with another name (standard Blender&#39;s renaming).
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if must_not_exist:
        if name in bpy.data.node_groups:
            raise Exception(&#34;Will not create tree `{}&#39;: it already exists&#34;.format(name))
    sv_logger.debug(&#34;Creating tree: %s&#34;, name)
    tree = bpy.data.node_groups.new(name=name, type=&#34;SverchCustomTreeType&#34;)
    tree.sv_process = False  # turn off auto processing tree by default
    return tree</code></pre>
</details>
<div class="desc"><p>Create new Sverchok node tree in the scene.
If must_not_exist == True (default), then it is checked that
the tree with such name did not exist before. If it exists,
an exception is raised.
If must_not_exist == False, then new tree will be created anyway,
but it can be created with another name (standard Blender's renaming).</p></div>
</dd>
<dt id="sverchok.utils.testing.generate_node_definition"><code class="name flex">
<span>def <span class="ident">generate_node_definition</span></span>(<span>node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_node_definition(node):
    &#34;&#34;&#34;
    Generate code that programmatically creates specified node.
    This works only for simple cases.
    &#34;&#34;&#34;

    result = &#34;&#34;&#34;
tree = get_or_create_node_tree()
node = create_node(&#34;{}&#34;, tree.name)
&#34;&#34;&#34;.format(node.bl_idname)
    
    for k, v in node.items():
        result += &#34;node.{} = {}\n&#34;.format(k, v)

    return result</code></pre>
</details>
<div class="desc"><p>Generate code that programmatically creates specified node.
This works only for simple cases.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_ci_branch"><code class="name flex">
<span>def <span class="ident">get_ci_branch</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ci_branch():
    &#34;&#34;&#34;
    If we are running inside an integration server build, return
    the name of git branch which we are checking.
    Otherwise, return None.
    &#34;&#34;&#34;
    branch = os.environ.get(&#34;TRAVIS_BRANCH&#34;, None)
    print(&#34;Branch:&#34;, branch)
    return branch</code></pre>
</details>
<div class="desc"><p>If we are running inside an integration server build, return
the name of git branch which we are checking.
Otherwise, return None.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_node"><code class="name flex">
<span>def <span class="ident">get_node</span></span>(<span>node_name, tree_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node(node_name, tree_name=None):
    &#34;&#34;&#34;
    Return existing node.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    if tree_name not in bpy.data.node_groups:
        raise Exception(&#34;There is no node tree named `{}&#39;&#34;.format(tree_name))
    return bpy.data.node_groups[tree_name].nodes[node_name]</code></pre>
</details>
<div class="desc"><p>Return existing node.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_node_editor_context"><code class="name flex">
<span>def <span class="ident">get_node_editor_context</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_editor_context():
    &#34;&#34;&#34;
    Prepare context override for bpy operators that need context.
    &#34;&#34;&#34;
    win      = bpy.context.window
    scr      = win.screen
    areas  = [area for area in scr.areas if area.type == &#39;NODE_EDITOR&#39;]
    region   = [region for region in areas[0].regions if region.type == &#39;WINDOW&#39;]

    context = {&#39;window&#39;:win,
                &#39;screen&#39;:scr,
                &#39;area&#39;  :areas[0],
                &#39;region&#39;:region,
                &#39;scene&#39; :bpy.context.scene,
                &#39;space&#39;: areas[0].spaces[0]
                }
    return context</code></pre>
</details>
<div class="desc"><p>Prepare context override for bpy operators that need context.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_node_tree"><code class="name flex">
<span>def <span class="ident">get_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_tree(name=None):
    &#34;&#34;&#34;
    Return existing node tree, or raise an exception if there is no such.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        sv_logger.debug(&#34;Using existing tree: %s&#34;, name)
        return bpy.data.node_groups[name]
    else:
        raise Exception(&#34;There is no node tree named `{}&#39;&#34;.format(name))</code></pre>
</details>
<div class="desc"><p>Return existing node tree, or raise an exception if there is no such.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_or_create_node_tree"><code class="name flex">
<span>def <span class="ident">get_or_create_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_node_tree(name=None):
    &#34;&#34;&#34;
    Create new Sverchok node tree or reuse existing one.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        sv_logger.debug(&#34;Using existing tree: %s&#34;, name)
        return bpy.data.node_groups[name]
    else:
        return create_node_tree(name)</code></pre>
</details>
<div class="desc"><p>Create new Sverchok node tree or reuse existing one.</p></div>
</dd>
<dt id="sverchok.utils.testing.get_tests_path"><code class="name flex">
<span>def <span class="ident">get_tests_path</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tests_path():
    &#34;&#34;&#34;
    Return path to all test cases (tests/ directory).
    &#34;&#34;&#34;
    sv_init = sverchok.__file__
    tests_dir = join(dirname(sv_init), &#34;tests&#34;)
    return tests_dir</code></pre>
</details>
<div class="desc"><p>Return path to all test cases (tests/ directory).</p></div>
</dd>
<dt id="sverchok.utils.testing.interactive_only"><code class="name flex">
<span>def <span class="ident">interactive_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interactive_only(func):
    &#34;&#34;&#34;
    Decorator for tests that are to be executed in interactive mode only
    (i.e. when tests are run from Blender&#39;s UI with &#34;Run all tests&#34; button).
    Usage:

        @interactive_only
        def test_something(self):
            ...
    &#34;&#34;&#34;
    if not bpy.app.background:
        return func
    else:
        return unittest.skip(&#34;This test is intended for interactive mode only&#34;)(func)</code></pre>
</details>
<div class="desc"><p>Decorator for tests that are to be executed in interactive mode only
(i.e. when tests are run from Blender's UI with "Run all tests" button).</p>
<h2 id="usage">Usage</h2>
<p>@interactive_only
def test_something(self):
&hellip;</p></div>
</dd>
<dt id="sverchok.utils.testing.is_integration_server"><code class="name flex">
<span>def <span class="ident">is_integration_server</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_integration_server():
    &#34;&#34;&#34;
    Return True if we a running inside an integration server (Travis CI) build.
    &#34;&#34;&#34;
    ci = os.environ.get(&#34;CI&#34;, None)
    return (ci == &#34;true&#34;)</code></pre>
</details>
<div class="desc"><p>Return True if we a running inside an integration server (Travis CI) build.</p></div>
</dd>
<dt id="sverchok.utils.testing.is_pull_request"><code class="name flex">
<span>def <span class="ident">is_pull_request</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_pull_request():
    &#34;&#34;&#34;
    Return True if we are running a build for pull-request check on Travis CI.
    &#34;&#34;&#34;
    pull_request = os.environ.get(&#34;TRAVIS_PULL_REQUEST&#34;, None)
    return (pull_request is not None and pull_request != &#34;false&#34;)</code></pre>
</details>
<div class="desc"><p>Return True if we are running a build for pull-request check on Travis CI.</p></div>
</dd>
<dt id="sverchok.utils.testing.link_node_tree"><code class="name flex">
<span>def <span class="ident">link_node_tree</span></span>(<span>reference_blend_path, tree_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_node_tree(reference_blend_path, tree_name=None):
    &#34;&#34;&#34;
    Link node tree from specified .blend file.
    &#34;&#34;&#34;
    if tree_name is None:
        tree_name = &#34;TestingTree&#34;
    if tree_name in bpy.data.node_groups:
        raise Exception(&#34;Tree named `{}&#39; already exists in current scene&#34;.format(tree_name))
    with bpy.data.libraries.load(reference_blend_path, link=True) as (data_src, data_dst):
        sv_logger.debug(f&#34;---- Linked node tree: {basename(reference_blend_path)}&#34;)
        data_dst.node_groups = [tree_name]
    # right here the update method of the imported tree will be called
    # sverchok does not have a way of preventing this update
    # make sure that all old nodes was registered</code></pre>
</details>
<div class="desc"><p>Link node tree from specified .blend file.</p></div>
</dd>
<dt id="sverchok.utils.testing.link_text_block"><code class="name flex">
<span>def <span class="ident">link_text_block</span></span>(<span>reference_blend_path, block_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_text_block(reference_blend_path, block_name):
    &#34;&#34;&#34;
    Link text block from specified .blend file.
    &#34;&#34;&#34;

    with bpy.data.libraries.load(reference_blend_path, link=True) as (data_src, data_dst):
        sv_logger.debug(f&#34;---- Linked text block: {basename(reference_blend_path)}&#34;)
        data_dst.texts = [block_name]</code></pre>
</details>
<div class="desc"><p>Link text block from specified .blend file.</p></div>
</dd>
<dt id="sverchok.utils.testing.make_skip_decorator"><code class="name flex">
<span>def <span class="ident">make_skip_decorator</span></span>(<span>condition, message)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_skip_decorator(condition, message):
    def decorator(func):
        if condition():
            return unittest.skip(message)(func)
        else:
            return func

    return decorator</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.manual_only"><code class="name flex">
<span>def <span class="ident">manual_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(func):
    if condition():
        return unittest.skip(message)(func)
    else:
        return func</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.only_test_logs"><code class="name flex">
<span>def <span class="ident">only_test_logs</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def only_test_logs():
    def filter_test_logs(record: logging.LogRecord):
        &#34;&#34;&#34;Turnoff all other than test logs&#34;&#34;&#34;
        return record.name.startswith(&#39;sverchok.testing&#39;)

    root_loger = logging.getLogger(&#39;sverchok&#39;)
    for handler in root_loger.handlers:
        handler.addFilter(filter_test_logs)
    try:
        yield
    finally:
        for handler in root_loger.handlers:
            handler.removeFilter(filter_test_logs)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.pull_requests_only"><code class="name flex">
<span>def <span class="ident">pull_requests_only</span></span>(<span>func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(func):
    if condition():
        return unittest.skip(message)(func)
    else:
        return func</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.remove_all_trees"><code class="name flex">
<span>def <span class="ident">remove_all_trees</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_all_trees():
    &#34;&#34;&#34;Remove all trees&#34;&#34;&#34;
    while True:
        try:
            bpy.data.node_groups.remove(bpy.data.node_groups[0])
        except IndexError:
            break</code></pre>
</details>
<div class="desc"><p>Remove all trees</p></div>
</dd>
<dt id="sverchok.utils.testing.remove_node_tree"><code class="name flex">
<span>def <span class="ident">remove_node_tree</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node_tree(name=None):
    &#34;&#34;&#34;
    Remove existing Sverchok node tree.
    &#34;&#34;&#34;
    if name is None:
        name = &#34;TestingTree&#34;
    if name in bpy.data.node_groups:
        win      = bpy.context.window
        scr      = win.screen
        areas  = [area for area in scr.areas if area.type == &#39;NODE_EDITOR&#39;]
        if len(areas):
            space = areas[0].spaces[0]
            space.node_tree = None
        sv_logger.debug(&#34;Removing tree: %s&#34;, name)
        tree = bpy.data.node_groups[name]
        bpy.data.node_groups.remove(tree)</code></pre>
</details>
<div class="desc"><p>Remove existing Sverchok node tree.</p></div>
</dd>
<dt id="sverchok.utils.testing.requires"><code class="name flex">
<span>def <span class="ident">requires</span></span>(<span>module)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires(module):
    return unittest.skipIf(module is None, &#34;This test requires a module which is not currently available&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.run_all_tests"><code class="name flex">
<span>def <span class="ident">run_all_tests</span></span>(<span>pattern=None,<br>log_file='sverchok_tests.log',<br>log_level=None,<br>verbosity=2,<br>failfast=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_all_tests(pattern=None, log_file = &#39;sverchok_tests.log&#39;, log_level = None, verbosity=2, failfast=False):
    &#34;&#34;&#34;
    Run all existing test cases.
    Test cases are looked up under tests/ directory.
    &#34;&#34;&#34;
    
    if pattern is None:
        pattern = &#34;*_tests.py&#34;

    if log_level is not None:
        sv_logger.setLevel(log_level)

    tests_path = get_tests_path()
    log_handler = logging.FileHandler(join(tests_path, log_file), mode=&#39;w&#39;)
    logging.getLogger().addHandler(log_handler)
    try:
        loader = unittest.TestLoader()
        suite = loader.discover(start_dir = tests_path, pattern = pattern)
        buffer = StringIO()
        runner = unittest.TextTestRunner(stream = buffer, verbosity=verbosity, failfast=failfast)
        old_nodes.register_all()
        with coverage_report(), only_test_logs():
            sv_logger.warning(&#34;Run all tests with log level=[%s]&#34;,
                              logging.getLevelName(sv_logger.getEffectiveLevel()))
            result = runner.run(suite)
            sv_logger.info(&#34;Test cases result:\n%s&#34;, buffer.getvalue())
            return result
    finally:
        logging.getLogger().removeHandler(log_handler)</code></pre>
</details>
<div class="desc"><p>Run all existing test cases.
Test cases are looked up under tests/ directory.</p></div>
</dd>
<dt id="sverchok.utils.testing.run_test_from_file"><code class="name flex">
<span>def <span class="ident">run_test_from_file</span></span>(<span>file_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_test_from_file(file_name):
    &#34;&#34;&#34;
    Run test from file given by name. File should be places in tests folder
    :param file_name: string like avl_tree_tests.py
    :return: result
    &#34;&#34;&#34;
    tests_path = get_tests_path()
    log_handler = logging.FileHandler(join(tests_path, &#34;sverchok_tests.log&#34;), mode=&#39;w&#39;)
    logging.getLogger().addHandler(log_handler)
    buffer = None
    try:
        loader = unittest.TestLoader()
        suite = loader.discover(start_dir=tests_path, pattern=file_name)
        buffer = StringIO()
        runner = unittest.TextTestRunner(stream=buffer, verbosity=2)
        old_nodes.register_all()
        result = runner.run(suite)
        sv_logger.info(&#34;Test cases result:\n%s&#34;, buffer.getvalue())
        return result
    finally:
        logging.getLogger().removeHandler(log_handler)
        return buffer.getvalue().split(&#39;\n&#39;)[-2] if buffer else &#34;Global error&#34;</code></pre>
</details>
<div class="desc"><p>Run test from file given by name. File should be places in tests folder
:param file_name: string like avl_tree_tests.py
:return: result</p></div>
</dd>
<dt id="sverchok.utils.testing.skip_pull_requests"><code class="name flex">
<span>def <span class="ident">skip_pull_requests</span></span>(<span>func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(func):
    if condition():
        return unittest.skip(message)(func)
    else:
        return func</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.testing.EmptyTreeTestCase"><code class="flex name class">
<span>class <span class="ident">EmptyTreeTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that work on empty node tree.
    At setup, it creates new node tree (it becomes available as self.tree).
    At teardown, it removes created node tree.
    &#34;&#34;&#34;

    def setUp(self):
        super().setUp()
        self.tree = get_or_create_node_tree()

    def tearDown(self):
        remove_node_tree()
        super().tearDown()</code></pre>
</details>
<div class="desc"><p>Base class for test cases, that work on empty node tree.
At setup, it creates new node tree (it becomes available as self.tree).
At teardown, it removes created node tree.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.NodeProcessTestCase" href="#sverchok.utils.testing.NodeProcessTestCase">NodeProcessTestCase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.EmptyTreeTestCase.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self):
    remove_node_tree()
    super().tearDown()</code></pre>
</details>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase"><code class="flex name class">
<span>class <span class="ident">NodeProcessTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeProcessTestCase(EmptyTreeTestCase):
    &#34;&#34;&#34;
    Base class for test cases that test process() function
    of one single node.
    At setup, this class creates an empty node tree and one
    node in it. bl_idname of tested node must be specified in
    `node_bl_idname&#39; property of child test case class.
    Optionally, some simple nodes can be created (by default
    a Note node) and connected to some outputs of tested node.
    This is useful for nodes that return from process() if they
    see that nothing is linked to outputs.

    In actual test_xxx() method, the test case should call
    self.node.process(), and after that examine output of the
    node by either self.get_output_data() or self.assert_output_data_equals().

    At teardown, the whole tested node tree is deleted.
    &#34;&#34;&#34;

    node_bl_idname = None
    connect_output_sockets = None
    output_node_bl_idname = &#34;NoteNode&#34;

    def get_output_data(self, output_name):
        &#34;&#34;&#34;
        Return data that tested node has written to named output socket.
        Returns None if it hasn&#39;t written any data.
        &#34;&#34;&#34;
        try:
            return get_output_socket_data(self.node, output_name)
        except SvNoDataError:
            return None
    
    def assert_output_data_equals(self, output_name, expected_data, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected_data to
        output socket output_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        self.assertEqual(data, expected_data, message)

    def assert_output_data_equals_file(self, output_name, expected_data_file_name, message=None):
        &#34;&#34;&#34;
        Assert that tested node has written expected data to
        output socket output_name.
        Expected data is stored in reference file expected_data_file_name.
        &#34;&#34;&#34;
        data = self.get_output_data(output_name)
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        self.assert_sverchok_data_equal(data, expected_data, message=message)

    def setUp(self):
        super().setUp()

        if self.node_bl_idname is None:
            raise Exception(&#34;NodeProcessTestCase subclass must have `node_bl_idname&#39; set&#34;)

        self.node = create_node(self.node_bl_idname)

        if self.connect_output_sockets and self.output_node_bl_idname:
            for output_name in self.connect_output_sockets:
                out_node = create_node(self.output_node_bl_idname)
                self.tree.links.new(self.node.outputs[output_name], out_node.inputs[0])</code></pre>
</details>
<div class="desc"><p>Base class for test cases that test process() function
of one single node.
At setup, this class creates an empty node tree and one
node in it. bl_idname of tested node must be specified in
`node_bl_idname' property of child test case class.
Optionally, some simple nodes can be created (by default
a Note node) and connected to some outputs of tested node.
This is useful for nodes that return from process() if they
see that nothing is linked to outputs.</p>
<p>In actual test_xxx() method, the test case should call
self.node.process(), and after that examine output of the
node by either self.get_output_data() or self.assert_output_data_equals().</p>
<p>At teardown, the whole tested node tree is deleted.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></li>
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets"><code class="name">var <span class="ident">connect_output_sockets</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.node_bl_idname"><code class="name">var <span class="ident">node_bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname"><code class="name">var <span class="ident">output_node_bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals"><code class="name flex">
<span>def <span class="ident">assert_output_data_equals</span></span>(<span>self, output_name, expected_data, message=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_output_data_equals(self, output_name, expected_data, message=None):
    &#34;&#34;&#34;
    Assert that tested node has written expected_data to
    output socket output_name.
    &#34;&#34;&#34;
    data = self.get_output_data(output_name)
    self.assertEqual(data, expected_data, message)</code></pre>
</details>
<div class="desc"><p>Assert that tested node has written expected_data to
output socket output_name.</p></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file"><code class="name flex">
<span>def <span class="ident">assert_output_data_equals_file</span></span>(<span>self, output_name, expected_data_file_name, message=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_output_data_equals_file(self, output_name, expected_data_file_name, message=None):
    &#34;&#34;&#34;
    Assert that tested node has written expected data to
    output socket output_name.
    Expected data is stored in reference file expected_data_file_name.
    &#34;&#34;&#34;
    data = self.get_output_data(output_name)
    expected_data = self.load_reference_sverchok_data(expected_data_file_name)
    self.assert_sverchok_data_equal(data, expected_data, message=message)</code></pre>
</details>
<div class="desc"><p>Assert that tested node has written expected data to
output socket output_name.
Expected data is stored in reference file expected_data_file_name.</p></div>
</dd>
<dt id="sverchok.utils.testing.NodeProcessTestCase.get_output_data"><code class="name flex">
<span>def <span class="ident">get_output_data</span></span>(<span>self, output_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_data(self, output_name):
    &#34;&#34;&#34;
    Return data that tested node has written to named output socket.
    Returns None if it hasn&#39;t written any data.
    &#34;&#34;&#34;
    try:
        return get_output_socket_data(self.node, output_name)
    except SvNoDataError:
        return None</code></pre>
</details>
<div class="desc"><p>Return data that tested node has written to named output socket.
Returns None if it hasn't written any data.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.tearDown" href="#sverchok.utils.testing.EmptyTreeTestCase.tearDown">tearDown</a></code></li>
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase"><code class="flex name class">
<span>class <span class="ident">ReferenceTreeTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferenceTreeTestCase(SverchokTestCase):
    &#34;&#34;&#34;
    Base class for test cases, that require existing node tree
    for their work.
    At setup, this class links a node tree from specified .blend
    file into current scene. Name of .blend (or better .blend.gz)
    file must be specified in `reference_file_name` property
    of inherited class. Name of linked tree can be specified
    in `reference_tree_name&#39; property, by default it is &#34;TestingTree&#34;.
    The linked node tree is available as `self.tree&#39;.
    At teardown, this class removes that tree from scene.
    &#34;&#34;&#34;

    reference_file_name = None
    reference_tree_name = None

    def get_reference_file_path(self, file_name=None):
        if file_name is None:
            file_name = self.reference_file_name
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def link_node_tree(self, tree_name=None):
        if tree_name is None:
            tree_name = self.reference_tree_name
        path = self.get_reference_file_path()
        link_node_tree(path, tree_name)
        return get_node_tree(tree_name)

    def link_text_block(self, block_name):
        link_text_block(self.get_reference_file_path(), block_name)

    def setUp(self):
        super().setUp()
        if self.reference_file_name is None:
            raise Exception(&#34;ReferenceTreeTestCase subclass must have `reference_file_name&#39; set&#34;)
        if self.reference_tree_name is None:
            self.reference_tree_name = &#34;TestingTree&#34;

        with self.assert_logs_no_errors():
            self.tree = self.link_node_tree()

    def tearDown(self):
        remove_all_trees()  # node trees can include references to many other trees
        super().tearDown()</code></pre>
</details>
<div class="desc"><p>Base class for test cases, that require existing node tree
for their work.
At setup, this class links a node tree from specified .blend
file into current scene. Name of .blend (or better .blend.gz)
file must be specified in <code>reference_file_name</code> property
of inherited class. Name of linked tree can be specified
in <code>reference_tree_name' property, by default it is "TestingTree".
The linked node tree is available as</code>self.tree'.
At teardown, this class removes that tree from scene.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name"><code class="name">var <span class="ident">reference_file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name"><code class="name">var <span class="ident">reference_tree_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path"><code class="name flex">
<span>def <span class="ident">get_reference_file_path</span></span>(<span>self, file_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_file_path(self, file_name=None):
    if file_name is None:
        file_name = self.reference_file_name
    return join(get_tests_path(), &#34;references&#34;, file_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree"><code class="name flex">
<span>def <span class="ident">link_node_tree</span></span>(<span>self, tree_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_node_tree(self, tree_name=None):
    if tree_name is None:
        tree_name = self.reference_tree_name
    path = self.get_reference_file_path()
    link_node_tree(path, tree_name)
    return get_node_tree(tree_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.link_text_block"><code class="name flex">
<span>def <span class="ident">link_text_block</span></span>(<span>self, block_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_text_block(self, block_name):
    link_text_block(self.get_reference_file_path(), block_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.ReferenceTreeTestCase.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self):
    remove_all_trees()  # node trees can include references to many other trees
    super().tearDown()</code></pre>
</details>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase"><code class="flex name class">
<span>class <span class="ident">SverchokTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SverchokTestCase(unittest.TestCase):
    &#34;&#34;&#34;
    Base class for Sverchok test cases.
    &#34;&#34;&#34;

    def setUp(self):
        sv_logger.debug(&#34;Starting test: %s&#34;, self.id())

    @contextmanager
    def temporary_node_tree(self, new_tree_name):
        &#34;&#34;&#34;
        Context manager for dealing with new temporary node tree.
        The tree is created on entering context and removed when
        exiting context. Example of usage:

        with self.temporary_node_tree(&#34;TempTree&#34;) as tmp:
            do_something(tree)
        &#34;&#34;&#34;
        new_tree = create_node_tree(new_tree_name)
        try:
            yield new_tree
        finally:
            remove_node_tree(new_tree_name)

    @contextmanager
    def tree_from_file(self, file_name: str, tree_name: str) -&gt; Iterator[NodeTree]:
        path = join(get_tests_path(), &#34;references&#34;, file_name)
        link_node_tree(path, tree_name)
        try:
            yield get_node_tree(tree_name)
        finally:
            remove_node_tree(tree_name)

    def getLogger(self):
        return logging.getLogger(self.__class__.__name__)

    def debug(self, *args):
        self.getLogger().debug(*args)

    def info(self, *args):
        self.getLogger().info(*args)

    def serialize_json(self, data):
        &#34;&#34;&#34;
        Serialize JSON object in standard format.
        &#34;&#34;&#34;
        return json.dumps(data, sort_keys=True, indent=2)

    def store_reference_json(self, file_name, json_data):
        &#34;&#34;&#34;
        Store JSON data for further reference.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;wb&#39;) as f:
            data = json.dumps(json_data).encode(&#39;utf8&#39;)
            f.write(data)

    def get_reference_file_path(self, file_name):
        return join(get_tests_path(), &#34;references&#34;, file_name)

    def load_reference_sverchok_data(self, file_name):
        &#34;&#34;&#34;
        Load reference data in Sverchok format
        (plain Python syntax of nested lists).
        Returns: Sverchok data (nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;r&#39;) as f:
            data = f.read()
            return ast.literal_eval(data)

    def store_reference_sverchok_data(self, file_name, data):
        &#34;&#34;&#34;
        Store reference data in Sverchok format
        (plain Python syntax of nested lists).
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(file_name), &#39;w&#39;) as f:
            f.write(repr(data))

    def assert_json_equals(self, actual_json, expected_json):
        &#34;&#34;&#34;
        Assert that two JSON objects are equal.
        Comparison is done by serializing both objects.
        &#34;&#34;&#34;
        actual_data = self.serialize_json(actual_json)
        expected_data = self.serialize_json(expected_json)
        self.assertEqual(actual_data, expected_data)

    def assert_json_equals_file(self, actual_json, expected_json_file_name):
        &#34;&#34;&#34;
        Assert that actual_json equals to JSON stored in expected_json_file_name.
        &#34;&#34;&#34;
        with open(self.get_reference_file_path(expected_json_file_name), &#39;rb&#39;) as f:
            data = f.read().decode(&#39;utf8&#39;)
            expected_result = json.loads(data)
            self.assert_json_equals(actual_json, expected_result)

    def assert_node_property_equals(self, tree_name, node_name, property_name, expected_value):
        &#34;&#34;&#34;
        Assert that named property of the node equals to specified value.
        &#34;&#34;&#34;
        node = get_node(node_name, tree_name)
        actual_value = getattr(node, property_name)
        self.assertEqual(actual_value, expected_value)

    def assert_node_input_equals(self, tree_name, node_name, input_name, expected_value):
        node = get_node(node_name, tree_name)
        actual_value = node.inputs[input_name].sv_get()
        self.assertEqual(actual_value, expected_value)

    def assert_nodes_linked(self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name):
        &#34;&#34;&#34;
        Assert that certain output of node1 is linked to certain input of node2.
        &#34;&#34;&#34;
        node1 = get_node(node1_name, tree_name)
        node2 = get_node(node2_name, tree_name)

        if node1_output_name not in node1.outputs:
            raise AssertionError(&#34;Node `{}&#39; does not have output named `{}&#39;&#34;.format(node1_name, node1_output_name))
        if node2_input_name not in node2.inputs:
            raise AssertionError(&#34;Node `{}&#39; does not have input named `{}&#39;&#34;.format(node2_name, node2_input_name))

        if not node1.outputs[node1_output_name].is_linked:
            raise AssertionError(&#34;Output `{}&#39; of node `{}&#39; is not linked to anything&#34;, node1_output_name, node1_name)
        if not node2.inputs[node2_input_name].is_linked:
            raise AssertionError(&#34;Input `{}&#39; of node `{}&#39; is not linked to anything&#34;, node2_input_name, node2_name)

        self.assertEqual(node1.outputs[node1_output_name].other, node2.inputs[node2_input_name])

    def assert_nodes_are_equal(self, actual, reference):
        &#34;&#34;&#34;
        Assert that two nodes have the same settings.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if actual.bl_idname != reference.bl_idname:
            raise AssertionError(&#34;Actual node {} has bl_idname `{}&#39;, but reference has `{}&#39;&#34;.format(actual, actual.bl_idname, reference.bl_idname))
        for k, v in actual.items():
            if k not in reference:
                raise AssertionError(&#34;Property `{}&#39; is present is actual node {}, but is not present in reference&#34;.format(k, actual))
            if v != reference[k] and k != &#39;n_id&#39;:
                raise AssertionError(&#34;Property `{}&#39; has value `{}&#39; in actual node {}, but in reference it has value `{}&#39;&#34;.format(k, v, actual, reference[k]))

        for k in reference.keys():
            if k not in actual:
                raise AssertionError(&#34;Property `{}&#39; is present in reference node, but is not present in actual node {}&#34;.format(k, actual))

    def assert_node_equals_file(self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None):
        &#34;&#34;&#34;
        Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
        This works only for simple nodes.
        &#34;&#34;&#34;
        if imported_tree_name is None:
            imported_tree_name = &#34;ImportedTree&#34;

        try:
            new_tree = get_or_create_node_tree(imported_tree_name)
            importer = JSONImporter.init_from_path(self.get_reference_file_path(reference_file_name))
            importer.import_into_tree(new_tree, print_log=False)
            self.assert_nodes_are_equal(actual_node, get_node(reference_node_name, imported_tree_name))
        finally:
            remove_node_tree(imported_tree_name)

    def assert_numpy_arrays_equal(self, arr1, arr2, precision=None, fail_fast=True):
        &#34;&#34;&#34;
        Assert that two numpy arrays are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        if arr1.shape != arr2.shape:
            raise AssertionError(&#34;Shape of 1st array {} != shape of 2nd array {}&#34;.format(arr1.shape, arr2.shape))
        shape = list(arr1.shape)
        fails = []

        def compare(prev_indicies):
            step = len(prev_indicies) 
            if step == arr1.ndim:
                ind = tuple(prev_indicies)
                if precision is None:
                    a1 = arr1[ind]
                    a2 = arr2[ind]
                else:
                    a1 = round(arr1[ind], precision)
                    a2 = round(arr2[ind], precision)

                if fail_fast:
                    self.assertEqual(a1, a2, &#34;Array 1 [{}] != Array 2 [{}]&#34;.format(ind, ind))
                else:
                    if a1 != a2:
                        fails.append((a1, a2, ind))
            else:
                for idx in range(shape[step]):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(idx)
                    compare(new_indicies)

        compare([])
        if not fail_fast and fails:
            messages = []
            for a1, a2, ind in fails:
                message = f&#34;{a1} != {a2}: Array 1 [{ind}] != Array 2 [{ind}]&#34;
                messages.append(message)
            header = f&#34;{len(fails)} fails of {arr1.size} comparisons:\n&#34;
            message = header + &#34;\n&#34;.join(messages)
            self.fail(message)

    def assert_sverchok_data_equal(self, data1, data2, precision=None, message=None):
        &#34;&#34;&#34;
        Assert that two arrays of Sverchok data (nested tuples or lists)
        are equal.
        Floating-point numbers are compared with specified precision.
        &#34;&#34;&#34;
        def format_message(text):
            if message is None:
                return text
            else:
                return f&#34;{text}: {message}&#34;

        level1 = get_data_nesting_level(data1)
        level2 = get_data_nesting_level(data2)
        if level1 != level2:
            raise AssertionError(format_message(f&#34;Nesting level of 1st data {level1} != nesting level of 2nd data {level2}&#34;))
        
        def do_assert(d1, d2, idxs):
            if precision is not None:
                d1 = round(d1, precision)
                d2 = round(d2, precision)
            self.assertEqual(d1, d2, format_message(f&#34;Data 1 [{idxs}] != Data 2 [{idxs}]&#34;))

        if level1 == 0:
            do_assert(data1, data2, [])
            return

        def compare(prev_indicies, item1, item2):
            step = len(prev_indicies)
            index = prev_indicies[-1]
            if step == level1:
                if index &gt;= len(item1):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 1: {item1}&#34;))
                if index &gt;= len(item2):
                    raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 2: {item2}&#34;))
                do_assert(item1[index], item2[index], prev_indicies)
            else:
                l1 = len(item1)
                l2 = len(item2)
                self.assertEqual(l1, l2, format_message(f&#34;Size of data 1 at level {step} != size of data 2&#34;))
                for next_idx in range(len(item1[index])):
                    new_indicies = prev_indicies[:]
                    new_indicies.append(next_idx)
                    compare(new_indicies, item1[index], item2[index])

        for idx in range(len(data1)):
            compare([idx], data1, data2)

    def assert_sverchok_data_equals_file(self, data, expected_data_file_name, precision=None):
        expected_data = self.load_reference_sverchok_data(expected_data_file_name)
        # sv_logger.info(&#34;Data: %s&#34;, data)
        # sv_logger.info(&#34;Expected data: %s&#34;, expected_data)
        self.assert_sverchok_data_equal(data, expected_data, precision=precision)
        #self.assertEqual(data, expected_data)
    
    def assert_dicts_equal(self, first, second, precision=None):
        keys1 = set(first.keys())
        keys2 = set(second.keys())
        if keys1 != keys2:
            raise AssertionError(f&#34;Keys of first dictionary {keys1} do not match to keys of the second dictionary {keys2}&#34;)
        for key in first.keys():
            value1 = first[key]
            value2 = second[key]
            self.assert_sverchok_data_equal(value1, value2, precision=precision, message=f&#34;Values for dictionary key {key} do not match&#34;)


    @contextmanager
    def assert_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code prints something matching regexp to stdout.
        Usage:

            with self.assert_prints_stdout(&#34;hello&#34;):
                print(&#34;hello world&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_not_prints_stdout(self, regexp):
        &#34;&#34;&#34;
        Assert that the code does not print anything matching regexp to stdout.
        Usage:

            with self.assert_not_prints_stdout(&#34;hello&#34;):
                print(&#34;goodbye&#34;)

        &#34;&#34;&#34;
        with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
            yield fake_stdout
            self.assertNotRegex(fake_stdout.getvalue(), regexp)

    @contextmanager
    def assert_logs_no_errors(self):
        &#34;&#34;&#34;
        Assert that the code does not write any ERROR to the log.
        Usage:

            with self.assert_logs_no_errors():
                sv_logger.info(&#34;this is just an information, not error&#34;)

        &#34;&#34;&#34;

        has_errors = False

        class Handler(logging.Handler):
            def emit(self, record):
                nonlocal has_errors
                if record.levelno &gt;= logging.ERROR:
                    has_errors = True

        handler = Handler()
        logging.getLogger().addHandler(handler)

        try:
            sv_logger.debug(&#34;=== \/ === [%s] Here should be no errors === \/ ===&#34;, self.__class__.__name__)
            yield handler
            self.assertFalse(has_errors, &#34;There were some errors logged&#34;)
        finally:
            sv_logger.debug(&#34;=== /\ === [%s] There should be no errors === /\ ===&#34;, self.__class__.__name__)
            logging.getLogger().handlers.remove(handler)

    def subtest_assert_equals(self, value1, value2, message=None):
        &#34;&#34;&#34;
        The same as assertEqual(), but within subtest.
        Use this to do several assertions per test method,
        for case test execution not to be stopped at
        the first failure.
        &#34;&#34;&#34;

        with self.subTest():
            self.assertEqual(value1, value2, message)</code></pre>
</details>
<div class="desc"><p>Base class for Sverchok test cases.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></li>
<li><a title="sverchok.utils.testing.ReferenceTreeTestCase" href="#sverchok.utils.testing.ReferenceTreeTestCase">ReferenceTreeTestCase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_dicts_equal"><code class="name flex">
<span>def <span class="ident">assert_dicts_equal</span></span>(<span>self, first, second, precision=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_dicts_equal(self, first, second, precision=None):
    keys1 = set(first.keys())
    keys2 = set(second.keys())
    if keys1 != keys2:
        raise AssertionError(f&#34;Keys of first dictionary {keys1} do not match to keys of the second dictionary {keys2}&#34;)
    for key in first.keys():
        value1 = first[key]
        value2 = second[key]
        self.assert_sverchok_data_equal(value1, value2, precision=precision, message=f&#34;Values for dictionary key {key} do not match&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_json_equals"><code class="name flex">
<span>def <span class="ident">assert_json_equals</span></span>(<span>self, actual_json, expected_json)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_json_equals(self, actual_json, expected_json):
    &#34;&#34;&#34;
    Assert that two JSON objects are equal.
    Comparison is done by serializing both objects.
    &#34;&#34;&#34;
    actual_data = self.serialize_json(actual_json)
    expected_data = self.serialize_json(expected_json)
    self.assertEqual(actual_data, expected_data)</code></pre>
</details>
<div class="desc"><p>Assert that two JSON objects are equal.
Comparison is done by serializing both objects.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file"><code class="name flex">
<span>def <span class="ident">assert_json_equals_file</span></span>(<span>self, actual_json, expected_json_file_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_json_equals_file(self, actual_json, expected_json_file_name):
    &#34;&#34;&#34;
    Assert that actual_json equals to JSON stored in expected_json_file_name.
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(expected_json_file_name), &#39;rb&#39;) as f:
        data = f.read().decode(&#39;utf8&#39;)
        expected_result = json.loads(data)
        self.assert_json_equals(actual_json, expected_result)</code></pre>
</details>
<div class="desc"><p>Assert that actual_json equals to JSON stored in expected_json_file_name.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors"><code class="name flex">
<span>def <span class="ident">assert_logs_no_errors</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def assert_logs_no_errors(self):
    &#34;&#34;&#34;
    Assert that the code does not write any ERROR to the log.
    Usage:

        with self.assert_logs_no_errors():
            sv_logger.info(&#34;this is just an information, not error&#34;)

    &#34;&#34;&#34;

    has_errors = False

    class Handler(logging.Handler):
        def emit(self, record):
            nonlocal has_errors
            if record.levelno &gt;= logging.ERROR:
                has_errors = True

    handler = Handler()
    logging.getLogger().addHandler(handler)

    try:
        sv_logger.debug(&#34;=== \/ === [%s] Here should be no errors === \/ ===&#34;, self.__class__.__name__)
        yield handler
        self.assertFalse(has_errors, &#34;There were some errors logged&#34;)
    finally:
        sv_logger.debug(&#34;=== /\ === [%s] There should be no errors === /\ ===&#34;, self.__class__.__name__)
        logging.getLogger().handlers.remove(handler)</code></pre>
</details>
<div class="desc"><p>Assert that the code does not write any ERROR to the log.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_logs_no_errors():
sv_logger.info("this is just an information, not error")</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file"><code class="name flex">
<span>def <span class="ident">assert_node_equals_file</span></span>(<span>self,<br>actual_node,<br>reference_node_name,<br>reference_file_name,<br>imported_tree_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_node_equals_file(self, actual_node, reference_node_name, reference_file_name, imported_tree_name=None):
    &#34;&#34;&#34;
    Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
    This works only for simple nodes.
    &#34;&#34;&#34;
    if imported_tree_name is None:
        imported_tree_name = &#34;ImportedTree&#34;

    try:
        new_tree = get_or_create_node_tree(imported_tree_name)
        importer = JSONImporter.init_from_path(self.get_reference_file_path(reference_file_name))
        importer.import_into_tree(new_tree, print_log=False)
        self.assert_nodes_are_equal(actual_node, get_node(reference_node_name, imported_tree_name))
    finally:
        remove_node_tree(imported_tree_name)</code></pre>
</details>
<div class="desc"><p>Assert that actual_node equals to node named reference_node_name imported from file reference_file_name.
This works only for simple nodes.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_input_equals"><code class="name flex">
<span>def <span class="ident">assert_node_input_equals</span></span>(<span>self, tree_name, node_name, input_name, expected_value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_node_input_equals(self, tree_name, node_name, input_name, expected_value):
    node = get_node(node_name, tree_name)
    actual_value = node.inputs[input_name].sv_get()
    self.assertEqual(actual_value, expected_value)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals"><code class="name flex">
<span>def <span class="ident">assert_node_property_equals</span></span>(<span>self, tree_name, node_name, property_name, expected_value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_node_property_equals(self, tree_name, node_name, property_name, expected_value):
    &#34;&#34;&#34;
    Assert that named property of the node equals to specified value.
    &#34;&#34;&#34;
    node = get_node(node_name, tree_name)
    actual_value = getattr(node, property_name)
    self.assertEqual(actual_value, expected_value)</code></pre>
</details>
<div class="desc"><p>Assert that named property of the node equals to specified value.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal"><code class="name flex">
<span>def <span class="ident">assert_nodes_are_equal</span></span>(<span>self, actual, reference)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_nodes_are_equal(self, actual, reference):
    &#34;&#34;&#34;
    Assert that two nodes have the same settings.
    This works only for simple nodes.
    &#34;&#34;&#34;
    if actual.bl_idname != reference.bl_idname:
        raise AssertionError(&#34;Actual node {} has bl_idname `{}&#39;, but reference has `{}&#39;&#34;.format(actual, actual.bl_idname, reference.bl_idname))
    for k, v in actual.items():
        if k not in reference:
            raise AssertionError(&#34;Property `{}&#39; is present is actual node {}, but is not present in reference&#34;.format(k, actual))
        if v != reference[k] and k != &#39;n_id&#39;:
            raise AssertionError(&#34;Property `{}&#39; has value `{}&#39; in actual node {}, but in reference it has value `{}&#39;&#34;.format(k, v, actual, reference[k]))

    for k in reference.keys():
        if k not in actual:
            raise AssertionError(&#34;Property `{}&#39; is present in reference node, but is not present in actual node {}&#34;.format(k, actual))</code></pre>
</details>
<div class="desc"><p>Assert that two nodes have the same settings.
This works only for simple nodes.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked"><code class="name flex">
<span>def <span class="ident">assert_nodes_linked</span></span>(<span>self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_nodes_linked(self, tree_name, node1_name, node1_output_name, node2_name, node2_input_name):
    &#34;&#34;&#34;
    Assert that certain output of node1 is linked to certain input of node2.
    &#34;&#34;&#34;
    node1 = get_node(node1_name, tree_name)
    node2 = get_node(node2_name, tree_name)

    if node1_output_name not in node1.outputs:
        raise AssertionError(&#34;Node `{}&#39; does not have output named `{}&#39;&#34;.format(node1_name, node1_output_name))
    if node2_input_name not in node2.inputs:
        raise AssertionError(&#34;Node `{}&#39; does not have input named `{}&#39;&#34;.format(node2_name, node2_input_name))

    if not node1.outputs[node1_output_name].is_linked:
        raise AssertionError(&#34;Output `{}&#39; of node `{}&#39; is not linked to anything&#34;, node1_output_name, node1_name)
    if not node2.inputs[node2_input_name].is_linked:
        raise AssertionError(&#34;Input `{}&#39; of node `{}&#39; is not linked to anything&#34;, node2_input_name, node2_name)

    self.assertEqual(node1.outputs[node1_output_name].other, node2.inputs[node2_input_name])</code></pre>
</details>
<div class="desc"><p>Assert that certain output of node1 is linked to certain input of node2.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout"><code class="name flex">
<span>def <span class="ident">assert_not_prints_stdout</span></span>(<span>self, regexp)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def assert_not_prints_stdout(self, regexp):
    &#34;&#34;&#34;
    Assert that the code does not print anything matching regexp to stdout.
    Usage:

        with self.assert_not_prints_stdout(&#34;hello&#34;):
            print(&#34;goodbye&#34;)

    &#34;&#34;&#34;
    with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
        yield fake_stdout
        self.assertNotRegex(fake_stdout.getvalue(), regexp)</code></pre>
</details>
<div class="desc"><p>Assert that the code does not print anything matching regexp to stdout.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_not_prints_stdout("hello"):
print("goodbye")</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal"><code class="name flex">
<span>def <span class="ident">assert_numpy_arrays_equal</span></span>(<span>self, arr1, arr2, precision=None, fail_fast=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_numpy_arrays_equal(self, arr1, arr2, precision=None, fail_fast=True):
    &#34;&#34;&#34;
    Assert that two numpy arrays are equal.
    Floating-point numbers are compared with specified precision.
    &#34;&#34;&#34;
    if arr1.shape != arr2.shape:
        raise AssertionError(&#34;Shape of 1st array {} != shape of 2nd array {}&#34;.format(arr1.shape, arr2.shape))
    shape = list(arr1.shape)
    fails = []

    def compare(prev_indicies):
        step = len(prev_indicies) 
        if step == arr1.ndim:
            ind = tuple(prev_indicies)
            if precision is None:
                a1 = arr1[ind]
                a2 = arr2[ind]
            else:
                a1 = round(arr1[ind], precision)
                a2 = round(arr2[ind], precision)

            if fail_fast:
                self.assertEqual(a1, a2, &#34;Array 1 [{}] != Array 2 [{}]&#34;.format(ind, ind))
            else:
                if a1 != a2:
                    fails.append((a1, a2, ind))
        else:
            for idx in range(shape[step]):
                new_indicies = prev_indicies[:]
                new_indicies.append(idx)
                compare(new_indicies)

    compare([])
    if not fail_fast and fails:
        messages = []
        for a1, a2, ind in fails:
            message = f&#34;{a1} != {a2}: Array 1 [{ind}] != Array 2 [{ind}]&#34;
            messages.append(message)
        header = f&#34;{len(fails)} fails of {arr1.size} comparisons:\n&#34;
        message = header + &#34;\n&#34;.join(messages)
        self.fail(message)</code></pre>
</details>
<div class="desc"><p>Assert that two numpy arrays are equal.
Floating-point numbers are compared with specified precision.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout"><code class="name flex">
<span>def <span class="ident">assert_prints_stdout</span></span>(<span>self, regexp)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def assert_prints_stdout(self, regexp):
    &#34;&#34;&#34;
    Assert that the code prints something matching regexp to stdout.
    Usage:

        with self.assert_prints_stdout(&#34;hello&#34;):
            print(&#34;hello world&#34;)

    &#34;&#34;&#34;
    with unittest.mock.patch(&#39;sys.stdout&#39;, new=StringIO()) as fake_stdout:
        yield fake_stdout
        self.assertRegex(fake_stdout.getvalue(), regexp)</code></pre>
</details>
<div class="desc"><p>Assert that the code prints something matching regexp to stdout.</p>
<h2 id="usage">Usage</h2>
<p>with self.assert_prints_stdout("hello"):
print("hello world")</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal"><code class="name flex">
<span>def <span class="ident">assert_sverchok_data_equal</span></span>(<span>self, data1, data2, precision=None, message=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_sverchok_data_equal(self, data1, data2, precision=None, message=None):
    &#34;&#34;&#34;
    Assert that two arrays of Sverchok data (nested tuples or lists)
    are equal.
    Floating-point numbers are compared with specified precision.
    &#34;&#34;&#34;
    def format_message(text):
        if message is None:
            return text
        else:
            return f&#34;{text}: {message}&#34;

    level1 = get_data_nesting_level(data1)
    level2 = get_data_nesting_level(data2)
    if level1 != level2:
        raise AssertionError(format_message(f&#34;Nesting level of 1st data {level1} != nesting level of 2nd data {level2}&#34;))
    
    def do_assert(d1, d2, idxs):
        if precision is not None:
            d1 = round(d1, precision)
            d2 = round(d2, precision)
        self.assertEqual(d1, d2, format_message(f&#34;Data 1 [{idxs}] != Data 2 [{idxs}]&#34;))

    if level1 == 0:
        do_assert(data1, data2, [])
        return

    def compare(prev_indicies, item1, item2):
        step = len(prev_indicies)
        index = prev_indicies[-1]
        if step == level1:
            if index &gt;= len(item1):
                raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 1: {item1}&#34;))
            if index &gt;= len(item2):
                raise AssertionError(format_message(f&#34;At {prev_indicies}: index {index} &gt;= length of Item 2: {item2}&#34;))
            do_assert(item1[index], item2[index], prev_indicies)
        else:
            l1 = len(item1)
            l2 = len(item2)
            self.assertEqual(l1, l2, format_message(f&#34;Size of data 1 at level {step} != size of data 2&#34;))
            for next_idx in range(len(item1[index])):
                new_indicies = prev_indicies[:]
                new_indicies.append(next_idx)
                compare(new_indicies, item1[index], item2[index])

    for idx in range(len(data1)):
        compare([idx], data1, data2)</code></pre>
</details>
<div class="desc"><p>Assert that two arrays of Sverchok data (nested tuples or lists)
are equal.
Floating-point numbers are compared with specified precision.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file"><code class="name flex">
<span>def <span class="ident">assert_sverchok_data_equals_file</span></span>(<span>self, data, expected_data_file_name, precision=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_sverchok_data_equals_file(self, data, expected_data_file_name, precision=None):
    expected_data = self.load_reference_sverchok_data(expected_data_file_name)
    # sv_logger.info(&#34;Data: %s&#34;, data)
    # sv_logger.info(&#34;Expected data: %s&#34;, expected_data)
    self.assert_sverchok_data_equal(data, expected_data, precision=precision)
    #self.assertEqual(data, expected_data)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(self, *args):
    self.getLogger().debug(*args)</code></pre>
</details>
<div class="desc"><p>Run the test without collecting errors in a TestResult</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.getLogger"><code class="name flex">
<span>def <span class="ident">getLogger</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogger(self):
    return logging.getLogger(self.__class__.__name__)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.get_reference_file_path"><code class="name flex">
<span>def <span class="ident">get_reference_file_path</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reference_file_path(self, file_name):
    return join(get_tests_path(), &#34;references&#34;, file_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, *args):
    self.getLogger().info(*args)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data"><code class="name flex">
<span>def <span class="ident">load_reference_sverchok_data</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_reference_sverchok_data(self, file_name):
    &#34;&#34;&#34;
    Load reference data in Sverchok format
    (plain Python syntax of nested lists).
    Returns: Sverchok data (nested lists).
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(file_name), &#39;r&#39;) as f:
        data = f.read()
        return ast.literal_eval(data)</code></pre>
</details>
<div class="desc"><p>Load reference data in Sverchok format
(plain Python syntax of nested lists).
Returns: Sverchok data (nested lists).</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.serialize_json"><code class="name flex">
<span>def <span class="ident">serialize_json</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_json(self, data):
    &#34;&#34;&#34;
    Serialize JSON object in standard format.
    &#34;&#34;&#34;
    return json.dumps(data, sort_keys=True, indent=2)</code></pre>
</details>
<div class="desc"><p>Serialize JSON object in standard format.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
    sv_logger.debug(&#34;Starting test: %s&#34;, self.id())</code></pre>
</details>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.store_reference_json"><code class="name flex">
<span>def <span class="ident">store_reference_json</span></span>(<span>self, file_name, json_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_reference_json(self, file_name, json_data):
    &#34;&#34;&#34;
    Store JSON data for further reference.
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(file_name), &#39;wb&#39;) as f:
        data = json.dumps(json_data).encode(&#39;utf8&#39;)
        f.write(data)</code></pre>
</details>
<div class="desc"><p>Store JSON data for further reference.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data"><code class="name flex">
<span>def <span class="ident">store_reference_sverchok_data</span></span>(<span>self, file_name, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_reference_sverchok_data(self, file_name, data):
    &#34;&#34;&#34;
    Store reference data in Sverchok format
    (plain Python syntax of nested lists).
    &#34;&#34;&#34;
    with open(self.get_reference_file_path(file_name), &#39;w&#39;) as f:
        f.write(repr(data))</code></pre>
</details>
<div class="desc"><p>Store reference data in Sverchok format
(plain Python syntax of nested lists).</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals"><code class="name flex">
<span>def <span class="ident">subtest_assert_equals</span></span>(<span>self, value1, value2, message=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtest_assert_equals(self, value1, value2, message=None):
    &#34;&#34;&#34;
    The same as assertEqual(), but within subtest.
    Use this to do several assertions per test method,
    for case test execution not to be stopped at
    the first failure.
    &#34;&#34;&#34;

    with self.subTest():
        self.assertEqual(value1, value2, message)</code></pre>
</details>
<div class="desc"><p>The same as assertEqual(), but within subtest.
Use this to do several assertions per test method,
for case test execution not to be stopped at
the first failure.</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.temporary_node_tree"><code class="name flex">
<span>def <span class="ident">temporary_node_tree</span></span>(<span>self, new_tree_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def temporary_node_tree(self, new_tree_name):
    &#34;&#34;&#34;
    Context manager for dealing with new temporary node tree.
    The tree is created on entering context and removed when
    exiting context. Example of usage:

    with self.temporary_node_tree(&#34;TempTree&#34;) as tmp:
        do_something(tree)
    &#34;&#34;&#34;
    new_tree = create_node_tree(new_tree_name)
    try:
        yield new_tree
    finally:
        remove_node_tree(new_tree_name)</code></pre>
</details>
<div class="desc"><p>Context manager for dealing with new temporary node tree.
The tree is created on entering context and removed when
exiting context. Example of usage:</p>
<p>with self.temporary_node_tree("TempTree") as tmp:
do_something(tree)</p></div>
</dd>
<dt id="sverchok.utils.testing.SverchokTestCase.tree_from_file"><code class="name flex">
<span>def <span class="ident">tree_from_file</span></span>(<span>self, file_name:str, tree_name:str) >Iterator[bpy_types.NodeTree]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def tree_from_file(self, file_name: str, tree_name: str) -&gt; Iterator[NodeTree]:
    path = join(get_tests_path(), &#34;references&#34;, file_name)
    link_node_tree(path, tree_name)
    try:
        yield get_node_tree(tree_name)
    finally:
        remove_node_tree(tree_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.testing.batch_only" href="#sverchok.utils.testing.batch_only">batch_only</a></code></li>
<li><code><a title="sverchok.utils.testing.branches_only" href="#sverchok.utils.testing.branches_only">branches_only</a></code></li>
<li><code><a title="sverchok.utils.testing.coverage_report" href="#sverchok.utils.testing.coverage_report">coverage_report</a></code></li>
<li><code><a title="sverchok.utils.testing.create_node" href="#sverchok.utils.testing.create_node">create_node</a></code></li>
<li><code><a title="sverchok.utils.testing.create_node_tree" href="#sverchok.utils.testing.create_node_tree">create_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.generate_node_definition" href="#sverchok.utils.testing.generate_node_definition">generate_node_definition</a></code></li>
<li><code><a title="sverchok.utils.testing.get_ci_branch" href="#sverchok.utils.testing.get_ci_branch">get_ci_branch</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node" href="#sverchok.utils.testing.get_node">get_node</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node_editor_context" href="#sverchok.utils.testing.get_node_editor_context">get_node_editor_context</a></code></li>
<li><code><a title="sverchok.utils.testing.get_node_tree" href="#sverchok.utils.testing.get_node_tree">get_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.get_or_create_node_tree" href="#sverchok.utils.testing.get_or_create_node_tree">get_or_create_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.get_tests_path" href="#sverchok.utils.testing.get_tests_path">get_tests_path</a></code></li>
<li><code><a title="sverchok.utils.testing.interactive_only" href="#sverchok.utils.testing.interactive_only">interactive_only</a></code></li>
<li><code><a title="sverchok.utils.testing.is_integration_server" href="#sverchok.utils.testing.is_integration_server">is_integration_server</a></code></li>
<li><code><a title="sverchok.utils.testing.is_pull_request" href="#sverchok.utils.testing.is_pull_request">is_pull_request</a></code></li>
<li><code><a title="sverchok.utils.testing.link_node_tree" href="#sverchok.utils.testing.link_node_tree">link_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.link_text_block" href="#sverchok.utils.testing.link_text_block">link_text_block</a></code></li>
<li><code><a title="sverchok.utils.testing.make_skip_decorator" href="#sverchok.utils.testing.make_skip_decorator">make_skip_decorator</a></code></li>
<li><code><a title="sverchok.utils.testing.manual_only" href="#sverchok.utils.testing.manual_only">manual_only</a></code></li>
<li><code><a title="sverchok.utils.testing.only_test_logs" href="#sverchok.utils.testing.only_test_logs">only_test_logs</a></code></li>
<li><code><a title="sverchok.utils.testing.pull_requests_only" href="#sverchok.utils.testing.pull_requests_only">pull_requests_only</a></code></li>
<li><code><a title="sverchok.utils.testing.remove_all_trees" href="#sverchok.utils.testing.remove_all_trees">remove_all_trees</a></code></li>
<li><code><a title="sverchok.utils.testing.remove_node_tree" href="#sverchok.utils.testing.remove_node_tree">remove_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.requires" href="#sverchok.utils.testing.requires">requires</a></code></li>
<li><code><a title="sverchok.utils.testing.run_all_tests" href="#sverchok.utils.testing.run_all_tests">run_all_tests</a></code></li>
<li><code><a title="sverchok.utils.testing.run_test_from_file" href="#sverchok.utils.testing.run_test_from_file">run_test_from_file</a></code></li>
<li><code><a title="sverchok.utils.testing.skip_pull_requests" href="#sverchok.utils.testing.skip_pull_requests">skip_pull_requests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.testing.EmptyTreeTestCase" href="#sverchok.utils.testing.EmptyTreeTestCase">EmptyTreeTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.EmptyTreeTestCase.tearDown" href="#sverchok.utils.testing.EmptyTreeTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.NodeProcessTestCase" href="#sverchok.utils.testing.NodeProcessTestCase">NodeProcessTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals" href="#sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals">assert_output_data_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file" href="#sverchok.utils.testing.NodeProcessTestCase.assert_output_data_equals_file">assert_output_data_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets" href="#sverchok.utils.testing.NodeProcessTestCase.connect_output_sockets">connect_output_sockets</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.get_output_data" href="#sverchok.utils.testing.NodeProcessTestCase.get_output_data">get_output_data</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.node_bl_idname" href="#sverchok.utils.testing.NodeProcessTestCase.node_bl_idname">node_bl_idname</a></code></li>
<li><code><a title="sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname" href="#sverchok.utils.testing.NodeProcessTestCase.output_node_bl_idname">output_node_bl_idname</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.ReferenceTreeTestCase" href="#sverchok.utils.testing.ReferenceTreeTestCase">ReferenceTreeTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path" href="#sverchok.utils.testing.ReferenceTreeTestCase.get_reference_file_path">get_reference_file_path</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree" href="#sverchok.utils.testing.ReferenceTreeTestCase.link_node_tree">link_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.link_text_block" href="#sverchok.utils.testing.ReferenceTreeTestCase.link_text_block">link_text_block</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name" href="#sverchok.utils.testing.ReferenceTreeTestCase.reference_file_name">reference_file_name</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name" href="#sverchok.utils.testing.ReferenceTreeTestCase.reference_tree_name">reference_tree_name</a></code></li>
<li><code><a title="sverchok.utils.testing.ReferenceTreeTestCase.tearDown" href="#sverchok.utils.testing.ReferenceTreeTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.testing.SverchokTestCase" href="#sverchok.utils.testing.SverchokTestCase">SverchokTestCase</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_dicts_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_dicts_equal">assert_dicts_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals">assert_json_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_json_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_json_equals_file">assert_json_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors" href="#sverchok.utils.testing.SverchokTestCase.assert_logs_no_errors">assert_logs_no_errors</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_node_equals_file">assert_node_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_input_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_input_equals">assert_node_input_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_node_property_equals" href="#sverchok.utils.testing.SverchokTestCase.assert_node_property_equals">assert_node_property_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_are_equal">assert_nodes_are_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_nodes_linked" href="#sverchok.utils.testing.SverchokTestCase.assert_nodes_linked">assert_nodes_linked</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_not_prints_stdout">assert_not_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_numpy_arrays_equal">assert_numpy_arrays_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_prints_stdout" href="#sverchok.utils.testing.SverchokTestCase.assert_prints_stdout">assert_prints_stdout</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equal">assert_sverchok_data_equal</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file" href="#sverchok.utils.testing.SverchokTestCase.assert_sverchok_data_equals_file">assert_sverchok_data_equals_file</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.debug" href="#sverchok.utils.testing.SverchokTestCase.debug">debug</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.getLogger" href="#sverchok.utils.testing.SverchokTestCase.getLogger">getLogger</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.get_reference_file_path" href="#sverchok.utils.testing.SverchokTestCase.get_reference_file_path">get_reference_file_path</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.info" href="#sverchok.utils.testing.SverchokTestCase.info">info</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.load_reference_sverchok_data">load_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.serialize_json" href="#sverchok.utils.testing.SverchokTestCase.serialize_json">serialize_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.setUp" href="#sverchok.utils.testing.SverchokTestCase.setUp">setUp</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_json" href="#sverchok.utils.testing.SverchokTestCase.store_reference_json">store_reference_json</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data" href="#sverchok.utils.testing.SverchokTestCase.store_reference_sverchok_data">store_reference_sverchok_data</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.subtest_assert_equals" href="#sverchok.utils.testing.SverchokTestCase.subtest_assert_equals">subtest_assert_equals</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.temporary_node_tree" href="#sverchok.utils.testing.SverchokTestCase.temporary_node_tree">temporary_node_tree</a></code></li>
<li><code><a title="sverchok.utils.testing.SverchokTestCase.tree_from_file" href="#sverchok.utils.testing.SverchokTestCase.tree_from_file">tree_from_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
