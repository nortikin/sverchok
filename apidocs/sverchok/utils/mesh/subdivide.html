<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.mesh.subdivide API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.mesh.subdivide</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import numpy as np
from numpy.random import random
from sverchok.data_structure import numpy_full_list, repeat_last_for_length
from sverchok.utils.modules.polygon_utils import np_faces_normals, np_faces_perimeters as face_perimeter



def np_pols(pols):
    if isinstance(pols, np.ndarray):
        flat_pols = pols.flat
        p_lens = np.full(pols.shape[0], pols.shape[1])
        pol_end = np.cumsum(p_lens)
    else:
        p_lens = np.array(list(map(len, pols)))
        flat_pols = np.array([c for p in pols for c in p])
        pol_end = np.cumsum(p_lens)
    return flat_pols, p_lens, pol_end

def normal_offset(v_pols, normal_displace, random_normal):

    if normal_displace == 0:
        return face_perimeter(v_pols)[:, np.newaxis] * np_faces_normals(v_pols) * (2*random_normal-random_normal) * random(len(v_pols))[:, np.newaxis]

    if random_normal == 0:
        return face_perimeter(v_pols)[:, np.newaxis] * np_faces_normals(v_pols) * (normal_displace)

    return face_perimeter(v_pols)[:, np.newaxis] * np_faces_normals(v_pols) * (normal_displace + (2*random_normal-random_normal) * random(len(v_pols))[:, np.newaxis])

def regular_random_centers(np_faces, v_pols, randomf, vert_data):

    centers = np.sum(v_pols * randomf[:, :, np.newaxis], axis=1) / np.sum(randomf, axis=1)[:, np.newaxis]
    if vert_data:
        center_vert_data = dict()
        for key in vert_data:
            data = vert_data[key]
            np_data = data if isinstance(data, np.ndarray) else np.array(data)
            if len(np_data.shape)&gt;1:
                center_vert_data[key] = np.sum(np_data[np_faces] * randomf[:, :, np.newaxis], axis=1) / np.sum(randomf, axis=1)[:, np.newaxis]
            else:
                center_vert_data[key] = np.sum(np_data[np_faces] * randomf, axis=1) / np.sum(randomf, axis=1)
    else:
        center_vert_data = []
    return centers, center_vert_data
def regular_mid_centers(np_faces, v_pols, vert_data):

    centers = np.sum(v_pols, axis=1) / v_pols.shape[1]
    if vert_data:
        center_vert_data = dict()
        for key in vert_data:
            data = vert_data[key]
            np_data = data if isinstance(data, np.ndarray) else np.array(data)
            if len(np_data.shape) &gt; 1:
                center_vert_data[key] = np.sum(np_data[np_faces], axis=1)/v_pols.shape[1]
            else:
                center_vert_data[key] = np.sum(np_data[np_faces], axis=1)/v_pols.shape[1]
    else:
        center_vert_data = []
    return centers, center_vert_data

def irregular_random_centers(centers, mask, v_pols, np_faces_g, randomf, vert_data, center_vert_data, np_data_dict):
    centers[mask, :] = np.sum(v_pols * randomf[:, :, np.newaxis], axis=1) / (np.sum(randomf, axis=1)[:, np.newaxis])

    if vert_data:
        for key in vert_data:
            np_data = np_data_dict[key]
            if len(np_data.shape)&gt;1:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g] * randomf[:, np.newaxis], axis=1) / np.sum(randomf, axis=1)[:, np.newaxis]
            else:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g] * randomf, axis=1) / np.sum(randomf, axis=1)

def irregular_mid_centers(centers, mask, v_pols, np_faces_g, vert_data, center_vert_data, np_data_dict):
    centers[mask, :] = np.sum(v_pols, axis=1) / v_pols.shape[1]

    if vert_data:
        for key in vert_data:
            np_data = np_data_dict[key]
            if len(np_data.shape) &gt; 1:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g], axis=1) / v_pols.shape[1]
            else:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g], axis=1) / v_pols.shape[1]

def random_centers(np_verts, faces, lens, vert_data, normal_displace, random_f, random_normal):


    if isinstance(faces, np.ndarray):
        np_faces = faces
    else:
        np_faces = np.array(faces)

    if np_faces.dtype == object:
        pol_types = np.unique(lens)
        center_vert_data = dict()
        np_data_dict = dict()
        if vert_data:
            for key in vert_data:
                data = vert_data[key]
                np_data = data if isinstance(data, np.ndarray) else np.array(data)
                np_data_dict[key] = np_data
                center_vert_data[key] = np.zeros(np_faces.shape[0], np_data.shape[1], dtype=np_data.dtype)
        else:
            center_vert_data = []
        centers = np.zeros((np_faces.shape[0], 3), dtype=float)
        for p in pol_types:
            mask = lens == p
            np_faces_g = np.array(np_faces[mask].tolist())
            v_pols = np_verts[np_faces_g]
            if random_f != 0:
                randomf = 0.5+(random(np_faces_g.shape)-0.5) * random_f
                irregular_random_centers(centers, mask, v_pols, np_faces_g,
                                         randomf, vert_data, center_vert_data,
                                         np_data_dict)
            else:
                irregular_mid_centers(centers, mask, v_pols, np_faces_g,
                                      vert_data, center_vert_data,
                                      np_data_dict)

            if random_normal != 0 or normal_displace != 0:
                centers[mask, :] += normal_offset(v_pols, normal_displace, random_normal)
    else:
        v_pols = np_verts[np_faces] #num pols, num sides
        if random_f != 0:
            randomf = 0.5 + (np.random.random(np_faces.shape) - 0.5) * random_f
            centers, center_vert_data = regular_random_centers(np_faces, v_pols, randomf, vert_data)
        else:
            centers, center_vert_data = regular_mid_centers(np_faces, v_pols, vert_data)

        if random_normal != 0 or normal_displace != 0:
            centers += normal_offset(v_pols, normal_displace, random_normal)

    return centers, center_vert_data

def random_pol_center(v_pols, f):
    randomf = 0.5+(np.random.random(v_pols.shape)-0.5) *f
    return np.sum(v_pols*randomf, axis=1) / (np.sum(randomf, axis=1))

def smooth_verts(np_verts, edges,f):
    average= np.zeros_like(np_verts)
    nums = np.zeros(len(np_verts), dtype=int)
    np.add.at(average, edges, np_verts[np.flip(edges,axis=1)])
    np.add.at(nums, edges, 1)
    masks_unreferenced = nums == 0
    average[masks_unreferenced] = np_verts[masks_unreferenced]
    return np_verts*(1-f)+average/nums[:,np.newaxis]*f

def pols_to_edges(flat_pols, lens, pol_end):
    edges = np.zeros((len(flat_pols), 2), dtype=int)
    edges[:, 0] = flat_pols
    edges[:, 1] = np.roll(flat_pols, -1)
    edges[pol_end-1, 1] = flat_pols[pol_end-lens]
    return  (edges,
             *np.unique(np.sort(edges, axis=1), axis=0, return_inverse=True))

def subdivide(np_verts, pols_m, normal_displace, random_f, random_normal,
              edges, unique_edges, eds_inverse_idx,
              pol_end, pol_len,
              vert_map, vert_data, face_data):

    pol_center, center_vert_data = random_centers(np_verts, pols_m, pol_len,
                                                  vert_data, normal_displace,
                                                  random_f, random_normal)

    if random_f != 0:
        mid_random = 0.5+(np.random.random(unique_edges.shape)-0.5)*random_f
        mid_points = np.sum(np_verts[unique_edges]*mid_random[:, :, np.newaxis], axis=1)/np.sum(mid_random, axis=1)[:,np.newaxis]
    else:
        mid_points = np.sum(np_verts[unique_edges], axis=1)/2

    verts_out = np.concatenate([np_verts, mid_points, pol_center])

    if len(vert_map) &gt; 0:
        vert_map = np.concatenate([vert_map,
                                   np.full(mid_points.shape[0], vert_map[-1]+1),
                                   np.full(pol_center.shape[0], vert_map[-1]+2)])
    num_verts = np_verts.shape[0]
    num_mids = mid_points.shape[0]
    num_centers = len(pols_m)
    mid_point_idx = np.arange(num_verts, num_verts + num_mids)
    center_point_idx = np.arange(num_verts + num_mids, num_verts + num_mids + num_centers)

    pols_out = np.zeros([edges.shape[0], 4], dtype=int)
    mids_idx = mid_point_idx[eds_inverse_idx]
    mid_idx_end = np.roll(mids_idx, 1)
    mid_idx_end[pol_end - pol_len] = mids_idx[pol_end-1]

    pols_out[:, 0] = edges[:, 0]
    pols_out[:, 1] = mids_idx
    pols_out[:, 2] = np.repeat(center_point_idx, pol_len)
    pols_out[:, 3] = mid_idx_end

    if face_data:
        new_face_data = dict()
        for key in face_data:
            data = face_data[key]
            if isinstance(data, np.ndarray):
                new_data = np.repeat(data, pol_len)
            else:
                new_data = [d for d, p_l in zip(data, pol_len) for i in range(p_l)]
            new_face_data[key] = new_data
    else:
        new_face_data = dict()

    if vert_data:
        new_vert_data = dict()
        for key in vert_data:
            data = vert_data[key]
            np_data = data if isinstance(data, np.ndarray) else np.array(data)

            new_data = np.concatenate([np_data,
                                       np.sum(np_data[unique_edges], axis=1)/2,
                                       center_vert_data[key]])

            new_vert_data[key] = new_data
    else:
        new_vert_data = dict()

    return verts_out, pols_out, vert_map, new_vert_data, new_face_data

def subdiv_mesh_to_quads_np(vertices, polygons,
                            iterations, normal_displace,
                            random_f, random_normal, random_seed,
                            smooth_f,
                            vert_data, face_data,
                            output_edges=True,
                            output_vert_map=True):
    np.random.seed(int(random_seed))
    np_verts = vertices if isinstance(vertices, np.ndarray) else np.array(vertices)
    if output_vert_map:
        vert_map = np.zeros(np_verts.shape[0], dtype=int)
    else:
        vert_map = np.array([], dtype=int)

    matched_vert_data = dict()
    if vert_data:
        for key in vert_data:
            matched_vert_data[key] = numpy_full_list(vert_data[key], np_verts.shape[0])

    matched_face_data = dict()
    if face_data:
        for key in face_data:
            data = face_data[key]
            if isinstance(data, np.ndarray):
                matched_face_data[key] = numpy_full_list(data, len(polygons))
            else:
                matched_face_data[key] = repeat_last_for_length(data, len(polygons))


    flat_pols, pol_len, pol_end = np_pols(polygons)
    edges, unique_edges, eds_inverse_idx = pols_to_edges(flat_pols, pol_len, pol_end)
    return subdiv_mesh_to_quads_inner(
        np_verts, polygons,
        pol_len, pol_end,
        edges, unique_edges, eds_inverse_idx,
        iterations, normal_displace,
        random_f, random_normal,
        smooth_f,
        vert_map, matched_vert_data, matched_face_data,
        output_edges=output_edges,
        max_iterations=iterations)

def get_item(data, i):
    return data[i%len(data)]

def subdiv_mesh_to_quads_inner(
        np_verts, pols_m,
        pol_len, pol_end,
        edges, unique_edges, eds_inverse_idx,
        it, normal_displace,
        random_f, random_normal,
        smooth_f,
        vert_map, vert_data, face_data,
        output_edges=True,
        max_iterations=1):

    iteration_num = max_iterations-it
    verts_out, pols_out, vert_map_out, vert_data_out, face_data_out = subdivide(
        np_verts, pols_m,
        get_item(normal_displace, iteration_num),
        get_item(random_f, iteration_num),
        get_item(random_normal, iteration_num),
        edges, unique_edges, eds_inverse_idx,
        pol_end, pol_len,
        vert_map, vert_data, face_data)


    actual_smooth_f = get_item(smooth_f, iteration_num)
    if actual_smooth_f == 0:
        do_smooth_f = False
    else:
        do_smooth_f = True
    if output_edges or do_smooth_f or it &gt;= 2:
        p_lens = np.full(pols_out.shape[0], 4)
        p_end = np.cumsum(p_lens)
        new_all_edges, new_edges, new_eds_inverse_idx = pols_to_edges(pols_out.flat, p_lens, p_end)
        if do_smooth_f:
            verts_out = smooth_verts(verts_out, new_edges, actual_smooth_f)
    else:
        new_edges = np.array([], np.int32) #[]

    if it &lt; 2:
        return verts_out, new_edges, pols_out, vert_map_out, vert_data_out, face_data_out


    return subdiv_mesh_to_quads_inner(
        verts_out, pols_out,
        p_lens, p_end,
        new_all_edges, new_edges, new_eds_inverse_idx,
        it-1, normal_displace,
        random_f, random_normal,
        smooth_f,
        vert_map_out, vert_data_out, face_data_out,
        output_edges=output_edges,
        max_iterations=max_iterations)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.mesh.subdivide.get_item"><code class="name flex">
<span>def <span class="ident">get_item</span></span>(<span>data, i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item(data, i):
    return data[i%len(data)]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.irregular_mid_centers"><code class="name flex">
<span>def <span class="ident">irregular_mid_centers</span></span>(<span>centers, mask, v_pols, np_faces_g, vert_data, center_vert_data, np_data_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def irregular_mid_centers(centers, mask, v_pols, np_faces_g, vert_data, center_vert_data, np_data_dict):
    centers[mask, :] = np.sum(v_pols, axis=1) / v_pols.shape[1]

    if vert_data:
        for key in vert_data:
            np_data = np_data_dict[key]
            if len(np_data.shape) &gt; 1:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g], axis=1) / v_pols.shape[1]
            else:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g], axis=1) / v_pols.shape[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.irregular_random_centers"><code class="name flex">
<span>def <span class="ident">irregular_random_centers</span></span>(<span>centers, mask, v_pols, np_faces_g, randomf, vert_data, center_vert_data, np_data_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def irregular_random_centers(centers, mask, v_pols, np_faces_g, randomf, vert_data, center_vert_data, np_data_dict):
    centers[mask, :] = np.sum(v_pols * randomf[:, :, np.newaxis], axis=1) / (np.sum(randomf, axis=1)[:, np.newaxis])

    if vert_data:
        for key in vert_data:
            np_data = np_data_dict[key]
            if len(np_data.shape)&gt;1:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g] * randomf[:, np.newaxis], axis=1) / np.sum(randomf, axis=1)[:, np.newaxis]
            else:
                center_vert_data[key][mask] = np.sum(np_data[np_faces_g] * randomf, axis=1) / np.sum(randomf, axis=1)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.normal_offset"><code class="name flex">
<span>def <span class="ident">normal_offset</span></span>(<span>v_pols, normal_displace, random_normal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_offset(v_pols, normal_displace, random_normal):

    if normal_displace == 0:
        return face_perimeter(v_pols)[:, np.newaxis] * np_faces_normals(v_pols) * (2*random_normal-random_normal) * random(len(v_pols))[:, np.newaxis]

    if random_normal == 0:
        return face_perimeter(v_pols)[:, np.newaxis] * np_faces_normals(v_pols) * (normal_displace)

    return face_perimeter(v_pols)[:, np.newaxis] * np_faces_normals(v_pols) * (normal_displace + (2*random_normal-random_normal) * random(len(v_pols))[:, np.newaxis])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.np_pols"><code class="name flex">
<span>def <span class="ident">np_pols</span></span>(<span>pols)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np_pols(pols):
    if isinstance(pols, np.ndarray):
        flat_pols = pols.flat
        p_lens = np.full(pols.shape[0], pols.shape[1])
        pol_end = np.cumsum(p_lens)
    else:
        p_lens = np.array(list(map(len, pols)))
        flat_pols = np.array([c for p in pols for c in p])
        pol_end = np.cumsum(p_lens)
    return flat_pols, p_lens, pol_end</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.pols_to_edges"><code class="name flex">
<span>def <span class="ident">pols_to_edges</span></span>(<span>flat_pols, lens, pol_end)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pols_to_edges(flat_pols, lens, pol_end):
    edges = np.zeros((len(flat_pols), 2), dtype=int)
    edges[:, 0] = flat_pols
    edges[:, 1] = np.roll(flat_pols, -1)
    edges[pol_end-1, 1] = flat_pols[pol_end-lens]
    return  (edges,
             *np.unique(np.sort(edges, axis=1), axis=0, return_inverse=True))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return random floats in the half-open interval [0.0, 1.0). Alias for
<code>random_sample</code> to ease forward-porting to the new random API.</p></div>
</dd>
<dt id="sverchok.utils.mesh.subdivide.random_centers"><code class="name flex">
<span>def <span class="ident">random_centers</span></span>(<span>np_verts, faces, lens, vert_data, normal_displace, random_f, random_normal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_centers(np_verts, faces, lens, vert_data, normal_displace, random_f, random_normal):


    if isinstance(faces, np.ndarray):
        np_faces = faces
    else:
        np_faces = np.array(faces)

    if np_faces.dtype == object:
        pol_types = np.unique(lens)
        center_vert_data = dict()
        np_data_dict = dict()
        if vert_data:
            for key in vert_data:
                data = vert_data[key]
                np_data = data if isinstance(data, np.ndarray) else np.array(data)
                np_data_dict[key] = np_data
                center_vert_data[key] = np.zeros(np_faces.shape[0], np_data.shape[1], dtype=np_data.dtype)
        else:
            center_vert_data = []
        centers = np.zeros((np_faces.shape[0], 3), dtype=float)
        for p in pol_types:
            mask = lens == p
            np_faces_g = np.array(np_faces[mask].tolist())
            v_pols = np_verts[np_faces_g]
            if random_f != 0:
                randomf = 0.5+(random(np_faces_g.shape)-0.5) * random_f
                irregular_random_centers(centers, mask, v_pols, np_faces_g,
                                         randomf, vert_data, center_vert_data,
                                         np_data_dict)
            else:
                irregular_mid_centers(centers, mask, v_pols, np_faces_g,
                                      vert_data, center_vert_data,
                                      np_data_dict)

            if random_normal != 0 or normal_displace != 0:
                centers[mask, :] += normal_offset(v_pols, normal_displace, random_normal)
    else:
        v_pols = np_verts[np_faces] #num pols, num sides
        if random_f != 0:
            randomf = 0.5 + (np.random.random(np_faces.shape) - 0.5) * random_f
            centers, center_vert_data = regular_random_centers(np_faces, v_pols, randomf, vert_data)
        else:
            centers, center_vert_data = regular_mid_centers(np_faces, v_pols, vert_data)

        if random_normal != 0 or normal_displace != 0:
            centers += normal_offset(v_pols, normal_displace, random_normal)

    return centers, center_vert_data</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.random_pol_center"><code class="name flex">
<span>def <span class="ident">random_pol_center</span></span>(<span>v_pols, f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_pol_center(v_pols, f):
    randomf = 0.5+(np.random.random(v_pols.shape)-0.5) *f
    return np.sum(v_pols*randomf, axis=1) / (np.sum(randomf, axis=1))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.regular_mid_centers"><code class="name flex">
<span>def <span class="ident">regular_mid_centers</span></span>(<span>np_faces, v_pols, vert_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_mid_centers(np_faces, v_pols, vert_data):

    centers = np.sum(v_pols, axis=1) / v_pols.shape[1]
    if vert_data:
        center_vert_data = dict()
        for key in vert_data:
            data = vert_data[key]
            np_data = data if isinstance(data, np.ndarray) else np.array(data)
            if len(np_data.shape) &gt; 1:
                center_vert_data[key] = np.sum(np_data[np_faces], axis=1)/v_pols.shape[1]
            else:
                center_vert_data[key] = np.sum(np_data[np_faces], axis=1)/v_pols.shape[1]
    else:
        center_vert_data = []
    return centers, center_vert_data</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.regular_random_centers"><code class="name flex">
<span>def <span class="ident">regular_random_centers</span></span>(<span>np_faces, v_pols, randomf, vert_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_random_centers(np_faces, v_pols, randomf, vert_data):

    centers = np.sum(v_pols * randomf[:, :, np.newaxis], axis=1) / np.sum(randomf, axis=1)[:, np.newaxis]
    if vert_data:
        center_vert_data = dict()
        for key in vert_data:
            data = vert_data[key]
            np_data = data if isinstance(data, np.ndarray) else np.array(data)
            if len(np_data.shape)&gt;1:
                center_vert_data[key] = np.sum(np_data[np_faces] * randomf[:, :, np.newaxis], axis=1) / np.sum(randomf, axis=1)[:, np.newaxis]
            else:
                center_vert_data[key] = np.sum(np_data[np_faces] * randomf, axis=1) / np.sum(randomf, axis=1)
    else:
        center_vert_data = []
    return centers, center_vert_data</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.smooth_verts"><code class="name flex">
<span>def <span class="ident">smooth_verts</span></span>(<span>np_verts, edges, f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smooth_verts(np_verts, edges,f):
    average= np.zeros_like(np_verts)
    nums = np.zeros(len(np_verts), dtype=int)
    np.add.at(average, edges, np_verts[np.flip(edges,axis=1)])
    np.add.at(nums, edges, 1)
    masks_unreferenced = nums == 0
    average[masks_unreferenced] = np_verts[masks_unreferenced]
    return np_verts*(1-f)+average/nums[:,np.newaxis]*f</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.subdiv_mesh_to_quads_inner"><code class="name flex">
<span>def <span class="ident">subdiv_mesh_to_quads_inner</span></span>(<span>np_verts, pols_m, pol_len, pol_end, edges, unique_edges, eds_inverse_idx, it, normal_displace, random_f, random_normal, smooth_f, vert_map, vert_data, face_data, output_edges=True, max_iterations=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdiv_mesh_to_quads_inner(
        np_verts, pols_m,
        pol_len, pol_end,
        edges, unique_edges, eds_inverse_idx,
        it, normal_displace,
        random_f, random_normal,
        smooth_f,
        vert_map, vert_data, face_data,
        output_edges=True,
        max_iterations=1):

    iteration_num = max_iterations-it
    verts_out, pols_out, vert_map_out, vert_data_out, face_data_out = subdivide(
        np_verts, pols_m,
        get_item(normal_displace, iteration_num),
        get_item(random_f, iteration_num),
        get_item(random_normal, iteration_num),
        edges, unique_edges, eds_inverse_idx,
        pol_end, pol_len,
        vert_map, vert_data, face_data)


    actual_smooth_f = get_item(smooth_f, iteration_num)
    if actual_smooth_f == 0:
        do_smooth_f = False
    else:
        do_smooth_f = True
    if output_edges or do_smooth_f or it &gt;= 2:
        p_lens = np.full(pols_out.shape[0], 4)
        p_end = np.cumsum(p_lens)
        new_all_edges, new_edges, new_eds_inverse_idx = pols_to_edges(pols_out.flat, p_lens, p_end)
        if do_smooth_f:
            verts_out = smooth_verts(verts_out, new_edges, actual_smooth_f)
    else:
        new_edges = np.array([], np.int32) #[]

    if it &lt; 2:
        return verts_out, new_edges, pols_out, vert_map_out, vert_data_out, face_data_out


    return subdiv_mesh_to_quads_inner(
        verts_out, pols_out,
        p_lens, p_end,
        new_all_edges, new_edges, new_eds_inverse_idx,
        it-1, normal_displace,
        random_f, random_normal,
        smooth_f,
        vert_map_out, vert_data_out, face_data_out,
        output_edges=output_edges,
        max_iterations=max_iterations)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.subdiv_mesh_to_quads_np"><code class="name flex">
<span>def <span class="ident">subdiv_mesh_to_quads_np</span></span>(<span>vertices, polygons, iterations, normal_displace, random_f, random_normal, random_seed, smooth_f, vert_data, face_data, output_edges=True, output_vert_map=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdiv_mesh_to_quads_np(vertices, polygons,
                            iterations, normal_displace,
                            random_f, random_normal, random_seed,
                            smooth_f,
                            vert_data, face_data,
                            output_edges=True,
                            output_vert_map=True):
    np.random.seed(int(random_seed))
    np_verts = vertices if isinstance(vertices, np.ndarray) else np.array(vertices)
    if output_vert_map:
        vert_map = np.zeros(np_verts.shape[0], dtype=int)
    else:
        vert_map = np.array([], dtype=int)

    matched_vert_data = dict()
    if vert_data:
        for key in vert_data:
            matched_vert_data[key] = numpy_full_list(vert_data[key], np_verts.shape[0])

    matched_face_data = dict()
    if face_data:
        for key in face_data:
            data = face_data[key]
            if isinstance(data, np.ndarray):
                matched_face_data[key] = numpy_full_list(data, len(polygons))
            else:
                matched_face_data[key] = repeat_last_for_length(data, len(polygons))


    flat_pols, pol_len, pol_end = np_pols(polygons)
    edges, unique_edges, eds_inverse_idx = pols_to_edges(flat_pols, pol_len, pol_end)
    return subdiv_mesh_to_quads_inner(
        np_verts, polygons,
        pol_len, pol_end,
        edges, unique_edges, eds_inverse_idx,
        iterations, normal_displace,
        random_f, random_normal,
        smooth_f,
        vert_map, matched_vert_data, matched_face_data,
        output_edges=output_edges,
        max_iterations=iterations)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.mesh.subdivide.subdivide"><code class="name flex">
<span>def <span class="ident">subdivide</span></span>(<span>np_verts, pols_m, normal_displace, random_f, random_normal, edges, unique_edges, eds_inverse_idx, pol_end, pol_len, vert_map, vert_data, face_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subdivide(np_verts, pols_m, normal_displace, random_f, random_normal,
              edges, unique_edges, eds_inverse_idx,
              pol_end, pol_len,
              vert_map, vert_data, face_data):

    pol_center, center_vert_data = random_centers(np_verts, pols_m, pol_len,
                                                  vert_data, normal_displace,
                                                  random_f, random_normal)

    if random_f != 0:
        mid_random = 0.5+(np.random.random(unique_edges.shape)-0.5)*random_f
        mid_points = np.sum(np_verts[unique_edges]*mid_random[:, :, np.newaxis], axis=1)/np.sum(mid_random, axis=1)[:,np.newaxis]
    else:
        mid_points = np.sum(np_verts[unique_edges], axis=1)/2

    verts_out = np.concatenate([np_verts, mid_points, pol_center])

    if len(vert_map) &gt; 0:
        vert_map = np.concatenate([vert_map,
                                   np.full(mid_points.shape[0], vert_map[-1]+1),
                                   np.full(pol_center.shape[0], vert_map[-1]+2)])
    num_verts = np_verts.shape[0]
    num_mids = mid_points.shape[0]
    num_centers = len(pols_m)
    mid_point_idx = np.arange(num_verts, num_verts + num_mids)
    center_point_idx = np.arange(num_verts + num_mids, num_verts + num_mids + num_centers)

    pols_out = np.zeros([edges.shape[0], 4], dtype=int)
    mids_idx = mid_point_idx[eds_inverse_idx]
    mid_idx_end = np.roll(mids_idx, 1)
    mid_idx_end[pol_end - pol_len] = mids_idx[pol_end-1]

    pols_out[:, 0] = edges[:, 0]
    pols_out[:, 1] = mids_idx
    pols_out[:, 2] = np.repeat(center_point_idx, pol_len)
    pols_out[:, 3] = mid_idx_end

    if face_data:
        new_face_data = dict()
        for key in face_data:
            data = face_data[key]
            if isinstance(data, np.ndarray):
                new_data = np.repeat(data, pol_len)
            else:
                new_data = [d for d, p_l in zip(data, pol_len) for i in range(p_l)]
            new_face_data[key] = new_data
    else:
        new_face_data = dict()

    if vert_data:
        new_vert_data = dict()
        for key in vert_data:
            data = vert_data[key]
            np_data = data if isinstance(data, np.ndarray) else np.array(data)

            new_data = np.concatenate([np_data,
                                       np.sum(np_data[unique_edges], axis=1)/2,
                                       center_vert_data[key]])

            new_vert_data[key] = new_data
    else:
        new_vert_data = dict()

    return verts_out, pols_out, vert_map, new_vert_data, new_face_data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.mesh" href="index.html">sverchok.utils.mesh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.mesh.subdivide.get_item" href="#sverchok.utils.mesh.subdivide.get_item">get_item</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.irregular_mid_centers" href="#sverchok.utils.mesh.subdivide.irregular_mid_centers">irregular_mid_centers</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.irregular_random_centers" href="#sverchok.utils.mesh.subdivide.irregular_random_centers">irregular_random_centers</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.normal_offset" href="#sverchok.utils.mesh.subdivide.normal_offset">normal_offset</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.np_pols" href="#sverchok.utils.mesh.subdivide.np_pols">np_pols</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.pols_to_edges" href="#sverchok.utils.mesh.subdivide.pols_to_edges">pols_to_edges</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.random" href="#sverchok.utils.mesh.subdivide.random">random</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.random_centers" href="#sverchok.utils.mesh.subdivide.random_centers">random_centers</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.random_pol_center" href="#sverchok.utils.mesh.subdivide.random_pol_center">random_pol_center</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.regular_mid_centers" href="#sverchok.utils.mesh.subdivide.regular_mid_centers">regular_mid_centers</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.regular_random_centers" href="#sverchok.utils.mesh.subdivide.regular_random_centers">regular_random_centers</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.smooth_verts" href="#sverchok.utils.mesh.subdivide.smooth_verts">smooth_verts</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.subdiv_mesh_to_quads_inner" href="#sverchok.utils.mesh.subdivide.subdiv_mesh_to_quads_inner">subdiv_mesh_to_quads_inner</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.subdiv_mesh_to_quads_np" href="#sverchok.utils.mesh.subdivide.subdiv_mesh_to_quads_np">subdiv_mesh_to_quads_np</a></code></li>
<li><code><a title="sverchok.utils.mesh.subdivide.subdivide" href="#sverchok.utils.mesh.subdivide.subdivide">subdivide</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>