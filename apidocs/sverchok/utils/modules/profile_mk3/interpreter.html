<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.modules.profile_mk3.interpreter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.modules.profile_mk3.interpreter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

import ast
from math import *
import numpy as np

from mathutils.geometry import interpolate_bezier
from mathutils import Vector, Matrix

from sverchok.utils.sv_logging import sv_logger
from sverchok.utils.geom import interpolate_quadratic_bezier
from sverchok.utils.sv_curve_utils import Arc
from sverchok.utils.nurbs_common import SvNurbsMaths
from sverchok.utils.curve import SvCircle, SvLine, SvBezierCurve, SvCubicBezierCurve
import sverchok.utils.curve.knotvector as sv_knotvector
from sverchok.utils.curve.nurbs_solver import SvNurbsCurveControlPoints
from sverchok.utils.curve.nurbs_solver_applications import prepare_solver_for_interpolation

def make_functions_dict(*functions):
    return dict([(function.__name__, function) for function in functions])

# Functions
safe_names = make_functions_dict(
        # From math module
        acos, acosh, asin, asinh, atan, atan2,
        atanh, ceil, copysign, cos, cosh, degrees,
        erf, erfc, exp, expm1, fabs, factorial, floor,
        fmod, frexp, fsum, gamma, hypot, isfinite, isinf,
        isnan, ldexp, lgamma, log, log10, log1p, log2, modf,
        pow, radians, sin, sinh, sqrt, tan, tanh, trunc,
        # Additional functions
        abs,
        # From mathutlis module
        Vector, Matrix,
        # Python type conversions
        tuple, list, str
    )
# Constants
safe_names[&#39;e&#39;] = e
safe_names[&#39;pi&#39;] = pi

##########################################
# Expression classes
##########################################

class Expression(object):
    def __init__(self, expr, string):
        self.expr = expr
        self.string = string

    def __repr__(self):
        return &#34;Expr({})&#34;.format(self.string)

    def __eq__(self, other):
        # Proper comparison of ast.Expression would be too complex to implement
        # (it is not implemented in the ast module).
        return isinstance(other, Expression) and self.string == other.string

    @classmethod
    def from_string(cls, string):
        try:
            string = string[1:][:-1]
            expr = ast.parse(string, mode=&#39;eval&#39;)
            return Expression(expr, string)
        except Exception as e:
            print(e)
            print(string)
            return None

    def eval_(self, variables):
        env = dict()
        env.update(safe_names)
        env.update(variables)
        env[&#34;__builtins__&#34;] = {}
        return eval(compile(self.expr, &#34;&lt;expression&gt;&#34;, &#39;eval&#39;), env)

    def get_variables(self):
        result = {node.id for node in ast.walk(self.expr) if isinstance(node, ast.Name)}
        return result.difference(safe_names.keys())

class Const(Expression):
    def __init__(self, value):
        self.value = value

    @classmethod
    def from_string(cls, string):
        try:
            return Const( float(string) )
        except ValueError:
            return None

    def __repr__(self):
        return &#34;Const({})&#34;.format(self.value)

    def __eq__(self, other):
        return isinstance(other,Const) and self.value == other.value

    def eval_(self, variables):
        return self.value

    def get_variables(self):
        return set()

class Variable(Expression):
    def __init__(self, name):
        self.name = name

    @classmethod
    def from_string(cls, string):
        return Variable(string)

    def __repr__(self):
        return &#34;Variable({})&#34;.format(self.name)

    def __eq__(self, other):
        return isinstance(other, Variable) and self.name == other.name

    def eval_(self, variables):
        value = variables.get(self.name, None)
        if value is not None:
            return value
        else:
            raise SyntaxError(&#34;Unknown variable: &#34; + self.name)

    def get_variables(self):
        return set([self.name])

# In general, this does not have very much sense:
# instead of -a one can write {-a}, then it will
# be parsed as Expression and will work fine.
# This is mostly implemented for compatibility
# with older Profile node syntax.
class NegatedVariable(Variable):
    @classmethod
    def from_string(cls, string):
        return NegatedVariable(string)

    def eval_(self, variables):
        value = variables.get(self.name, None)
        if value is not None:
            return -value
        else:
            raise SyntaxError(&#34;Unknown variable: &#34; + self.name)

    def __repr__(self):
        return &#34;NegatedVariable({})&#34;.format(self.name)

    def __eq__(self, other):
        return isinstance(other, NegatedVariable) and self.name == other.name

############################################
# Statement classes
# Classes for AST of our DSL
############################################

# These classes are responsible for interpretation of specific DSL statements.
# Each of these classes does the following:
# 
#  * Stores statement parameters (for example, MoveTo stores x and y).
#  * defines get_variables() method, which should return a set of all
#    variables used by all expressions in the statement.
#  * defines interpret() method, which should calculate all vertices and
#    edges according to statement parameters, and pass them to the interpreter.

class Statement(object):
    
    def get_variables(self):
        return set()

    def get_hidden_inputs(self):
        return set()

    def get_optional_inputs(self):
        return set()

    def _interpolate(self, v0, v1, num_segments):
        if num_segments is None or num_segments &lt;= 1:
            return [v0, v1]
        dx_total, dy_total = v1[0] - v0[0], v1[1] - v0[1]
        dx, dy = dx_total / float(num_segments), dy_total / float(num_segments)
        x, y = v0
        dt = 1.0 / float(num_segments)
        result = []
        t = 0
        for i in range(round(num_segments)):
            result.append((x,y))
            x = x + dx
            y = y + dy
        result.append(v1)
        return result

class MoveTo(Statement):
    def __init__(self, is_abs, x, y):
        self.is_abs = is_abs
        self.x = x
        self.y = y

    def __repr__(self):
        letter = &#34;M&#34; if self.is_abs else &#34;m&#34;
        return &#34;{} {} {}&#34;.format(letter, self.x, self.y)

    def __eq__(self, other):
        return isinstance(other, MoveTo) and \
                self.is_abs == other.is_abs and \
                self.x == other.x and \
                self.y == other.y

    def get_variables(self):
        variables = set()
        variables.update(self.x.get_variables())
        variables.update(self.y.get_variables())
        return variables

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        pos = interpreter.calc_vertex(self.is_abs, self.x, self.y, variables)
        interpreter.position = pos
        interpreter.new_knot(&#34;M.#&#34;, *pos)
        interpreter.has_last_vertex = False

class LineTo(Statement):
    def __init__(self, is_abs, pairs, num_segments, close):
        self.is_abs = is_abs
        self.pairs = pairs
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for x, y in self.pairs:
            variables.update(x.get_variables())
            variables.update(y.get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;L&#34; if self.is_abs else &#34;l&#34;
        return &#34;{} {} n={} {}&#34;.format(letter, self.pairs, self.num_segments, self.close)
    
    def __eq__(self, other):
        return isinstance(other, LineTo) and \
                self.is_abs == other.is_abs and \
                self.pairs == other.pairs and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        v0 = interpreter.position
        if interpreter.has_last_vertex:
            prev_index = interpreter.get_last_vertex()
        else:
            prev_index = interpreter.new_vertex(*v0)

        if self.num_segments is not None:
            num_segments = interpreter.eval_(self.num_segments, variables)
        else:
            num_segments = None

        for i, (x_expr, y_expr) in enumerate(self.pairs):
            v1 = interpreter.calc_vertex(self.is_abs, x_expr, y_expr, variables)
            interpreter.position = v1
            for vertex in self._interpolate(v0, v1, num_segments)[1:]:
                v_index = interpreter.new_vertex(*vertex)
                interpreter.new_edge(prev_index, v_index)
                prev_index = v_index
            interpreter.new_line_segment(v0, v1)
            v0 = v1
            interpreter.new_knot(&#34;L#.{}&#34;.format(i), *v1)

        if self.close:
            interpreter.close_segment(v_index)

        interpreter.has_last_vertex = True

class HorizontalLineTo(Statement):
    def __init__(self, is_abs, xs, num_segments):
        self.is_abs = is_abs
        self.xs = xs
        self.num_segments = num_segments

    def get_variables(self):
        variables = set()
        for x in self.xs:
            variables.update(x.get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;H&#34; if self.is_abs else &#34;h&#34;
        return &#34;{} {} n={};&#34;.format(letter, self.xs, self.num_segments)

    def __eq__(self, other):
        return isinstance(other, HorizontalLineTo) and \
                self.is_abs == other.is_abs and \
                self.num_segments == other.num_segments and \
                self.xs == other.xs

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        v0 = interpreter.position
        if interpreter.has_last_vertex:
            prev_index = interpreter.get_last_vertex()
        else:
            prev_index = interpreter.new_vertex(*v0)

        if self.num_segments is not None:
            num_segments = interpreter.eval_(self.num_segments, variables)
        else:
            num_segments = None

        for i, x_expr in enumerate(self.xs):
            x0,y0 = interpreter.position
            x = interpreter.eval_(x_expr, variables)
            if not self.is_abs:
                x = x0 + x
            v1 = (x, y0)
            interpreter.position = v1
            verts = self._interpolate(v0, v1, num_segments)
            # sv_logger.debug(&#34;V0 %s, v1 %s, N %s =&gt; %s&#34;, v0, v1, num_segments, verts)
            for vertex in verts[1:]:
                v_index = interpreter.new_vertex(*vertex)
                interpreter.new_edge(prev_index, v_index)
                prev_index = v_index
            interpreter.new_line_segment(v0, v1)
            v0 = v1
            interpreter.new_knot(&#34;H#.{}&#34;.format(i), *v1)

        interpreter.has_last_vertex = True

class VerticalLineTo(Statement):
    def __init__(self, is_abs, ys, num_segments):
        self.is_abs = is_abs
        self.ys = ys
        self.num_segments = num_segments

    def get_variables(self):
        variables = set()
        for y in self.ys:
            variables.update(y.get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;V&#34; if self.is_abs else &#34;v&#34;
        return &#34;{} {} n={};&#34;.format(letter, self.ys, self.num_segments)

    def __eq__(self, other):
        return isinstance(other, VerticalLineTo) and \
                self.is_abs == other.is_abs and \
                self.num_segments == other.num_segments and \
                self.ys == other.ys

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        v0 = interpreter.position
        if interpreter.has_last_vertex:
            prev_index = interpreter.get_last_vertex()
        else:
            prev_index = interpreter.new_vertex(*v0)

        if self.num_segments is not None:
            num_segments = interpreter.eval_(self.num_segments, variables)
        else:
            num_segments = None

        for i, y_expr in enumerate(self.ys):
            x0,y0 = interpreter.position
            y = interpreter.eval_(y_expr, variables)
            if not self.is_abs:
                y = y0 + y
            v1 = (x0, y)
            interpreter.position = v1
            for vertex in self._interpolate(v0, v1, num_segments)[1:]:
                v_index = interpreter.new_vertex(*vertex)
                interpreter.new_edge(prev_index, v_index)
                prev_index = v_index
            interpreter.new_line_segment(v0, v1)
            v0 = v1
            interpreter.new_knot(&#34;V#.{}&#34;.format(i), *v1)

        interpreter.has_last_vertex = True

class CurveTo(Statement):
    class Segment(object):
        def __init__(self, control1, control2, knot2):
            self.control1 = control1
            self.control2 = control2
            self.knot2 = knot2

        def __repr__(self):
            return &#34;{} {} {}&#34;.format(self.control1, self.control2, self.knot2)

        def __eq__(self, other):
            return self.control1 == other.control1 and \
                    self.control2 == other.control2 and \
                    self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.control1[0].get_variables())
            variables.update(segment.control1[1].get_variables())
            variables.update(segment.control2[0].get_variables())
            variables.update(segment.control2[1].get_variables())
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;C&#34; if self.is_abs else &#34;c&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, CurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            handle1 = interpreter.calc_vertex(self.is_abs, segment.control1[0], segment.control1[1], variables)

            # In Profile mk2, for &#34;c&#34; handle2 was calculated relative to handle1,
            # and knot2 was calculated relative to handle2.
            # But in SVG specification, 
            # &gt;&gt; ...  *At the end of the command*, the new current point becomes
            # &gt;&gt; the final (x,y) coordinate pair used in the polybézier.
            # This is also behaviour of browsers.

            #interpreter.position = handle1
            handle2 = interpreter.calc_vertex(self.is_abs, segment.control2[0], segment.control2[1], variables)
            #interpreter.position = handle2
            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            # Judging by the behaviour of Inkscape and Firefox, by &#34;end of command&#34;
            # SVG spec means &#34;end of segment&#34;.
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvCubicBezierCurve(vec(knot1), vec(handle1), vec(handle2), vec(knot2))
            interpreter.new_curve(curve, self)

            points = interpolate_bezier(vec(knot1), vec(handle1), vec(handle2), vec(knot2), r)

            interpreter.new_knot(&#34;C#.{}.h1&#34;.format(i), *handle1)
            interpreter.new_knot(&#34;C#.{}.h2&#34;.format(i), *handle2)
            interpreter.new_knot(&#34;C#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_bezier_knot = handle2

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True

class SmoothCurveTo(Statement):
    class Segment(object):
        def __init__(self, control2, knot2):
            self.control2 = control2
            self.knot2 = knot2

        def __repr__(self):
            return &#34;{} {}&#34;.format(self.control2, self.knot2)

        def __eq__(self, other):
            return self.control2 == other.control2 and \
                    self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.control2[0].get_variables())
            variables.update(segment.control2[1].get_variables())
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;S&#34; if self.is_abs else &#34;s&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, SmoothCurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            if interpreter.prev_bezier_knot is None:
                # If there is no previous command or if the previous command was
                # not an C, c, S or s, assume the first control point is coincident
                # with the current point.
                handle1 = knot1
            else:
                # The first control point is assumed to be the reflection of the
                # second control point on the previous command relative to the
                # current point. 
                prev_knot_x, prev_knot_y = interpreter.prev_bezier_knot
                x0, y0 = knot1
                dx, dy = x0 - prev_knot_x, y0 - prev_knot_y
                handle1 = x0 + dx, y0 + dy

            # I assume that handle2 should be relative to knot1, not to handle1.
            # interpreter.position = handle1
            handle2 = interpreter.calc_vertex(self.is_abs, segment.control2[0], segment.control2[1], variables)
            # interpreter.position = handle2
            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvCubicBezierCurve(vec(knot1), vec(handle1), vec(handle2), vec(knot2))
            interpreter.new_curve(curve, self)

            points = interpolate_bezier(vec(knot1), vec(handle1), vec(handle2), vec(knot2), r)

            interpreter.new_knot(&#34;S#.{}.h1&#34;.format(i), *handle1)
            interpreter.new_knot(&#34;S#.{}.h2&#34;.format(i), *handle2)
            interpreter.new_knot(&#34;S#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_bezier_knot = handle2

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True

class QuadraticCurveTo(Statement):
    class Segment(object):
        def __init__(self, control, knot2):
            self.control = control
            self.knot2 = knot2

        def __repr__(self):
            return &#34;{} {}&#34;.format(self.control, self.knot2)

        def __eq__(self, other):
            return self.control == other.control and \
                    self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.control[0].get_variables())
            variables.update(segment.control[1].get_variables())
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;Q&#34; if self.is_abs else &#34;q&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, QuadraticCurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            handle = interpreter.calc_vertex(self.is_abs, segment.control[0], segment.control[1], variables)
            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvBezierCurve([vec(knot1), vec(handle), vec(knot2)])
            interpreter.new_curve(curve, self)

            points = interpolate_quadratic_bezier(vec(knot1), vec(handle), vec(knot2), r)

            interpreter.new_knot(&#34;Q#.{}.h&#34;.format(i), *handle)
            interpreter.new_knot(&#34;Q#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_quad_bezier_knot = handle

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True

class SmoothQuadraticCurveTo(Statement):
    class Segment(object):
        def __init__(self, knot2):
            self.knot2 = knot2

        def __repr__(self):
            return str(self.knot2)

        def __eq__(self, other):
            return self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;T&#34; if self.is_abs else &#34;t&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, SmoothQuadraticCurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            if interpreter.prev_quad_bezier_knot is None:
                # If there is no previous command or if the previous command was
                # not a Q, q, T or t, assume the control point is coincident with
                # the current point.
                handle = knot1
            else:
                # The first control point is assumed to be the reflection of the
                # second control point on the previous command relative to the
                # current point. 
                prev_knot_x, prev_knot_y = interpreter.prev_quad_bezier_knot
                x0, y0 = knot1
                dx, dy = x0 - prev_knot_x, y0 - prev_knot_y
                handle = x0 + dx, y0 + dy

            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvBezierCurve([vec(knot1), vec(handle), vec(knot2)])
            interpreter.new_curve(curve, self)

            points = interpolate_quadratic_bezier(vec(knot1), vec(handle), vec(knot2), r)

            interpreter.new_knot(&#34;T#.{}.h&#34;.format(i), *handle)
            interpreter.new_knot(&#34;T#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_quad_bezier_knot = handle

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True

class ArcTo(Statement):
    def __init__(self, is_abs, radii, rot, flag1, flag2, end, num_verts, close):
        self.is_abs = is_abs
        self.radii = radii
        self.rot = rot
        self.flag1 = flag1
        self.flag2 = flag2
        self.end = end
        self.num_verts = num_verts
        self.close = close

    def get_variables(self):
        variables = set()
        variables.update(self.radii[0].get_variables())
        variables.update(self.radii[1].get_variables())
        variables.update(self.rot.get_variables())
        variables.update(self.flag1.get_variables())
        variables.update(self.flag2.get_variables())
        variables.update(self.end[0].get_variables())
        variables.update(self.end[1].get_variables())
        if self.num_verts:
            variables.update(self.num_verts.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;A&#34; if self.is_abs else &#34;a&#34;
        return &#34;{} {} {} {} {} {} n={} {}&#34;.format(letter, self.radii, self.rot, self.flag1, self.flag2, self.end, self.num_verts, self.close)

    def __eq__(self, other):
        return isinstance(other, ArcTo) and \
                self.is_abs == other.is_abs and \
                self.radii == other.radii and \
                self.rot == other.rot and \
                self.flag1 == other.flag1 and \
                self.flag2 == other.flag2 and \
                self.end == other.end and \
                self.num_verts == other.num_verts and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        start = complex(*v0)
        rad_x_expr, rad_y_expr = self.radii
        rad_x = interpreter.eval_(rad_x_expr, variables)
        rad_y = interpreter.eval_(rad_y_expr, variables)
        radius = complex(rad_x, rad_y)
        xaxis_rot = interpreter.eval_(self.rot, variables)
        flag1 = interpreter.eval_(self.flag1, variables)
        flag2 = interpreter.eval_(self.flag2, variables)

        # numverts, requires -1 else it means segments (21 verts is 20 segments).
        if self.num_verts is not None:
            num_verts = interpreter.eval_(self.num_verts, variables)
        else:
            num_verts = interpreter.dflt_num_verts
        num_verts -= 1

        end = interpreter.calc_vertex(self.is_abs, self.end[0], self.end[1], variables)
        end = complex(*end)

        arc = Arc(start, radius, xaxis_rot, flag1, flag2, end)

        theta = 1/num_verts
        for i in range(1, num_verts+1):
            v1 = x, y = arc.point(theta * i)
            v1_index = interpreter.new_vertex(x, y)
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

        curve = SvCircle.from_arc(arc, z_axis=interpreter.z_axis)
        interpreter.new_curve(curve, self)

        interpreter.position = v1
        interpreter.new_knot(&#34;A.#&#34;, *v1)
        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True

class InterpolatedCurveTo(Statement):
    def __init__(self, is_abs, degree, points, num_segments, metric, is_smooth, close):
        self.is_abs = is_abs
        self.degree = degree
        self.points = points
        self.metric = metric
        self.num_segments = num_segments
        self.is_smooth = is_smooth
        self.close = close

    def get_variables(self):
        variables = set()
        variables.update(self.degree.get_variables())
        for point in self.points:
            variables.update(point[0].get_variables())
            variables.update(point[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;I&#34; if self.is_abs else &#34;i&#34;
        points = &#34; &#34;.join(str(point) for point in self.points)
        return f&#34;{letter} {self.degree} {points} n={self.num_segments} {self.close}&#34;

    def __eq__(self, other):
        return isinstance(other, InterpolatedCurveTo) and \
                self.is_abs == other.is_abs and \
                self.points == other.points and \
                self.degree == other.degree and \
                self.metric == other.metric and \
                self.num_segments == other.num_segments and \
                self.is_smooth == other.is_smooth and \
                self.close == other.close

    def _make_curve(self, interpreter, degree, points):
        points = np.array(points)
        prev_control_point = None
        if degree == 2 and interpreter.prev_quad_bezier_knot is not None:
            prev_control_point = interpreter.to3d_np(interpreter.prev_quad_bezier_knot)
        elif degree == 3 and interpreter.prev_bezier_knot is not None:
            prev_control_point = interpreter.to3d_np(interpreter.prev_bezier_knot)
        if self.is_smooth and prev_control_point is not None:
            solver = prepare_solver_for_interpolation(degree,
                                points,
                                metric = self.metric,
                                cyclic = self.close)
            pos = interpreter.to3d_np(interpreter.position)
            new_control_point = pos + (pos - prev_control_point)
            print(f&#34;Prev CP: {prev_control_point}, pos: {pos}, new CP: {new_control_point}&#34;)
            solver.add_goal(SvNurbsCurveControlPoints.single(1, new_control_point, relative=False))
            knotvector = solver.get_knotvector()
            n_cpts = solver.guess_n_control_points()
            knotvector = sv_knotvector.add_one_by_resampling(knotvector, index=1, degree=degree)
            solver.set_curve_params(n_cpts, knotvector)
            curve = solver.solve_welldetermined()
        else:
            curve = SvNurbsMaths.interpolate_curve(SvNurbsMaths.NATIVE, degree,
                                points,
                                metric = self.metric,
                                cyclic = self.close)
        return curve

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        interpolated_points = [[v0[0], v0[1], 0.0]]
        for i, pt in enumerate(self.points):
            knot = interpreter.calc_vertex(self.is_abs, pt[0], pt[1], variables)
            interpreter.new_knot(f&#34;I#.{i}&#34;, knot[0], knot[1])
            interpolated_points.append([knot[0], knot[1], 0.0])

        degree = interpreter.eval_(self.degree, variables)
        curve = self._make_curve(interpreter, degree, interpolated_points)
        interpreter.new_curve(curve, self)
        interpreter.position = knot

        cpts = curve.get_control_points()
        if degree == 2:
            interpreter.prev_quad_bezier_knot = (cpts[-2][0], cpts[-2][1])
        elif degree == 3:
            interpreter.prev_bezier_knot = (cpts[-2][0], cpts[-2][1])

        if self.num_segments is not None:
            r = interpreter.eval_(self.num_segments, variables)
        else:
            r = interpreter.dflt_num_verts

        t_min, t_max = curve.get_u_bounds()
        ts = np.linspace(t_min, t_max, num = r)
        points = curve.evaluate_array(ts)

        for point in points[1:]:
            v1_index = interpreter.new_vertex(point[0], point[1])
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True

class CloseAll(Statement):
    def __init__(self):
        pass

    def __repr__(self):
        return &#34;X&#34;

    def __eq__(self, other):
        return isinstance(other, CloseAll)

    def get_variables(self):
        return set()

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        if not interpreter.has_last_vertex:
            sv_logger.info(&#34;X statement: no current point, do nothing&#34;)
            return

        v0 = interpreter.vertices[0]
        v1 = interpreter.vertices[-1]

        distance = (Vector(v0) - Vector(v1)).length

        if distance &lt; interpreter.close_threshold:
            interpreter.pop_last_vertex()

        v1_index = interpreter.get_last_vertex()
        interpreter.new_edge(v1_index, 0)

        interpreter.new_line_segment(v1, v0)

        interpreter.closed = True

class ClosePath(Statement):
    def __init__(self):
        pass

    def __repr__(self):
        return &#34;x&#34;

    def __eq__(self, other):
        return isinstance(other, ClosePath)

    def get_variables(self):
        return set()

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        if not interpreter.has_last_vertex:
            sv_logger.info(&#34;X statement: no current point, do nothing&#34;)
            return

        v0 = interpreter.vertices[interpreter.close_first_index]
        v1 = interpreter.vertices[-1]

        distance = (Vector(v0) - Vector(v1)).length

        if distance &lt; interpreter.close_threshold:
            interpreter.pop_last_vertex()

        v1_index = interpreter.get_last_vertex()
        interpreter.new_edge(v1_index, interpreter.close_first_index)
        interpreter.new_line_segment(v1_index, interpreter.close_first_index)
        interpreter.close_first_index = interpreter.next_vertex_index

class Default(Statement):
    def __init__(self, name, value):
        self.name = name
        self.value = value

    def __repr__(self):
        return &#34;default {} = {}&#34;.format(self.name, self.value)

    def __eq__(self, other):
        return isinstance(other, Default) and \
                self.name == other.name and \
                self.value == other.value

    def get_variables(self):
        return self.value.get_variables()

    def get_optional_inputs(self):
        return set([self.name])

    def interpret(self, interpreter, variables):
        if self.name in interpreter.defaults:
            raise Exception(&#34;Value for the `{}&#39; variable has been already assigned!&#34;.format(self.name))
        if self.name not in interpreter.input_names:
            value = interpreter.eval_(self.value, variables)
            interpreter.defaults[self.name] = value

class Assign(Default):
    def __repr__(self):
        return &#34;let {} = {}&#34;.format(self.name, self.value)

    def __eq__(self, other):
        return isinstance(other, Assign) and \
                self.name == other.name and \
                self.value == other.value

    def get_hidden_inputs(self):
        return set([self.name])

#################################
# DSL Interpreter
#################################

# This class does the following:
#
# * Stores the &#34;drawing&#34; state, such as &#34;current pen position&#34;
# * Provides API for Statement classes to add vertices, edges to the current
#   drawing
# * Contains the interpret() method, which runs the whole interpretation process.

class Interpreter(object):

    NURBS = &#39;NURBS&#39;
    BEZIER = &#39;BEZIER&#39;

    def __init__(self, node, input_names, curves_form = None, force_curves_form = False, z_axis=&#39;Z&#39;):
        self.position = (0, 0)
        self.next_vertex_index = 0
        self.segment_start_index = 0
        self.segment_continues_line = False
        self.segment_number = 0
        self.has_last_vertex = False
        self.closed = False
        self.close_first_index = 0
        self.prev_bezier_knot = None
        self.prev_quad_bezier_knot = None
        self.curves = []
        self.vertices = []
        self.edges = []
        self.knots = []
        self.knotnames = []
        self.dflt_num_verts = node.curve_points_count
        self.close_threshold = node.close_threshold
        self.defaults = dict()
        self.input_names = input_names
        self.curves_form = curves_form
        self.force_curves_form = force_curves_form
        self.z_axis = z_axis

    def to3d(self, vertex):
        if self.z_axis == &#39;X&#39;:
            return Vector((0, vertex[0], vertex[1]))
        elif self.z_axis == &#39;Y&#39;:
            return Vector((vertex[0], 0, vertex[1]))
        else: # self.z_axis == &#39;Z&#39;:
            return Vector((vertex[0], vertex[1], 0))

    def to3d_np(self, vertex):
        if self.z_axis == &#39;X&#39;:
            return np.array((0, vertex[0], vertex[1]))
        elif self.z_axis == &#39;Y&#39;:
            return np.array((vertex[0], 0, vertex[1]))
        else: # self.z_axis == &#39;Z&#39;:
            return np.array((vertex[0], vertex[1], 0))

    def assert_not_closed(self):
        if self.closed:
            raise Exception(&#34;Path was already closed, will not process any further directives!&#34;)

    def relative(self, x, y):
        x0, y0 = self.position
        return x0+x, y0+y

    def calc_vertex(self, is_abs, x_expr, y_expr, variables):
        x = self.eval_(x_expr, variables)
        y = self.eval_(y_expr, variables)
        if is_abs:
            return x,y
        else:
            return self.relative(x,y)

    def new_vertex(self, x, y):
        index = self.next_vertex_index
        vertex = (x, y)
        self.vertices.append(vertex)
        self.next_vertex_index += 1
        return index

    def new_edge(self, v1, v2):
        self.edges.append((v1, v2))

    def new_knot(self, name, x, y):
        self.knots.append((x, y))
        name = name.replace(&#34;#&#34;, str(self.segment_number))
        self.knotnames.append(name)

    def new_curve(self, curve, statement):
        if self.curves_form == Interpreter.NURBS:
            if hasattr(curve, &#39;to_nurbs&#39;):
                curve = curve.to_nurbs()
            else:
                if self.force_curves_form:
                    raise Exception(f&#34;Cannot convert curve to NURBS: {statement}&#34;)
        elif self.curves_form == Interpreter.BEZIER:
            if not isinstance(curve, (SvBezierCurve, SvCubicBezierCurve)):
                if hasattr(curve, &#39;to_bezier&#39;):
                    curve = curve.to_bezier()
                else:
                    if self.force_curves_form:
                        raise Exception(&#34;Cannot convert curve to Bezier: {statement}&#34;)
        self.curves.append(curve)

    def new_line_segment(self, v1, v2):
        if isinstance(v1, int):
            v1, v2 = self.vertices[v1], self.vertices[v2]
        v1, v2 = self.to3d(v1), self.to3d(v2)
        if (v1 - v2).length &lt; self.close_threshold:
            return
        curve = SvLine.from_two_points(v1, v2)
        self.new_curve(curve, None)

    def start_new_segment(self):
        self.segment_start_index = self.next_vertex_index
        self.segment_continues_line = self.has_last_vertex
        self.segment_number += 1

    def close_segment(self, v_index):
        if self.segment_continues_line:
            start_index = self.segment_start_index-1
        else:
            start_index = self.segment_start_index
        self.new_edge(v_index, start_index)

    def get_last_vertex(self):
        return self.next_vertex_index - 1

    def pop_last_vertex(self):
        self.vertices.pop()
        self.next_vertex_index -= 1
        is_not_last = lambda e: e[0] != self.next_vertex_index and e[1] != self.next_vertex_index
        self.edges = list(filter(is_not_last, self.edges))

    def eval_(self, expr, variables):
        variables_ = self.defaults.copy()
        for name in variables:
            value = variables[name]
            if value is not None:
                variables_[name] = value
        return expr.eval_(variables_)

    def interpret(self, profile, variables):
        if not profile:
            return
        for statement in profile:
            sv_logger.debug(&#34;Interpret: %s&#34;, statement)
            statement.interpret(self, variables)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.make_functions_dict"><code class="name flex">
<span>def <span class="ident">make_functions_dict</span></span>(<span>*functions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_functions_dict(*functions):
    return dict([(function.__name__, function) for function in functions])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.ArcTo"><code class="flex name class">
<span>class <span class="ident">ArcTo</span></span>
<span>(</span><span>is_abs, radii, rot, flag1, flag2, end, num_verts, close)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArcTo(Statement):
    def __init__(self, is_abs, radii, rot, flag1, flag2, end, num_verts, close):
        self.is_abs = is_abs
        self.radii = radii
        self.rot = rot
        self.flag1 = flag1
        self.flag2 = flag2
        self.end = end
        self.num_verts = num_verts
        self.close = close

    def get_variables(self):
        variables = set()
        variables.update(self.radii[0].get_variables())
        variables.update(self.radii[1].get_variables())
        variables.update(self.rot.get_variables())
        variables.update(self.flag1.get_variables())
        variables.update(self.flag2.get_variables())
        variables.update(self.end[0].get_variables())
        variables.update(self.end[1].get_variables())
        if self.num_verts:
            variables.update(self.num_verts.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;A&#34; if self.is_abs else &#34;a&#34;
        return &#34;{} {} {} {} {} {} n={} {}&#34;.format(letter, self.radii, self.rot, self.flag1, self.flag2, self.end, self.num_verts, self.close)

    def __eq__(self, other):
        return isinstance(other, ArcTo) and \
                self.is_abs == other.is_abs and \
                self.radii == other.radii and \
                self.rot == other.rot and \
                self.flag1 == other.flag1 and \
                self.flag2 == other.flag2 and \
                self.end == other.end and \
                self.num_verts == other.num_verts and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        start = complex(*v0)
        rad_x_expr, rad_y_expr = self.radii
        rad_x = interpreter.eval_(rad_x_expr, variables)
        rad_y = interpreter.eval_(rad_y_expr, variables)
        radius = complex(rad_x, rad_y)
        xaxis_rot = interpreter.eval_(self.rot, variables)
        flag1 = interpreter.eval_(self.flag1, variables)
        flag2 = interpreter.eval_(self.flag2, variables)

        # numverts, requires -1 else it means segments (21 verts is 20 segments).
        if self.num_verts is not None:
            num_verts = interpreter.eval_(self.num_verts, variables)
        else:
            num_verts = interpreter.dflt_num_verts
        num_verts -= 1

        end = interpreter.calc_vertex(self.is_abs, self.end[0], self.end[1], variables)
        end = complex(*end)

        arc = Arc(start, radius, xaxis_rot, flag1, flag2, end)

        theta = 1/num_verts
        for i in range(1, num_verts+1):
            v1 = x, y = arc.point(theta * i)
            v1_index = interpreter.new_vertex(x, y)
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

        curve = SvCircle.from_arc(arc, z_axis=interpreter.z_axis)
        interpreter.new_curve(curve, self)

        interpreter.position = v1
        interpreter.new_knot(&#34;A.#&#34;, *v1)
        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.ArcTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    variables.update(self.radii[0].get_variables())
    variables.update(self.radii[1].get_variables())
    variables.update(self.rot.get_variables())
    variables.update(self.flag1.get_variables())
    variables.update(self.flag2.get_variables())
    variables.update(self.end[0].get_variables())
    variables.update(self.end[1].get_variables())
    if self.num_verts:
        variables.update(self.num_verts.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.ArcTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    interpreter.start_new_segment()

    v0 = interpreter.position
    if interpreter.has_last_vertex:
        v0_index = interpreter.get_last_vertex()
    else:
        v0_index = interpreter.new_vertex(*v0)

    start = complex(*v0)
    rad_x_expr, rad_y_expr = self.radii
    rad_x = interpreter.eval_(rad_x_expr, variables)
    rad_y = interpreter.eval_(rad_y_expr, variables)
    radius = complex(rad_x, rad_y)
    xaxis_rot = interpreter.eval_(self.rot, variables)
    flag1 = interpreter.eval_(self.flag1, variables)
    flag2 = interpreter.eval_(self.flag2, variables)

    # numverts, requires -1 else it means segments (21 verts is 20 segments).
    if self.num_verts is not None:
        num_verts = interpreter.eval_(self.num_verts, variables)
    else:
        num_verts = interpreter.dflt_num_verts
    num_verts -= 1

    end = interpreter.calc_vertex(self.is_abs, self.end[0], self.end[1], variables)
    end = complex(*end)

    arc = Arc(start, radius, xaxis_rot, flag1, flag2, end)

    theta = 1/num_verts
    for i in range(1, num_verts+1):
        v1 = x, y = arc.point(theta * i)
        v1_index = interpreter.new_vertex(x, y)
        interpreter.new_edge(v0_index, v1_index)
        v0_index = v1_index

    curve = SvCircle.from_arc(arc, z_axis=interpreter.z_axis)
    interpreter.new_curve(curve, self)

    interpreter.position = v1
    interpreter.new_knot(&#34;A.#&#34;, *v1)
    if self.close:
        interpreter.close_segment(v1_index)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Assign"><code class="flex name class">
<span>class <span class="ident">Assign</span></span>
<span>(</span><span>name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Assign(Default):
    def __repr__(self):
        return &#34;let {} = {}&#34;.format(self.name, self.value)

    def __eq__(self, other):
        return isinstance(other, Assign) and \
                self.name == other.name and \
                self.value == other.value

    def get_hidden_inputs(self):
        return set([self.name])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Default" href="#sverchok.utils.modules.profile_mk3.interpreter.Default">Default</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Assign.get_hidden_inputs"><code class="name flex">
<span>def <span class="ident">get_hidden_inputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hidden_inputs(self):
    return set([self.name])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.CloseAll"><code class="flex name class">
<span>class <span class="ident">CloseAll</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CloseAll(Statement):
    def __init__(self):
        pass

    def __repr__(self):
        return &#34;X&#34;

    def __eq__(self, other):
        return isinstance(other, CloseAll)

    def get_variables(self):
        return set()

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        if not interpreter.has_last_vertex:
            sv_logger.info(&#34;X statement: no current point, do nothing&#34;)
            return

        v0 = interpreter.vertices[0]
        v1 = interpreter.vertices[-1]

        distance = (Vector(v0) - Vector(v1)).length

        if distance &lt; interpreter.close_threshold:
            interpreter.pop_last_vertex()

        v1_index = interpreter.get_last_vertex()
        interpreter.new_edge(v1_index, 0)

        interpreter.new_line_segment(v1, v0)

        interpreter.closed = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.CloseAll.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    return set()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.CloseAll.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    if not interpreter.has_last_vertex:
        sv_logger.info(&#34;X statement: no current point, do nothing&#34;)
        return

    v0 = interpreter.vertices[0]
    v1 = interpreter.vertices[-1]

    distance = (Vector(v0) - Vector(v1)).length

    if distance &lt; interpreter.close_threshold:
        interpreter.pop_last_vertex()

    v1_index = interpreter.get_last_vertex()
    interpreter.new_edge(v1_index, 0)

    interpreter.new_line_segment(v1, v0)

    interpreter.closed = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.ClosePath"><code class="flex name class">
<span>class <span class="ident">ClosePath</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClosePath(Statement):
    def __init__(self):
        pass

    def __repr__(self):
        return &#34;x&#34;

    def __eq__(self, other):
        return isinstance(other, ClosePath)

    def get_variables(self):
        return set()

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        if not interpreter.has_last_vertex:
            sv_logger.info(&#34;X statement: no current point, do nothing&#34;)
            return

        v0 = interpreter.vertices[interpreter.close_first_index]
        v1 = interpreter.vertices[-1]

        distance = (Vector(v0) - Vector(v1)).length

        if distance &lt; interpreter.close_threshold:
            interpreter.pop_last_vertex()

        v1_index = interpreter.get_last_vertex()
        interpreter.new_edge(v1_index, interpreter.close_first_index)
        interpreter.new_line_segment(v1_index, interpreter.close_first_index)
        interpreter.close_first_index = interpreter.next_vertex_index</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.ClosePath.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    return set()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.ClosePath.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    if not interpreter.has_last_vertex:
        sv_logger.info(&#34;X statement: no current point, do nothing&#34;)
        return

    v0 = interpreter.vertices[interpreter.close_first_index]
    v1 = interpreter.vertices[-1]

    distance = (Vector(v0) - Vector(v1)).length

    if distance &lt; interpreter.close_threshold:
        interpreter.pop_last_vertex()

    v1_index = interpreter.get_last_vertex()
    interpreter.new_edge(v1_index, interpreter.close_first_index)
    interpreter.new_line_segment(v1_index, interpreter.close_first_index)
    interpreter.close_first_index = interpreter.next_vertex_index</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Const"><code class="flex name class">
<span>class <span class="ident">Const</span></span>
<span>(</span><span>value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Const(Expression):
    def __init__(self, value):
        self.value = value

    @classmethod
    def from_string(cls, string):
        try:
            return Const( float(string) )
        except ValueError:
            return None

    def __repr__(self):
        return &#34;Const({})&#34;.format(self.value)

    def __eq__(self, other):
        return isinstance(other,Const) and self.value == other.value

    def eval_(self, variables):
        return self.value

    def get_variables(self):
        return set()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Expression" href="#sverchok.utils.modules.profile_mk3.interpreter.Expression">Expression</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Const.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, string):
    try:
        return Const( float(string) )
    except ValueError:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Const.eval_"><code class="name flex">
<span>def <span class="ident">eval_</span></span>(<span>self, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_(self, variables):
    return self.value</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Const.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    return set()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.CurveTo"><code class="flex name class">
<span>class <span class="ident">CurveTo</span></span>
<span>(</span><span>is_abs, segments, num_segments, close)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurveTo(Statement):
    class Segment(object):
        def __init__(self, control1, control2, knot2):
            self.control1 = control1
            self.control2 = control2
            self.knot2 = knot2

        def __repr__(self):
            return &#34;{} {} {}&#34;.format(self.control1, self.control2, self.knot2)

        def __eq__(self, other):
            return self.control1 == other.control1 and \
                    self.control2 == other.control2 and \
                    self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.control1[0].get_variables())
            variables.update(segment.control1[1].get_variables())
            variables.update(segment.control2[0].get_variables())
            variables.update(segment.control2[1].get_variables())
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;C&#34; if self.is_abs else &#34;c&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, CurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            handle1 = interpreter.calc_vertex(self.is_abs, segment.control1[0], segment.control1[1], variables)

            # In Profile mk2, for &#34;c&#34; handle2 was calculated relative to handle1,
            # and knot2 was calculated relative to handle2.
            # But in SVG specification, 
            # &gt;&gt; ...  *At the end of the command*, the new current point becomes
            # &gt;&gt; the final (x,y) coordinate pair used in the polybézier.
            # This is also behaviour of browsers.

            #interpreter.position = handle1
            handle2 = interpreter.calc_vertex(self.is_abs, segment.control2[0], segment.control2[1], variables)
            #interpreter.position = handle2
            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            # Judging by the behaviour of Inkscape and Firefox, by &#34;end of command&#34;
            # SVG spec means &#34;end of segment&#34;.
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvCubicBezierCurve(vec(knot1), vec(handle1), vec(handle2), vec(knot2))
            interpreter.new_curve(curve, self)

            points = interpolate_bezier(vec(knot1), vec(handle1), vec(handle2), vec(knot2), r)

            interpreter.new_knot(&#34;C#.{}.h1&#34;.format(i), *handle1)
            interpreter.new_knot(&#34;C#.{}.h2&#34;.format(i), *handle2)
            interpreter.new_knot(&#34;C#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_bezier_knot = handle2

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.CurveTo.Segment"><code class="name">var <span class="ident">Segment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.CurveTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    for segment in self.segments:
        variables.update(segment.control1[0].get_variables())
        variables.update(segment.control1[1].get_variables())
        variables.update(segment.control2[0].get_variables())
        variables.update(segment.control2[1].get_variables())
        variables.update(segment.knot2[0].get_variables())
        variables.update(segment.knot2[1].get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.CurveTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    vec = lambda v: Vector((v[0], v[1], 0))

    interpreter.assert_not_closed()
    interpreter.start_new_segment()

    v0 = interpreter.position
    if interpreter.has_last_vertex:
        v0_index = interpreter.get_last_vertex()
    else:
        v0_index = interpreter.new_vertex(*v0)

    knot1 = None
    for i, segment in enumerate(self.segments):
        # For first segment, knot1 is initial pen position;
        # for the following, knot1 is knot2 of previous segment.
        if knot1 is None:
            knot1 = interpreter.position
        else:
            knot1 = knot2

        handle1 = interpreter.calc_vertex(self.is_abs, segment.control1[0], segment.control1[1], variables)

        # In Profile mk2, for &#34;c&#34; handle2 was calculated relative to handle1,
        # and knot2 was calculated relative to handle2.
        # But in SVG specification, 
        # &gt;&gt; ...  *At the end of the command*, the new current point becomes
        # &gt;&gt; the final (x,y) coordinate pair used in the polybézier.
        # This is also behaviour of browsers.

        #interpreter.position = handle1
        handle2 = interpreter.calc_vertex(self.is_abs, segment.control2[0], segment.control2[1], variables)
        #interpreter.position = handle2
        knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
        # Judging by the behaviour of Inkscape and Firefox, by &#34;end of command&#34;
        # SVG spec means &#34;end of segment&#34;.
        interpreter.position = knot2

        if self.num_segments is not None:
            r = interpreter.eval_(self.num_segments, variables)
        else:
            r = interpreter.dflt_num_verts

        curve = SvCubicBezierCurve(vec(knot1), vec(handle1), vec(handle2), vec(knot2))
        interpreter.new_curve(curve, self)

        points = interpolate_bezier(vec(knot1), vec(handle1), vec(handle2), vec(knot2), r)

        interpreter.new_knot(&#34;C#.{}.h1&#34;.format(i), *handle1)
        interpreter.new_knot(&#34;C#.{}.h2&#34;.format(i), *handle2)
        interpreter.new_knot(&#34;C#.{}.k&#34;.format(i), *knot2)

        interpreter.prev_bezier_knot = handle2

        for point in points[1:]:
            v1_index = interpreter.new_vertex(point.x, point.y)
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

    if self.close:
        interpreter.close_segment(v1_index)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Default"><code class="flex name class">
<span>class <span class="ident">Default</span></span>
<span>(</span><span>name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Default(Statement):
    def __init__(self, name, value):
        self.name = name
        self.value = value

    def __repr__(self):
        return &#34;default {} = {}&#34;.format(self.name, self.value)

    def __eq__(self, other):
        return isinstance(other, Default) and \
                self.name == other.name and \
                self.value == other.value

    def get_variables(self):
        return self.value.get_variables()

    def get_optional_inputs(self):
        return set([self.name])

    def interpret(self, interpreter, variables):
        if self.name in interpreter.defaults:
            raise Exception(&#34;Value for the `{}&#39; variable has been already assigned!&#34;.format(self.name))
        if self.name not in interpreter.input_names:
            value = interpreter.eval_(self.value, variables)
            interpreter.defaults[self.name] = value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Assign" href="#sverchok.utils.modules.profile_mk3.interpreter.Assign">Assign</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Default.get_optional_inputs"><code class="name flex">
<span>def <span class="ident">get_optional_inputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_optional_inputs(self):
    return set([self.name])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Default.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    return self.value.get_variables()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Default.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    if self.name in interpreter.defaults:
        raise Exception(&#34;Value for the `{}&#39; variable has been already assigned!&#34;.format(self.name))
    if self.name not in interpreter.input_names:
        value = interpreter.eval_(self.value, variables)
        interpreter.defaults[self.name] = value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Expression"><code class="flex name class">
<span>class <span class="ident">Expression</span></span>
<span>(</span><span>expr, string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Expression(object):
    def __init__(self, expr, string):
        self.expr = expr
        self.string = string

    def __repr__(self):
        return &#34;Expr({})&#34;.format(self.string)

    def __eq__(self, other):
        # Proper comparison of ast.Expression would be too complex to implement
        # (it is not implemented in the ast module).
        return isinstance(other, Expression) and self.string == other.string

    @classmethod
    def from_string(cls, string):
        try:
            string = string[1:][:-1]
            expr = ast.parse(string, mode=&#39;eval&#39;)
            return Expression(expr, string)
        except Exception as e:
            print(e)
            print(string)
            return None

    def eval_(self, variables):
        env = dict()
        env.update(safe_names)
        env.update(variables)
        env[&#34;__builtins__&#34;] = {}
        return eval(compile(self.expr, &#34;&lt;expression&gt;&#34;, &#39;eval&#39;), env)

    def get_variables(self):
        result = {node.id for node in ast.walk(self.expr) if isinstance(node, ast.Name)}
        return result.difference(safe_names.keys())</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Const" href="#sverchok.utils.modules.profile_mk3.interpreter.Const">Const</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Variable" href="#sverchok.utils.modules.profile_mk3.interpreter.Variable">Variable</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Expression.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, string):
    try:
        string = string[1:][:-1]
        expr = ast.parse(string, mode=&#39;eval&#39;)
        return Expression(expr, string)
    except Exception as e:
        print(e)
        print(string)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Expression.eval_"><code class="name flex">
<span>def <span class="ident">eval_</span></span>(<span>self, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_(self, variables):
    env = dict()
    env.update(safe_names)
    env.update(variables)
    env[&#34;__builtins__&#34;] = {}
    return eval(compile(self.expr, &#34;&lt;expression&gt;&#34;, &#39;eval&#39;), env)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Expression.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    result = {node.id for node in ast.walk(self.expr) if isinstance(node, ast.Name)}
    return result.difference(safe_names.keys())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo"><code class="flex name class">
<span>class <span class="ident">HorizontalLineTo</span></span>
<span>(</span><span>is_abs, xs, num_segments)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HorizontalLineTo(Statement):
    def __init__(self, is_abs, xs, num_segments):
        self.is_abs = is_abs
        self.xs = xs
        self.num_segments = num_segments

    def get_variables(self):
        variables = set()
        for x in self.xs:
            variables.update(x.get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;H&#34; if self.is_abs else &#34;h&#34;
        return &#34;{} {} n={};&#34;.format(letter, self.xs, self.num_segments)

    def __eq__(self, other):
        return isinstance(other, HorizontalLineTo) and \
                self.is_abs == other.is_abs and \
                self.num_segments == other.num_segments and \
                self.xs == other.xs

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        v0 = interpreter.position
        if interpreter.has_last_vertex:
            prev_index = interpreter.get_last_vertex()
        else:
            prev_index = interpreter.new_vertex(*v0)

        if self.num_segments is not None:
            num_segments = interpreter.eval_(self.num_segments, variables)
        else:
            num_segments = None

        for i, x_expr in enumerate(self.xs):
            x0,y0 = interpreter.position
            x = interpreter.eval_(x_expr, variables)
            if not self.is_abs:
                x = x0 + x
            v1 = (x, y0)
            interpreter.position = v1
            verts = self._interpolate(v0, v1, num_segments)
            # sv_logger.debug(&#34;V0 %s, v1 %s, N %s =&gt; %s&#34;, v0, v1, num_segments, verts)
            for vertex in verts[1:]:
                v_index = interpreter.new_vertex(*vertex)
                interpreter.new_edge(prev_index, v_index)
                prev_index = v_index
            interpreter.new_line_segment(v0, v1)
            v0 = v1
            interpreter.new_knot(&#34;H#.{}&#34;.format(i), *v1)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    for x in self.xs:
        variables.update(x.get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    interpreter.start_new_segment()
    v0 = interpreter.position
    if interpreter.has_last_vertex:
        prev_index = interpreter.get_last_vertex()
    else:
        prev_index = interpreter.new_vertex(*v0)

    if self.num_segments is not None:
        num_segments = interpreter.eval_(self.num_segments, variables)
    else:
        num_segments = None

    for i, x_expr in enumerate(self.xs):
        x0,y0 = interpreter.position
        x = interpreter.eval_(x_expr, variables)
        if not self.is_abs:
            x = x0 + x
        v1 = (x, y0)
        interpreter.position = v1
        verts = self._interpolate(v0, v1, num_segments)
        # sv_logger.debug(&#34;V0 %s, v1 %s, N %s =&gt; %s&#34;, v0, v1, num_segments, verts)
        for vertex in verts[1:]:
            v_index = interpreter.new_vertex(*vertex)
            interpreter.new_edge(prev_index, v_index)
            prev_index = v_index
        interpreter.new_line_segment(v0, v1)
        v0 = v1
        interpreter.new_knot(&#34;H#.{}&#34;.format(i), *v1)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo"><code class="flex name class">
<span>class <span class="ident">InterpolatedCurveTo</span></span>
<span>(</span><span>is_abs, degree, points, num_segments, metric, is_smooth, close)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InterpolatedCurveTo(Statement):
    def __init__(self, is_abs, degree, points, num_segments, metric, is_smooth, close):
        self.is_abs = is_abs
        self.degree = degree
        self.points = points
        self.metric = metric
        self.num_segments = num_segments
        self.is_smooth = is_smooth
        self.close = close

    def get_variables(self):
        variables = set()
        variables.update(self.degree.get_variables())
        for point in self.points:
            variables.update(point[0].get_variables())
            variables.update(point[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;I&#34; if self.is_abs else &#34;i&#34;
        points = &#34; &#34;.join(str(point) for point in self.points)
        return f&#34;{letter} {self.degree} {points} n={self.num_segments} {self.close}&#34;

    def __eq__(self, other):
        return isinstance(other, InterpolatedCurveTo) and \
                self.is_abs == other.is_abs and \
                self.points == other.points and \
                self.degree == other.degree and \
                self.metric == other.metric and \
                self.num_segments == other.num_segments and \
                self.is_smooth == other.is_smooth and \
                self.close == other.close

    def _make_curve(self, interpreter, degree, points):
        points = np.array(points)
        prev_control_point = None
        if degree == 2 and interpreter.prev_quad_bezier_knot is not None:
            prev_control_point = interpreter.to3d_np(interpreter.prev_quad_bezier_knot)
        elif degree == 3 and interpreter.prev_bezier_knot is not None:
            prev_control_point = interpreter.to3d_np(interpreter.prev_bezier_knot)
        if self.is_smooth and prev_control_point is not None:
            solver = prepare_solver_for_interpolation(degree,
                                points,
                                metric = self.metric,
                                cyclic = self.close)
            pos = interpreter.to3d_np(interpreter.position)
            new_control_point = pos + (pos - prev_control_point)
            print(f&#34;Prev CP: {prev_control_point}, pos: {pos}, new CP: {new_control_point}&#34;)
            solver.add_goal(SvNurbsCurveControlPoints.single(1, new_control_point, relative=False))
            knotvector = solver.get_knotvector()
            n_cpts = solver.guess_n_control_points()
            knotvector = sv_knotvector.add_one_by_resampling(knotvector, index=1, degree=degree)
            solver.set_curve_params(n_cpts, knotvector)
            curve = solver.solve_welldetermined()
        else:
            curve = SvNurbsMaths.interpolate_curve(SvNurbsMaths.NATIVE, degree,
                                points,
                                metric = self.metric,
                                cyclic = self.close)
        return curve

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        interpolated_points = [[v0[0], v0[1], 0.0]]
        for i, pt in enumerate(self.points):
            knot = interpreter.calc_vertex(self.is_abs, pt[0], pt[1], variables)
            interpreter.new_knot(f&#34;I#.{i}&#34;, knot[0], knot[1])
            interpolated_points.append([knot[0], knot[1], 0.0])

        degree = interpreter.eval_(self.degree, variables)
        curve = self._make_curve(interpreter, degree, interpolated_points)
        interpreter.new_curve(curve, self)
        interpreter.position = knot

        cpts = curve.get_control_points()
        if degree == 2:
            interpreter.prev_quad_bezier_knot = (cpts[-2][0], cpts[-2][1])
        elif degree == 3:
            interpreter.prev_bezier_knot = (cpts[-2][0], cpts[-2][1])

        if self.num_segments is not None:
            r = interpreter.eval_(self.num_segments, variables)
        else:
            r = interpreter.dflt_num_verts

        t_min, t_max = curve.get_u_bounds()
        ts = np.linspace(t_min, t_max, num = r)
        points = curve.evaluate_array(ts)

        for point in points[1:]:
            v1_index = interpreter.new_vertex(point[0], point[1])
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    variables.update(self.degree.get_variables())
    for point in self.points:
        variables.update(point[0].get_variables())
        variables.update(point[1].get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    interpreter.start_new_segment()

    v0 = interpreter.position
    if interpreter.has_last_vertex:
        v0_index = interpreter.get_last_vertex()
    else:
        v0_index = interpreter.new_vertex(*v0)

    interpolated_points = [[v0[0], v0[1], 0.0]]
    for i, pt in enumerate(self.points):
        knot = interpreter.calc_vertex(self.is_abs, pt[0], pt[1], variables)
        interpreter.new_knot(f&#34;I#.{i}&#34;, knot[0], knot[1])
        interpolated_points.append([knot[0], knot[1], 0.0])

    degree = interpreter.eval_(self.degree, variables)
    curve = self._make_curve(interpreter, degree, interpolated_points)
    interpreter.new_curve(curve, self)
    interpreter.position = knot

    cpts = curve.get_control_points()
    if degree == 2:
        interpreter.prev_quad_bezier_knot = (cpts[-2][0], cpts[-2][1])
    elif degree == 3:
        interpreter.prev_bezier_knot = (cpts[-2][0], cpts[-2][1])

    if self.num_segments is not None:
        r = interpreter.eval_(self.num_segments, variables)
    else:
        r = interpreter.dflt_num_verts

    t_min, t_max = curve.get_u_bounds()
    ts = np.linspace(t_min, t_max, num = r)
    points = curve.evaluate_array(ts)

    for point in points[1:]:
        v1_index = interpreter.new_vertex(point[0], point[1])
        interpreter.new_edge(v0_index, v1_index)
        v0_index = v1_index

    if self.close:
        interpreter.close_segment(v1_index)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter"><code class="flex name class">
<span>class <span class="ident">Interpreter</span></span>
<span>(</span><span>node, input_names, curves_form=None, force_curves_form=False, z_axis='Z')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interpreter(object):

    NURBS = &#39;NURBS&#39;
    BEZIER = &#39;BEZIER&#39;

    def __init__(self, node, input_names, curves_form = None, force_curves_form = False, z_axis=&#39;Z&#39;):
        self.position = (0, 0)
        self.next_vertex_index = 0
        self.segment_start_index = 0
        self.segment_continues_line = False
        self.segment_number = 0
        self.has_last_vertex = False
        self.closed = False
        self.close_first_index = 0
        self.prev_bezier_knot = None
        self.prev_quad_bezier_knot = None
        self.curves = []
        self.vertices = []
        self.edges = []
        self.knots = []
        self.knotnames = []
        self.dflt_num_verts = node.curve_points_count
        self.close_threshold = node.close_threshold
        self.defaults = dict()
        self.input_names = input_names
        self.curves_form = curves_form
        self.force_curves_form = force_curves_form
        self.z_axis = z_axis

    def to3d(self, vertex):
        if self.z_axis == &#39;X&#39;:
            return Vector((0, vertex[0], vertex[1]))
        elif self.z_axis == &#39;Y&#39;:
            return Vector((vertex[0], 0, vertex[1]))
        else: # self.z_axis == &#39;Z&#39;:
            return Vector((vertex[0], vertex[1], 0))

    def to3d_np(self, vertex):
        if self.z_axis == &#39;X&#39;:
            return np.array((0, vertex[0], vertex[1]))
        elif self.z_axis == &#39;Y&#39;:
            return np.array((vertex[0], 0, vertex[1]))
        else: # self.z_axis == &#39;Z&#39;:
            return np.array((vertex[0], vertex[1], 0))

    def assert_not_closed(self):
        if self.closed:
            raise Exception(&#34;Path was already closed, will not process any further directives!&#34;)

    def relative(self, x, y):
        x0, y0 = self.position
        return x0+x, y0+y

    def calc_vertex(self, is_abs, x_expr, y_expr, variables):
        x = self.eval_(x_expr, variables)
        y = self.eval_(y_expr, variables)
        if is_abs:
            return x,y
        else:
            return self.relative(x,y)

    def new_vertex(self, x, y):
        index = self.next_vertex_index
        vertex = (x, y)
        self.vertices.append(vertex)
        self.next_vertex_index += 1
        return index

    def new_edge(self, v1, v2):
        self.edges.append((v1, v2))

    def new_knot(self, name, x, y):
        self.knots.append((x, y))
        name = name.replace(&#34;#&#34;, str(self.segment_number))
        self.knotnames.append(name)

    def new_curve(self, curve, statement):
        if self.curves_form == Interpreter.NURBS:
            if hasattr(curve, &#39;to_nurbs&#39;):
                curve = curve.to_nurbs()
            else:
                if self.force_curves_form:
                    raise Exception(f&#34;Cannot convert curve to NURBS: {statement}&#34;)
        elif self.curves_form == Interpreter.BEZIER:
            if not isinstance(curve, (SvBezierCurve, SvCubicBezierCurve)):
                if hasattr(curve, &#39;to_bezier&#39;):
                    curve = curve.to_bezier()
                else:
                    if self.force_curves_form:
                        raise Exception(&#34;Cannot convert curve to Bezier: {statement}&#34;)
        self.curves.append(curve)

    def new_line_segment(self, v1, v2):
        if isinstance(v1, int):
            v1, v2 = self.vertices[v1], self.vertices[v2]
        v1, v2 = self.to3d(v1), self.to3d(v2)
        if (v1 - v2).length &lt; self.close_threshold:
            return
        curve = SvLine.from_two_points(v1, v2)
        self.new_curve(curve, None)

    def start_new_segment(self):
        self.segment_start_index = self.next_vertex_index
        self.segment_continues_line = self.has_last_vertex
        self.segment_number += 1

    def close_segment(self, v_index):
        if self.segment_continues_line:
            start_index = self.segment_start_index-1
        else:
            start_index = self.segment_start_index
        self.new_edge(v_index, start_index)

    def get_last_vertex(self):
        return self.next_vertex_index - 1

    def pop_last_vertex(self):
        self.vertices.pop()
        self.next_vertex_index -= 1
        is_not_last = lambda e: e[0] != self.next_vertex_index and e[1] != self.next_vertex_index
        self.edges = list(filter(is_not_last, self.edges))

    def eval_(self, expr, variables):
        variables_ = self.defaults.copy()
        for name in variables:
            value = variables[name]
            if value is not None:
                variables_[name] = value
        return expr.eval_(variables_)

    def interpret(self, profile, variables):
        if not profile:
            return
        for statement in profile:
            sv_logger.debug(&#34;Interpret: %s&#34;, statement)
            statement.interpret(self, variables)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.BEZIER"><code class="name">var <span class="ident">BEZIER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.NURBS"><code class="name">var <span class="ident">NURBS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.assert_not_closed"><code class="name flex">
<span>def <span class="ident">assert_not_closed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_not_closed(self):
    if self.closed:
        raise Exception(&#34;Path was already closed, will not process any further directives!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.calc_vertex"><code class="name flex">
<span>def <span class="ident">calc_vertex</span></span>(<span>self, is_abs, x_expr, y_expr, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_vertex(self, is_abs, x_expr, y_expr, variables):
    x = self.eval_(x_expr, variables)
    y = self.eval_(y_expr, variables)
    if is_abs:
        return x,y
    else:
        return self.relative(x,y)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.close_segment"><code class="name flex">
<span>def <span class="ident">close_segment</span></span>(<span>self, v_index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_segment(self, v_index):
    if self.segment_continues_line:
        start_index = self.segment_start_index-1
    else:
        start_index = self.segment_start_index
    self.new_edge(v_index, start_index)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.eval_"><code class="name flex">
<span>def <span class="ident">eval_</span></span>(<span>self, expr, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_(self, expr, variables):
    variables_ = self.defaults.copy()
    for name in variables:
        value = variables[name]
        if value is not None:
            variables_[name] = value
    return expr.eval_(variables_)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.get_last_vertex"><code class="name flex">
<span>def <span class="ident">get_last_vertex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_vertex(self):
    return self.next_vertex_index - 1</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, profile, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, profile, variables):
    if not profile:
        return
    for statement in profile:
        sv_logger.debug(&#34;Interpret: %s&#34;, statement)
        statement.interpret(self, variables)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_curve"><code class="name flex">
<span>def <span class="ident">new_curve</span></span>(<span>self, curve, statement)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_curve(self, curve, statement):
    if self.curves_form == Interpreter.NURBS:
        if hasattr(curve, &#39;to_nurbs&#39;):
            curve = curve.to_nurbs()
        else:
            if self.force_curves_form:
                raise Exception(f&#34;Cannot convert curve to NURBS: {statement}&#34;)
    elif self.curves_form == Interpreter.BEZIER:
        if not isinstance(curve, (SvBezierCurve, SvCubicBezierCurve)):
            if hasattr(curve, &#39;to_bezier&#39;):
                curve = curve.to_bezier()
            else:
                if self.force_curves_form:
                    raise Exception(&#34;Cannot convert curve to Bezier: {statement}&#34;)
    self.curves.append(curve)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_edge"><code class="name flex">
<span>def <span class="ident">new_edge</span></span>(<span>self, v1, v2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_edge(self, v1, v2):
    self.edges.append((v1, v2))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_knot"><code class="name flex">
<span>def <span class="ident">new_knot</span></span>(<span>self, name, x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_knot(self, name, x, y):
    self.knots.append((x, y))
    name = name.replace(&#34;#&#34;, str(self.segment_number))
    self.knotnames.append(name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_line_segment"><code class="name flex">
<span>def <span class="ident">new_line_segment</span></span>(<span>self, v1, v2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_line_segment(self, v1, v2):
    if isinstance(v1, int):
        v1, v2 = self.vertices[v1], self.vertices[v2]
    v1, v2 = self.to3d(v1), self.to3d(v2)
    if (v1 - v2).length &lt; self.close_threshold:
        return
    curve = SvLine.from_two_points(v1, v2)
    self.new_curve(curve, None)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_vertex"><code class="name flex">
<span>def <span class="ident">new_vertex</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_vertex(self, x, y):
    index = self.next_vertex_index
    vertex = (x, y)
    self.vertices.append(vertex)
    self.next_vertex_index += 1
    return index</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.pop_last_vertex"><code class="name flex">
<span>def <span class="ident">pop_last_vertex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_last_vertex(self):
    self.vertices.pop()
    self.next_vertex_index -= 1
    is_not_last = lambda e: e[0] != self.next_vertex_index and e[1] != self.next_vertex_index
    self.edges = list(filter(is_not_last, self.edges))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.relative"><code class="name flex">
<span>def <span class="ident">relative</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relative(self, x, y):
    x0, y0 = self.position
    return x0+x, y0+y</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.start_new_segment"><code class="name flex">
<span>def <span class="ident">start_new_segment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_new_segment(self):
    self.segment_start_index = self.next_vertex_index
    self.segment_continues_line = self.has_last_vertex
    self.segment_number += 1</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.to3d"><code class="name flex">
<span>def <span class="ident">to3d</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to3d(self, vertex):
    if self.z_axis == &#39;X&#39;:
        return Vector((0, vertex[0], vertex[1]))
    elif self.z_axis == &#39;Y&#39;:
        return Vector((vertex[0], 0, vertex[1]))
    else: # self.z_axis == &#39;Z&#39;:
        return Vector((vertex[0], vertex[1], 0))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.to3d_np"><code class="name flex">
<span>def <span class="ident">to3d_np</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to3d_np(self, vertex):
    if self.z_axis == &#39;X&#39;:
        return np.array((0, vertex[0], vertex[1]))
    elif self.z_axis == &#39;Y&#39;:
        return np.array((vertex[0], 0, vertex[1]))
    else: # self.z_axis == &#39;Z&#39;:
        return np.array((vertex[0], vertex[1], 0))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.LineTo"><code class="flex name class">
<span>class <span class="ident">LineTo</span></span>
<span>(</span><span>is_abs, pairs, num_segments, close)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineTo(Statement):
    def __init__(self, is_abs, pairs, num_segments, close):
        self.is_abs = is_abs
        self.pairs = pairs
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for x, y in self.pairs:
            variables.update(x.get_variables())
            variables.update(y.get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;L&#34; if self.is_abs else &#34;l&#34;
        return &#34;{} {} n={} {}&#34;.format(letter, self.pairs, self.num_segments, self.close)
    
    def __eq__(self, other):
        return isinstance(other, LineTo) and \
                self.is_abs == other.is_abs and \
                self.pairs == other.pairs and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        v0 = interpreter.position
        if interpreter.has_last_vertex:
            prev_index = interpreter.get_last_vertex()
        else:
            prev_index = interpreter.new_vertex(*v0)

        if self.num_segments is not None:
            num_segments = interpreter.eval_(self.num_segments, variables)
        else:
            num_segments = None

        for i, (x_expr, y_expr) in enumerate(self.pairs):
            v1 = interpreter.calc_vertex(self.is_abs, x_expr, y_expr, variables)
            interpreter.position = v1
            for vertex in self._interpolate(v0, v1, num_segments)[1:]:
                v_index = interpreter.new_vertex(*vertex)
                interpreter.new_edge(prev_index, v_index)
                prev_index = v_index
            interpreter.new_line_segment(v0, v1)
            v0 = v1
            interpreter.new_knot(&#34;L#.{}&#34;.format(i), *v1)

        if self.close:
            interpreter.close_segment(v_index)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.LineTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    for x, y in self.pairs:
        variables.update(x.get_variables())
        variables.update(y.get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.LineTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    interpreter.start_new_segment()
    v0 = interpreter.position
    if interpreter.has_last_vertex:
        prev_index = interpreter.get_last_vertex()
    else:
        prev_index = interpreter.new_vertex(*v0)

    if self.num_segments is not None:
        num_segments = interpreter.eval_(self.num_segments, variables)
    else:
        num_segments = None

    for i, (x_expr, y_expr) in enumerate(self.pairs):
        v1 = interpreter.calc_vertex(self.is_abs, x_expr, y_expr, variables)
        interpreter.position = v1
        for vertex in self._interpolate(v0, v1, num_segments)[1:]:
            v_index = interpreter.new_vertex(*vertex)
            interpreter.new_edge(prev_index, v_index)
            prev_index = v_index
        interpreter.new_line_segment(v0, v1)
        v0 = v1
        interpreter.new_knot(&#34;L#.{}&#34;.format(i), *v1)

    if self.close:
        interpreter.close_segment(v_index)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.MoveTo"><code class="flex name class">
<span>class <span class="ident">MoveTo</span></span>
<span>(</span><span>is_abs, x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MoveTo(Statement):
    def __init__(self, is_abs, x, y):
        self.is_abs = is_abs
        self.x = x
        self.y = y

    def __repr__(self):
        letter = &#34;M&#34; if self.is_abs else &#34;m&#34;
        return &#34;{} {} {}&#34;.format(letter, self.x, self.y)

    def __eq__(self, other):
        return isinstance(other, MoveTo) and \
                self.is_abs == other.is_abs and \
                self.x == other.x and \
                self.y == other.y

    def get_variables(self):
        variables = set()
        variables.update(self.x.get_variables())
        variables.update(self.y.get_variables())
        return variables

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        pos = interpreter.calc_vertex(self.is_abs, self.x, self.y, variables)
        interpreter.position = pos
        interpreter.new_knot(&#34;M.#&#34;, *pos)
        interpreter.has_last_vertex = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.MoveTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    variables.update(self.x.get_variables())
    variables.update(self.y.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.MoveTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    interpreter.start_new_segment()
    pos = interpreter.calc_vertex(self.is_abs, self.x, self.y, variables)
    interpreter.position = pos
    interpreter.new_knot(&#34;M.#&#34;, *pos)
    interpreter.has_last_vertex = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable"><code class="flex name class">
<span>class <span class="ident">NegatedVariable</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NegatedVariable(Variable):
    @classmethod
    def from_string(cls, string):
        return NegatedVariable(string)

    def eval_(self, variables):
        value = variables.get(self.name, None)
        if value is not None:
            return -value
        else:
            raise SyntaxError(&#34;Unknown variable: &#34; + self.name)

    def __repr__(self):
        return &#34;NegatedVariable({})&#34;.format(self.name)

    def __eq__(self, other):
        return isinstance(other, NegatedVariable) and self.name == other.name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Variable" href="#sverchok.utils.modules.profile_mk3.interpreter.Variable">Variable</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Expression" href="#sverchok.utils.modules.profile_mk3.interpreter.Expression">Expression</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, string):
    return NegatedVariable(string)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable.eval_"><code class="name flex">
<span>def <span class="ident">eval_</span></span>(<span>self, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_(self, variables):
    value = variables.get(self.name, None)
    if value is not None:
        return -value
    else:
        raise SyntaxError(&#34;Unknown variable: &#34; + self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo"><code class="flex name class">
<span>class <span class="ident">QuadraticCurveTo</span></span>
<span>(</span><span>is_abs, segments, num_segments, close)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuadraticCurveTo(Statement):
    class Segment(object):
        def __init__(self, control, knot2):
            self.control = control
            self.knot2 = knot2

        def __repr__(self):
            return &#34;{} {}&#34;.format(self.control, self.knot2)

        def __eq__(self, other):
            return self.control == other.control and \
                    self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.control[0].get_variables())
            variables.update(segment.control[1].get_variables())
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;Q&#34; if self.is_abs else &#34;q&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, QuadraticCurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            handle = interpreter.calc_vertex(self.is_abs, segment.control[0], segment.control[1], variables)
            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvBezierCurve([vec(knot1), vec(handle), vec(knot2)])
            interpreter.new_curve(curve, self)

            points = interpolate_quadratic_bezier(vec(knot1), vec(handle), vec(knot2), r)

            interpreter.new_knot(&#34;Q#.{}.h&#34;.format(i), *handle)
            interpreter.new_knot(&#34;Q#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_quad_bezier_knot = handle

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.Segment"><code class="name">var <span class="ident">Segment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    for segment in self.segments:
        variables.update(segment.control[0].get_variables())
        variables.update(segment.control[1].get_variables())
        variables.update(segment.knot2[0].get_variables())
        variables.update(segment.knot2[1].get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    vec = lambda v: Vector((v[0], v[1], 0))

    interpreter.assert_not_closed()
    interpreter.start_new_segment()

    v0 = interpreter.position
    if interpreter.has_last_vertex:
        v0_index = interpreter.get_last_vertex()
    else:
        v0_index = interpreter.new_vertex(*v0)

    knot1 = None
    for i, segment in enumerate(self.segments):
        # For first segment, knot1 is initial pen position;
        # for the following, knot1 is knot2 of previous segment.
        if knot1 is None:
            knot1 = interpreter.position
        else:
            knot1 = knot2

        handle = interpreter.calc_vertex(self.is_abs, segment.control[0], segment.control[1], variables)
        knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
        interpreter.position = knot2

        if self.num_segments is not None:
            r = interpreter.eval_(self.num_segments, variables)
        else:
            r = interpreter.dflt_num_verts

        curve = SvBezierCurve([vec(knot1), vec(handle), vec(knot2)])
        interpreter.new_curve(curve, self)

        points = interpolate_quadratic_bezier(vec(knot1), vec(handle), vec(knot2), r)

        interpreter.new_knot(&#34;Q#.{}.h&#34;.format(i), *handle)
        interpreter.new_knot(&#34;Q#.{}.k&#34;.format(i), *knot2)

        interpreter.prev_quad_bezier_knot = handle

        for point in points[1:]:
            v1_index = interpreter.new_vertex(point.x, point.y)
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

    if self.close:
        interpreter.close_segment(v1_index)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo"><code class="flex name class">
<span>class <span class="ident">SmoothCurveTo</span></span>
<span>(</span><span>is_abs, segments, num_segments, close)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SmoothCurveTo(Statement):
    class Segment(object):
        def __init__(self, control2, knot2):
            self.control2 = control2
            self.knot2 = knot2

        def __repr__(self):
            return &#34;{} {}&#34;.format(self.control2, self.knot2)

        def __eq__(self, other):
            return self.control2 == other.control2 and \
                    self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.control2[0].get_variables())
            variables.update(segment.control2[1].get_variables())
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;S&#34; if self.is_abs else &#34;s&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, SmoothCurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            if interpreter.prev_bezier_knot is None:
                # If there is no previous command or if the previous command was
                # not an C, c, S or s, assume the first control point is coincident
                # with the current point.
                handle1 = knot1
            else:
                # The first control point is assumed to be the reflection of the
                # second control point on the previous command relative to the
                # current point. 
                prev_knot_x, prev_knot_y = interpreter.prev_bezier_knot
                x0, y0 = knot1
                dx, dy = x0 - prev_knot_x, y0 - prev_knot_y
                handle1 = x0 + dx, y0 + dy

            # I assume that handle2 should be relative to knot1, not to handle1.
            # interpreter.position = handle1
            handle2 = interpreter.calc_vertex(self.is_abs, segment.control2[0], segment.control2[1], variables)
            # interpreter.position = handle2
            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvCubicBezierCurve(vec(knot1), vec(handle1), vec(handle2), vec(knot2))
            interpreter.new_curve(curve, self)

            points = interpolate_bezier(vec(knot1), vec(handle1), vec(handle2), vec(knot2), r)

            interpreter.new_knot(&#34;S#.{}.h1&#34;.format(i), *handle1)
            interpreter.new_knot(&#34;S#.{}.h2&#34;.format(i), *handle2)
            interpreter.new_knot(&#34;S#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_bezier_knot = handle2

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.Segment"><code class="name">var <span class="ident">Segment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    for segment in self.segments:
        variables.update(segment.control2[0].get_variables())
        variables.update(segment.control2[1].get_variables())
        variables.update(segment.knot2[0].get_variables())
        variables.update(segment.knot2[1].get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    vec = lambda v: Vector((v[0], v[1], 0))

    interpreter.assert_not_closed()
    interpreter.start_new_segment()

    v0 = interpreter.position
    if interpreter.has_last_vertex:
        v0_index = interpreter.get_last_vertex()
    else:
        v0_index = interpreter.new_vertex(*v0)

    knot1 = None
    for i, segment in enumerate(self.segments):
        # For first segment, knot1 is initial pen position;
        # for the following, knot1 is knot2 of previous segment.
        if knot1 is None:
            knot1 = interpreter.position
        else:
            knot1 = knot2

        if interpreter.prev_bezier_knot is None:
            # If there is no previous command or if the previous command was
            # not an C, c, S or s, assume the first control point is coincident
            # with the current point.
            handle1 = knot1
        else:
            # The first control point is assumed to be the reflection of the
            # second control point on the previous command relative to the
            # current point. 
            prev_knot_x, prev_knot_y = interpreter.prev_bezier_knot
            x0, y0 = knot1
            dx, dy = x0 - prev_knot_x, y0 - prev_knot_y
            handle1 = x0 + dx, y0 + dy

        # I assume that handle2 should be relative to knot1, not to handle1.
        # interpreter.position = handle1
        handle2 = interpreter.calc_vertex(self.is_abs, segment.control2[0], segment.control2[1], variables)
        # interpreter.position = handle2
        knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
        interpreter.position = knot2

        if self.num_segments is not None:
            r = interpreter.eval_(self.num_segments, variables)
        else:
            r = interpreter.dflt_num_verts

        curve = SvCubicBezierCurve(vec(knot1), vec(handle1), vec(handle2), vec(knot2))
        interpreter.new_curve(curve, self)

        points = interpolate_bezier(vec(knot1), vec(handle1), vec(handle2), vec(knot2), r)

        interpreter.new_knot(&#34;S#.{}.h1&#34;.format(i), *handle1)
        interpreter.new_knot(&#34;S#.{}.h2&#34;.format(i), *handle2)
        interpreter.new_knot(&#34;S#.{}.k&#34;.format(i), *knot2)

        interpreter.prev_bezier_knot = handle2

        for point in points[1:]:
            v1_index = interpreter.new_vertex(point.x, point.y)
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

    if self.close:
        interpreter.close_segment(v1_index)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo"><code class="flex name class">
<span>class <span class="ident">SmoothQuadraticCurveTo</span></span>
<span>(</span><span>is_abs, segments, num_segments, close)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SmoothQuadraticCurveTo(Statement):
    class Segment(object):
        def __init__(self, knot2):
            self.knot2 = knot2

        def __repr__(self):
            return str(self.knot2)

        def __eq__(self, other):
            return self.knot2 == other.knot2

    def __init__(self, is_abs, segments, num_segments, close):
        self.is_abs = is_abs
        self.segments = segments
        self.num_segments = num_segments
        self.close = close

    def get_variables(self):
        variables = set()
        for segment in self.segments:
            variables.update(segment.knot2[0].get_variables())
            variables.update(segment.knot2[1].get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;T&#34; if self.is_abs else &#34;t&#34;
        segments = &#34; &#34;.join(str(segment) for segment in self.segments)
        return &#34;{} {} n={} {}&#34;.format(letter, segments, self.num_segments, self.close)

    def __eq__(self, other):
        return isinstance(other, SmoothQuadraticCurveTo) and \
                self.is_abs == other.is_abs and \
                self.segments == other.segments and \
                self.num_segments == other.num_segments and \
                self.close == other.close

    def interpret(self, interpreter, variables):
        vec = lambda v: Vector((v[0], v[1], 0))

        interpreter.assert_not_closed()
        interpreter.start_new_segment()

        v0 = interpreter.position
        if interpreter.has_last_vertex:
            v0_index = interpreter.get_last_vertex()
        else:
            v0_index = interpreter.new_vertex(*v0)

        knot1 = None
        for i, segment in enumerate(self.segments):
            # For first segment, knot1 is initial pen position;
            # for the following, knot1 is knot2 of previous segment.
            if knot1 is None:
                knot1 = interpreter.position
            else:
                knot1 = knot2

            if interpreter.prev_quad_bezier_knot is None:
                # If there is no previous command or if the previous command was
                # not a Q, q, T or t, assume the control point is coincident with
                # the current point.
                handle = knot1
            else:
                # The first control point is assumed to be the reflection of the
                # second control point on the previous command relative to the
                # current point. 
                prev_knot_x, prev_knot_y = interpreter.prev_quad_bezier_knot
                x0, y0 = knot1
                dx, dy = x0 - prev_knot_x, y0 - prev_knot_y
                handle = x0 + dx, y0 + dy

            knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
            interpreter.position = knot2

            if self.num_segments is not None:
                r = interpreter.eval_(self.num_segments, variables)
            else:
                r = interpreter.dflt_num_verts

            curve = SvBezierCurve([vec(knot1), vec(handle), vec(knot2)])
            interpreter.new_curve(curve, self)

            points = interpolate_quadratic_bezier(vec(knot1), vec(handle), vec(knot2), r)

            interpreter.new_knot(&#34;T#.{}.h&#34;.format(i), *handle)
            interpreter.new_knot(&#34;T#.{}.k&#34;.format(i), *knot2)

            interpreter.prev_quad_bezier_knot = handle

            for point in points[1:]:
                v1_index = interpreter.new_vertex(point.x, point.y)
                interpreter.new_edge(v0_index, v1_index)
                v0_index = v1_index

        if self.close:
            interpreter.close_segment(v1_index)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.Segment"><code class="name">var <span class="ident">Segment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    for segment in self.segments:
        variables.update(segment.knot2[0].get_variables())
        variables.update(segment.knot2[1].get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    vec = lambda v: Vector((v[0], v[1], 0))

    interpreter.assert_not_closed()
    interpreter.start_new_segment()

    v0 = interpreter.position
    if interpreter.has_last_vertex:
        v0_index = interpreter.get_last_vertex()
    else:
        v0_index = interpreter.new_vertex(*v0)

    knot1 = None
    for i, segment in enumerate(self.segments):
        # For first segment, knot1 is initial pen position;
        # for the following, knot1 is knot2 of previous segment.
        if knot1 is None:
            knot1 = interpreter.position
        else:
            knot1 = knot2

        if interpreter.prev_quad_bezier_knot is None:
            # If there is no previous command or if the previous command was
            # not a Q, q, T or t, assume the control point is coincident with
            # the current point.
            handle = knot1
        else:
            # The first control point is assumed to be the reflection of the
            # second control point on the previous command relative to the
            # current point. 
            prev_knot_x, prev_knot_y = interpreter.prev_quad_bezier_knot
            x0, y0 = knot1
            dx, dy = x0 - prev_knot_x, y0 - prev_knot_y
            handle = x0 + dx, y0 + dy

        knot2 = interpreter.calc_vertex(self.is_abs, segment.knot2[0], segment.knot2[1], variables)
        interpreter.position = knot2

        if self.num_segments is not None:
            r = interpreter.eval_(self.num_segments, variables)
        else:
            r = interpreter.dflt_num_verts

        curve = SvBezierCurve([vec(knot1), vec(handle), vec(knot2)])
        interpreter.new_curve(curve, self)

        points = interpolate_quadratic_bezier(vec(knot1), vec(handle), vec(knot2), r)

        interpreter.new_knot(&#34;T#.{}.h&#34;.format(i), *handle)
        interpreter.new_knot(&#34;T#.{}.k&#34;.format(i), *knot2)

        interpreter.prev_quad_bezier_knot = handle

        for point in points[1:]:
            v1_index = interpreter.new_vertex(point.x, point.y)
            interpreter.new_edge(v0_index, v1_index)
            v0_index = v1_index

    if self.close:
        interpreter.close_segment(v1_index)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Statement"><code class="flex name class">
<span>class <span class="ident">Statement</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Statement(object):
    
    def get_variables(self):
        return set()

    def get_hidden_inputs(self):
        return set()

    def get_optional_inputs(self):
        return set()

    def _interpolate(self, v0, v1, num_segments):
        if num_segments is None or num_segments &lt;= 1:
            return [v0, v1]
        dx_total, dy_total = v1[0] - v0[0], v1[1] - v0[1]
        dx, dy = dx_total / float(num_segments), dy_total / float(num_segments)
        x, y = v0
        dt = 1.0 / float(num_segments)
        result = []
        t = 0
        for i in range(round(num_segments)):
            result.append((x,y))
            x = x + dx
            y = y + dy
        result.append(v1)
        return result</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.ArcTo" href="#sverchok.utils.modules.profile_mk3.interpreter.ArcTo">ArcTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.CloseAll" href="#sverchok.utils.modules.profile_mk3.interpreter.CloseAll">CloseAll</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.ClosePath" href="#sverchok.utils.modules.profile_mk3.interpreter.ClosePath">ClosePath</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.CurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.CurveTo">CurveTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Default" href="#sverchok.utils.modules.profile_mk3.interpreter.Default">Default</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo" href="#sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo">HorizontalLineTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo">InterpolatedCurveTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.LineTo" href="#sverchok.utils.modules.profile_mk3.interpreter.LineTo">LineTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.MoveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.MoveTo">MoveTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo">QuadraticCurveTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo">SmoothCurveTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo">SmoothQuadraticCurveTo</a></li>
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo" href="#sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo">VerticalLineTo</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Statement.get_hidden_inputs"><code class="name flex">
<span>def <span class="ident">get_hidden_inputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hidden_inputs(self):
    return set()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Statement.get_optional_inputs"><code class="name flex">
<span>def <span class="ident">get_optional_inputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_optional_inputs(self):
    return set()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Statement.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    return set()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Variable"><code class="flex name class">
<span>class <span class="ident">Variable</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Variable(Expression):
    def __init__(self, name):
        self.name = name

    @classmethod
    def from_string(cls, string):
        return Variable(string)

    def __repr__(self):
        return &#34;Variable({})&#34;.format(self.name)

    def __eq__(self, other):
        return isinstance(other, Variable) and self.name == other.name

    def eval_(self, variables):
        value = variables.get(self.name, None)
        if value is not None:
            return value
        else:
            raise SyntaxError(&#34;Unknown variable: &#34; + self.name)

    def get_variables(self):
        return set([self.name])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Expression" href="#sverchok.utils.modules.profile_mk3.interpreter.Expression">Expression</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable" href="#sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable">NegatedVariable</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Variable.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, string):
    return Variable(string)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Variable.eval_"><code class="name flex">
<span>def <span class="ident">eval_</span></span>(<span>self, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_(self, variables):
    value = variables.get(self.name, None)
    if value is not None:
        return value
    else:
        raise SyntaxError(&#34;Unknown variable: &#34; + self.name)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.Variable.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    return set([self.name])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo"><code class="flex name class">
<span>class <span class="ident">VerticalLineTo</span></span>
<span>(</span><span>is_abs, ys, num_segments)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VerticalLineTo(Statement):
    def __init__(self, is_abs, ys, num_segments):
        self.is_abs = is_abs
        self.ys = ys
        self.num_segments = num_segments

    def get_variables(self):
        variables = set()
        for y in self.ys:
            variables.update(y.get_variables())
        if self.num_segments:
            variables.update(self.num_segments.get_variables())
        return variables

    def __repr__(self):
        letter = &#34;V&#34; if self.is_abs else &#34;v&#34;
        return &#34;{} {} n={};&#34;.format(letter, self.ys, self.num_segments)

    def __eq__(self, other):
        return isinstance(other, VerticalLineTo) and \
                self.is_abs == other.is_abs and \
                self.num_segments == other.num_segments and \
                self.ys == other.ys

    def interpret(self, interpreter, variables):
        interpreter.assert_not_closed()
        interpreter.start_new_segment()
        v0 = interpreter.position
        if interpreter.has_last_vertex:
            prev_index = interpreter.get_last_vertex()
        else:
            prev_index = interpreter.new_vertex(*v0)

        if self.num_segments is not None:
            num_segments = interpreter.eval_(self.num_segments, variables)
        else:
            num_segments = None

        for i, y_expr in enumerate(self.ys):
            x0,y0 = interpreter.position
            y = interpreter.eval_(y_expr, variables)
            if not self.is_abs:
                y = y0 + y
            v1 = (x0, y)
            interpreter.position = v1
            for vertex in self._interpolate(v0, v1, num_segments)[1:]:
                v_index = interpreter.new_vertex(*vertex)
                interpreter.new_edge(prev_index, v_index)
                prev_index = v_index
            interpreter.new_line_segment(v0, v1)
            v0 = v1
            interpreter.new_knot(&#34;V#.{}&#34;.format(i), *v1)

        interpreter.has_last_vertex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo.get_variables"><code class="name flex">
<span>def <span class="ident">get_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables(self):
    variables = set()
    for y in self.ys:
        variables.update(y.get_variables())
    if self.num_segments:
        variables.update(self.num_segments.get_variables())
    return variables</code></pre>
</details>
</dd>
<dt id="sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, interpreter, variables)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, interpreter, variables):
    interpreter.assert_not_closed()
    interpreter.start_new_segment()
    v0 = interpreter.position
    if interpreter.has_last_vertex:
        prev_index = interpreter.get_last_vertex()
    else:
        prev_index = interpreter.new_vertex(*v0)

    if self.num_segments is not None:
        num_segments = interpreter.eval_(self.num_segments, variables)
    else:
        num_segments = None

    for i, y_expr in enumerate(self.ys):
        x0,y0 = interpreter.position
        y = interpreter.eval_(y_expr, variables)
        if not self.is_abs:
            y = y0 + y
        v1 = (x0, y)
        interpreter.position = v1
        for vertex in self._interpolate(v0, v1, num_segments)[1:]:
            v_index = interpreter.new_vertex(*vertex)
            interpreter.new_edge(prev_index, v_index)
            prev_index = v_index
        interpreter.new_line_segment(v0, v1)
        v0 = v1
        interpreter.new_knot(&#34;V#.{}&#34;.format(i), *v1)

    interpreter.has_last_vertex = True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.modules.profile_mk3" href="index.html">sverchok.utils.modules.profile_mk3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.make_functions_dict" href="#sverchok.utils.modules.profile_mk3.interpreter.make_functions_dict">make_functions_dict</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.ArcTo" href="#sverchok.utils.modules.profile_mk3.interpreter.ArcTo">ArcTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.ArcTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.ArcTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.ArcTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.ArcTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Assign" href="#sverchok.utils.modules.profile_mk3.interpreter.Assign">Assign</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Assign.get_hidden_inputs" href="#sverchok.utils.modules.profile_mk3.interpreter.Assign.get_hidden_inputs">get_hidden_inputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.CloseAll" href="#sverchok.utils.modules.profile_mk3.interpreter.CloseAll">CloseAll</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.CloseAll.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.CloseAll.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.CloseAll.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.CloseAll.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.ClosePath" href="#sverchok.utils.modules.profile_mk3.interpreter.ClosePath">ClosePath</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.ClosePath.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.ClosePath.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.ClosePath.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.ClosePath.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Const" href="#sverchok.utils.modules.profile_mk3.interpreter.Const">Const</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Const.eval_" href="#sverchok.utils.modules.profile_mk3.interpreter.Const.eval_">eval_</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Const.from_string" href="#sverchok.utils.modules.profile_mk3.interpreter.Const.from_string">from_string</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Const.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.Const.get_variables">get_variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.CurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.CurveTo">CurveTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.CurveTo.Segment" href="#sverchok.utils.modules.profile_mk3.interpreter.CurveTo.Segment">Segment</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.CurveTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.CurveTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.CurveTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.CurveTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Default" href="#sverchok.utils.modules.profile_mk3.interpreter.Default">Default</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Default.get_optional_inputs" href="#sverchok.utils.modules.profile_mk3.interpreter.Default.get_optional_inputs">get_optional_inputs</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Default.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.Default.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Default.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.Default.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Expression" href="#sverchok.utils.modules.profile_mk3.interpreter.Expression">Expression</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Expression.eval_" href="#sverchok.utils.modules.profile_mk3.interpreter.Expression.eval_">eval_</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Expression.from_string" href="#sverchok.utils.modules.profile_mk3.interpreter.Expression.from_string">from_string</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Expression.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.Expression.get_variables">get_variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo" href="#sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo">HorizontalLineTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.HorizontalLineTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo">InterpolatedCurveTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.InterpolatedCurveTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter">Interpreter</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.BEZIER" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.BEZIER">BEZIER</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.NURBS" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.NURBS">NURBS</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.assert_not_closed" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.assert_not_closed">assert_not_closed</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.calc_vertex" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.calc_vertex">calc_vertex</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.close_segment" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.close_segment">close_segment</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.eval_" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.eval_">eval_</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.get_last_vertex" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.get_last_vertex">get_last_vertex</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.interpret">interpret</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_curve" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_curve">new_curve</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_edge" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_edge">new_edge</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_knot" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_knot">new_knot</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_line_segment" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_line_segment">new_line_segment</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_vertex" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.new_vertex">new_vertex</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.pop_last_vertex" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.pop_last_vertex">pop_last_vertex</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.relative" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.relative">relative</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.start_new_segment" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.start_new_segment">start_new_segment</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.to3d" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.to3d">to3d</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Interpreter.to3d_np" href="#sverchok.utils.modules.profile_mk3.interpreter.Interpreter.to3d_np">to3d_np</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.LineTo" href="#sverchok.utils.modules.profile_mk3.interpreter.LineTo">LineTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.LineTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.LineTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.LineTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.LineTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.MoveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.MoveTo">MoveTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.MoveTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.MoveTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.MoveTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.MoveTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable" href="#sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable">NegatedVariable</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable.eval_" href="#sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable.eval_">eval_</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable.from_string" href="#sverchok.utils.modules.profile_mk3.interpreter.NegatedVariable.from_string">from_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo">QuadraticCurveTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.Segment" href="#sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.Segment">Segment</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.QuadraticCurveTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo">SmoothCurveTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.Segment" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.Segment">Segment</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothCurveTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo">SmoothQuadraticCurveTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.Segment" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.Segment">Segment</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.SmoothQuadraticCurveTo.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement">Statement</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement.get_hidden_inputs" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement.get_hidden_inputs">get_hidden_inputs</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement.get_optional_inputs" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement.get_optional_inputs">get_optional_inputs</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Statement.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.Statement.get_variables">get_variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Variable" href="#sverchok.utils.modules.profile_mk3.interpreter.Variable">Variable</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Variable.eval_" href="#sverchok.utils.modules.profile_mk3.interpreter.Variable.eval_">eval_</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Variable.from_string" href="#sverchok.utils.modules.profile_mk3.interpreter.Variable.from_string">from_string</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.Variable.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.Variable.get_variables">get_variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo" href="#sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo">VerticalLineTo</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo.get_variables" href="#sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo.get_variables">get_variables</a></code></li>
<li><code><a title="sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo.interpret" href="#sverchok.utils.modules.profile_mk3.interpreter.VerticalLineTo.interpret">interpret</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>