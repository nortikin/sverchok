<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.field.probe API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.field.probe</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#  
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import random
import numpy as np

from sverchok.utils.sv_logging import sv_logger
from sverchok.utils.kdtree import SvKdTree

BATCH_SIZE = 50
MAX_ITERATIONS = 1000

def _check_min_distance(v_new, vs_old, min_r):
    if not vs_old:
        return True
    kdt = SvKdTree.new(SvKdTree.BLENDER, vs_old)
    nearest, idx, dist = kdt.query(v_new)
    if dist is None:
        return True
    ok = (dist &gt;= min_r)
    #if not ok:
    #    print(f&#34;V {v_new} =&gt; {nearest}, {dist} &gt;= {min_r}&#34;)
    return ok

def _check_min_radius(point, old_points, old_radiuses, min_r):
    if not old_points:
        return True
    old_points = np.array(old_points)
    old_radiuses = np.array(old_radiuses)
    point = np.array(point)
    distances = np.linalg.norm(old_points - point, axis=1)
    ok = (old_radiuses + min_r &lt; distances).all()
    return ok

def field_random_probe(field, bbox, count,
        threshold=0, proportional=False, field_min=None, field_max=None,
        min_r=0, min_r_field=None,
        random_radius = False,
        seed=0, predicate=None):
    &#34;&#34;&#34;
    Generate random points within bounding box, with distribution controlled (optionally) by a scalar field.

    inputs:
    * field: SvScalarField. Pass None to use uniform distribution.
    * bbox: nested tuple: ((min_x, min_y, min_z), (max_x, max_y, max_z)).
    * count: number of points to generate.
    * threshold: do not generate points where value of scalar field is less than this value.
    * proportional: if True, then density of points will be proportional to
      values of the scalar field. Otherwise, values of the field will be used
      only to not generate points in places where scalar field value is less than
      threshold.
    * field_min: (expected) minimum value of scalar field within the bounding box.
      Mandatory if `proportional` is set to True.
    * field_max: (expected) maximum value of scalar field within the bounding box.
      Mandatory if `proportional` is set to True.
    * min_r: minimum distance between generated points. Set to zero to disable this check.
    * seed: random generator seed value.
    * predicate: additional predicate to check if generated point is valid. Optional.

    outputs:
        list of vertices.
    &#34;&#34;&#34;
    if min_r != 0 and min_r_field is not None:
        raise Exception(&#34;min_r and min_r_field can not be specified simultaneously&#34;)
    if seed == 0:
        seed = 12345
    if seed is not None:
        random.seed(seed)

    b1, b2 = bbox
    x_min, y_min, z_min = b1
    x_max, y_max, z_max = b2

    done = 0
    generated_verts = []
    generated_radiuses = []
    iterations = 0
    while done &lt; count:
        iterations += 1
        if iterations &gt; MAX_ITERATIONS:
            sv_logger.error(&#34;Maximum number of iterations (%s) reached, stop.&#34;, MAX_ITERATIONS)
            break
        batch_xs = []
        batch_ys = []
        batch_zs = []
        batch = []
        left = count - done
        max_size = min(BATCH_SIZE, left)
        for i in range(max_size):
            x = random.uniform(x_min, x_max)
            y = random.uniform(y_min, y_max)
            z = random.uniform(z_min, z_max)
            batch_xs.append(x)
            batch_ys.append(y)
            batch_zs.append(z)
            batch.append((x, y, z))
        batch_xs = np.array(batch_xs)#[np.newaxis][np.newaxis]
        batch_ys = np.array(batch_ys)#[np.newaxis][np.newaxis]
        batch_zs = np.array(batch_zs)#[np.newaxis][np.newaxis]
        batch = np.array(batch)

        if field is None:
            candidates = batch.tolist()
        else:
            values = field.evaluate_grid(batch_xs, batch_ys, batch_zs)
            good_idxs = values &gt;= threshold
            if not proportional:
                candidates = batch[good_idxs].tolist()
            else:
                candidates = []
                for vert, value in zip(batch[good_idxs].tolist(), values[good_idxs].tolist()):
                    probe = random.uniform(field_min, field_max)
                    if probe &lt;= value:
                        candidates.append(vert)

        good_radiuses = []
        if min_r == 0 and min_r_field is None:
            good_verts = candidates
            good_radiuses = [0 for i in range(len(good_verts))]
        elif min_r_field is not None:
            xs = np.array([p[0] for p in candidates])
            ys = np.array([p[1] for p in candidates])
            zs = np.array([p[2] for p in candidates])
            min_rs = min_r_field.evaluate_grid(xs, ys, zs).tolist()
            good_verts = []
            for candidate, min_r in zip(candidates, min_rs):
                if random_radius:
                    min_r = random.uniform(0, min_r)
                if _check_min_radius(candidate, generated_verts + good_verts, generated_radiuses + good_radiuses, min_r):
                    good_verts.append(candidate)
                    good_radiuses.append(min_r)
        else: # min_r != 0
            good_verts = []
            for candidate in candidates:
                if _check_min_distance(candidate, generated_verts + good_verts, min_r):
                    good_verts.append(candidate)
            good_radiuses = [1 for c in good_verts]

        if predicate is not None:
            pairs = [(vert, r) for vert, r in zip(good_verts, good_radiuses) if predicate(vert)]
            good_verts = [p[0] for p in pairs]
            good_radiuses = [p[1] for p in pairs]

        generated_verts.extend(good_verts)
        generated_radiuses.extend(good_radiuses)
        done += len(good_verts)

    return generated_verts, generated_radiuses</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.field.probe.field_random_probe"><code class="name flex">
<span>def <span class="ident">field_random_probe</span></span>(<span>field, bbox, count, threshold=0, proportional=False, field_min=None, field_max=None, min_r=0, min_r_field=None, random_radius=False, seed=0, predicate=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate random points within bounding box, with distribution controlled (optionally) by a scalar field.</p>
<p>inputs:
* field: SvScalarField. Pass None to use uniform distribution.
* bbox: nested tuple: ((min_x, min_y, min_z), (max_x, max_y, max_z)).
* count: number of points to generate.
* threshold: do not generate points where value of scalar field is less than this value.
* proportional: if True, then density of points will be proportional to
values of the scalar field. Otherwise, values of the field will be used
only to not generate points in places where scalar field value is less than
threshold.
* field_min: (expected) minimum value of scalar field within the bounding box.
Mandatory if <code>proportional</code> is set to True.
* field_max: (expected) maximum value of scalar field within the bounding box.
Mandatory if <code>proportional</code> is set to True.
* min_r: minimum distance between generated points. Set to zero to disable this check.
* seed: random generator seed value.
* predicate: additional predicate to check if generated point is valid. Optional.</p>
<p>outputs:
list of vertices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field_random_probe(field, bbox, count,
        threshold=0, proportional=False, field_min=None, field_max=None,
        min_r=0, min_r_field=None,
        random_radius = False,
        seed=0, predicate=None):
    &#34;&#34;&#34;
    Generate random points within bounding box, with distribution controlled (optionally) by a scalar field.

    inputs:
    * field: SvScalarField. Pass None to use uniform distribution.
    * bbox: nested tuple: ((min_x, min_y, min_z), (max_x, max_y, max_z)).
    * count: number of points to generate.
    * threshold: do not generate points where value of scalar field is less than this value.
    * proportional: if True, then density of points will be proportional to
      values of the scalar field. Otherwise, values of the field will be used
      only to not generate points in places where scalar field value is less than
      threshold.
    * field_min: (expected) minimum value of scalar field within the bounding box.
      Mandatory if `proportional` is set to True.
    * field_max: (expected) maximum value of scalar field within the bounding box.
      Mandatory if `proportional` is set to True.
    * min_r: minimum distance between generated points. Set to zero to disable this check.
    * seed: random generator seed value.
    * predicate: additional predicate to check if generated point is valid. Optional.

    outputs:
        list of vertices.
    &#34;&#34;&#34;
    if min_r != 0 and min_r_field is not None:
        raise Exception(&#34;min_r and min_r_field can not be specified simultaneously&#34;)
    if seed == 0:
        seed = 12345
    if seed is not None:
        random.seed(seed)

    b1, b2 = bbox
    x_min, y_min, z_min = b1
    x_max, y_max, z_max = b2

    done = 0
    generated_verts = []
    generated_radiuses = []
    iterations = 0
    while done &lt; count:
        iterations += 1
        if iterations &gt; MAX_ITERATIONS:
            sv_logger.error(&#34;Maximum number of iterations (%s) reached, stop.&#34;, MAX_ITERATIONS)
            break
        batch_xs = []
        batch_ys = []
        batch_zs = []
        batch = []
        left = count - done
        max_size = min(BATCH_SIZE, left)
        for i in range(max_size):
            x = random.uniform(x_min, x_max)
            y = random.uniform(y_min, y_max)
            z = random.uniform(z_min, z_max)
            batch_xs.append(x)
            batch_ys.append(y)
            batch_zs.append(z)
            batch.append((x, y, z))
        batch_xs = np.array(batch_xs)#[np.newaxis][np.newaxis]
        batch_ys = np.array(batch_ys)#[np.newaxis][np.newaxis]
        batch_zs = np.array(batch_zs)#[np.newaxis][np.newaxis]
        batch = np.array(batch)

        if field is None:
            candidates = batch.tolist()
        else:
            values = field.evaluate_grid(batch_xs, batch_ys, batch_zs)
            good_idxs = values &gt;= threshold
            if not proportional:
                candidates = batch[good_idxs].tolist()
            else:
                candidates = []
                for vert, value in zip(batch[good_idxs].tolist(), values[good_idxs].tolist()):
                    probe = random.uniform(field_min, field_max)
                    if probe &lt;= value:
                        candidates.append(vert)

        good_radiuses = []
        if min_r == 0 and min_r_field is None:
            good_verts = candidates
            good_radiuses = [0 for i in range(len(good_verts))]
        elif min_r_field is not None:
            xs = np.array([p[0] for p in candidates])
            ys = np.array([p[1] for p in candidates])
            zs = np.array([p[2] for p in candidates])
            min_rs = min_r_field.evaluate_grid(xs, ys, zs).tolist()
            good_verts = []
            for candidate, min_r in zip(candidates, min_rs):
                if random_radius:
                    min_r = random.uniform(0, min_r)
                if _check_min_radius(candidate, generated_verts + good_verts, generated_radiuses + good_radiuses, min_r):
                    good_verts.append(candidate)
                    good_radiuses.append(min_r)
        else: # min_r != 0
            good_verts = []
            for candidate in candidates:
                if _check_min_distance(candidate, generated_verts + good_verts, min_r):
                    good_verts.append(candidate)
            good_radiuses = [1 for c in good_verts]

        if predicate is not None:
            pairs = [(vert, r) for vert, r in zip(good_verts, good_radiuses) if predicate(vert)]
            good_verts = [p[0] for p in pairs]
            good_radiuses = [p[1] for p in pairs]

        generated_verts.extend(good_verts)
        generated_radiuses.extend(good_radiuses)
        done += len(good_verts)

    return generated_verts, generated_radiuses</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.field" href="index.html">sverchok.utils.field</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.field.probe.field_random_probe" href="#sverchok.utils.field.probe.field_random_probe">field_random_probe</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>