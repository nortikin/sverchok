<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.curve.catmull_rom API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.curve.catmull_rom</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import numpy as np

from sverchok.utils.geom import Spline, LineEquation, bounding_box, are_points_coplanar, get_common_plane
from sverchok.utils.nurbs_common import SvNurbsMaths
from sverchok.utils.curve.core import SvCurve, UnsupportedCurveTypeException
from sverchok.utils.curve.bezier import SvBezierCurve, SvCubicBezierCurve
from sverchok.utils.curve.nurbs_algorithms import concatenate_nurbs_curves

bezierM = np.zeros((4,4))
bezierM[:,0] = 1.0
bezierM[3,:] = 1.0
bezierM[1,1] = 1.0/3.0
bezierM[2,1] = 2.0/3.0
bezierM[2,2] = 1.0/3.0

def prepare_data(tknots, points, cyclic=False):
    &#34;&#34;&#34;
    Prepare tknots and points for use in Catmull-Rom spline:
    * For non-cyclic curve, add one point in the beginning, by mirroring
      the 2nd point around the first, and one point in the end, in a similar
      way. Similarly, mirror T knot values.
    * For a cyclic curve, add one point in the beginning, equal to the last
      of initial points; and add two points in the end, equal to the first
      and the second of initial points, to make a wrap.
    &#34;&#34;&#34;
    if cyclic:
        points = np.concatenate(([points[-1]], points), axis=0)
        points = np.append(points, [points[1], points[2]], axis=0)

        if tknots is not None:
            dt0 = tknots[1] - tknots[0]
            dt1 = tknots[-1] - tknots[-2]
            dt = (dt0 + dt1) * 0.5
            tknots = np.concatenate(([tknots[0] - dt], tknots), axis=0)
            tknots = np.append(tknots, [tknots[-1] + dt, tknots[-1] + dt + dt0], axis=0)
    else:
        p0 = 2*points[0] - points[1]
        pn = 2*points[-1] - points[-2]
        points = np.insert(points, 0, p0, axis=0)
        points = np.append(points, [pn], axis=0)

        if tknots is not None:
            t0 = 2*tknots[0] - tknots[1]
            tn = 2*tknots[-1] - tknots[-2]
            tknots = np.insert(tknots, 0, t0, axis=0)
            tknots = np.append(tknots, [tn], axis=0)
    return tknots, points

class SvUniformCatmullRomCurve(SvCurve):
    &#34;&#34;&#34;
    Uniform Catmull-Rom spline, allowing to specify
    tension value for each segment.
    &#34;&#34;&#34;
    def __init__(self, points, tensions):
        self.points = np.asarray(points)
        self.tensions = np.asarray(tensions)
        self.__description__ = f&#34;Uniform Catmull-Rom[{len(self.points)}]&#34;

    @classmethod
    def build(cls, points, cyclic=False, tensions=None):
        points = np.asarray(points)
        if tensions is None:
            tensions = np.ones((len(points)-3,))
        _, points = prepare_data(None, points, cyclic=cyclic)
        if cyclic:
            t0 = tensions[0]
            tn = tensions[-1]
            ts = (t0 + tn)*0.5
            tensions = np.insert(tensions, 0, ts, axis=0)
            tensions = np.append(tensions, [ts], axis=0)
        else:
            tensions = np.insert(tensions, 0, 1.0, axis=0)
            tensions = np.append(tensions, [1.0], axis=0)

        return SvUniformCatmullRomCurve(points, tensions)

    def get_u_bounds(self):
        n = len(self.points)
        return (0.0, float(n)-3)

    def get_end_points(self):
        return self.points[1], self.points[-2]

    def get_degree(self):
        return 3

    def _make_uniform_tknots(self):
        n = len(self.points)
        return np.arange(-1.0, n-1)

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        # Calculate non-uniform Catmull-Rom spline
        # by Barry &amp; Goldman formulas.
        n = len(self.points)
        tknots = self._make_uniform_tknots()
        i = tknots.searchsorted(ts, side=&#39;right&#39;)-1
        i = np.clip(i, 1, n-3)
        u = ts - tknots[i]
        n_points = len(ts)

        tau = self.tensions[i]

        M = np.zeros((n_points,4,4))
        M[:,0,1] = 2.0
        M[:,1,0] = -tau
        M[:,1,2] = tau
        M[:,2,0] = 2*tau
        M[:,2,1] = tau - 6
        M[:,2,2] = -2*(tau-3)
        M[:,2,3] = -tau
        M[:,3,0] = -tau
        M[:,3,1] = 4-tau
        M[:,3,2] = tau-4
        M[:,3,3] = tau
        M *= 0.5

        P = np.empty((n_points,4,3))
        P[:,0] = self.points[i-1]
        P[:,1] = self.points[i]
        P[:,2] = self.points[i+1]
        P[:,3] = self.points[i+2]

        U = np.ones((n_points,1,4))
        U[:,0,1] = u
        U[:,0,2] = u**2
        U[:,0,3] = u**3

        R = U @ M @ P

        return R[:,0,:]

    def to_bezier_segments(self):
        segments = []
        n = len(self.points)
        for i in range(n-3):
            spline_cpts = self.points[i:i+4]
            print(f&#34;I {i} =&gt; tension {self.tensions[i+1]}&#34;)
            segment = uniform_catmull_rom_bezier_segment(spline_cpts, self.tensions[i+1])
            segments.append(segment)
        return segments

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        return concatenate_nurbs_curves(self.to_bezier_segments(), tolerance=None)

    def get_control_points(self):
        return self.to_nurbs().get_control_points()

    def is_line(self):
        pts = self.points
        begin, end = pts[0], pts[-1]
        # direction from first to last point of the curve
        direction = end - begin
        if np.linalg.norm(direction) &lt; tolerance:
            return True
        line = LineEquation.from_direction_and_point(direction, begin)
        distances = line.distance_to_points(pts[1:-1])
        # Technically, this means that all control points lie
        # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
        # As a consequence, the convex hull of control points lie in the
        # same cylinder; and the curve lies in that convex hull.
        return (distances &lt; tolerance).all()

    def get_bounding_box(self):
        return bounding_box(self.points)

    def reverse(self):
        return SvUniformCatmullRomCurve(self.points[::-1])

    def reparametrize(self, new_t_min, new_t_max):
        tknots = self._make_uniform_tknots()
        t0 = tknots[0]
        tn = tknots[-1]
        tknots = (new_t_max - new_t_min) * (self.tknots - t0) / (tn - t0) + new_t_min
        return SvCatmullRomCurve(tknots, self.points)

    def is_rational(self):
        return False

    def is_planar(self, tolerance=1e-6):
        return are_points_coplanar(self.points, tolerance)

    def get_plane(self, tolerance=1e-6):
        return get_common_plane(self.points, tolerance)

    def concatenate(self, curve2, tolerance=None):
        curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
        if curve2 is None:
            raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
        return self.to_nurbs().concatenate(curve2, tolerance=tolerance)

    def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
        return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)
    
    def extrude_along_vector(self, vector):
        return self.to_nurbs().extrude_along_vector(vector)

    def make_ruled_surface(self, curve2, vmin, vmax):
        return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)

    def extrude_to_point(self, point):
        return self.to_nurbs().extrude_to_point(point)

    def lerp_to(self, curve2, coefficient):
        return self.to_nurbs().lerp_to(curve2, coefficient)
        
class SvCatmullRomCurve(SvUniformCatmullRomCurve):
    &#34;&#34;&#34;
    Non-uniform Catmull-Rom cubic spline.
    See https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
    &#34;&#34;&#34;
    def __init__(self, tknots, points):
        self.points = np.asarray(points)
        self.tknots = np.asarray(tknots)
        self.__description__ = f&#34;Catmull-Rom[{len(self.points)}]&#34;

    @classmethod
    def build(cls, points, tknots=None, metric=&#39;DISTANCE&#39;, cyclic=False):
        points = np.asarray(points)
        if tknots is not None:
            tknots = np.asarray(tknots)
        else:
            tknots = Spline.create_knots(points, metric=metric)
        tknots, points = prepare_data(tknots, points, cyclic=cyclic)
        return SvCatmullRomCurve(tknots, points)

    def get_u_bounds(self):
        return self.tknots[1], self.tknots[-2]

    def evaluate_array(self, ts):
        i = self.tknots.searchsorted(ts, side=&#39;right&#39;)-1
        i = np.clip(i, 1, len(self.tknots)-3)
        tknots = self.tknots[np.newaxis].T
        t0 = tknots[i-1]
        t1 = tknots[i]
        t2 = tknots[i+1]
        t3 = tknots[i+2]

        p0 = self.points[i-1]
        p1 = self.points[i]
        p2 = self.points[i+1]
        p3 = self.points[i+2]

        t20 = t2 - t0
        t31 = t3 - t1
        t10 = t1 - t0
        t21 = t2 - t1
        t32 = t3 - t2

        ts = ts[np.newaxis].T
        t0s = t0 - ts
        t1s = t1 - ts
        t2s = t2 - ts
        t3s = t3 - ts

        a1 = (p0 * t1s - p1 * t0s) / t10
        a2 = (p1 * t2s - p2 * t1s) / t21
        a3 = (p2 * t3s - p3 * t2s) / t32

        b1 = (a1 * t2s - a2 * t0s) / t20
        b2 = (a2 * t3s - a3 * t1s) / t31

        c = (b1 * t2s - b2 * t1s) / t21
        return c

    def get_bezier_control_points(self):
        # The derivation of formulas used in this method is as follows.
        # 1. Take formulas for non-uniform Catmull-Rom splines.
        # 2. Write them in matrix form:
        #
        # C = [ 1, t, t^2, t^3] * M * column(P0, P1, P2, P3)
        #
        # (P0 - P3 are control points for Catmull-Rom spline).
        # Coefficients of the M (4x4) matrix will be some formulas in terms of
        # T knot values (t0 - t3).
        #
        # 3. Write similar equation for cubic Bezier spline:
        #
        # C = [1, t, t^2, t^3] * B * column(B0, B1, B2, B3)
        # (B0 - B3 are control points for Bezier spline).
        # Coefficients for B matrix are well known:
        # 
        #     / 1   0  0 0 \
        # B = | -3  3  0 0 |
        #     |  3 -6  3 0 |
        #     \ -1  3 -3 1 /
        #
        # 4. Equate right-hand sides of these two equations, and note
        # that the component with T is the same, then remaining must be
        # the same too:
        #
        # M * column(P0, P1, P2, P3) = B * column(B0, B1, B2, B3)
        #
        # 5. Then, obviously, we can write
        #
        # column(B0, B1, B2, B3) = B^{-1} * M * column(P0, P1, P2, P3)
        #
        # 6. Above is the formula for Bezier control points, which is valid when
        # T is in [t0 .. t3] segment. But usual formulation of Bezier curve
        # assumes that it&#39;s parameter goes from 0 to 1. So, let&#39;s introduce
        # a parameter U as
        #
        # u = (t - t0) / (t3 - t0)

        # which goes from 0 to 1 when T goes from t0 to t3. Now if we express
        # u^2 and u^3 in terms of T, we will have
        #
        # [1, u, u^2, u^3] = U * [1, t, t^2, t^3]
        #
        # where U is some 4x4 (lower-triangular) matrix, coefficients of which
        # are some polynomials in terms of t0 and t3.
        #
        # 7. Gathering all the above together, we will have that
        #
        # column(B0&#39;, B1&#39;, B2&#39;, B3&#39;) = B^{-1} * U * M * column(P0, P1, P2, P3)
        #
        n = len(self.tknots)
        tk = self.tknots
        t0 = tk[0:n-3]
        t1 = tk[1:n-2]
        t2 = tk[2:n-1]
        t3 = tk[3:n]
        dt10 = t1 - t0
        dt20 = t2 - t0
        dt30 = t3 - t0
        dt21 = t2 - t1
        dt31 = t3 - t1
        dt32 = t3 - t2
        
        t01 = t0*t1
        t02 = t0*t2
        t12 = t1*t2
        t13 = t1*t3
        t23 = t2*t3
        
        t012 = t0*t1*t2
        t013 = t0*t1*t3
        t023 = t0*t2*t3
        t123 = t1*t2*t3

        # Formulas for M matrix coefficients all have rational form:
        # numerator / denominator,
        # where numerator and denominator are some polynomial in terms of t0 - t3.
        # Nice thing is that all formulas in each column of M matrix have the
        # same denominator.
        
        denom = np.zeros((n-3,4,4))
        denom[:,0,0] = 1.0/(dt10*dt20*dt21)
        denom[:,1,1] = 1.0/(dt10*dt21**2*dt31)
        denom[:,2,2] = 1.0/(dt20*dt21**2*dt32)
        denom[:,3,3] = 1.0/(dt21*dt31*dt32)
        
        numer = np.zeros((n-3,4,4))
        numer[:,0,0] = t1*t2**2
        numer[:,0,1] = -t2*(t023 + t1**2*t3 - t013 - t012)
        numer[:,0,2] =  t1*(t123 + t023 - t013 - t0*t2**2)
        numer[:,0,3] = -t1**2*t2
        numer[:,1,0] = -t2*(t2 + 2*t1)
        numer[:,1,1] = t2**2*t3 + t123 + t023 + t1**2*t3 - t013 - t1*t2**2 + t1**2*t2 - 3*t012
        numer[:,1,2] = -(3*t123 + t023 - t013 - t1*t2**2 - t0*t2**2 + t1**2*t2 - t012 - t0*t1**2)
        numer[:,1,3] = t1*(2*t2 + t1)
        numer[:,2,0] = 2*t2 + t1
        numer[:,2,1] = -(2*t23 + t13 - t12 - t02 + t1**2 - 2*t01)
        numer[:,2,2] =   2*t23 + t13 - t2**2 + t12 - t02 - 2*t01
        numer[:,2,3] = -(t2 + 2*t1)
        numer[:,3,0] = -1.0
        numer[:,3,1] = dt30
        numer[:,3,2] = -dt30
        numer[:,3,3] = 1.0
        
        U = np.zeros((n-3,4,4))
        U[:,0,0] = 1.0
        U[:,0,1] = t1
        U[:,0,2] = t1**2
        U[:,0,3] = t1**3
        U[:,1,1] = dt21
        U[:,1,2] = 2*t1*dt21
        U[:,1,3] = 3*t1**2*dt21
        U[:,2,2] = dt21**2
        U[:,2,3] = 3*t1*dt21**2
        U[:,3,3] = dt21**3
        
        bz = np.zeros((n-3,4,4))
        bz[:] = bezierM
        ms = (bz @ U @ numer) @ denom
        cpts = []
        for i,m in enumerate(ms):
            ps = self.points[i:i+4]
            cpt = m @ ps
            cpts.append(cpt)
        return np.array(cpts)

    def to_bezier_segments(self):
        segments = []
        all_cpts = self.get_bezier_control_points()
        for i, cpts in enumerate(all_cpts):
            bezier = SvBezierCurve.from_control_points(cpts)
            segments.append(bezier)
        return segments

    def reverse(self):
        points = self.points[::-1]
        t0 = self.tknots[0]
        tn = self.tknots[-1]
        tknots = tn + t0 - self.tknots[::-1]
        return SvCatmullRomCurve(tknots, points)

    def reparametrize(self, new_t_min, new_t_max):
        t0 = self.tknots[0]
        tn = self.tknots[-1]
        tknots = (new_t_max - new_t_min) * (self.tknots - t0) / (tn - t0) + new_t_min
        return SvCatmullRomCurve(tknots, self.points)

def uniform_catmull_rom_bezier_segment(points, tension=1.0):
    v = np.asarray(points)
    p0 = v[1]
    p1 = v[1] + tension*(v[2] - v[0]) / 6
    p2 = v[2] - tension*(v[3] - v[1]) / 6
    p3 = v[2]
    return SvCubicBezierCurve(p0, p1, p2, p3)

def uniform_catmull_rom_bezier_interpolate(points, concatenate=True, cyclic=False, tension=1.0):
    points = np.asarray(points)
    if isinstance(tension, (list, np.ndarray)):
        tensions = tension
    else:
        tensions = np.full((len(points)-3,), tension)
    _, points = prepare_data(None, points, cyclic=cyclic)

    segments = []
    for i in range(len(points)-3):
        spline_cpts = points[i:i+4]
        segment = uniform_catmull_rom_bezier_segment(spline_cpts, tensions[i])
        segments.append(segment)
    if concatenate:
        return concatenate_nurbs_curves(segments)
    else:
        return segments</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.curve.catmull_rom.prepare_data"><code class="name flex">
<span>def <span class="ident">prepare_data</span></span>(<span>tknots, points, cyclic=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare tknots and points for use in Catmull-Rom spline:
* For non-cyclic curve, add one point in the beginning, by mirroring
the 2nd point around the first, and one point in the end, in a similar
way. Similarly, mirror T knot values.
* For a cyclic curve, add one point in the beginning, equal to the last
of initial points; and add two points in the end, equal to the first
and the second of initial points, to make a wrap.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_data(tknots, points, cyclic=False):
    &#34;&#34;&#34;
    Prepare tknots and points for use in Catmull-Rom spline:
    * For non-cyclic curve, add one point in the beginning, by mirroring
      the 2nd point around the first, and one point in the end, in a similar
      way. Similarly, mirror T knot values.
    * For a cyclic curve, add one point in the beginning, equal to the last
      of initial points; and add two points in the end, equal to the first
      and the second of initial points, to make a wrap.
    &#34;&#34;&#34;
    if cyclic:
        points = np.concatenate(([points[-1]], points), axis=0)
        points = np.append(points, [points[1], points[2]], axis=0)

        if tknots is not None:
            dt0 = tknots[1] - tknots[0]
            dt1 = tknots[-1] - tknots[-2]
            dt = (dt0 + dt1) * 0.5
            tknots = np.concatenate(([tknots[0] - dt], tknots), axis=0)
            tknots = np.append(tknots, [tknots[-1] + dt, tknots[-1] + dt + dt0], axis=0)
    else:
        p0 = 2*points[0] - points[1]
        pn = 2*points[-1] - points[-2]
        points = np.insert(points, 0, p0, axis=0)
        points = np.append(points, [pn], axis=0)

        if tknots is not None:
            t0 = 2*tknots[0] - tknots[1]
            tn = 2*tknots[-1] - tknots[-2]
            tknots = np.insert(tknots, 0, t0, axis=0)
            tknots = np.append(tknots, [tn], axis=0)
    return tknots, points</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.uniform_catmull_rom_bezier_interpolate"><code class="name flex">
<span>def <span class="ident">uniform_catmull_rom_bezier_interpolate</span></span>(<span>points, concatenate=True, cyclic=False, tension=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniform_catmull_rom_bezier_interpolate(points, concatenate=True, cyclic=False, tension=1.0):
    points = np.asarray(points)
    if isinstance(tension, (list, np.ndarray)):
        tensions = tension
    else:
        tensions = np.full((len(points)-3,), tension)
    _, points = prepare_data(None, points, cyclic=cyclic)

    segments = []
    for i in range(len(points)-3):
        spline_cpts = points[i:i+4]
        segment = uniform_catmull_rom_bezier_segment(spline_cpts, tensions[i])
        segments.append(segment)
    if concatenate:
        return concatenate_nurbs_curves(segments)
    else:
        return segments</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.uniform_catmull_rom_bezier_segment"><code class="name flex">
<span>def <span class="ident">uniform_catmull_rom_bezier_segment</span></span>(<span>points, tension=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniform_catmull_rom_bezier_segment(points, tension=1.0):
    v = np.asarray(points)
    p0 = v[1]
    p1 = v[1] + tension*(v[2] - v[0]) / 6
    p2 = v[2] - tension*(v[3] - v[1]) / 6
    p3 = v[2]
    return SvCubicBezierCurve(p0, p1, p2, p3)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve"><code class="flex name class">
<span>class <span class="ident">SvCatmullRomCurve</span></span>
<span>(</span><span>tknots, points)</span>
</code></dt>
<dd>
<div class="desc"><p>Non-uniform Catmull-Rom cubic spline.
See <a href="https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline">https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCatmullRomCurve(SvUniformCatmullRomCurve):
    &#34;&#34;&#34;
    Non-uniform Catmull-Rom cubic spline.
    See https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
    &#34;&#34;&#34;
    def __init__(self, tknots, points):
        self.points = np.asarray(points)
        self.tknots = np.asarray(tknots)
        self.__description__ = f&#34;Catmull-Rom[{len(self.points)}]&#34;

    @classmethod
    def build(cls, points, tknots=None, metric=&#39;DISTANCE&#39;, cyclic=False):
        points = np.asarray(points)
        if tknots is not None:
            tknots = np.asarray(tknots)
        else:
            tknots = Spline.create_knots(points, metric=metric)
        tknots, points = prepare_data(tknots, points, cyclic=cyclic)
        return SvCatmullRomCurve(tknots, points)

    def get_u_bounds(self):
        return self.tknots[1], self.tknots[-2]

    def evaluate_array(self, ts):
        i = self.tknots.searchsorted(ts, side=&#39;right&#39;)-1
        i = np.clip(i, 1, len(self.tknots)-3)
        tknots = self.tknots[np.newaxis].T
        t0 = tknots[i-1]
        t1 = tknots[i]
        t2 = tknots[i+1]
        t3 = tknots[i+2]

        p0 = self.points[i-1]
        p1 = self.points[i]
        p2 = self.points[i+1]
        p3 = self.points[i+2]

        t20 = t2 - t0
        t31 = t3 - t1
        t10 = t1 - t0
        t21 = t2 - t1
        t32 = t3 - t2

        ts = ts[np.newaxis].T
        t0s = t0 - ts
        t1s = t1 - ts
        t2s = t2 - ts
        t3s = t3 - ts

        a1 = (p0 * t1s - p1 * t0s) / t10
        a2 = (p1 * t2s - p2 * t1s) / t21
        a3 = (p2 * t3s - p3 * t2s) / t32

        b1 = (a1 * t2s - a2 * t0s) / t20
        b2 = (a2 * t3s - a3 * t1s) / t31

        c = (b1 * t2s - b2 * t1s) / t21
        return c

    def get_bezier_control_points(self):
        # The derivation of formulas used in this method is as follows.
        # 1. Take formulas for non-uniform Catmull-Rom splines.
        # 2. Write them in matrix form:
        #
        # C = [ 1, t, t^2, t^3] * M * column(P0, P1, P2, P3)
        #
        # (P0 - P3 are control points for Catmull-Rom spline).
        # Coefficients of the M (4x4) matrix will be some formulas in terms of
        # T knot values (t0 - t3).
        #
        # 3. Write similar equation for cubic Bezier spline:
        #
        # C = [1, t, t^2, t^3] * B * column(B0, B1, B2, B3)
        # (B0 - B3 are control points for Bezier spline).
        # Coefficients for B matrix are well known:
        # 
        #     / 1   0  0 0 \
        # B = | -3  3  0 0 |
        #     |  3 -6  3 0 |
        #     \ -1  3 -3 1 /
        #
        # 4. Equate right-hand sides of these two equations, and note
        # that the component with T is the same, then remaining must be
        # the same too:
        #
        # M * column(P0, P1, P2, P3) = B * column(B0, B1, B2, B3)
        #
        # 5. Then, obviously, we can write
        #
        # column(B0, B1, B2, B3) = B^{-1} * M * column(P0, P1, P2, P3)
        #
        # 6. Above is the formula for Bezier control points, which is valid when
        # T is in [t0 .. t3] segment. But usual formulation of Bezier curve
        # assumes that it&#39;s parameter goes from 0 to 1. So, let&#39;s introduce
        # a parameter U as
        #
        # u = (t - t0) / (t3 - t0)

        # which goes from 0 to 1 when T goes from t0 to t3. Now if we express
        # u^2 and u^3 in terms of T, we will have
        #
        # [1, u, u^2, u^3] = U * [1, t, t^2, t^3]
        #
        # where U is some 4x4 (lower-triangular) matrix, coefficients of which
        # are some polynomials in terms of t0 and t3.
        #
        # 7. Gathering all the above together, we will have that
        #
        # column(B0&#39;, B1&#39;, B2&#39;, B3&#39;) = B^{-1} * U * M * column(P0, P1, P2, P3)
        #
        n = len(self.tknots)
        tk = self.tknots
        t0 = tk[0:n-3]
        t1 = tk[1:n-2]
        t2 = tk[2:n-1]
        t3 = tk[3:n]
        dt10 = t1 - t0
        dt20 = t2 - t0
        dt30 = t3 - t0
        dt21 = t2 - t1
        dt31 = t3 - t1
        dt32 = t3 - t2
        
        t01 = t0*t1
        t02 = t0*t2
        t12 = t1*t2
        t13 = t1*t3
        t23 = t2*t3
        
        t012 = t0*t1*t2
        t013 = t0*t1*t3
        t023 = t0*t2*t3
        t123 = t1*t2*t3

        # Formulas for M matrix coefficients all have rational form:
        # numerator / denominator,
        # where numerator and denominator are some polynomial in terms of t0 - t3.
        # Nice thing is that all formulas in each column of M matrix have the
        # same denominator.
        
        denom = np.zeros((n-3,4,4))
        denom[:,0,0] = 1.0/(dt10*dt20*dt21)
        denom[:,1,1] = 1.0/(dt10*dt21**2*dt31)
        denom[:,2,2] = 1.0/(dt20*dt21**2*dt32)
        denom[:,3,3] = 1.0/(dt21*dt31*dt32)
        
        numer = np.zeros((n-3,4,4))
        numer[:,0,0] = t1*t2**2
        numer[:,0,1] = -t2*(t023 + t1**2*t3 - t013 - t012)
        numer[:,0,2] =  t1*(t123 + t023 - t013 - t0*t2**2)
        numer[:,0,3] = -t1**2*t2
        numer[:,1,0] = -t2*(t2 + 2*t1)
        numer[:,1,1] = t2**2*t3 + t123 + t023 + t1**2*t3 - t013 - t1*t2**2 + t1**2*t2 - 3*t012
        numer[:,1,2] = -(3*t123 + t023 - t013 - t1*t2**2 - t0*t2**2 + t1**2*t2 - t012 - t0*t1**2)
        numer[:,1,3] = t1*(2*t2 + t1)
        numer[:,2,0] = 2*t2 + t1
        numer[:,2,1] = -(2*t23 + t13 - t12 - t02 + t1**2 - 2*t01)
        numer[:,2,2] =   2*t23 + t13 - t2**2 + t12 - t02 - 2*t01
        numer[:,2,3] = -(t2 + 2*t1)
        numer[:,3,0] = -1.0
        numer[:,3,1] = dt30
        numer[:,3,2] = -dt30
        numer[:,3,3] = 1.0
        
        U = np.zeros((n-3,4,4))
        U[:,0,0] = 1.0
        U[:,0,1] = t1
        U[:,0,2] = t1**2
        U[:,0,3] = t1**3
        U[:,1,1] = dt21
        U[:,1,2] = 2*t1*dt21
        U[:,1,3] = 3*t1**2*dt21
        U[:,2,2] = dt21**2
        U[:,2,3] = 3*t1*dt21**2
        U[:,3,3] = dt21**3
        
        bz = np.zeros((n-3,4,4))
        bz[:] = bezierM
        ms = (bz @ U @ numer) @ denom
        cpts = []
        for i,m in enumerate(ms):
            ps = self.points[i:i+4]
            cpt = m @ ps
            cpts.append(cpt)
        return np.array(cpts)

    def to_bezier_segments(self):
        segments = []
        all_cpts = self.get_bezier_control_points()
        for i, cpts in enumerate(all_cpts):
            bezier = SvBezierCurve.from_control_points(cpts)
            segments.append(bezier)
        return segments

    def reverse(self):
        points = self.points[::-1]
        t0 = self.tknots[0]
        tn = self.tknots[-1]
        tknots = tn + t0 - self.tknots[::-1]
        return SvCatmullRomCurve(tknots, points)

    def reparametrize(self, new_t_min, new_t_max):
        t0 = self.tknots[0]
        tn = self.tknots[-1]
        tknots = (new_t_max - new_t_min) * (self.tknots - t0) / (tn - t0) + new_t_min
        return SvCatmullRomCurve(tknots, self.points)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve">SvUniformCatmullRomCurve</a></li>
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>points, tknots=None, metric='DISTANCE', cyclic=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, points, tknots=None, metric=&#39;DISTANCE&#39;, cyclic=False):
    points = np.asarray(points)
    if tknots is not None:
        tknots = np.asarray(tknots)
    else:
        tknots = Spline.create_knots(points, metric=metric)
    tknots, points = prepare_data(tknots, points, cyclic=cyclic)
    return SvCatmullRomCurve(tknots, points)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.get_bezier_control_points"><code class="name flex">
<span>def <span class="ident">get_bezier_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bezier_control_points(self):
    # The derivation of formulas used in this method is as follows.
    # 1. Take formulas for non-uniform Catmull-Rom splines.
    # 2. Write them in matrix form:
    #
    # C = [ 1, t, t^2, t^3] * M * column(P0, P1, P2, P3)
    #
    # (P0 - P3 are control points for Catmull-Rom spline).
    # Coefficients of the M (4x4) matrix will be some formulas in terms of
    # T knot values (t0 - t3).
    #
    # 3. Write similar equation for cubic Bezier spline:
    #
    # C = [1, t, t^2, t^3] * B * column(B0, B1, B2, B3)
    # (B0 - B3 are control points for Bezier spline).
    # Coefficients for B matrix are well known:
    # 
    #     / 1   0  0 0 \
    # B = | -3  3  0 0 |
    #     |  3 -6  3 0 |
    #     \ -1  3 -3 1 /
    #
    # 4. Equate right-hand sides of these two equations, and note
    # that the component with T is the same, then remaining must be
    # the same too:
    #
    # M * column(P0, P1, P2, P3) = B * column(B0, B1, B2, B3)
    #
    # 5. Then, obviously, we can write
    #
    # column(B0, B1, B2, B3) = B^{-1} * M * column(P0, P1, P2, P3)
    #
    # 6. Above is the formula for Bezier control points, which is valid when
    # T is in [t0 .. t3] segment. But usual formulation of Bezier curve
    # assumes that it&#39;s parameter goes from 0 to 1. So, let&#39;s introduce
    # a parameter U as
    #
    # u = (t - t0) / (t3 - t0)

    # which goes from 0 to 1 when T goes from t0 to t3. Now if we express
    # u^2 and u^3 in terms of T, we will have
    #
    # [1, u, u^2, u^3] = U * [1, t, t^2, t^3]
    #
    # where U is some 4x4 (lower-triangular) matrix, coefficients of which
    # are some polynomials in terms of t0 and t3.
    #
    # 7. Gathering all the above together, we will have that
    #
    # column(B0&#39;, B1&#39;, B2&#39;, B3&#39;) = B^{-1} * U * M * column(P0, P1, P2, P3)
    #
    n = len(self.tknots)
    tk = self.tknots
    t0 = tk[0:n-3]
    t1 = tk[1:n-2]
    t2 = tk[2:n-1]
    t3 = tk[3:n]
    dt10 = t1 - t0
    dt20 = t2 - t0
    dt30 = t3 - t0
    dt21 = t2 - t1
    dt31 = t3 - t1
    dt32 = t3 - t2
    
    t01 = t0*t1
    t02 = t0*t2
    t12 = t1*t2
    t13 = t1*t3
    t23 = t2*t3
    
    t012 = t0*t1*t2
    t013 = t0*t1*t3
    t023 = t0*t2*t3
    t123 = t1*t2*t3

    # Formulas for M matrix coefficients all have rational form:
    # numerator / denominator,
    # where numerator and denominator are some polynomial in terms of t0 - t3.
    # Nice thing is that all formulas in each column of M matrix have the
    # same denominator.
    
    denom = np.zeros((n-3,4,4))
    denom[:,0,0] = 1.0/(dt10*dt20*dt21)
    denom[:,1,1] = 1.0/(dt10*dt21**2*dt31)
    denom[:,2,2] = 1.0/(dt20*dt21**2*dt32)
    denom[:,3,3] = 1.0/(dt21*dt31*dt32)
    
    numer = np.zeros((n-3,4,4))
    numer[:,0,0] = t1*t2**2
    numer[:,0,1] = -t2*(t023 + t1**2*t3 - t013 - t012)
    numer[:,0,2] =  t1*(t123 + t023 - t013 - t0*t2**2)
    numer[:,0,3] = -t1**2*t2
    numer[:,1,0] = -t2*(t2 + 2*t1)
    numer[:,1,1] = t2**2*t3 + t123 + t023 + t1**2*t3 - t013 - t1*t2**2 + t1**2*t2 - 3*t012
    numer[:,1,2] = -(3*t123 + t023 - t013 - t1*t2**2 - t0*t2**2 + t1**2*t2 - t012 - t0*t1**2)
    numer[:,1,3] = t1*(2*t2 + t1)
    numer[:,2,0] = 2*t2 + t1
    numer[:,2,1] = -(2*t23 + t13 - t12 - t02 + t1**2 - 2*t01)
    numer[:,2,2] =   2*t23 + t13 - t2**2 + t12 - t02 - 2*t01
    numer[:,2,3] = -(t2 + 2*t1)
    numer[:,3,0] = -1.0
    numer[:,3,1] = dt30
    numer[:,3,2] = -dt30
    numer[:,3,3] = 1.0
    
    U = np.zeros((n-3,4,4))
    U[:,0,0] = 1.0
    U[:,0,1] = t1
    U[:,0,2] = t1**2
    U[:,0,3] = t1**3
    U[:,1,1] = dt21
    U[:,1,2] = 2*t1*dt21
    U[:,1,3] = 3*t1**2*dt21
    U[:,2,2] = dt21**2
    U[:,2,3] = 3*t1*dt21**2
    U[:,3,3] = dt21**3
    
    bz = np.zeros((n-3,4,4))
    bz[:] = bezierM
    ms = (bz @ U @ numer) @ denom
    cpts = []
    for i,m in enumerate(ms):
        ps = self.points[i:i+4]
        cpt = m @ ps
        cpts.append(cpt)
    return np.array(cpts)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.reparametrize"><code class="name flex">
<span>def <span class="ident">reparametrize</span></span>(<span>self, new_t_min, new_t_max)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparametrize(self, new_t_min, new_t_max):
    t0 = self.tknots[0]
    tn = self.tknots[-1]
    tknots = (new_t_max - new_t_min) * (self.tknots - t0) / (tn - t0) + new_t_min
    return SvCatmullRomCurve(tknots, self.points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    points = self.points[::-1]
    t0 = self.tknots[0]
    tn = self.tknots[-1]
    tknots = tn + t0 - self.tknots[::-1]
    return SvCatmullRomCurve(tknots, points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.to_bezier_segments"><code class="name flex">
<span>def <span class="ident">to_bezier_segments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bezier_segments(self):
    segments = []
    all_cpts = self.get_bezier_control_points()
    for i, cpts in enumerate(all_cpts):
        bezier = SvBezierCurve.from_control_points(cpts)
        segments.append(bezier)
    return segments</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve">SvUniformCatmullRomCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve"><code class="flex name class">
<span>class <span class="ident">SvUniformCatmullRomCurve</span></span>
<span>(</span><span>points, tensions)</span>
</code></dt>
<dd>
<div class="desc"><p>Uniform Catmull-Rom spline, allowing to specify
tension value for each segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvUniformCatmullRomCurve(SvCurve):
    &#34;&#34;&#34;
    Uniform Catmull-Rom spline, allowing to specify
    tension value for each segment.
    &#34;&#34;&#34;
    def __init__(self, points, tensions):
        self.points = np.asarray(points)
        self.tensions = np.asarray(tensions)
        self.__description__ = f&#34;Uniform Catmull-Rom[{len(self.points)}]&#34;

    @classmethod
    def build(cls, points, cyclic=False, tensions=None):
        points = np.asarray(points)
        if tensions is None:
            tensions = np.ones((len(points)-3,))
        _, points = prepare_data(None, points, cyclic=cyclic)
        if cyclic:
            t0 = tensions[0]
            tn = tensions[-1]
            ts = (t0 + tn)*0.5
            tensions = np.insert(tensions, 0, ts, axis=0)
            tensions = np.append(tensions, [ts], axis=0)
        else:
            tensions = np.insert(tensions, 0, 1.0, axis=0)
            tensions = np.append(tensions, [1.0], axis=0)

        return SvUniformCatmullRomCurve(points, tensions)

    def get_u_bounds(self):
        n = len(self.points)
        return (0.0, float(n)-3)

    def get_end_points(self):
        return self.points[1], self.points[-2]

    def get_degree(self):
        return 3

    def _make_uniform_tknots(self):
        n = len(self.points)
        return np.arange(-1.0, n-1)

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        # Calculate non-uniform Catmull-Rom spline
        # by Barry &amp; Goldman formulas.
        n = len(self.points)
        tknots = self._make_uniform_tknots()
        i = tknots.searchsorted(ts, side=&#39;right&#39;)-1
        i = np.clip(i, 1, n-3)
        u = ts - tknots[i]
        n_points = len(ts)

        tau = self.tensions[i]

        M = np.zeros((n_points,4,4))
        M[:,0,1] = 2.0
        M[:,1,0] = -tau
        M[:,1,2] = tau
        M[:,2,0] = 2*tau
        M[:,2,1] = tau - 6
        M[:,2,2] = -2*(tau-3)
        M[:,2,3] = -tau
        M[:,3,0] = -tau
        M[:,3,1] = 4-tau
        M[:,3,2] = tau-4
        M[:,3,3] = tau
        M *= 0.5

        P = np.empty((n_points,4,3))
        P[:,0] = self.points[i-1]
        P[:,1] = self.points[i]
        P[:,2] = self.points[i+1]
        P[:,3] = self.points[i+2]

        U = np.ones((n_points,1,4))
        U[:,0,1] = u
        U[:,0,2] = u**2
        U[:,0,3] = u**3

        R = U @ M @ P

        return R[:,0,:]

    def to_bezier_segments(self):
        segments = []
        n = len(self.points)
        for i in range(n-3):
            spline_cpts = self.points[i:i+4]
            print(f&#34;I {i} =&gt; tension {self.tensions[i+1]}&#34;)
            segment = uniform_catmull_rom_bezier_segment(spline_cpts, self.tensions[i+1])
            segments.append(segment)
        return segments

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        return concatenate_nurbs_curves(self.to_bezier_segments(), tolerance=None)

    def get_control_points(self):
        return self.to_nurbs().get_control_points()

    def is_line(self):
        pts = self.points
        begin, end = pts[0], pts[-1]
        # direction from first to last point of the curve
        direction = end - begin
        if np.linalg.norm(direction) &lt; tolerance:
            return True
        line = LineEquation.from_direction_and_point(direction, begin)
        distances = line.distance_to_points(pts[1:-1])
        # Technically, this means that all control points lie
        # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
        # As a consequence, the convex hull of control points lie in the
        # same cylinder; and the curve lies in that convex hull.
        return (distances &lt; tolerance).all()

    def get_bounding_box(self):
        return bounding_box(self.points)

    def reverse(self):
        return SvUniformCatmullRomCurve(self.points[::-1])

    def reparametrize(self, new_t_min, new_t_max):
        tknots = self._make_uniform_tknots()
        t0 = tknots[0]
        tn = tknots[-1]
        tknots = (new_t_max - new_t_min) * (self.tknots - t0) / (tn - t0) + new_t_min
        return SvCatmullRomCurve(tknots, self.points)

    def is_rational(self):
        return False

    def is_planar(self, tolerance=1e-6):
        return are_points_coplanar(self.points, tolerance)

    def get_plane(self, tolerance=1e-6):
        return get_common_plane(self.points, tolerance)

    def concatenate(self, curve2, tolerance=None):
        curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
        if curve2 is None:
            raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
        return self.to_nurbs().concatenate(curve2, tolerance=tolerance)

    def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
        return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)
    
    def extrude_along_vector(self, vector):
        return self.to_nurbs().extrude_along_vector(vector)

    def make_ruled_surface(self, curve2, vmin, vmax):
        return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)

    def extrude_to_point(self, point):
        return self.to_nurbs().extrude_to_point(point)

    def lerp_to(self, curve2, coefficient):
        return self.to_nurbs().lerp_to(curve2, coefficient)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve" href="#sverchok.utils.curve.catmull_rom.SvCatmullRomCurve">SvCatmullRomCurve</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>points, cyclic=False, tensions=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, points, cyclic=False, tensions=None):
    points = np.asarray(points)
    if tensions is None:
        tensions = np.ones((len(points)-3,))
    _, points = prepare_data(None, points, cyclic=cyclic)
    if cyclic:
        t0 = tensions[0]
        tn = tensions[-1]
        ts = (t0 + tn)*0.5
        tensions = np.insert(tensions, 0, ts, axis=0)
        tensions = np.append(tensions, [ts], axis=0)
    else:
        tensions = np.insert(tensions, 0, 1.0, axis=0)
        tensions = np.append(tensions, [1.0], axis=0)

    return SvUniformCatmullRomCurve(points, tensions)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.concatenate"><code class="name flex">
<span>def <span class="ident">concatenate</span></span>(<span>self, curve2, tolerance=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate(self, curve2, tolerance=None):
    curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
    if curve2 is None:
        raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
    return self.to_nurbs().concatenate(curve2, tolerance=tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.extrude_along_vector"><code class="name flex">
<span>def <span class="ident">extrude_along_vector</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrude_along_vector(self, vector):
    return self.to_nurbs().extrude_along_vector(vector)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.extrude_to_point"><code class="name flex">
<span>def <span class="ident">extrude_to_point</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrude_to_point(self, point):
    return self.to_nurbs().extrude_to_point(point)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_bounding_box"><code class="name flex">
<span>def <span class="ident">get_bounding_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounding_box(self):
    return bounding_box(self.points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_end_points"><code class="name flex">
<span>def <span class="ident">get_end_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_points(self):
    return self.points[1], self.points[-2]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_plane"><code class="name flex">
<span>def <span class="ident">get_plane</span></span>(<span>self, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plane(self, tolerance=1e-6):
    return get_common_plane(self.points, tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_line"><code class="name flex">
<span>def <span class="ident">is_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_line(self):
    pts = self.points
    begin, end = pts[0], pts[-1]
    # direction from first to last point of the curve
    direction = end - begin
    if np.linalg.norm(direction) &lt; tolerance:
        return True
    line = LineEquation.from_direction_and_point(direction, begin)
    distances = line.distance_to_points(pts[1:-1])
    # Technically, this means that all control points lie
    # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
    # As a consequence, the convex hull of control points lie in the
    # same cylinder; and the curve lies in that convex hull.
    return (distances &lt; tolerance).all()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_planar"><code class="name flex">
<span>def <span class="ident">is_planar</span></span>(<span>self, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_planar(self, tolerance=1e-6):
    return are_points_coplanar(self.points, tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_rational"><code class="name flex">
<span>def <span class="ident">is_rational</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_rational(self):
    return False</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.lerp_to"><code class="name flex">
<span>def <span class="ident">lerp_to</span></span>(<span>self, curve2, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lerp_to(self, curve2, coefficient):
    return self.to_nurbs().lerp_to(curve2, coefficient)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.make_revolution_surface"><code class="name flex">
<span>def <span class="ident">make_revolution_surface</span></span>(<span>self, point, direction, v_min, v_max, global_origin)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
    return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.make_ruled_surface"><code class="name flex">
<span>def <span class="ident">make_ruled_surface</span></span>(<span>self, curve2, vmin, vmax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_ruled_surface(self, curve2, vmin, vmax):
    return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.reparametrize"><code class="name flex">
<span>def <span class="ident">reparametrize</span></span>(<span>self, new_t_min, new_t_max)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparametrize(self, new_t_min, new_t_max):
    tknots = self._make_uniform_tknots()
    t0 = tknots[0]
    tn = tknots[-1]
    tknots = (new_t_max - new_t_min) * (self.tknots - t0) / (tn - t0) + new_t_min
    return SvCatmullRomCurve(tknots, self.points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    return SvUniformCatmullRomCurve(self.points[::-1])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.to_bezier_segments"><code class="name flex">
<span>def <span class="ident">to_bezier_segments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bezier_segments(self):
    segments = []
    n = len(self.points)
    for i in range(n-3):
        spline_cpts = self.points[i:i+4]
        print(f&#34;I {i} =&gt; tension {self.tensions[i+1]}&#34;)
        segment = uniform_catmull_rom_bezier_segment(spline_cpts, self.tensions[i+1])
        segments.append(segment)
    return segments</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.to_nurbs"><code class="name flex">
<span>def <span class="ident">to_nurbs</span></span>(<span>self, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
    return concatenate_nurbs_curves(self.to_bezier_segments(), tolerance=None)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.curve" href="index.html">sverchok.utils.curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.curve.catmull_rom.prepare_data" href="#sverchok.utils.curve.catmull_rom.prepare_data">prepare_data</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.uniform_catmull_rom_bezier_interpolate" href="#sverchok.utils.curve.catmull_rom.uniform_catmull_rom_bezier_interpolate">uniform_catmull_rom_bezier_interpolate</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.uniform_catmull_rom_bezier_segment" href="#sverchok.utils.curve.catmull_rom.uniform_catmull_rom_bezier_segment">uniform_catmull_rom_bezier_segment</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve" href="#sverchok.utils.curve.catmull_rom.SvCatmullRomCurve">SvCatmullRomCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.build" href="#sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.build">build</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.get_bezier_control_points" href="#sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.get_bezier_control_points">get_bezier_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.reparametrize" href="#sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.reparametrize">reparametrize</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.reverse" href="#sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.reverse">reverse</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.to_bezier_segments" href="#sverchok.utils.curve.catmull_rom.SvCatmullRomCurve.to_bezier_segments">to_bezier_segments</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve">SvUniformCatmullRomCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.build" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.build">build</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.concatenate" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.concatenate">concatenate</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.extrude_along_vector" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.extrude_along_vector">extrude_along_vector</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.extrude_to_point" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.extrude_to_point">extrude_to_point</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_bounding_box" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_bounding_box">get_bounding_box</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_end_points" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_end_points">get_end_points</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_plane" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.get_plane">get_plane</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_line" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_line">is_line</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_planar" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_planar">is_planar</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_rational" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.is_rational">is_rational</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.lerp_to" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.lerp_to">lerp_to</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.make_revolution_surface" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.make_revolution_surface">make_revolution_surface</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.make_ruled_surface" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.make_ruled_surface">make_ruled_surface</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.reparametrize" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.reparametrize">reparametrize</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.reverse" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.reverse">reverse</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.to_bezier_segments" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.to_bezier_segments">to_bezier_segments</a></code></li>
<li><code><a title="sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.to_nurbs" href="#sverchok.utils.curve.catmull_rom.SvUniformCatmullRomCurve.to_nurbs">to_nurbs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>