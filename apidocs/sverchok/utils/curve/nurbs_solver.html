<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.curve.nurbs_solver API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.curve.nurbs_solver</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import numpy as np
from collections import defaultdict

from sverchok.utils.logging import getLogger
from sverchok.utils.curve.core import SvCurve
from sverchok.utils.curve import knotvector as sv_knotvector
from sverchok.utils.nurbs_common import SvNurbsBasisFunctions, SvNurbsMaths, from_homogenous
from sverchok.utils.curve.nurbs import SvNurbsCurve

class SvNurbsCurveGoal(object):
    def copy(self):
        raise Exception(&#34;Not implemented&#34;)

    def add(self, other):
        raise Exception(&#34;Not implemented&#34;)
        
    def get_equations(self, solver):
        raise Exception(&#34;Not implemented&#34;)

    def get_n_defined_control_points(self):
        raise Exception(&#34;Not implemented&#34;)

class SvNurbsCurvePoints(SvNurbsCurveGoal):
    def __init__(self, us, points, weights = None, relative=False):
        self.us = np.asarray(us)
        self.vectors = np.asarray(points)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Points at {self.us} = {self.vectors}, relative={self.relative}&gt;&#34;

    @staticmethod
    def single(u, point, weight=None, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurvePoints([u], [point], weights, relative=relative)

    def copy(self):
        return SvNurbsCurvePoints(self.us, self.vectors, self.weights, relative=self.relative)

    def get_weights(self):
        weights = self.weights
        n_points = len(self.vectors)
        if weights is None:
            weights = np.ones((n_points,))
        elif isinstance(weights, np.ndarray) and weights.shape == (1,):
            weights = np.full((n_points,), weights[0])
        elif isinstance(weights, (int,float)):
            weights = np.full((n_points,), weights)
        return weights

    def add(self, other):
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.us = np.concatenate((g.us, other.us))
        g.vectors = np.concatenate((g.vectors, other.vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver, us):
        p = solver.degree
        alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        return alphas

    def get_src_points(self, solver):
        return solver.src_curve.evaluate_array(self.us)

    def get_n_defined_control_points(self):
        return len(self.us)

    def get_equations(self, solver):
        ndim = 3
        us = self.us
        vectors = self.vectors

        n_points = len(vectors)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas = self.calc_alphas(solver, us)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))
        #print(f&#34;A: {A.shape}, W {weights.shape}, n_points {n_points}&#34;)

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * alpha

        if solver.src_curve is None:
            if self.relative:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                src_points = None
        else:
            if self.relative:
                src_points = None
            else:
                src_points = self.get_src_points(solver)

        for pt_idx, point in enumerate(vectors):
            if src_points is not None:
                point = point - src_points[pt_idx]
            B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * point[np.newaxis]

        return A, B

class SvNurbsCurveTangents(SvNurbsCurvePoints):
    def __init__(self, us, tangents, weights = None, relative=False):
        self.us = np.asarray(us)
        self.vectors = np.asarray(tangents)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Tangents at {self.us} = {self.vectors}, relative={self.relative}&gt;&#34;

    @staticmethod
    def single(u, tangent, weight=None, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveTangents([u], [tangent], weights, relative=relative)

    def copy(self):
        return SvNurbsCurveTangents(self.us, self.vectors, self.weights, relative=self.relative)

    def add(self, other):
        if self.relative != other.relative:
            return None
        g = self.copy()
        g.us = np.concatenate((g.us, other.us))
        g.vectors = np.concatenate((g.vectors, other.vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver, us):
        p = solver.degree
        betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return betas
    
    def get_src_points(self, solver):
        return solver.src_curve.tangent_array(self.us)

class SvNurbsCurveSelfIntersections(SvNurbsCurveGoal):
    def __init__(self, us1, us2, weights = None, relative_u=False, relative=False):
        if len(us1) != len(us2):
            raise Exception(&#34;Lengths of us1 and us2 must be equal&#34;)
        self.us1 = np.asarray(us1)
        self.us2 = np.asarray(us2)
        self.relative_u = relative_u
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Self-intersections at {self.us1} x {self.us2}&gt;&#34;

    @staticmethod
    def single(u1, u2, weight=None, relative_u=False, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveSelfIntersections([u1], [u2], weights, relative_u=relative_u, relative=relative)

    def copy(self):
        return SvNurbsCurveSelfIntersections(self.us1, self.us2, self.weights, self.relative_u, self.relative)

    def get_weights(self):
        weights = self.weights
        if weights is None:
            n_points = len(self.us1)
            weights = np.ones((n_points,))
        return weights

    def add(self, other):
        if other.relative_u != self.relative_u:
            return None
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.us1 = np.concatenate((g.us1, other.us1))
        g.us2 = np.concatenate((g.us2, other.us2))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver):
        us1 = self.us1
        us2 = self.us2
        if self.relative_u:
            u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
            us1 = u_min + (u_max - u_min) * us1
            us2 = u_min + (u_max - u_min) * us2
        p = solver.degree
        alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        betas = [solver.basis.fraction(k,p, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return alphas, betas
    
    def calc_vectors(self, solver):
        points1 = solver.src_curve.evaluate_array(self.us1)
        points2 = solver.src_curve.evaluate_array(self.us2)
        return points1, points2

    def get_n_defined_control_points(self):
        return len(self.us1)

    def get_equations(self, solver):
        ndim = 3
        us1 = self.us1
        us2 = self.us2
        p = solver.degree

        n_points = len(us1)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas, betas = self.calc_alphas(solver)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                beta = betas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * (alpha - beta)

        if self.relative:
            if solver.src_curve is None:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                points1, points2 = self.calc_vectors(solver)
                for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                    for dim_idx in range(ndim):
                        B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * (pt2 - pt1)[np.newaxis]

        return A, B

class SvNurbsCurveCotangents(SvNurbsCurveSelfIntersections):
    def __init__(self, us1, us2, weights = None, relative_u=False, relative=False):
        if len(us1) != len(us2):
            raise Exception(&#34;Lengths of us1 and us2 must be equal&#34;)
        self.us1 = np.asarray(us1)
        self.us2 = np.asarray(us2)
        self.relative_u = relative_u
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Equal tangents at {self.us1} x {self.us2}&gt;&#34;

    @staticmethod
    def single(u1, u2, weight=None, relative_u=False, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveCotangents([u1], [u2], weights, relative_u=relative_u, relative=relative)

    def copy(self):
        return SvNurbsCurveCotangents(self.us1, self.us2, self.weights, self.relative_u, self.relative)

    def calc_alphas(self, solver):
        us1 = self.us1
        us2 = self.us2
        if self.relative_u:
            u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
            us1 = u_min + (u_max - u_min) * us1
            us2 = u_min + (u_max - u_min) * us2
        p = solver.degree
        alphas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return alphas, betas
    
    def get_equations(self, solver):
        ndim = 3
        us1 = self.us1
        us2 = self.us2
        p = solver.degree

        n_points = len(us1)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas, betas = self.calc_alphas(solver)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        weight = 1

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                beta = betas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weight * (alpha - beta)

        if self.relative:
            if solver.src_curve is None:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                points1, points2 = self.calc_vectors(solver)
                for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                    for dim_idx in range(ndim):
                        B[pt_idx*3:pt_idx*3+3,0] = weight * (pt2 - pt1)[np.newaxis]

        print(&#34;A&#34;, A)
        print(&#34;B&#34;, B)
        return A, B

    def calc_vectors(self, solver):
        points1 = solver.src_curve.tangent_array(self.us1)
        points2 = solver.src_curve.tangent_array(self.us2)
        print(f&#34;Tg1: {points1}, Tg2: {points2}&#34;)
        return points1, points2

class SvNurbsCurveControlPoints(SvNurbsCurveGoal):
    def __init__(self, cpt_idxs, cpt_vectors, weights = None, relative=True):
        self.cpt_idxs = np.asarray(cpt_idxs)
        self.cpt_vectors = np.asarray(cpt_vectors)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    @staticmethod
    def single(idx, vector, weight=None, relative=True):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveControlPoints([idx], [vector], weights=weights, relative=relative)

    def get_weights(self):
        weights = self.weights
        n_points = len(self.cpt_vectors)
        if weights is None:
            weights = np.ones((n_points,))
        return weights

    def copy(self):
        return SvNurbsCurveControlPoints(self.cpt_idxs, self.cpt_vectors, self.weights, self.relative)

    def add(self, other):
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.cpt_idxs = np.concatenate((g.cpt_idxs, other.cpt_idxs))
        g.cpt_vectors = np.concatenate((g.cpt_vectors, other.cpt_vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def get_n_defined_control_points(self):
        return len(self.cpt_idxs)

    def get_equations(self, solver):
        ndim = 3

        n_points = len(self.cpt_vectors)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        for pt_idx, cpt_idx in enumerate(self.cpt_idxs):
            for dim_idx in range(ndim):
                A[dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx]

        if solver.src_curve is None:
            if self.relative:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                src_points = None
        else:
            if self.relative:
                src_points = None
            else:
                src_points = solver.src_curve.get_control_points()

        for pt_idx, (cpt_idx, point) in enumerate(zip(self.cpt_idxs, self.cpt_vectors)):
            if src_points is not None:
                point = point - src_points[cpt_idx]
            B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * point[np.newaxis]

        return A, B

class SvNurbsCurveSolver(SvCurve):
    def __init__(self, degree=None, src_curve=None):
        if degree is None and src_curve is None:
            raise Exception(&#34;Either degree or src_curve must be provided&#34;)
        elif degree is not None and src_curve is not None and src_curve.get_degree() != degree:
            raise Exception(&#34;If src_curve is provided, then degree must not be provided&#34;)
        self.src_curve = src_curve
        if src_curve is not None and degree is None:
            self.degree = src_curve.get_degree()
        else:
            self.degree = degree
        self.n_cpts = None
        self.curve_weights = None
        self.knotvector = None
        self.goals = []
        self.A = self.B = None

    def copy(self):
        solver = SvNurbsCurveSolver(degree=self.degree, src_curve=self.src_curve)
        solver.n_cpts = self.n_cpts
        solver.curve_weights = self.curve_weights
        solver.knotvector = self.knotvector
        solver.goals = self.goals[:]
        solver.A = self.A
        solver.B = self.B
        return solver

    def evaluate(self, t):
        return self.to_nurbs().evaluate(t)

    def evaluate_array(self, ts):
        return self.to_nurbs().evaluate_array(ts)

    def get_u_bounds(self):
        return self.to_nurbs().get_u_bounds()

    def get_degree(self):
        return self.degree

    def get_control_points(self):
        return self.to_nurbs().get_control_points()

    def set_curve_weights(self, weights):
        if len(weights) != self.n_cpts:
            raise Exception(&#34;Number of weights must be equal to the number of control points&#34;)
        self.curve_weights = np.asarray(weights)

    def set_curve_params(self, n_cpts, knotvector = None, weights = None):
        self.n_cpts = n_cpts
        if knotvector is not None:
            err = sv_knotvector.check(self.degree, knotvector, n_cpts)
            if err is not None:
                raise Exception(err)
            self.knotvector = np.asarray(knotvector)
        else:
            self.knotvector = sv_knotvector.generate(self.degree, n_cpts)
        self.curve_weights = weights

    def guess_curve_params(self):
        n_equations = sum(g.get_n_defined_control_points() for g in self.goals)
        self.n_cpts = n_equations
        self.knotvector = sv_knotvector.generate(self.degree, self.n_cpts)

    def add_goal(self, goal):
        self.goals.append(goal)

    def set_goals(self, goals):
        self.goals = goals[:]

    def _sort_goals(self):
        goal_dict = defaultdict(list)
        for goal in self.goals:
            goal_dict[type(goal)].append(goal)
        goals = []
        for clazz in goal_dict:
            clz_goals = goal_dict[clazz]
            #print(f&#34;Merging goals of class {clazz}: {clz_goals}&#34;)
            merged_goal = clz_goals[0]
            g = merged_goal
            for other_goal in clz_goals[1:]:
                g = merged_goal.add(other_goal)
                #print(f&#34;{merged_goal} + {other_goal} = {g}&#34;)
                if g is not None:
                    merged_goal = g
                else:
                    goals.append(merged_goal)
                    merged_goal = other_goal
            goals.append(merged_goal)
        #print(f&#34;Merge result: {goals}&#34;)
        self.goals = goals

    def _init(self):
        if self.n_cpts is None:
            raise Exception(&#34;Number of control points is not specified; specify it in the constructor, in set_curve_params() call, or call guess_curve_params()&#34;)
        if self.knotvector is None:
            raise Exception(&#34;Knotvector is not specified; specify it in the constructor, in set_curve_params() call, or call guess_curve_params()&#34;)
        ndim = 3
        n = self.n_cpts
        p = self.degree
        if self.curve_weights is None:
            self.curve_weights = np.ones((n,))
        self.basis = SvNurbsBasisFunctions(self.knotvector)

        self._sort_goals()
        As = []
        Bs = []
        for goal in self.goals:
            Ai, Bi = goal.get_equations(self)
            As.append(Ai)
            Bs.append(Bi)
        self.A = np.concatenate(As)
        self.B = np.concatenate(Bs)

    def solve(self, implementation = SvNurbsMaths.NATIVE, logger = None):
        self._init()

        ndim = 3
        n = self.n_cpts
        n_equations, n_unknowns = self.A.shape
        #print(f&#34;A: {self.A.shape}&#34;)
        if n_equations == n_unknowns:
            print(f&#34;Solving well-determined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            try:
                A1 = np.linalg.inv(self.A)
                X = (A1 @ self.B).T
            except np.linalg.LinAlgError as e:
                print(self.A)
                raise Exception(f&#34;Can not solve: #equations = {n_equations}, #unknowns = {n_unknowns}: {e}&#34;) from e
        elif n_equations &lt; n_unknowns:
            print(f&#34;Solving underdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            A1 = np.linalg.pinv(self.A)
            X = (A1 @ self.B).T
        else: # n_equations &gt; n_unknowns
            print(f&#34;Solving overdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            X, residues, rank, singval = np.linalg.lstsq(self.A, self.B)
            print(residues)
            
        d_cpts = X.reshape((n, ndim))
        if self.src_curve is None:
            return SvNurbsCurve.build(implementation, self.degree, self.knotvector, d_cpts, self.curve_weights)
        else:
            cpts = self.src_curve.get_control_points() + d_cpts
            return SvNurbsCurve.build(implementation, self.degree, self.knotvector, cpts, self.curve_weights)

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        solver = self.copy()
        solver.guess_curve_params()
        return solver.solve(implementation = implementation)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveControlPoints</span></span>
<span>(</span><span>cpt_idxs, cpt_vectors, weights=None, relative=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveControlPoints(SvNurbsCurveGoal):
    def __init__(self, cpt_idxs, cpt_vectors, weights = None, relative=True):
        self.cpt_idxs = np.asarray(cpt_idxs)
        self.cpt_vectors = np.asarray(cpt_vectors)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    @staticmethod
    def single(idx, vector, weight=None, relative=True):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveControlPoints([idx], [vector], weights=weights, relative=relative)

    def get_weights(self):
        weights = self.weights
        n_points = len(self.cpt_vectors)
        if weights is None:
            weights = np.ones((n_points,))
        return weights

    def copy(self):
        return SvNurbsCurveControlPoints(self.cpt_idxs, self.cpt_vectors, self.weights, self.relative)

    def add(self, other):
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.cpt_idxs = np.concatenate((g.cpt_idxs, other.cpt_idxs))
        g.cpt_vectors = np.concatenate((g.cpt_vectors, other.cpt_vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def get_n_defined_control_points(self):
        return len(self.cpt_idxs)

    def get_equations(self, solver):
        ndim = 3

        n_points = len(self.cpt_vectors)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        for pt_idx, cpt_idx in enumerate(self.cpt_idxs):
            for dim_idx in range(ndim):
                A[dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx]

        if solver.src_curve is None:
            if self.relative:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                src_points = None
        else:
            if self.relative:
                src_points = None
            else:
                src_points = solver.src_curve.get_control_points()

        for pt_idx, (cpt_idx, point) in enumerate(zip(self.cpt_idxs, self.cpt_vectors)):
            if src_points is not None:
                point = point - src_points[cpt_idx]
            B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * point[np.newaxis]

        return A, B</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>idx, vector, weight=None, relative=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(idx, vector, weight=None, relative=True):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveControlPoints([idx], [vector], weights=weights, relative=relative)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if other.relative != self.relative:
        return None
    g = self.copy()
    g.cpt_idxs = np.concatenate((g.cpt_idxs, other.cpt_idxs))
    g.cpt_vectors = np.concatenate((g.cpt_vectors, other.cpt_vectors))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveControlPoints(self.cpt_idxs, self.cpt_vectors, self.weights, self.relative)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = 3

    n_points = len(self.cpt_vectors)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))

    for pt_idx, cpt_idx in enumerate(self.cpt_idxs):
        for dim_idx in range(ndim):
            A[dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx]

    if solver.src_curve is None:
        if self.relative:
            raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            src_points = None
    else:
        if self.relative:
            src_points = None
        else:
            src_points = solver.src_curve.get_control_points()

    for pt_idx, (cpt_idx, point) in enumerate(zip(self.cpt_idxs, self.cpt_vectors)):
        if src_points is not None:
            point = point - src_points[cpt_idx]
        B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * point[np.newaxis]

    return A, B</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    return len(self.cpt_idxs)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    weights = self.weights
    n_points = len(self.cpt_vectors)
    if weights is None:
        weights = np.ones((n_points,))
    return weights</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveCotangents</span></span>
<span>(</span><span>us1, us2, weights=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveCotangents(SvNurbsCurveSelfIntersections):
    def __init__(self, us1, us2, weights = None, relative_u=False, relative=False):
        if len(us1) != len(us2):
            raise Exception(&#34;Lengths of us1 and us2 must be equal&#34;)
        self.us1 = np.asarray(us1)
        self.us2 = np.asarray(us2)
        self.relative_u = relative_u
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Equal tangents at {self.us1} x {self.us2}&gt;&#34;

    @staticmethod
    def single(u1, u2, weight=None, relative_u=False, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveCotangents([u1], [u2], weights, relative_u=relative_u, relative=relative)

    def copy(self):
        return SvNurbsCurveCotangents(self.us1, self.us2, self.weights, self.relative_u, self.relative)

    def calc_alphas(self, solver):
        us1 = self.us1
        us2 = self.us2
        if self.relative_u:
            u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
            us1 = u_min + (u_max - u_min) * us1
            us2 = u_min + (u_max - u_min) * us2
        p = solver.degree
        alphas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return alphas, betas
    
    def get_equations(self, solver):
        ndim = 3
        us1 = self.us1
        us2 = self.us2
        p = solver.degree

        n_points = len(us1)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas, betas = self.calc_alphas(solver)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        weight = 1

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                beta = betas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weight * (alpha - beta)

        if self.relative:
            if solver.src_curve is None:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                points1, points2 = self.calc_vectors(solver)
                for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                    for dim_idx in range(ndim):
                        B[pt_idx*3:pt_idx*3+3,0] = weight * (pt2 - pt1)[np.newaxis]

        print(&#34;A&#34;, A)
        print(&#34;B&#34;, B)
        return A, B

    def calc_vectors(self, solver):
        points1 = solver.src_curve.tangent_array(self.us1)
        points2 = solver.src_curve.tangent_array(self.us2)
        print(f&#34;Tg1: {points1}, Tg2: {points2}&#34;)
        return points1, points2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections">SvNurbsCurveSelfIntersections</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u1, u2, weight=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u1, u2, weight=None, relative_u=False, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveCotangents([u1], [u2], weights, relative_u=relative_u, relative=relative)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver):
    us1 = self.us1
    us2 = self.us2
    if self.relative_u:
        u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
        us1 = u_min + (u_max - u_min) * us1
        us2 = u_min + (u_max - u_min) * us2
    p = solver.degree
    alphas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
    alphas = np.array(alphas) # (n_cpts, n_points)
    betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
    betas = np.array(betas) # (n_cpts, n_points)
    return alphas, betas</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_vectors"><code class="name flex">
<span>def <span class="ident">calc_vectors</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_vectors(self, solver):
    points1 = solver.src_curve.tangent_array(self.us1)
    points2 = solver.src_curve.tangent_array(self.us2)
    print(f&#34;Tg1: {points1}, Tg2: {points2}&#34;)
    return points1, points2</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveCotangents(self.us1, self.us2, self.weights, self.relative_u, self.relative)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = 3
    us1 = self.us1
    us2 = self.us2
    p = solver.degree

    n_points = len(us1)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    alphas, betas = self.calc_alphas(solver)

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))

    weight = 1

    for pt_idx in range(n_points):
        for cpt_idx in range(solver.n_cpts):
            alpha = alphas[cpt_idx][pt_idx]
            beta = betas[cpt_idx][pt_idx]
            for dim_idx in range(ndim):
                A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weight * (alpha - beta)

    if self.relative:
        if solver.src_curve is None:
            raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            points1, points2 = self.calc_vectors(solver)
            for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                for dim_idx in range(ndim):
                    B[pt_idx*3:pt_idx*3+3,0] = weight * (pt2 - pt1)[np.newaxis]

    print(&#34;A&#34;, A)
    print(&#34;B&#34;, B)
    return A, B</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveGoal</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveGoal(object):
    def copy(self):
        raise Exception(&#34;Not implemented&#34;)

    def add(self, other):
        raise Exception(&#34;Not implemented&#34;)
        
    def get_equations(self, solver):
        raise Exception(&#34;Not implemented&#34;)

    def get_n_defined_control_points(self):
        raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints">SvNurbsCurveControlPoints</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints">SvNurbsCurvePoints</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections">SvNurbsCurveSelfIntersections</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurvePoints</span></span>
<span>(</span><span>us, points, weights=None, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurvePoints(SvNurbsCurveGoal):
    def __init__(self, us, points, weights = None, relative=False):
        self.us = np.asarray(us)
        self.vectors = np.asarray(points)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Points at {self.us} = {self.vectors}, relative={self.relative}&gt;&#34;

    @staticmethod
    def single(u, point, weight=None, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurvePoints([u], [point], weights, relative=relative)

    def copy(self):
        return SvNurbsCurvePoints(self.us, self.vectors, self.weights, relative=self.relative)

    def get_weights(self):
        weights = self.weights
        n_points = len(self.vectors)
        if weights is None:
            weights = np.ones((n_points,))
        elif isinstance(weights, np.ndarray) and weights.shape == (1,):
            weights = np.full((n_points,), weights[0])
        elif isinstance(weights, (int,float)):
            weights = np.full((n_points,), weights)
        return weights

    def add(self, other):
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.us = np.concatenate((g.us, other.us))
        g.vectors = np.concatenate((g.vectors, other.vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver, us):
        p = solver.degree
        alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        return alphas

    def get_src_points(self, solver):
        return solver.src_curve.evaluate_array(self.us)

    def get_n_defined_control_points(self):
        return len(self.us)

    def get_equations(self, solver):
        ndim = 3
        us = self.us
        vectors = self.vectors

        n_points = len(vectors)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas = self.calc_alphas(solver, us)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))
        #print(f&#34;A: {A.shape}, W {weights.shape}, n_points {n_points}&#34;)

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * alpha

        if solver.src_curve is None:
            if self.relative:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                src_points = None
        else:
            if self.relative:
                src_points = None
            else:
                src_points = self.get_src_points(solver)

        for pt_idx, point in enumerate(vectors):
            if src_points is not None:
                point = point - src_points[pt_idx]
            B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * point[np.newaxis]

        return A, B</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents">SvNurbsCurveTangents</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u, point, weight=None, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u, point, weight=None, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurvePoints([u], [point], weights, relative=relative)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if other.relative != self.relative:
        return None
    g = self.copy()
    g.us = np.concatenate((g.us, other.us))
    g.vectors = np.concatenate((g.vectors, other.vectors))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver, us)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver, us):
    p = solver.degree
    alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us) for k in range(solver.n_cpts)]
    alphas = np.array(alphas) # (n_cpts, n_points)
    return alphas</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurvePoints(self.us, self.vectors, self.weights, relative=self.relative)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = 3
    us = self.us
    vectors = self.vectors

    n_points = len(vectors)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    alphas = self.calc_alphas(solver, us)

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))
    #print(f&#34;A: {A.shape}, W {weights.shape}, n_points {n_points}&#34;)

    for pt_idx in range(n_points):
        for cpt_idx in range(solver.n_cpts):
            alpha = alphas[cpt_idx][pt_idx]
            for dim_idx in range(ndim):
                A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * alpha

    if solver.src_curve is None:
        if self.relative:
            raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            src_points = None
    else:
        if self.relative:
            src_points = None
        else:
            src_points = self.get_src_points(solver)

    for pt_idx, point in enumerate(vectors):
        if src_points is not None:
            point = point - src_points[pt_idx]
        B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * point[np.newaxis]

    return A, B</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    return len(self.us)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_src_points"><code class="name flex">
<span>def <span class="ident">get_src_points</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_src_points(self, solver):
    return solver.src_curve.evaluate_array(self.us)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    weights = self.weights
    n_points = len(self.vectors)
    if weights is None:
        weights = np.ones((n_points,))
    elif isinstance(weights, np.ndarray) and weights.shape == (1,):
        weights = np.full((n_points,), weights[0])
    elif isinstance(weights, (int,float)):
        weights = np.full((n_points,), weights)
    return weights</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveSelfIntersections</span></span>
<span>(</span><span>us1, us2, weights=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveSelfIntersections(SvNurbsCurveGoal):
    def __init__(self, us1, us2, weights = None, relative_u=False, relative=False):
        if len(us1) != len(us2):
            raise Exception(&#34;Lengths of us1 and us2 must be equal&#34;)
        self.us1 = np.asarray(us1)
        self.us2 = np.asarray(us2)
        self.relative_u = relative_u
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Self-intersections at {self.us1} x {self.us2}&gt;&#34;

    @staticmethod
    def single(u1, u2, weight=None, relative_u=False, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveSelfIntersections([u1], [u2], weights, relative_u=relative_u, relative=relative)

    def copy(self):
        return SvNurbsCurveSelfIntersections(self.us1, self.us2, self.weights, self.relative_u, self.relative)

    def get_weights(self):
        weights = self.weights
        if weights is None:
            n_points = len(self.us1)
            weights = np.ones((n_points,))
        return weights

    def add(self, other):
        if other.relative_u != self.relative_u:
            return None
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.us1 = np.concatenate((g.us1, other.us1))
        g.us2 = np.concatenate((g.us2, other.us2))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver):
        us1 = self.us1
        us2 = self.us2
        if self.relative_u:
            u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
            us1 = u_min + (u_max - u_min) * us1
            us2 = u_min + (u_max - u_min) * us2
        p = solver.degree
        alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        betas = [solver.basis.fraction(k,p, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return alphas, betas
    
    def calc_vectors(self, solver):
        points1 = solver.src_curve.evaluate_array(self.us1)
        points2 = solver.src_curve.evaluate_array(self.us2)
        return points1, points2

    def get_n_defined_control_points(self):
        return len(self.us1)

    def get_equations(self, solver):
        ndim = 3
        us1 = self.us1
        us2 = self.us2
        p = solver.degree

        n_points = len(us1)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas, betas = self.calc_alphas(solver)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                beta = betas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * (alpha - beta)

        if self.relative:
            if solver.src_curve is None:
                raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                points1, points2 = self.calc_vectors(solver)
                for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                    for dim_idx in range(ndim):
                        B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * (pt2 - pt1)[np.newaxis]

        return A, B</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents">SvNurbsCurveCotangents</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u1, u2, weight=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u1, u2, weight=None, relative_u=False, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveSelfIntersections([u1], [u2], weights, relative_u=relative_u, relative=relative)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if other.relative_u != self.relative_u:
        return None
    if other.relative != self.relative:
        return None
    g = self.copy()
    g.us1 = np.concatenate((g.us1, other.us1))
    g.us2 = np.concatenate((g.us2, other.us2))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver):
    us1 = self.us1
    us2 = self.us2
    if self.relative_u:
        u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
        us1 = u_min + (u_max - u_min) * us1
        us2 = u_min + (u_max - u_min) * us2
    p = solver.degree
    alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
    alphas = np.array(alphas) # (n_cpts, n_points)
    betas = [solver.basis.fraction(k,p, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
    betas = np.array(betas) # (n_cpts, n_points)
    return alphas, betas</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_vectors"><code class="name flex">
<span>def <span class="ident">calc_vectors</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_vectors(self, solver):
    points1 = solver.src_curve.evaluate_array(self.us1)
    points2 = solver.src_curve.evaluate_array(self.us2)
    return points1, points2</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveSelfIntersections(self.us1, self.us2, self.weights, self.relative_u, self.relative)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = 3
    us1 = self.us1
    us2 = self.us2
    p = solver.degree

    n_points = len(us1)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    alphas, betas = self.calc_alphas(solver)

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))

    for pt_idx in range(n_points):
        for cpt_idx in range(solver.n_cpts):
            alpha = alphas[cpt_idx][pt_idx]
            beta = betas[cpt_idx][pt_idx]
            for dim_idx in range(ndim):
                A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * (alpha - beta)

    if self.relative:
        if solver.src_curve is None:
            raise Exception(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            points1, points2 = self.calc_vectors(solver)
            for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                for dim_idx in range(ndim):
                    B[pt_idx*3:pt_idx*3+3,0] = weights[pt_idx] * (pt2 - pt1)[np.newaxis]

    return A, B</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    return len(self.us1)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    weights = self.weights
    if weights is None:
        n_points = len(self.us1)
        weights = np.ones((n_points,))
    return weights</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveSolver</span></span>
<span>(</span><span>degree=None, src_curve=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveSolver(SvCurve):
    def __init__(self, degree=None, src_curve=None):
        if degree is None and src_curve is None:
            raise Exception(&#34;Either degree or src_curve must be provided&#34;)
        elif degree is not None and src_curve is not None and src_curve.get_degree() != degree:
            raise Exception(&#34;If src_curve is provided, then degree must not be provided&#34;)
        self.src_curve = src_curve
        if src_curve is not None and degree is None:
            self.degree = src_curve.get_degree()
        else:
            self.degree = degree
        self.n_cpts = None
        self.curve_weights = None
        self.knotvector = None
        self.goals = []
        self.A = self.B = None

    def copy(self):
        solver = SvNurbsCurveSolver(degree=self.degree, src_curve=self.src_curve)
        solver.n_cpts = self.n_cpts
        solver.curve_weights = self.curve_weights
        solver.knotvector = self.knotvector
        solver.goals = self.goals[:]
        solver.A = self.A
        solver.B = self.B
        return solver

    def evaluate(self, t):
        return self.to_nurbs().evaluate(t)

    def evaluate_array(self, ts):
        return self.to_nurbs().evaluate_array(ts)

    def get_u_bounds(self):
        return self.to_nurbs().get_u_bounds()

    def get_degree(self):
        return self.degree

    def get_control_points(self):
        return self.to_nurbs().get_control_points()

    def set_curve_weights(self, weights):
        if len(weights) != self.n_cpts:
            raise Exception(&#34;Number of weights must be equal to the number of control points&#34;)
        self.curve_weights = np.asarray(weights)

    def set_curve_params(self, n_cpts, knotvector = None, weights = None):
        self.n_cpts = n_cpts
        if knotvector is not None:
            err = sv_knotvector.check(self.degree, knotvector, n_cpts)
            if err is not None:
                raise Exception(err)
            self.knotvector = np.asarray(knotvector)
        else:
            self.knotvector = sv_knotvector.generate(self.degree, n_cpts)
        self.curve_weights = weights

    def guess_curve_params(self):
        n_equations = sum(g.get_n_defined_control_points() for g in self.goals)
        self.n_cpts = n_equations
        self.knotvector = sv_knotvector.generate(self.degree, self.n_cpts)

    def add_goal(self, goal):
        self.goals.append(goal)

    def set_goals(self, goals):
        self.goals = goals[:]

    def _sort_goals(self):
        goal_dict = defaultdict(list)
        for goal in self.goals:
            goal_dict[type(goal)].append(goal)
        goals = []
        for clazz in goal_dict:
            clz_goals = goal_dict[clazz]
            #print(f&#34;Merging goals of class {clazz}: {clz_goals}&#34;)
            merged_goal = clz_goals[0]
            g = merged_goal
            for other_goal in clz_goals[1:]:
                g = merged_goal.add(other_goal)
                #print(f&#34;{merged_goal} + {other_goal} = {g}&#34;)
                if g is not None:
                    merged_goal = g
                else:
                    goals.append(merged_goal)
                    merged_goal = other_goal
            goals.append(merged_goal)
        #print(f&#34;Merge result: {goals}&#34;)
        self.goals = goals

    def _init(self):
        if self.n_cpts is None:
            raise Exception(&#34;Number of control points is not specified; specify it in the constructor, in set_curve_params() call, or call guess_curve_params()&#34;)
        if self.knotvector is None:
            raise Exception(&#34;Knotvector is not specified; specify it in the constructor, in set_curve_params() call, or call guess_curve_params()&#34;)
        ndim = 3
        n = self.n_cpts
        p = self.degree
        if self.curve_weights is None:
            self.curve_weights = np.ones((n,))
        self.basis = SvNurbsBasisFunctions(self.knotvector)

        self._sort_goals()
        As = []
        Bs = []
        for goal in self.goals:
            Ai, Bi = goal.get_equations(self)
            As.append(Ai)
            Bs.append(Bi)
        self.A = np.concatenate(As)
        self.B = np.concatenate(Bs)

    def solve(self, implementation = SvNurbsMaths.NATIVE, logger = None):
        self._init()

        ndim = 3
        n = self.n_cpts
        n_equations, n_unknowns = self.A.shape
        #print(f&#34;A: {self.A.shape}&#34;)
        if n_equations == n_unknowns:
            print(f&#34;Solving well-determined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            try:
                A1 = np.linalg.inv(self.A)
                X = (A1 @ self.B).T
            except np.linalg.LinAlgError as e:
                print(self.A)
                raise Exception(f&#34;Can not solve: #equations = {n_equations}, #unknowns = {n_unknowns}: {e}&#34;) from e
        elif n_equations &lt; n_unknowns:
            print(f&#34;Solving underdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            A1 = np.linalg.pinv(self.A)
            X = (A1 @ self.B).T
        else: # n_equations &gt; n_unknowns
            print(f&#34;Solving overdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            X, residues, rank, singval = np.linalg.lstsq(self.A, self.B)
            print(residues)
            
        d_cpts = X.reshape((n, ndim))
        if self.src_curve is None:
            return SvNurbsCurve.build(implementation, self.degree, self.knotvector, d_cpts, self.curve_weights)
        else:
            cpts = self.src_curve.get_control_points() + d_cpts
            return SvNurbsCurve.build(implementation, self.degree, self.knotvector, cpts, self.curve_weights)

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        solver = self.copy()
        solver.guess_curve_params()
        return solver.solve(implementation = implementation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.add_goal"><code class="name flex">
<span>def <span class="ident">add_goal</span></span>(<span>self, goal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_goal(self, goal):
    self.goals.append(goal)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    solver = SvNurbsCurveSolver(degree=self.degree, src_curve=self.src_curve)
    solver.n_cpts = self.n_cpts
    solver.curve_weights = self.curve_weights
    solver.knotvector = self.knotvector
    solver.goals = self.goals[:]
    solver.A = self.A
    solver.B = self.B
    return solver</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_curve_params"><code class="name flex">
<span>def <span class="ident">guess_curve_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def guess_curve_params(self):
    n_equations = sum(g.get_n_defined_control_points() for g in self.goals)
    self.n_cpts = n_equations
    self.knotvector = sv_knotvector.generate(self.degree, self.n_cpts)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_params"><code class="name flex">
<span>def <span class="ident">set_curve_params</span></span>(<span>self, n_cpts, knotvector=None, weights=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curve_params(self, n_cpts, knotvector = None, weights = None):
    self.n_cpts = n_cpts
    if knotvector is not None:
        err = sv_knotvector.check(self.degree, knotvector, n_cpts)
        if err is not None:
            raise Exception(err)
        self.knotvector = np.asarray(knotvector)
    else:
        self.knotvector = sv_knotvector.generate(self.degree, n_cpts)
    self.curve_weights = weights</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_weights"><code class="name flex">
<span>def <span class="ident">set_curve_weights</span></span>(<span>self, weights)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curve_weights(self, weights):
    if len(weights) != self.n_cpts:
        raise Exception(&#34;Number of weights must be equal to the number of control points&#34;)
    self.curve_weights = np.asarray(weights)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_goals"><code class="name flex">
<span>def <span class="ident">set_goals</span></span>(<span>self, goals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_goals(self, goals):
    self.goals = goals[:]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, implementation='NATIVE', logger=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, implementation = SvNurbsMaths.NATIVE, logger = None):
    self._init()

    ndim = 3
    n = self.n_cpts
    n_equations, n_unknowns = self.A.shape
    #print(f&#34;A: {self.A.shape}&#34;)
    if n_equations == n_unknowns:
        print(f&#34;Solving well-determined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
        try:
            A1 = np.linalg.inv(self.A)
            X = (A1 @ self.B).T
        except np.linalg.LinAlgError as e:
            print(self.A)
            raise Exception(f&#34;Can not solve: #equations = {n_equations}, #unknowns = {n_unknowns}: {e}&#34;) from e
    elif n_equations &lt; n_unknowns:
        print(f&#34;Solving underdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
        A1 = np.linalg.pinv(self.A)
        X = (A1 @ self.B).T
    else: # n_equations &gt; n_unknowns
        print(f&#34;Solving overdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
        X, residues, rank, singval = np.linalg.lstsq(self.A, self.B)
        print(residues)
        
    d_cpts = X.reshape((n, ndim))
    if self.src_curve is None:
        return SvNurbsCurve.build(implementation, self.degree, self.knotvector, d_cpts, self.curve_weights)
    else:
        cpts = self.src_curve.get_control_points() + d_cpts
        return SvNurbsCurve.build(implementation, self.degree, self.knotvector, cpts, self.curve_weights)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.to_nurbs"><code class="name flex">
<span>def <span class="ident">to_nurbs</span></span>(<span>self, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
    solver = self.copy()
    solver.guess_curve_params()
    return solver.solve(implementation = implementation)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveTangents</span></span>
<span>(</span><span>us, tangents, weights=None, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveTangents(SvNurbsCurvePoints):
    def __init__(self, us, tangents, weights = None, relative=False):
        self.us = np.asarray(us)
        self.vectors = np.asarray(tangents)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Tangents at {self.us} = {self.vectors}, relative={self.relative}&gt;&#34;

    @staticmethod
    def single(u, tangent, weight=None, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveTangents([u], [tangent], weights, relative=relative)

    def copy(self):
        return SvNurbsCurveTangents(self.us, self.vectors, self.weights, relative=self.relative)

    def add(self, other):
        if self.relative != other.relative:
            return None
        g = self.copy()
        g.us = np.concatenate((g.us, other.us))
        g.vectors = np.concatenate((g.vectors, other.vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver, us):
        p = solver.degree
        betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return betas
    
    def get_src_points(self, solver):
        return solver.src_curve.tangent_array(self.us)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints">SvNurbsCurvePoints</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u, tangent, weight=None, relative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u, tangent, weight=None, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveTangents([u], [tangent], weights, relative=relative)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if self.relative != other.relative:
        return None
    g = self.copy()
    g.us = np.concatenate((g.us, other.us))
    g.vectors = np.concatenate((g.vectors, other.vectors))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver, us)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver, us):
    p = solver.degree
    betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us) for k in range(solver.n_cpts)]
    betas = np.array(betas) # (n_cpts, n_points)
    return betas</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveTangents(self.us, self.vectors, self.weights, relative=self.relative)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.get_src_points"><code class="name flex">
<span>def <span class="ident">get_src_points</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_src_points(self, solver):
    return solver.src_curve.tangent_array(self.us)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.curve" href="index.html">sverchok.utils.curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints">SvNurbsCurveControlPoints</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents">SvNurbsCurveCotangents</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_vectors" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_vectors">calc_vectors</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints">SvNurbsCurvePoints</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_src_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_src_points">get_src_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections">SvNurbsCurveSelfIntersections</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_vectors" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_vectors">calc_vectors</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver">SvNurbsCurveSolver</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.add_goal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.add_goal">add_goal</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_curve_params" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_curve_params">guess_curve_params</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_params" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_params">set_curve_params</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_weights">set_curve_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_goals" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_goals">set_goals</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve">solve</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.to_nurbs" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.to_nurbs">to_nurbs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents">SvNurbsCurveTangents</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.get_src_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.get_src_points">get_src_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.single">single</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>