<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sverchok.utils.curve.nurbs_solver API documentation</title>
<meta name="description" content="NURBS Curve Solver: general algorithm to find a curve which meets certain requirements â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.curve.nurbs_solver</code></h1>
</header>
<section id="section-intro">
<p>NURBS Curve Solver: general algorithm to find a curve which meets certain requirements.</p>
<p>The solver can be provided with several goals, which should be reached. Basic
curve parameters (number of control points and knotvector) must be provided.
Then the algorithm will try to find a curve which meets all these goals.</p>
<p>It is not always possible to find the single solution, given the list of goals.
There can be the following situations:</p>
<pre><code>* Well-determined system: specified number of curve control points is equal
to number of equations generated by goals. In most cases, for
well-determined system there is the single possible solution, and the
solver will find it. Although there can be situations when corresponding
system of equation is singular.
* Underdetermined system: specified number of control points is greater
than the number of equations generated by goals. In this case, the system
has an infinite number of solutions. The solver will find the solution
which has all control points as near to origin as possible. Usually, this
case is useful to solve "relative" problems, i.e. problems of adjsting
existing curve to meet the specified goals, by moving control points as
less as possible. For such cases, the solver must be provided with the
initial curve.
* Overdetermined system: specified number of control points is less than
the number of equations generated by goals. In such a case, the system
usually has no exact solutions. However, in such cases the solver will find
the curve which meets the goals approximately, as close as possible. For
such cases, it is possible to set different weights for different goals, to
instruct the solver that some goals are more important than others.
</code></pre>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveControlPoints</span></span>
<span>(</span><span>cpt_idxs, cpt_vectors, weights=None, relative=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveControlPoints(SvNurbsCurveGoal):
    &#34;&#34;&#34;
    Goal which says that the curve must have control points at particular
    locations.
    &#34;&#34;&#34;
    def __init__(self, cpt_idxs, cpt_vectors, weights = None, relative=True):
        self.cpt_idxs = np.asarray(cpt_idxs)
        self.cpt_vectors = np.asarray(cpt_vectors)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    @staticmethod
    def single(idx, vector, weight=None, relative=True):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveControlPoints([idx], [vector], weights=weights, relative=relative)

    def get_weights(self):
        weights = self.weights
        n_points = len(self.cpt_vectors)
        if weights is None:
            weights = np.ones((n_points,))
        return weights

    def copy(self):
        return SvNurbsCurveControlPoints(self.cpt_idxs, self.cpt_vectors, self.weights, self.relative)

    def add(self, other):
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.cpt_idxs = np.concatenate((g.cpt_idxs, other.cpt_idxs))
        g.cpt_vectors = np.concatenate((g.cpt_vectors, other.cpt_vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def get_n_defined_control_points(self):
        return len(self.cpt_idxs)

    def get_equations(self, solver):
        ndim = solver.ndim

        n_points = len(self.cpt_vectors)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        for pt_idx, cpt_idx in enumerate(self.cpt_idxs):
            for dim_idx in range(ndim):
                A[dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx]

        if solver.src_curve is None:
            if self.relative:
                raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                src_points = None
        else:
            if self.relative:
                src_points = None
            else:
                src_points = solver.src_curve.get_control_points()

        for pt_idx, (cpt_idx, point) in enumerate(zip(self.cpt_idxs, self.cpt_vectors)):
            if src_points is not None:
                point = point - src_points[cpt_idx]
            B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weights[pt_idx] * point[np.newaxis]

        return A, B</code></pre>
</details>
<div class="desc"><p>Goal which says that the curve must have control points at particular
locations.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>idx, vector, weight=None, relative=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(idx, vector, weight=None, relative=True):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveControlPoints([idx], [vector], weights=weights, relative=relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if other.relative != self.relative:
        return None
    g = self.copy()
    g.cpt_idxs = np.concatenate((g.cpt_idxs, other.cpt_idxs))
    g.cpt_vectors = np.concatenate((g.cpt_vectors, other.cpt_vectors))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveControlPoints(self.cpt_idxs, self.cpt_vectors, self.weights, self.relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = solver.ndim

    n_points = len(self.cpt_vectors)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))

    for pt_idx, cpt_idx in enumerate(self.cpt_idxs):
        for dim_idx in range(ndim):
            A[dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx]

    if solver.src_curve is None:
        if self.relative:
            raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            src_points = None
    else:
        if self.relative:
            src_points = None
        else:
            src_points = solver.src_curve.get_control_points()

    for pt_idx, (cpt_idx, point) in enumerate(zip(self.cpt_idxs, self.cpt_vectors)):
        if src_points is not None:
            point = point - src_points[cpt_idx]
        B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weights[pt_idx] * point[np.newaxis]

    return A, B</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    return len(self.cpt_idxs)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    weights = self.weights
    n_points = len(self.cpt_vectors)
    if weights is None:
        weights = np.ones((n_points,))
    return weights</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveCotangents</span></span>
<span>(</span><span>us1, us2, weights=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveCotangents(SvNurbsCurveSelfIntersections):
    &#34;&#34;&#34;
    Goal which says that curve must have equal tangent vectors at two sets of
    parameter values.
    &#34;&#34;&#34;
    def __init__(self, us1, us2, weights = None, relative_u=False, relative=False):
        if len(us1) != len(us2):
            raise ArgumentError(&#34;Lengths of us1 and us2 must be equal&#34;)
        self.us1 = np.asarray(us1)
        self.us2 = np.asarray(us2)
        self.relative_u = relative_u
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Equal tangents, cnt={len(self.us1)}&gt;&#34;

    @staticmethod
    def single(u1, u2, weight=None, relative_u=False, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveCotangents([u1], [u2], weights, relative_u=relative_u, relative=relative)

    def copy(self):
        return SvNurbsCurveCotangents(self.us1, self.us2, self.weights, self.relative_u, self.relative)

    def calc_alphas(self, solver):
        us1 = self.us1
        us2 = self.us2
        if self.relative_u:
            u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
            us1 = u_min + (u_max - u_min) * us1
            us2 = u_min + (u_max - u_min) * us2
        p = solver.degree
        alphas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return alphas, betas
    
    def get_equations(self, solver):
        ndim = solver.ndim
        us1 = self.us1
        us2 = self.us2
        p = solver.degree

        n_points = len(us1)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas, betas = self.calc_alphas(solver)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        weight = 1

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                beta = betas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weight * (alpha - beta)

        if self.relative:
            if solver.src_curve is None:
                raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                points1, points2 = self.calc_vectors(solver)
                for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                    for dim_idx in range(ndim):
                        B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weight * (pt2 - pt1)[np.newaxis]

        print(&#34;A&#34;, A)
        print(&#34;B&#34;, B)
        return A, B

    def calc_vectors(self, solver):
        points1 = solver.src_curve.tangent_array(self.us1)
        points2 = solver.src_curve.tangent_array(self.us2)
        print(f&#34;Tg1: {points1}, Tg2: {points2}&#34;)
        return points1, points2</code></pre>
</details>
<div class="desc"><p>Goal which says that curve must have equal tangent vectors at two sets of
parameter values.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections">SvNurbsCurveSelfIntersections</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u1, u2, weight=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u1, u2, weight=None, relative_u=False, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveCotangents([u1], [u2], weights, relative_u=relative_u, relative=relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver):
    us1 = self.us1
    us2 = self.us2
    if self.relative_u:
        u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
        us1 = u_min + (u_max - u_min) * us1
        us2 = u_min + (u_max - u_min) * us2
    p = solver.degree
    alphas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
    alphas = np.array(alphas) # (n_cpts, n_points)
    betas = [solver.basis.weighted_derivative(k, p, 1, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
    betas = np.array(betas) # (n_cpts, n_points)
    return alphas, betas</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_vectors"><code class="name flex">
<span>def <span class="ident">calc_vectors</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_vectors(self, solver):
    points1 = solver.src_curve.tangent_array(self.us1)
    points2 = solver.src_curve.tangent_array(self.us2)
    print(f&#34;Tg1: {points1}, Tg2: {points2}&#34;)
    return points1, points2</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveCotangents(self.us1, self.us2, self.weights, self.relative_u, self.relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = solver.ndim
    us1 = self.us1
    us2 = self.us2
    p = solver.degree

    n_points = len(us1)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    alphas, betas = self.calc_alphas(solver)

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))

    weight = 1

    for pt_idx in range(n_points):
        for cpt_idx in range(solver.n_cpts):
            alpha = alphas[cpt_idx][pt_idx]
            beta = betas[cpt_idx][pt_idx]
            for dim_idx in range(ndim):
                A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weight * (alpha - beta)

    if self.relative:
        if solver.src_curve is None:
            raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            points1, points2 = self.calc_vectors(solver)
            for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                for dim_idx in range(ndim):
                    B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weight * (pt2 - pt1)[np.newaxis]

    print(&#34;A&#34;, A)
    print(&#34;B&#34;, B)
    return A, B</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveDerivatives</span></span>
<span>(</span><span>order, us, vectors, weights=None, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveDerivatives(SvNurbsCurvePoints):
    def __init__(self, order, us, vectors, weights = None, relative=False):
        self.order = order
        self.us = np.asarray(us)
        if self.us.ndim != 1:
            raise ArgumentError(f&#34;T values array must be 1-dimensional, but got {self.us.shape}&#34;)
        self.vectors = np.asarray(vectors)
        if self.vectors.ndim != 2:
            raise ArgumentError(f&#34;Vectors must be 2-dimensional, but got {self.vectors.shape}&#34;)
        if len(us) != len(self.vectors):
            raise ArgumentError(f&#34;Number of T values and number of points must be equal, but got #T = {len(us)}, #P = {len(self.vectors)}&#34;)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        if self.relative:
            return f&#34;&lt;Relative Derivatives, order={self.order}, cnt={len(self.us)}&gt;&#34;
        else:
            return f&#34;&lt;Derivatives, order={self.order}, cnt={len(self.us)}&gt;&#34;

    @staticmethod
    def single(order, u, tangent, weight=None, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveDerivatives(order, [u], [tangent], weights, relative=relative)

    def copy(self):
        return SvNurbsCurveDerivatives(self.order, self.us, self.vectors, self.weights, relative=self.relative)

    def add(self, other):
        if self.relative != other.relative:
            return None
        if self.order != other.order:
            return None
        g = self.copy()
        g.us = np.concatenate((g.us, other.us))
        g.vectors = np.concatenate((g.vectors, other.vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver, us):
        p = solver.degree
        betas = [solver.basis.weighted_derivative(k, p, self.order, solver.curve_weights)(us) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return betas
    
    def get_src_points(self, solver):
        return solver.src_curve.tangent_array(self.us)</code></pre>
</details>
<div class="desc"><p>Goal which says that the curve must pass through the specified points at
specified values of parameter.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints">SvNurbsCurvePoints</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>order, u, tangent, weight=None, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(order, u, tangent, weight=None, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveDerivatives(order, [u], [tangent], weights, relative=relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if self.relative != other.relative:
        return None
    if self.order != other.order:
        return None
    g = self.copy()
    g.us = np.concatenate((g.us, other.us))
    g.vectors = np.concatenate((g.vectors, other.vectors))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver, us)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver, us):
    p = solver.degree
    betas = [solver.basis.weighted_derivative(k, p, self.order, solver.curve_weights)(us) for k in range(solver.n_cpts)]
    betas = np.array(betas) # (n_cpts, n_points)
    return betas</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveDerivatives(self.order, self.us, self.vectors, self.weights, relative=self.relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.get_src_points"><code class="name flex">
<span>def <span class="ident">get_src_points</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_src_points(self, solver):
    return solver.src_curve.tangent_array(self.us)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveGoal</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveGoal(object):
    &#34;&#34;&#34;
    Abstract class for curve goal.
    &#34;&#34;&#34;
    def copy(self):
        raise NotImplementedError(&#34;Not implemented&#34;)

    def add(self, other):
        raise NotImplementedError(&#34;Not implemented&#34;)
        
    def get_equations(self, solver):
        raise NotImplementedError(&#34;Not implemented&#34;)

    def get_n_defined_control_points(self):
        raise NotImplementedError(&#34;Not implemented&#34;)</code></pre>
</details>
<div class="desc"><p>Abstract class for curve goal.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints">SvNurbsCurveControlPoints</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints">SvNurbsCurvePoints</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections">SvNurbsCurveSelfIntersections</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    raise NotImplementedError(&#34;Not implemented&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    raise NotImplementedError(&#34;Not implemented&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    raise NotImplementedError(&#34;Not implemented&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    raise NotImplementedError(&#34;Not implemented&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurvePoints</span></span>
<span>(</span><span>us, points, weights=None, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurvePoints(SvNurbsCurveGoal):
    &#34;&#34;&#34;
    Goal which says that the curve must pass through the specified points at
    specified values of parameter.
    &#34;&#34;&#34;
    def __init__(self, us, points, weights = None, relative=False):
        self.us = np.asarray(us)
        if self.us.ndim != 1:
            raise ArgumentError(f&#34;T values array must be 1-dimensional, but got {self.us.shape}&#34;)
        self.vectors = np.asarray(points)
        if self.vectors.ndim != 2:
            raise ArgumentError(f&#34;Points must be 2-dimensional, but got {self.vectors.shape}&#34;)
        if len(us) != len(self.vectors):
            raise ArgumentError(f&#34;Number of T values and number of points must be equal, but got #T = {len(us)}, #P = {len(self.vectors)}&#34;)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        if self.relative:
            return f&#34;&lt;Relative Points, cnt={len(self.us)}&gt;&#34;
        else:
            return f&#34;&lt;Points, cnt={len(self.us)}&gt;&#34;

    @staticmethod
    def single(u, point, weight=None, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurvePoints([u], [point], weights, relative=relative)

    def copy(self):
        return SvNurbsCurvePoints(self.us, self.vectors, self.weights, relative=self.relative)

    def get_weights(self):
        weights = self.weights
        n_points = len(self.vectors)
        if weights is None:
            weights = np.ones((n_points,))
        elif isinstance(weights, np.ndarray) and weights.shape == (1,):
            weights = np.full((n_points,), weights[0])
        elif isinstance(weights, (int,float)):
            weights = np.full((n_points,), weights)
        return weights

    def add(self, other):
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.us = np.concatenate((g.us, other.us))
        g.vectors = np.concatenate((g.vectors, other.vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver, us):
        p = solver.degree
        if solver.is_rational():
            alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us) for k in range(solver.n_cpts)]
        else:
            alphas = [solver.basis.function(k,p)(us) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        return alphas

    def get_src_points(self, solver):
        return solver.src_curve.evaluate_array(self.us)

    def get_n_defined_control_points(self):
        return len(self.us)

    def get_equations(self, solver):
        ndim = solver.ndim
        us = self.us
        vectors = self.vectors

        n_points = len(vectors)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas = self.calc_alphas(solver, us)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))
        #print(f&#34;A: {A.shape}, W {weights.shape}, n_points {n_points}&#34;)

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * alpha

        if solver.src_curve is None:
            if self.relative:
                raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                src_points = None
        else:
            if self.relative:
                src_points = None
            else:
                src_points = self.get_src_points(solver)

        for pt_idx, point in enumerate(vectors):
            if src_points is not None:
                point = point - src_points[pt_idx]
            B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weights[pt_idx] * point[np.newaxis]

        return A, B</code></pre>
</details>
<div class="desc"><p>Goal which says that the curve must pass through the specified points at
specified values of parameter.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives">SvNurbsCurveDerivatives</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents">SvNurbsCurveTangents</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u, point, weight=None, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u, point, weight=None, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurvePoints([u], [point], weights, relative=relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if other.relative != self.relative:
        return None
    g = self.copy()
    g.us = np.concatenate((g.us, other.us))
    g.vectors = np.concatenate((g.vectors, other.vectors))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver, us)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver, us):
    p = solver.degree
    if solver.is_rational():
        alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us) for k in range(solver.n_cpts)]
    else:
        alphas = [solver.basis.function(k,p)(us) for k in range(solver.n_cpts)]
    alphas = np.array(alphas) # (n_cpts, n_points)
    return alphas</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurvePoints(self.us, self.vectors, self.weights, relative=self.relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = solver.ndim
    us = self.us
    vectors = self.vectors

    n_points = len(vectors)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    alphas = self.calc_alphas(solver, us)

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))
    #print(f&#34;A: {A.shape}, W {weights.shape}, n_points {n_points}&#34;)

    for pt_idx in range(n_points):
        for cpt_idx in range(solver.n_cpts):
            alpha = alphas[cpt_idx][pt_idx]
            for dim_idx in range(ndim):
                A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * alpha

    if solver.src_curve is None:
        if self.relative:
            raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            src_points = None
    else:
        if self.relative:
            src_points = None
        else:
            src_points = self.get_src_points(solver)

    for pt_idx, point in enumerate(vectors):
        if src_points is not None:
            point = point - src_points[pt_idx]
        B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weights[pt_idx] * point[np.newaxis]

    return A, B</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    return len(self.us)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_src_points"><code class="name flex">
<span>def <span class="ident">get_src_points</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_src_points(self, solver):
    return solver.src_curve.evaluate_array(self.us)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    weights = self.weights
    n_points = len(self.vectors)
    if weights is None:
        weights = np.ones((n_points,))
    elif isinstance(weights, np.ndarray) and weights.shape == (1,):
        weights = np.full((n_points,), weights[0])
    elif isinstance(weights, (int,float)):
        weights = np.full((n_points,), weights)
    return weights</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveSelfIntersections</span></span>
<span>(</span><span>us1, us2, weights=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveSelfIntersections(SvNurbsCurveGoal):
    &#34;&#34;&#34;
    Goal which says that the curve must have self-intersections at specified
    sets of parameter values.
    &#34;&#34;&#34;
    def __init__(self, us1, us2, weights = None, relative_u=False, relative=False):
        if len(us1) != len(us2):
            raise ArgumentError(&#34;Lengths of us1 and us2 must be equal&#34;)
        self.us1 = np.asarray(us1)
        self.us2 = np.asarray(us2)
        self.relative_u = relative_u
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        return f&#34;&lt;Self-intersections, cnt={len(self.us1)}&gt;&#34;

    @staticmethod
    def single(u1, u2, weight=None, relative_u=False, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveSelfIntersections([u1], [u2], weights, relative_u=relative_u, relative=relative)

    def copy(self):
        return SvNurbsCurveSelfIntersections(self.us1, self.us2, self.weights, self.relative_u, self.relative)

    def get_weights(self):
        weights = self.weights
        if weights is None:
            n_points = len(self.us1)
            weights = np.ones((n_points,))
        return weights

    def add(self, other):
        if other.relative_u != self.relative_u:
            return None
        if other.relative != self.relative:
            return None
        g = self.copy()
        g.us1 = np.concatenate((g.us1, other.us1))
        g.us2 = np.concatenate((g.us2, other.us2))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver):
        us1 = self.us1
        us2 = self.us2
        if self.relative_u:
            u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
            us1 = u_min + (u_max - u_min) * us1
            us2 = u_min + (u_max - u_min) * us2
        p = solver.degree
        alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
        alphas = np.array(alphas) # (n_cpts, n_points)
        betas = [solver.basis.fraction(k,p, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
        betas = np.array(betas) # (n_cpts, n_points)
        return alphas, betas
    
    def calc_vectors(self, solver):
        points1 = solver.src_curve.evaluate_array(self.us1)
        points2 = solver.src_curve.evaluate_array(self.us2)
        return points1, points2

    def get_n_defined_control_points(self):
        return len(self.us1)

    def get_equations(self, solver):
        ndim = solver.ndim
        us1 = self.us1
        us2 = self.us2
        p = solver.degree

        n_points = len(us1)
        n_equations = ndim * n_points
        n_unknowns = ndim * solver.n_cpts

        alphas, betas = self.calc_alphas(solver)

        weights = self.get_weights()

        A = np.zeros((n_equations, n_unknowns))
        B = np.zeros((n_equations, 1))

        for pt_idx in range(n_points):
            for cpt_idx in range(solver.n_cpts):
                alpha = alphas[cpt_idx][pt_idx]
                beta = betas[cpt_idx][pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * (alpha - beta)

        if self.relative:
            if solver.src_curve is None:
                raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
            else:
                points1, points2 = self.calc_vectors(solver)
                for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                    for dim_idx in range(ndim):
                        B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weights[pt_idx] * (pt2 - pt1)[np.newaxis]

        return A, B</code></pre>
</details>
<div class="desc"><p>Goal which says that the curve must have self-intersections at specified
sets of parameter values.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents">SvNurbsCurveCotangents</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u1, u2, weight=None, relative_u=False, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u1, u2, weight=None, relative_u=False, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveSelfIntersections([u1], [u2], weights, relative_u=relative_u, relative=relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if other.relative_u != self.relative_u:
        return None
    if other.relative != self.relative:
        return None
    g = self.copy()
    g.us1 = np.concatenate((g.us1, other.us1))
    g.us2 = np.concatenate((g.us2, other.us2))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver):
    us1 = self.us1
    us2 = self.us2
    if self.relative_u:
        u_min, u_max = solver.knotvector[0], solver.knotvector[-1]
        us1 = u_min + (u_max - u_min) * us1
        us2 = u_min + (u_max - u_min) * us2
    p = solver.degree
    alphas = [solver.basis.fraction(k,p, solver.curve_weights)(us1) for k in range(solver.n_cpts)]
    alphas = np.array(alphas) # (n_cpts, n_points)
    betas = [solver.basis.fraction(k,p, solver.curve_weights)(us2) for k in range(solver.n_cpts)]
    betas = np.array(betas) # (n_cpts, n_points)
    return alphas, betas</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_vectors"><code class="name flex">
<span>def <span class="ident">calc_vectors</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_vectors(self, solver):
    points1 = solver.src_curve.evaluate_array(self.us1)
    points2 = solver.src_curve.evaluate_array(self.us2)
    return points1, points2</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveSelfIntersections(self.us1, self.us2, self.weights, self.relative_u, self.relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_equations"><code class="name flex">
<span>def <span class="ident">get_equations</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_equations(self, solver):
    ndim = solver.ndim
    us1 = self.us1
    us2 = self.us2
    p = solver.degree

    n_points = len(us1)
    n_equations = ndim * n_points
    n_unknowns = ndim * solver.n_cpts

    alphas, betas = self.calc_alphas(solver)

    weights = self.get_weights()

    A = np.zeros((n_equations, n_unknowns))
    B = np.zeros((n_equations, 1))

    for pt_idx in range(n_points):
        for cpt_idx in range(solver.n_cpts):
            alpha = alphas[cpt_idx][pt_idx]
            beta = betas[cpt_idx][pt_idx]
            for dim_idx in range(ndim):
                A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = weights[pt_idx] * (alpha - beta)

    if self.relative:
        if solver.src_curve is None:
            raise InvalidStateError(&#34;Can not solve relative constraint without original curve&#34;)
        else:
            points1, points2 = self.calc_vectors(solver)
            for pt_idx, (pt1, pt2) in enumerate(zip(points1, points2)):
                for dim_idx in range(ndim):
                    B[pt_idx*ndim:pt_idx*ndim+ndim,0] = weights[pt_idx] * (pt2 - pt1)[np.newaxis]

    return A, B</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_n_defined_control_points"><code class="name flex">
<span>def <span class="ident">get_n_defined_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_defined_control_points(self):
    return len(self.us1)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    weights = self.weights
    if weights is None:
        n_points = len(self.us1)
        weights = np.ones((n_points,))
    return weights</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveSolver</span></span>
<span>(</span><span>degree=None, src_curve=None, ndim=3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveSolver(SvCurve):
    &#34;&#34;&#34;
    NURBS Curve Solver.

    Usually this class is used as follows:

        solver = SvNurbsCurveSolver(degree=3)
        # Provide goals
        solver.add_goal(SvNurbsCurvePoints(...))
        solver.add_goal(SvNurbsCurveTangents(...))
        
        # Guess curve parameters so that the system would be well-determined:
        solver.guess_curve_params()
        # Or the parameters can be provided explicitly:
        solver.set_curve_params(n_cpts, knotvector)

        # Solve the problem:
        curve = solver.solve()
    &#34;&#34;&#34;
    def __init__(self, degree=None, src_curve=None, ndim=3):
        if degree is None and src_curve is None:
            raise ArgumentError(&#34;Either degree or src_curve must be provided&#34;)
        elif degree is not None and src_curve is not None and src_curve.get_degree() != degree:
            raise ArgumentError(&#34;If src_curve is provided, then degree must not be provided&#34;)
        self.src_curve = src_curve
        if src_curve is not None and degree is None:
            self.degree = src_curve.get_degree()
        else:
            self.degree = degree
        self.ndim = ndim
        self.n_cpts = None
        self._curve_weights = None
        self._is_rational = None
        self.knotvector = None
        self.goals = []
        self.A = self.B = None

    @staticmethod
    def _check_is_rational(weights):
        w, W = weights.min(), weights.max()
        return abs(W/w - 1.0) &gt; 1e-6

    @property
    def curve_weights(self):
        return self._curve_weights
    
    @curve_weights.setter
    def curve_weights(self, weights):
        if weights is None:
            self._is_rational = False
        else:
            weights = np.asarray(weights)
            self._is_rational = SvNurbsCurveSolver._check_is_rational(weights)
        self._curve_weights = weights

    def is_rational(self):
        if self._is_rational is None:
            self._is_rational = SvNurbsCurveSolver._check_is_rational(self._curve_weights)
        return self._is_rational

    def copy(self):
        solver = SvNurbsCurveSolver(degree=self.degree, src_curve=self.src_curve)
        solver.n_cpts = self.n_cpts
        solver.curve_weights = self.curve_weights
        solver.knotvector = self.knotvector
        solver.goals = self.goals[:]
        solver.A = self.A
        solver.B = self.B
        return solver

    def evaluate(self, t):
        return self.to_nurbs().evaluate(t)

    def evaluate_array(self, ts):
        return self.to_nurbs().evaluate_array(ts)

    def get_u_bounds(self):
        return self.to_nurbs().get_u_bounds()

    def get_degree(self):
        return self.degree

    def get_control_points(self):
        return self.to_nurbs().get_control_points()
    
    def get_knotvector(self):
        return self.knotvector

    def set_curve_weights(self, weights):
        if len(weights) != self.n_cpts:
            raise ArgumentError(&#34;Number of weights must be equal to the number of control points&#34;)
        self.curve_weights = np.asarray(weights)

    def set_curve_params(self, n_cpts, knotvector = None, weights = None):
        self.n_cpts = n_cpts
        if knotvector is not None:
            err = sv_knotvector.check(self.degree, knotvector, n_cpts)
            if err is not None:
                raise AlgorithmError(err)
            self.knotvector = np.asarray(knotvector)
        else:
            self.knotvector = sv_knotvector.generate(self.degree, n_cpts)
        self.curve_weights = weights

    def guess_curve_params(self):
        n_equations = sum(g.get_n_defined_control_points() for g in self.goals)
        self.n_cpts = n_equations
        self.knotvector = sv_knotvector.generate(self.degree, self.n_cpts)

    def guess_n_control_points(self):
        n_equations = sum(g.get_n_defined_control_points() for g in self.goals)
        return n_equations

    def set_knotvector(self, knotvector):
        self.knotvector = np.asarray(knotvector)

    def add_goal(self, goal):
        self.goals.append(goal)

    def set_goals(self, goals):
        self.goals = goals[:]

    def _sort_goals(self):
        goal_dict = defaultdict(list)
        for goal in self.goals:
            goal_dict[type(goal)].append(goal)
        goals = []
        for clazz in goal_dict:
            clz_goals = goal_dict[clazz]
            #print(f&#34;Merging goals of class {clazz}: {clz_goals}&#34;)
            merged_goal = clz_goals[0]
            g = merged_goal
            for other_goal in clz_goals[1:]:
                g = merged_goal.add(other_goal)
                #print(f&#34;{merged_goal} + {other_goal} = {g}&#34;)
                if g is not None:
                    merged_goal = g
                else:
                    goals.append(merged_goal)
                    merged_goal = other_goal
            goals.append(merged_goal)
        #print(f&#34;Merge result: {goals}&#34;)
        self.goals = goals

    def _init(self):
        if self.n_cpts is None:
            raise InvalidStateError(&#34;Number of control points is not specified; specify it in the constructor, in set_curve_params() call, or call guess_curve_params()&#34;)
        if self.knotvector is None:
            raise InvalidStateError(&#34;Knotvector is not specified; specify it in the constructor, in set_curve_params() call, or call guess_curve_params()&#34;)
        ndim = self.ndim
        n = self.n_cpts
        p = self.degree
        if self.curve_weights is None:
            self.curve_weights = np.ones((n,))
        self.basis = SvNurbsBasisFunctions(self.knotvector)

        self._sort_goals()
        As = []
        Bs = []
        for goal in self.goals:
            Ai, Bi = goal.get_equations(self)
            As.append(Ai)
            Bs.append(Bi)
        self.A = np.concatenate(As)
        self.B = np.concatenate(Bs)

    PROBLEM_WELLDETERMINED = &#39;WELLDETERMINED&#39;
    PROBLEM_UNDERDETERMINED = &#39;UNDERDETERMINED&#39;
    PROBLEM_OVERDETERMINED = &#39;OVERDETERMINED&#39;
    PROBLEM_ANY = {PROBLEM_WELLDETERMINED, PROBLEM_UNDERDETERMINED, PROBLEM_OVERDETERMINED}

    def solve(self, implementation = SvNurbsMaths.NATIVE, logger = None):
        problem_type, residue, curve = self.solve_ex(implementation = implementation, logger = logger)
        return curve

    def solve_welldetermined(self, implementation = SvNurbsMaths.NATIVE, logger = None):
        problem_type, residue, curve = self.solve_ex(problem_types = {SvNurbsCurveSolver.PROBLEM_WELLDETERMINED},
                                        implementation = implementation, logger = logger)
        return curve

    def solve_ex(self, problem_types = PROBLEM_ANY, implementation = SvNurbsMaths.NATIVE, logger = None):
        self._init()

        if logger is None:
            logger = get_logger()

        residue = 0.0
        ndim = self.ndim
        n = self.n_cpts
        n_equations, n_unknowns = self.A.shape
        if n_equations == n_unknowns:
            #logger.debug(f&#34;Solving well-determined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            problem_type = SvNurbsCurveSolver.PROBLEM_WELLDETERMINED
            if problem_type not in problem_types:
                raise AlgorithmError(&#34;The problem is well-determined&#34;)
            try:
                A1 = np.linalg.inv(self.A)
                X = (A1 @ self.B).T
            except np.linalg.LinAlgError as e:
                logger.error(f&#34;Matrix: {self.A}&#34;)
                raise AlgorithmError(f&#34;Can not solve: #equations = {n_equations}, #unknowns = {n_unknowns}: {e}&#34;) from e
        elif n_equations &lt; n_unknowns:
            #logger.debug(f&#34;Solving underdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            problem_type = SvNurbsCurveSolver.PROBLEM_UNDERDETERMINED
            if problem_type not in problem_types:
                raise AlgorithmError(&#34;The problem is underdetermined&#34;)
            A1 = np.linalg.pinv(self.A)
            X = (A1 @ self.B).T
        else: # n_equations &gt; n_unknowns
            #logger.debug(f&#34;Solving overdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
            problem_type = SvNurbsCurveSolver.PROBLEM_OVERDETERMINED
            if problem_type not in problem_types:
                raise AlgorithmError(&#34;The system is overdetermined&#34;)
            X, residues, rank, singval = np.linalg.lstsq(self.A, self.B)
            residue = residues.sum()
            
        d_cpts = X.reshape((n, ndim))
        if ndim == 4:
            d_cpts, d_weights = from_homogenous(d_cpts)
            if self.src_curve is None:
                weights = d_weights
            else:
                weights = self.curve_weights + d_weights
        else:
            weights = self.curve_weights
        if self.src_curve is None:
            curve = SvNurbsMaths.build_curve(implementation, self.degree, self.knotvector, d_cpts, weights)
        else:
            cpts = self.src_curve.get_control_points() + d_cpts
            curve = SvNurbsMaths.build_curve(implementation, self.degree, self.knotvector, cpts, weights)
        return problem_type, residue, curve

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        solver = self.copy()
        solver.guess_curve_params()
        return solver.solve(implementation = implementation)</code></pre>
</details>
<div class="desc"><p>NURBS Curve Solver.</p>
<p>Usually this class is used as follows:</p>
<pre><code>solver = SvNurbsCurveSolver(degree=3)
# Provide goals
solver.add_goal(SvNurbsCurvePoints(...))
solver.add_goal(SvNurbsCurveTangents(...))

# Guess curve parameters so that the system would be well-determined:
solver.guess_curve_params()
# Or the parameters can be provided explicitly:
solver.set_curve_params(n_cpts, knotvector)

# Solve the problem:
curve = solver.solve()
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_ANY"><code class="name">var <span class="ident">PROBLEM_ANY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_OVERDETERMINED"><code class="name">var <span class="ident">PROBLEM_OVERDETERMINED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_UNDERDETERMINED"><code class="name">var <span class="ident">PROBLEM_UNDERDETERMINED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_WELLDETERMINED"><code class="name">var <span class="ident">PROBLEM_WELLDETERMINED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.curve_weights"><code class="name">prop <span class="ident">curve_weights</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def curve_weights(self):
    return self._curve_weights</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.add_goal"><code class="name flex">
<span>def <span class="ident">add_goal</span></span>(<span>self, goal)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_goal(self, goal):
    self.goals.append(goal)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    solver = SvNurbsCurveSolver(degree=self.degree, src_curve=self.src_curve)
    solver.n_cpts = self.n_cpts
    solver.curve_weights = self.curve_weights
    solver.knotvector = self.knotvector
    solver.goals = self.goals[:]
    solver.A = self.A
    solver.B = self.B
    return solver</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.get_knotvector"><code class="name flex">
<span>def <span class="ident">get_knotvector</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_knotvector(self):
    return self.knotvector</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_curve_params"><code class="name flex">
<span>def <span class="ident">guess_curve_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def guess_curve_params(self):
    n_equations = sum(g.get_n_defined_control_points() for g in self.goals)
    self.n_cpts = n_equations
    self.knotvector = sv_knotvector.generate(self.degree, self.n_cpts)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_n_control_points"><code class="name flex">
<span>def <span class="ident">guess_n_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def guess_n_control_points(self):
    n_equations = sum(g.get_n_defined_control_points() for g in self.goals)
    return n_equations</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.is_rational"><code class="name flex">
<span>def <span class="ident">is_rational</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_rational(self):
    if self._is_rational is None:
        self._is_rational = SvNurbsCurveSolver._check_is_rational(self._curve_weights)
    return self._is_rational</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_params"><code class="name flex">
<span>def <span class="ident">set_curve_params</span></span>(<span>self, n_cpts, knotvector=None, weights=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curve_params(self, n_cpts, knotvector = None, weights = None):
    self.n_cpts = n_cpts
    if knotvector is not None:
        err = sv_knotvector.check(self.degree, knotvector, n_cpts)
        if err is not None:
            raise AlgorithmError(err)
        self.knotvector = np.asarray(knotvector)
    else:
        self.knotvector = sv_knotvector.generate(self.degree, n_cpts)
    self.curve_weights = weights</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_weights"><code class="name flex">
<span>def <span class="ident">set_curve_weights</span></span>(<span>self, weights)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curve_weights(self, weights):
    if len(weights) != self.n_cpts:
        raise ArgumentError(&#34;Number of weights must be equal to the number of control points&#34;)
    self.curve_weights = np.asarray(weights)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_goals"><code class="name flex">
<span>def <span class="ident">set_goals</span></span>(<span>self, goals)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_goals(self, goals):
    self.goals = goals[:]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_knotvector"><code class="name flex">
<span>def <span class="ident">set_knotvector</span></span>(<span>self, knotvector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_knotvector(self, knotvector):
    self.knotvector = np.asarray(knotvector)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, implementation='NATIVE', logger=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, implementation = SvNurbsMaths.NATIVE, logger = None):
    problem_type, residue, curve = self.solve_ex(implementation = implementation, logger = logger)
    return curve</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve_ex"><code class="name flex">
<span>def <span class="ident">solve_ex</span></span>(<span>self,<br>problem_types={'WELLDETERMINED', 'OVERDETERMINED', 'UNDERDETERMINED'},<br>implementation='NATIVE',<br>logger=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_ex(self, problem_types = PROBLEM_ANY, implementation = SvNurbsMaths.NATIVE, logger = None):
    self._init()

    if logger is None:
        logger = get_logger()

    residue = 0.0
    ndim = self.ndim
    n = self.n_cpts
    n_equations, n_unknowns = self.A.shape
    if n_equations == n_unknowns:
        #logger.debug(f&#34;Solving well-determined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
        problem_type = SvNurbsCurveSolver.PROBLEM_WELLDETERMINED
        if problem_type not in problem_types:
            raise AlgorithmError(&#34;The problem is well-determined&#34;)
        try:
            A1 = np.linalg.inv(self.A)
            X = (A1 @ self.B).T
        except np.linalg.LinAlgError as e:
            logger.error(f&#34;Matrix: {self.A}&#34;)
            raise AlgorithmError(f&#34;Can not solve: #equations = {n_equations}, #unknowns = {n_unknowns}: {e}&#34;) from e
    elif n_equations &lt; n_unknowns:
        #logger.debug(f&#34;Solving underdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
        problem_type = SvNurbsCurveSolver.PROBLEM_UNDERDETERMINED
        if problem_type not in problem_types:
            raise AlgorithmError(&#34;The problem is underdetermined&#34;)
        A1 = np.linalg.pinv(self.A)
        X = (A1 @ self.B).T
    else: # n_equations &gt; n_unknowns
        #logger.debug(f&#34;Solving overdetermined system: #equations = {n_equations}, #unknonwns = {n_unknowns}&#34;)
        problem_type = SvNurbsCurveSolver.PROBLEM_OVERDETERMINED
        if problem_type not in problem_types:
            raise AlgorithmError(&#34;The system is overdetermined&#34;)
        X, residues, rank, singval = np.linalg.lstsq(self.A, self.B)
        residue = residues.sum()
        
    d_cpts = X.reshape((n, ndim))
    if ndim == 4:
        d_cpts, d_weights = from_homogenous(d_cpts)
        if self.src_curve is None:
            weights = d_weights
        else:
            weights = self.curve_weights + d_weights
    else:
        weights = self.curve_weights
    if self.src_curve is None:
        curve = SvNurbsMaths.build_curve(implementation, self.degree, self.knotvector, d_cpts, weights)
    else:
        cpts = self.src_curve.get_control_points() + d_cpts
        curve = SvNurbsMaths.build_curve(implementation, self.degree, self.knotvector, cpts, weights)
    return problem_type, residue, curve</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve_welldetermined"><code class="name flex">
<span>def <span class="ident">solve_welldetermined</span></span>(<span>self, implementation='NATIVE', logger=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_welldetermined(self, implementation = SvNurbsMaths.NATIVE, logger = None):
    problem_type, residue, curve = self.solve_ex(problem_types = {SvNurbsCurveSolver.PROBLEM_WELLDETERMINED},
                                    implementation = implementation, logger = logger)
    return curve</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.to_nurbs"><code class="name flex">
<span>def <span class="ident">to_nurbs</span></span>(<span>self, implementation='NATIVE')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
    solver = self.copy()
    solver.guess_curve_params()
    return solver.solve(implementation = implementation)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.derivatives_array" href="core.html#sverchok.utils.curve.core.SvCurve.derivatives_array">derivatives_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_by_plane_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_by_plane_array">frame_by_plane_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_end_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_end_points">get_end_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_polyline_vertices" href="core.html#sverchok.utils.curve.core.SvCurve.get_polyline_vertices">get_polyline_vertices</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tilt_pairs" href="core.html#sverchok.utils.curve.core.SvCurve.get_tilt_pairs">get_tilt_pairs</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.is_closed" href="core.html#sverchok.utils.curve.core.SvCurve.is_closed">is_closed</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.is_polyline" href="core.html#sverchok.utils.curve.core.SvCurve.is_polyline">is_polyline</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.second_derivative" href="core.html#sverchok.utils.curve.core.SvCurve.second_derivative">second_derivative</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.second_derivative_array" href="core.html#sverchok.utils.curve.core.SvCurve.second_derivative_array">second_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.third_derivative" href="core.html#sverchok.utils.curve.core.SvCurve.third_derivative">third_derivative</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.third_derivative_array" href="core.html#sverchok.utils.curve.core.SvCurve.third_derivative_array">third_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents"><code class="flex name class">
<span>class <span class="ident">SvNurbsCurveTangents</span></span>
<span>(</span><span>us, tangents, weights=None, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsCurveTangents(SvNurbsCurvePoints):
    &#34;&#34;&#34;
    Goal which says that the curve must have specified tangent vectors at
    specified values of parameter.
    &#34;&#34;&#34;
    def __init__(self, us, tangents, weights = None, relative=False):
        self.us = np.asarray(us)
        if self.us.ndim != 1:
            raise ArgumentError(f&#34;T values array must be 1-dimensional, but got {self.us.shape}&#34;)
        self.vectors = np.asarray(tangents)
        if self.vectors.ndim != 2:
            raise ArgumentError(f&#34;Points must be 2-dimensional, but got {self.vectors.shape}&#34;)
        if len(us) != len(self.vectors):
            raise ArgumentError(f&#34;Number of T values and number of points must be equal, but got #T = {len(us)}, #P = {len(self.vectors)}&#34;)
        self.relative = relative
        if weights is None:
            self.weights = None
        else:
            self.weights = np.asarray(weights)

    def __repr__(self):
        if self.relative:
            return f&#34;&lt;Relative Tangents, cnt={len(self.us)}&gt;&#34;
        else:
            return f&#34;&lt;Tangents, cnt={len(self.us)}&gt;&#34;

    @staticmethod
    def single(u, tangent, weight=None, relative=False):
        if weight is None:
            weights = None
        else:
            weights = [weight]
        return SvNurbsCurveTangents([u], [tangent], weights, relative=relative)

    def copy(self):
        return SvNurbsCurveTangents(self.us, self.vectors, self.weights, relative=self.relative)

    def add(self, other):
        if self.relative != other.relative:
            return None
        g = self.copy()
        g.us = np.concatenate((g.us, other.us))
        g.vectors = np.concatenate((g.vectors, other.vectors))
        g.weights = np.concatenate((g.get_weights(), other.get_weights()))
        return g

    def calc_alphas(self, solver, us):
        p = solver.degree
        ns = [solver.basis.function(k, p)(us) for k in range(solver.n_cpts)]
        ns = np.array(ns) # (n_cpts, n_pts)
        derivs = [solver.basis.derivative(k, p, 1)(us) for k in range(solver.n_cpts)]
        derivs = np.array(derivs) # (n_cpts, n_pts)
        weights = solver.curve_weights[np.newaxis].T # (n_cpts, 1)

        sum_ns = (ns * weights).sum(axis=0) # (n_pts,)
        sum_derivs = (derivs * weights).sum(axis=0) # (n_pts,)

        numerator = weights * (derivs * sum_ns - ns * sum_derivs)

        denominator = sum_ns**2

        return numerator / denominator
    
    def get_src_points(self, solver):
        return solver.src_curve.tangent_array(self.us)</code></pre>
</details>
<div class="desc"><p>Goal which says that the curve must have specified tangent vectors at
specified values of parameter.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints">SvNurbsCurvePoints</a></li>
<li><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.single"><code class="name flex">
<span>def <span class="ident">single</span></span>(<span>u, tangent, weight=None, relative=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def single(u, tangent, weight=None, relative=False):
    if weight is None:
        weights = None
    else:
        weights = [weight]
    return SvNurbsCurveTangents([u], [tangent], weights, relative=relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other):
    if self.relative != other.relative:
        return None
    g = self.copy()
    g.us = np.concatenate((g.us, other.us))
    g.vectors = np.concatenate((g.vectors, other.vectors))
    g.weights = np.concatenate((g.get_weights(), other.get_weights()))
    return g</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.calc_alphas"><code class="name flex">
<span>def <span class="ident">calc_alphas</span></span>(<span>self, solver, us)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_alphas(self, solver, us):
    p = solver.degree
    ns = [solver.basis.function(k, p)(us) for k in range(solver.n_cpts)]
    ns = np.array(ns) # (n_cpts, n_pts)
    derivs = [solver.basis.derivative(k, p, 1)(us) for k in range(solver.n_cpts)]
    derivs = np.array(derivs) # (n_cpts, n_pts)
    weights = solver.curve_weights[np.newaxis].T # (n_cpts, 1)

    sum_ns = (ns * weights).sum(axis=0) # (n_pts,)
    sum_derivs = (derivs * weights).sum(axis=0) # (n_pts,)

    numerator = weights * (derivs * sum_ns - ns * sum_derivs)

    denominator = sum_ns**2

    return numerator / denominator</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return SvNurbsCurveTangents(self.us, self.vectors, self.weights, relative=self.relative)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.get_src_points"><code class="name flex">
<span>def <span class="ident">get_src_points</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_src_points(self, solver):
    return solver.src_curve.tangent_array(self.us)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.curve" href="index.html">sverchok.utils.curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints">SvNurbsCurveControlPoints</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveControlPoints.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents">SvNurbsCurveCotangents</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_vectors" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.calc_vectors">calc_vectors</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveCotangents.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives">SvNurbsCurveDerivatives</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.get_src_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.get_src_points">get_src_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveDerivatives.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal">SvNurbsCurveGoal</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveGoal.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints">SvNurbsCurvePoints</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_src_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_src_points">get_src_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurvePoints.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections">SvNurbsCurveSelfIntersections</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_vectors" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.calc_vectors">calc_vectors</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_equations" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_equations">get_equations</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_n_defined_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_n_defined_control_points">get_n_defined_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSelfIntersections.single">single</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver">SvNurbsCurveSolver</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_ANY" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_ANY">PROBLEM_ANY</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_OVERDETERMINED" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_OVERDETERMINED">PROBLEM_OVERDETERMINED</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_UNDERDETERMINED" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_UNDERDETERMINED">PROBLEM_UNDERDETERMINED</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_WELLDETERMINED" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.PROBLEM_WELLDETERMINED">PROBLEM_WELLDETERMINED</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.add_goal" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.add_goal">add_goal</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.curve_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.curve_weights">curve_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.get_knotvector" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.get_knotvector">get_knotvector</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_curve_params" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_curve_params">guess_curve_params</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_n_control_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.guess_n_control_points">guess_n_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.is_rational" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.is_rational">is_rational</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_params" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_params">set_curve_params</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_weights" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_curve_weights">set_curve_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_goals" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_goals">set_goals</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_knotvector" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.set_knotvector">set_knotvector</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve">solve</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve_ex" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve_ex">solve_ex</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve_welldetermined" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.solve_welldetermined">solve_welldetermined</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.to_nurbs" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveSolver.to_nurbs">to_nurbs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents">SvNurbsCurveTangents</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.add" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.add">add</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.calc_alphas" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.calc_alphas">calc_alphas</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.copy" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.get_src_points" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.get_src_points">get_src_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.single" href="#sverchok.utils.curve.nurbs_solver.SvNurbsCurveTangents.single">single</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
