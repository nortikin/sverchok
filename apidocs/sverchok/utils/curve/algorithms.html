<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>sverchok.utils.curve.algorithms API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.curve.algorithms</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.curve.algorithms.concatenate_curves"><code class="name flex">
<span>def <span class="ident">concatenate_curves</span></span>(<span>curves, scale_to_unit=False, allow_generic=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenate a list of curves. When possible, use <code>concatenate</code> method of
curves to make a "native" concatenation - for example, make one Nurbs out of
several Nurbs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>curves</code></strong></dt>
<dd>list of SvCurve</dd>
<dt><strong><code>scale_to_unit</code></strong></dt>
<dd>if specified, reparametrize each curve to [0; 1] before concatenation.</dd>
<dt><strong><code>allow_generic</code></strong></dt>
<dd>what to do if it is not possible to concatenate curves natively:
* True - use generic SvConcatCurve
* False - raise an Exception.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an instance of SvCurve.</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.curve_frame_on_surface_array"><code class="name flex">
<span>def <span class="ident">curve_frame_on_surface_array</span></span>(<span>surface, uv_curve, us, w_axis=2, normalize=True, on_zero_curvature='asis')</span>
</code></dt>
<dd>
<div class="desc"><p>Curve frame which is lying in the surface.</p>
<p>Frame is oriented as follows:
* X is pointing along surface normal
* Z is pointing along curve tangent
* Y is perpendicular to both X and Z.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>surface</code></strong></dt>
<dd>source surface</dd>
<dt><strong><code>uv_curve</code></strong></dt>
<dd>uv_curve in the surface's UV space</dd>
<dt><strong><code>us</code></strong></dt>
<dd>values of curve's T parameter; type: np.array of shape (n,)</dd>
<dt><strong><code>w_axis</code></strong></dt>
<dd>defines which axis of the curve is surface's normal (two
other axes are surface's U and V). Default of 2 means X is U and Y is V.</dd>
<dt><strong><code>normalize</code></strong></dt>
<dd>whether the returned vectors should have unit norm</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple:
* matrices: np.array of shape (n, 3, 3)
* points: np.array of shape (n, 3) - points on the surface
* tangents: np.array of shape (n, 3)
* normals: np.array of shape (n, 3)
* binormals: np.array of shape (n, 3)</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.curve_segment"><code class="name flex">
<span>def <span class="ident">curve_segment</span></span>(<span>curve, new_t_min, new_t_max, use_native=True, rescale=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Cut a segment out of the curve.</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.make_euclidean_ts"><code class="name flex">
<span>def <span class="ident">make_euclidean_ts</span></span>(<span>pts)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.reparametrize_curve"><code class="name flex">
<span>def <span class="ident">reparametrize_curve</span></span>(<span>curve, new_t_min=0.0, new_t_max=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Reparametrize the curve to new domain.</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.reverse_curve"><code class="name flex">
<span>def <span class="ident">reverse_curve</span></span>(<span>curve)</span>
</code></dt>
<dd>
<div class="desc"><p>Reverse the curve, i.e. reverse the direction of it's parametrization.</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.sort_curves_for_concat"><code class="name flex">
<span>def <span class="ident">sort_curves_for_concat</span></span>(<span>curves, allow_flip=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort list of curves so that they could be concatenated into one curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>curves</code></strong></dt>
<dd>list of SvCurve to be sorted.</dd>
<dt><strong><code>allow_flip</code></strong></dt>
<dd>if True, then the method will be allowed to flip (reverse)
some of the curves.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an instance of <code><a title="sverchok.utils.curve.algorithms.SvCurvesSortResult" href="#sverchok.utils.curve.algorithms.SvCurvesSortResult">SvCurvesSortResult</a></code>.</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.split_curve"><code class="name flex">
<span>def <span class="ident">split_curve</span></span>(<span>curve, splits, rescale=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Split one curve into several segments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>curve</code></strong></dt>
<dd>SvCurve to be split.</dd>
<dt><strong><code>splits</code></strong></dt>
<dd>number of segments you want to receive.</dd>
<dt><strong><code>rescale</code></strong></dt>
<dd>if True, then each of segments will be reparametrized to
[0; 1] domain.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of SvCurve.</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.unify_curves_degree"><code class="name flex">
<span>def <span class="ident">unify_curves_degree</span></span>(<span>curves)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure that all curves have the same degree, by
elevating degree where necessary.
Assumes all curves have get_degree() and elevate_degree() methods.
Can raise UnsupportedCurveTypeException if some degrees can not be elevated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>curves</code></strong></dt>
<dd>list of SvCurve</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of SvCurve</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.curve.algorithms.DifferentialRotationCalculator"><code class="flex name class">
<span>class <span class="ident">DifferentialRotationCalculator</span></span>
<span>(</span><span>curve, algorithm, resolution=50)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DifferentialRotationCalculator(object):

    def __init__(self, curve, algorithm, resolution=50):
        self.curve = curve
        self.algorithm = algorithm
        if algorithm == TRACK_NORMAL:
            self.normal_tracker = SvNormalTrack(curve, resolution)
        elif algorithm == ZERO:
            self.curve.pre_calc_torsion_integral(resolution)

    def get_matrices(self, ts):
        n = len(ts)
        if self.algorithm == FRENET:
            frenet, _ , _ = self.curve.frame_array(ts)
            return frenet
        elif self.algorithm == ZERO:
            frenet, _ , _ = self.curve.frame_array(ts)
            angles = - self.curve.torsion_integral(ts)
            zeros = np.zeros((n,))
            ones = np.ones((n,))
            row1 = np.stack((np.cos(angles), np.sin(angles), zeros)).T # (n, 3)
            row2 = np.stack((-np.sin(angles), np.cos(angles), zeros)).T # (n, 3)
            row3 = np.stack((zeros, zeros, ones)).T # (n, 3)
            rotation_matrices = np.dstack((row1, row2, row3))
            return frenet @ rotation_matrices
        elif self.algorithm == TRACK_NORMAL:
            matrices = self.normal_tracker.evaluate_array(ts)
            return matrices
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.DifferentialRotationCalculator.get_matrices"><code class="name flex">
<span>def <span class="ident">get_matrices</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.algorithms.MathutilsRotationCalculator"><code class="flex name class">
<span>class <span class="ident">MathutilsRotationCalculator</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MathutilsRotationCalculator(object):

    @classmethod
    def get_matrix(cls, tangent, scale, axis, algorithm, scale_all=True, up_axis=&#39;X&#39;):
        &#34;&#34;&#34;
        Calculate matrix required to rotate object according to `tangent` vector.

        Args:
            tangent: np.array of shape (3,)
            scale: float
            axis: int, 0 - X, 1 - Y, 2 - Z
            algorithm: one of HOUSEHOLDER, TRACK, DIFF
            scale_all: True to scale along all axes, False to scale along tangent only
            up_axis: string, &#34;X&#34;, &#34;Y&#34; or &#34;Z&#34;, for algorithm == TRACK only.

        Returns:
            np.array of shape (3,3).
        &#34;&#34;&#34;
        x = Vector((1.0, 0.0, 0.0))
        y = Vector((0.0, 1.0, 0.0))
        z = Vector((0.0, 0.0, 1.0))

        if axis == 0:
            ax1, ax2, ax3 = x, y, z
        elif axis == 1:
            ax1, ax2, ax3 = y, x, z
        else:
            ax1, ax2, ax3 = z, x, y

        if scale_all:
            scale_matrix = Matrix.Scale(1/scale, 4, ax1) @ Matrix.Scale(scale, 4, ax2) @ Matrix.Scale(scale, 4, ax3)
        else:
            scale_matrix = Matrix.Scale(1/scale, 4, ax1)
        scale_matrix = np.array(scale_matrix.to_3x3())

        tangent = Vector(tangent)
        if algorithm == HOUSEHOLDER:
            rot = autorotate_householder(ax1, tangent).inverted()
        elif algorithm == TRACK:
            axis = &#34;XYZ&#34;[axis]
            rot = autorotate_track(axis, tangent, up_axis)
        elif algorithm == DIFF:
            rot = autorotate_diff(tangent, ax1)
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)
        rot = np.array(rot.to_3x3())

        return np.matmul(rot, scale_matrix)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.MathutilsRotationCalculator.get_matrix"><code class="name flex">
<span>def <span class="ident">get_matrix</span></span>(<span>tangent, scale, axis, algorithm, scale_all=True, up_axis='X')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate matrix required to rotate object according to <code>tangent</code> vector.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tangent</code></strong></dt>
<dd>np.array of shape (3,)</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>float</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>int, 0 - X, 1 - Y, 2 - Z</dd>
<dt><strong><code>algorithm</code></strong></dt>
<dd>one of HOUSEHOLDER, TRACK, DIFF</dd>
<dt><strong><code>scale_all</code></strong></dt>
<dd>True to scale along all axes, False to scale along tangent only</dd>
<dt><strong><code>up_axis</code></strong></dt>
<dd>string, "X", "Y" or "Z", for algorithm == TRACK only.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.array of shape (3,3).</p></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCastCurveToCylinder"><code class="flex name class">
<span>class <span class="ident">SvCastCurveToCylinder</span></span>
<span>(</span><span>curve, center, direction, radius, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCastCurveToCylinder(SvCurve):
    def __init__(self, curve, center, direction, radius, coefficient):
        self.curve = curve
        self.center = center
        self.direction = direction
        self.radius = radius
        self.coefficient = coefficient
        self.line = LineEquation.from_direction_and_point(direction, center)
        self.tangent_delta = 0.001
        self.__description__ = &#34;{} casted to Cylinder&#34;.format(curve)

    def evaluate(self, t):
        point = self.curve.evaluate(t)
        projection_to_line = self.line.projection_of_point(point)
        projection_to_line = np.array(projection_to_line)
        radial = point - projection_to_line
        radius = self.radius * radial / np.linalg.norm(radial)
        projection = projection_to_line + radius
        k = self.coefficient
        return (1 - k) * point + k * projection

    def evaluate_array(self, ts):
        points = self.curve.evaluate_array(ts)
        projection_to_line = self.line.projection_of_points(points)
        radial = points - projection_to_line
        radius = self.radius * radial / np.linalg.norm(radial, axis=1, keepdims=True)
        projections = projection_to_line + radius
        k = self.coefficient
        return (1 - k) * points + k * projections

    def get_u_bounds(self):
        return self.curve.get_u_bounds()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCastCurveToPlane"><code class="flex name class">
<span>class <span class="ident">SvCastCurveToPlane</span></span>
<span>(</span><span>curve, point, normal, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCastCurveToPlane(SvCurve):
    def __init__(self, curve, point, normal, coefficient):
        self.curve = curve
        self.point = point
        self.normal = normal
        self.coefficient = coefficient
        self.plane = PlaneEquation.from_normal_and_point(normal, point)
        self.tangent_delta = 0.001
        self.__description__ = &#34;{} casted to Plane&#34;.format(curve)

    def evaluate(self, t):
        point = self.curve.evaluate(t)
        target = np.array(self.plane.projection_of_point(point))
        k = self.coefficient
        return (1 - k) * point + k * target

    def evaluate_array(self, ts):
        points = self.curve.evaluate_array(ts)
        targets = self.plane.projection_of_points(points)
        k = self.coefficient
        return (1 - k) * points + k * targets

    def get_u_bounds(self):
        return self.curve.get_u_bounds()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCastCurveToSphere"><code class="flex name class">
<span>class <span class="ident">SvCastCurveToSphere</span></span>
<span>(</span><span>curve, center, radius, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCastCurveToSphere(SvCurve):
    def __init__(self, curve, center, radius, coefficient):
        self.curve = curve
        self.center = center
        self.radius = radius
        self.coefficient = coefficient
        self.tangent_delta = 0.001
        self.__description__ = &#34;{} casted to Sphere&#34;.format(curve)

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        points = self.curve.evaluate_array(ts)
        centered_points = points - self.center
        norms = np.linalg.norm(centered_points, axis=1)[np.newaxis].T
        normalized = centered_points / norms
        targets = self.radius * normalized + self.center
        k = self.coefficient
        return (1 - k) * points + k * targets

    def get_u_bounds(self):
        return self.curve.get_u_bounds()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveFrameCalculator"><code class="flex name class">
<span>class <span class="ident">SvCurveFrameCalculator</span></span>
<span>(</span><span>curve, algorithm, z_axis=2, resolution=50, normal=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveFrameCalculator(object):
    def __init__(self, curve, algorithm, z_axis=2, resolution=50, normal=None):
        self.algorithm = algorithm
        self.z_axis = z_axis
        self.curve = curve
        self.normal = normal
        if algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            self.calculator = DifferentialRotationCalculator(curve, algorithm, resolution)

    def get_matrix(self, tangent):
        return MathutilsRotationCalculator.get_matrix(tangent, scale=1.0,
                axis=self.z_axis,
                algorithm = self.algorithm,
                scale_all=False)

    def get_matrices(self, ts):
        if self.algorithm == NONE:
            identity = np.eye(3)
            n = len(ts)
            return np.broadcast_to(identity, (n, 3,3))
        elif self.algorithm == NORMAL_DIR:
            matrices, _, _ = self.curve.frame_by_plane_array(ts, self.normal)
            return matrices
        elif self.algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            return self.calculator.get_matrices(ts)
        elif self.algorithm in {HOUSEHOLDER, TRACK, DIFF}:
            tangents = self.curve.tangent_array(ts)
            matrices = np.vectorize(lambda t : self.get_matrix(t), signature=&#39;(3)-&gt;(3,3)&#39;)(tangents)
            return matrices
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvCurveFrameCalculator.get_matrices"><code class="name flex">
<span>def <span class="ident">get_matrices</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveFrameCalculator.get_matrix"><code class="name flex">
<span>def <span class="ident">get_matrix</span></span>(<span>self, tangent)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveLengthSolver"><code class="flex name class">
<span>class <span class="ident">SvCurveLengthSolver</span></span>
<span>(</span><span>curve)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveLengthSolver(object):
    def __init__(self, curve):
        self.curve = curve
        self._reverse_spline = None
        self._prime_spline = None

    def calc_length_segments(self, tknots):
        vectors = self.curve.evaluate_array(tknots)
        dvs = vectors[1:] - vectors[:-1]
        lengths = np.linalg.norm(dvs, axis=1)
        return lengths

    def get_total_length(self):
        if self._reverse_spline is None:
            raise Exception(&#34;You have to call solver.prepare() first&#34;)
        return self._length_params[-1]

    def _calc_tknots_fixed(self, resolution):
        t_min, t_max = self.curve.get_u_bounds()
        tknots = np.linspace(t_min, t_max, num=resolution)
        return tknots

    def _prepare_find(self, resolution, tolerance, tknots=None, lengths=None, length_params=None):
        if tknots is None:
            tknots = self._calc_tknots_fixed(resolution)
        if lengths is None:
            lengths = self.calc_length_segments(tknots)
        if length_params is None:
            length_params = np.cumsum(np.insert(lengths, 0, 0))

        resolution2 = resolution * 2 - 1
        tknots2 = self._calc_tknots_fixed(resolution2)
        lengths2 = self.calc_length_segments(tknots2)
        length_params2 = np.cumsum(np.insert(lengths2, 0, 0))
        
        dl = abs(length_params2[::2] - length_params)
        if (dl &lt; tolerance).all():
            return tknots2, length_params2
        else:
            return self._prepare_find(resolution2, tolerance, tknots2, lengths2, length_params2)

    def prepare(self, mode, resolution=50, tolerance=None):
        if tolerance is None:
            tknots = self._calc_tknots_fixed(resolution)
            lengths = self.calc_length_segments(tknots)
            self._length_params = np.cumsum(np.insert(lengths, 0, 0))
        else:
            tknots, self._length_params = self._prepare_find(resolution, tolerance)
        self._reverse_spline = self._make_spline(mode, tknots, self._length_params)
        self._prime_spline = self._make_spline(mode, self._length_params, tknots)


    def _make_spline(self, mode, tknots, values):
        zeros = np.zeros(len(tknots))
        control_points = np.vstack((values, tknots, zeros)).T
        if mode == &#39;LIN&#39;:
            spline = LinearSpline(control_points, tknots = values, is_cyclic = False)
        elif mode == &#39;SPL&#39;:
            spline = CubicSpline(control_points, tknots = values, is_cyclic = False)
        else:
            raise Exception(&#34;Unsupported mode; supported are LIN and SPL.&#34;)
        return spline

    def calc_length(self, t_min, t_max):
        if self._prime_spline is None:
            raise Exception(&#34;You have to call solver.prepare() first&#34;)
        lengths = self._prime_spline.eval(np.array([t_min, t_max]))
        return lengths[1][1] - lengths[0][1]

    def calc_length_params(self, ts):
        if self._prime_spline is None:
            raise Exception(&#34;You have to call solver.prepare() first&#34;)
        spline_verts = self._prime_spline.eval(ts)
        return spline_verts[:,1]

    def solve(self, input_lengths):
        if self._reverse_spline is None:
            raise Exception(&#34;You have to call solver.prepare() first&#34;)
        spline_verts = self._reverse_spline.eval(input_lengths)
        return spline_verts[:,1]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs_algorithms.SvNurbsCurveLengthSolver" href="nurbs_algorithms.html#sverchok.utils.curve.nurbs_algorithms.SvNurbsCurveLengthSolver">SvNurbsCurveLengthSolver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length"><code class="name flex">
<span>def <span class="ident">calc_length</span></span>(<span>self, t_min, t_max)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length_params"><code class="name flex">
<span>def <span class="ident">calc_length_params</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length_segments"><code class="name flex">
<span>def <span class="ident">calc_length_segments</span></span>(<span>self, tknots)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveLengthSolver.get_total_length"><code class="name flex">
<span>def <span class="ident">get_total_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveLengthSolver.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self, mode, resolution=50, tolerance=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveLengthSolver.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, input_lengths)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveLerpCurve"><code class="flex name class">
<span>class <span class="ident">SvCurveLerpCurve</span></span>
<span>(</span><span>curve1, curve2, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveLerpCurve(SvCurve):
    __description__ = &#34;Lerp&#34;

    def __init__(self, curve1, curve2, coefficient):
        self.curve1 = curve1
        self.curve2 = curve2
        self.coefficient = coefficient
        self.u_bounds = (0.0, 1.0)
        self.c1_min, self.c1_max = curve1.get_u_bounds()
        self.c2_min, self.c2_max = curve2.get_u_bounds()
        self.tangent_delta = 0.001

    @staticmethod
    def build(curve1, curve2, coefficient):
        if hasattr(curve1, &#39;lerp_to&#39;):
            try:
                return curve1.lerp_to(curve2, coefficient)
            except UnsupportedCurveTypeException:
                pass
        return SvCurveLerpCurve(curve1, curve2, coefficient)

    def get_u_bounds(self):
        return self.u_bounds

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        us1 = (self.c1_max - self.c1_min) * ts + self.c1_min
        us2 = (self.c2_max - self.c2_min) * ts + self.c2_min
        c1_points = self.curve1.evaluate_array(us1)
        c2_points = self.curve2.evaluate_array(us2)
        k = self.coefficient
        return (1.0 - k) * c1_points + k * c2_points</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvCurveLerpCurve.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>curve1, curve2, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface"><code class="flex name class">
<span>class <span class="ident">SvCurveOffsetOnSurface</span></span>
<span>(</span><span>curve, surface, offset=None, offset_curve=None, offset_curve_type='T', len_resolution=50, uv_space=False, axis=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveOffsetOnSurface(SvCurve):

    BY_PARAMETER = &#39;T&#39;
    BY_LENGTH = &#39;L&#39;

    def __init__(self, curve, surface, offset = None, offset_curve = None,
                    offset_curve_type = BY_PARAMETER, len_resolution = 50,
                    uv_space=False, axis=0):
        self.curve = curve
        self.surface = surface
        self.offset = offset
        self.offset_curve = offset_curve
        self.offset_curve_type = offset_curve_type
        self.uv_space = uv_space
        self.z_axis = axis
        self.tangent_delta = 0.001
        if offset_curve_type == SvCurveOffsetOnSurface.BY_LENGTH:
            self.len_solver = SvCurveLengthSolver(curve)
            self.len_solver.prepare(&#39;SPL&#39;, len_resolution)

    def get_u_bounds(self):
        return self.curve.get_u_bounds()

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def get_offset(self, ts):
        u_min, u_max = self.curve.get_u_bounds()
        if self.offset_curve_type == SvCurveOffsetOnSurface.BY_PARAMETER:
            off_u_min, off_u_max = self.offset_curve.get_u_bounds()
            ts = (off_u_max - off_u_min) * (ts - u_min) / (u_max - u_min) + off_u_min
            ps = self.offset_curve.evaluate_array(ts)
            return ps[:,1]
        else:
            off_u_max = self.len_solver.get_total_length()
            ts = off_u_max * (ts - u_min) / (u_max - u_min)
            ts = self.len_solver.solve(ts)
            ps = self.offset_curve.evaluate_array(ts)
            return ps[:,1]

    def evaluate_array(self, ts):
        if self.z_axis == 2:
            U, V = 0, 1
        elif self.z_axis == 1:
            U, V = 0, 2
        else:
            U, V = 1, 2

        uv_points = self.curve.evaluate_array(ts)
        us, vs = uv_points[:,U], uv_points[:,V]
        # Tangents of the curve in surface&#39;s UV space
        uv_tangents = self.curve.tangent_array(ts) # (n, 3), with Z == 0 (Z is ignored anyway)
        tangents_u, tangents_v = uv_tangents[:,U], uv_tangents[:,V] # (n,), (n,)
        derivs = self.surface.derivatives_data_array(us, vs)
        su, sv = derivs.du, derivs.dv

        # Take surface&#39;s normals as N = [su, sv];
        # Take curve&#39;s tangent in 3D space as T = (tangents_u * su + tangents_v * sv);
        # Take a vector in surface&#39;s tangent plane, which is perpendicular to curve&#39;s
        # tangent, as Nc = [N, T] (call it &#34;curve&#39;s normal on a surface&#34;);
        # Calculate Nc&#39;s decomposition in su, sv vectors as Ncu = (Nc, su) and Ncv = (Nc, sv);
        # Interpret Ncu and Ncv as coordinates of Nc in surface&#39;s UV space.

        # If you write down all above in formulas, you will have
        #
        # Nc = (Tu (Su, Sv) + Tv Sv^2) Su - (Tu Su^2 + Tv (Su, Sv)) Sv

        # We could&#39;ve calculate the offset as (Curve on a surface) + (offset*Nc),
        # but there is no guarantee that these points will lie on the surface again
        # (especially with not-so-small values of offset).
        # So instead we calculate Curve + offset*(Ncu; Ncv) in UV space, and then
        # map all that into 3D space.

        su2 = (su*su).sum(axis=1) # (n,)
        sv2 = (sv*sv).sum(axis=1) # (n,)
        suv = (su*sv).sum(axis=1) # (n,)

        su_norm, sv_norm = derivs.tangent_lens()
        su_norm, sv_norm = su_norm.flatten(), sv_norm.flatten()

        delta_u =   (tangents_u*suv + tangents_v*sv2) # (n,)
        delta_v = - (tangents_u*su2 + tangents_v*suv) # (n,)

        delta_s = delta_u[np.newaxis].T * su + delta_v[np.newaxis].T * sv
        delta_s = np.linalg.norm(delta_s, axis=1)

        if self.offset_curve is None:
            offset = self.offset
        else:
            offset = self.get_offset(ts)

        res_us = us + delta_u * offset / delta_s
        res_vs = vs + delta_v * offset / delta_s

        if self.uv_space:
            zs = np.zeros_like(us)
            if self.z_axis == 2:
                result = np.stack((res_us, res_vs, zs)).T
            elif self.z_axis == 1:
                result = np.stack((res_us, zs, res_vs)).T
            else:
                result = np.stack((zs, res_us, res_vs)).T
            return result
        else:
            result = self.surface.evaluate_array(res_us, res_vs)
            # Just for testing
            # on_curve = self.surface.evaluate_array(us, vs)
            # dvs = result - on_curve
            # print(np.linalg.norm(dvs, axis=1))
            return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.BY_LENGTH"><code class="name">var <span class="ident">BY_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.BY_PARAMETER"><code class="name">var <span class="ident">BY_PARAMETER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.get_offset"><code class="name flex">
<span>def <span class="ident">get_offset</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurface"><code class="flex name class">
<span>class <span class="ident">SvCurveOnSurface</span></span>
<span>(</span><span>curve, surface, axis=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveOnSurface(SvCurve):
    def __init__(self, curve, surface, axis=0):
        self.curve = curve
        self.surface = surface
        self.axis = axis
        self.tangent_delta = 0.001
        self.__description__ = &#34;{} on {}&#34;.format(curve, surface)

    def get_u_bounds(self):
        return self.curve.get_u_bounds()

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        points = self.curve.evaluate_array(ts)
        xs = points[:,0]
        ys = points[:,1]
        zs = points[:,2]
        if self.axis == 0:
            us = ys
            vs = zs
        elif self.axis == 1:
            us = xs
            vs = zs
        elif self.axis == 2:
            us = xs
            vs = ys
        else:
            raise Exception(&#34;Unsupported orientation axis&#34;)
        return self.surface.evaluate_array(us, vs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator"><code class="flex name class">
<span>class <span class="ident">SvCurveOnSurfaceCurvaturesCalculator</span></span>
<span>(</span><span>uv_curve, surface, ts, w_axis=2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveOnSurfaceCurvaturesCalculator(object):
    def __init__(self, uv_curve, surface, ts, w_axis=2):
        self.uv_curve = uv_curve
        self.surface = surface
        self.ts = np.asarray(ts)
        self.w_axis = w_axis
        self.curve = SvCurveOnSurface(self.uv_curve, self.surface, axis=w_axis)
        self._uv_points = None
        self._uv_tangents = None
        self._uv_normals = None
        self._uv_normals_in_3d = None
        self._tangents = None
        self._unit_tangents = None
        self._surface_calculator = None

    def uv_axes(self):
        if self.w_axis == 2:
            U, V = 0, 1
        elif self.w_axis == 1:
            U, V = 0, 2
        else:
            U, V = 1, 2
        return U, V

    @property
    def uv_points(self):
        if self._uv_points is None:
            self._uv_points = self.uv_curve.evaluate_array(self.ts)
        return self._uv_points

    @property
    def uv_tangents(self):
        if self._uv_tangents is None:
            self._uv_tangents = self.uv_curve.tangent_array(self.ts)
        return self._uv_tangents

    @property
    def uv_normals(self):
        if self._uv_normals is None:
            U, V = self.uv_axes()
            tangents = self.uv_tangents
            normals = np.zeros_like(tangents)
            normals[:,U] = tangents[:,V]
            normals[:,V] = -tangents[:,U]
            self._uv_normals = normals
        return self._uv_normals

    @property
    def uv_normals_in_3d(self):
        if self._uv_normals_in_3d is None:
            self._uv_normals_in_3d = self.surface_calculator.derivatives_data.tangents_in_direction(self.uv_normals, self.w_axis)
        return self._uv_normals_in_3d

    @property
    def surface_calculator(self):
        if self._surface_calculator is None:
            U, V = self.uv_axes()
            self._surface_calculator = self.surface.curvature_calculator(self.uv_points[:,U], self.uv_points[:,V])
        return self._surface_calculator

    @property
    def tangents(self):
        if self._tangents is None:
            self._tangents = self.curve.tangent_array(self.ts)
        return self._tangents

    @property
    def unit_tangents(self):
        if self._unit_tangents is None:
            self._unit_tangents = self.tangents / np.linalg.norm(self.tangents, axis=1, keepdims=True)
        return self._unit_tangents

    def calc_tangent_cosines(self):
        du = self.surface_calculator.fu / np.linalg.norm(self.surface_calculator.fu, axis=1, keepdims=True)
        dv = self.surface_calculator.fv / np.linalg.norm(self.surface_calculator.fv, axis=1, keepdims=True)
        v1 = (self.unit_tangents * du).sum(axis=1)
        v2 = (self.unit_tangents * dv).sum(axis=1)
        return v1, v2

    def calc_curvatures_along_curve(self):
        v1, v2 = self.calc_tangent_cosines()
        return self.surface_calculator.curvature_along_direction(v1, v2)

    def calc_curvatures_across_curve(self):
        v1, v2 = self.calc_tangent_cosines()

        #mean = self.surface_calculator.mean()
        #curvatures = self.surface_calculator.curvature_along_direction(v1, v2)
        #curvatures = 2*mean - curvatures

        n1 = -np.sqrt(1 - v1*v1)
        n2 = np.sqrt(1 - v2*v2)
        curvatures = self.surface_calculator.curvature_along_direction(n1, n2)
        return curvatures

    def curve_frame_on_surface_array(self, normalize=True, on_zero_curvature=SvCurve.ASIS):
        &#34;&#34;&#34;
        Curve frame which is lying in the surface.

        Frame is oriented as follows:
            * X is pointing along surface normal
            * Z is pointing along curve tangent
            * Y is perpendicular to both X and Z.

        Args:
            normalize: whether the returned vectors should have unit norm

        Returns:
            tuple:
                * matrices: np.array of shape (n, 3, 3)
                * points: np.array of shape (n, 3) - points on the surface
                * tangents: np.array of shape (n, 3)
                * normals: np.array of shape (n, 3)
                * binormals: np.array of shape (n, 3)
        &#34;&#34;&#34;
        surf_points = self.surface_calculator.points
        if normalize:
            tangents = self.unit_tangents
        else:
            tangents = self.tangents

        normals = self.surface_calculator.normals
        if normalize:
            normals = normals / np.linalg.norm(normals, axis=1, keepdims=True)

        if on_zero_curvature != SvCurve.ASIS:
            zero_normal = np.linalg.norm(normals, axis=1) &lt; 1e-6
            if zero_normal.any():
                if on_zero_curvature == SvCurve.FAIL:
                    raise ZeroCurvatureException(np.unique(ts[zero_normal]), zero_normal)
                elif on_zero_curvature == SvCurve.RETURN_NONE:
                    return None

        binormals = - np.cross(normals, tangents)
        matrices_np = np.dstack((normals, binormals, tangents))
        matrices_np = np.transpose(matrices_np, axes=(0,2,1))
        matrices_np = np.linalg.inv(matrices_np)
        return matrices_np, surf_points, tangents, normals, binormals</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.surface_calculator"><code class="name">prop <span class="ident">surface_calculator</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def surface_calculator(self):
    if self._surface_calculator is None:
        U, V = self.uv_axes()
        self._surface_calculator = self.surface.curvature_calculator(self.uv_points[:,U], self.uv_points[:,V])
    return self._surface_calculator</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.tangents"><code class="name">prop <span class="ident">tangents</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tangents(self):
    if self._tangents is None:
        self._tangents = self.curve.tangent_array(self.ts)
    return self._tangents</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.unit_tangents"><code class="name">prop <span class="ident">unit_tangents</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit_tangents(self):
    if self._unit_tangents is None:
        self._unit_tangents = self.tangents / np.linalg.norm(self.tangents, axis=1, keepdims=True)
    return self._unit_tangents</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_normals"><code class="name">prop <span class="ident">uv_normals</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uv_normals(self):
    if self._uv_normals is None:
        U, V = self.uv_axes()
        tangents = self.uv_tangents
        normals = np.zeros_like(tangents)
        normals[:,U] = tangents[:,V]
        normals[:,V] = -tangents[:,U]
        self._uv_normals = normals
    return self._uv_normals</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_normals_in_3d"><code class="name">prop <span class="ident">uv_normals_in_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uv_normals_in_3d(self):
    if self._uv_normals_in_3d is None:
        self._uv_normals_in_3d = self.surface_calculator.derivatives_data.tangents_in_direction(self.uv_normals, self.w_axis)
    return self._uv_normals_in_3d</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_points"><code class="name">prop <span class="ident">uv_points</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uv_points(self):
    if self._uv_points is None:
        self._uv_points = self.uv_curve.evaluate_array(self.ts)
    return self._uv_points</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_tangents"><code class="name">prop <span class="ident">uv_tangents</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uv_tangents(self):
    if self._uv_tangents is None:
        self._uv_tangents = self.uv_curve.tangent_array(self.ts)
    return self._uv_tangents</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_curvatures_across_curve"><code class="name flex">
<span>def <span class="ident">calc_curvatures_across_curve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_curvatures_along_curve"><code class="name flex">
<span>def <span class="ident">calc_curvatures_along_curve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_tangent_cosines"><code class="name flex">
<span>def <span class="ident">calc_tangent_cosines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.curve_frame_on_surface_array"><code class="name flex">
<span>def <span class="ident">curve_frame_on_surface_array</span></span>(<span>self, normalize=True, on_zero_curvature='asis')</span>
</code></dt>
<dd>
<div class="desc"><p>Curve frame which is lying in the surface.</p>
<p>Frame is oriented as follows:
* X is pointing along surface normal
* Z is pointing along curve tangent
* Y is perpendicular to both X and Z.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>normalize</code></strong></dt>
<dd>whether the returned vectors should have unit norm</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple:
* matrices: np.array of shape (n, 3, 3)
* points: np.array of shape (n, 3) - points on the surface
* tangents: np.array of shape (n, 3)
* normals: np.array of shape (n, 3)
* binormals: np.array of shape (n, 3)</p></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_axes"><code class="name flex">
<span>def <span class="ident">uv_axes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvCurvesSortResult"><code class="flex name class">
<span>class <span class="ident">SvCurvesSortResult</span></span>
</code></dt>
<dd>
<div class="desc"><p>Result of <code><a title="sverchok.utils.curve.algorithms.sort_curves_for_concat" href="#sverchok.utils.curve.algorithms.sort_curves_for_concat">sort_curves_for_concat()</a></code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurvesSortResult(object):
    &#34;&#34;&#34;
    Result of `sort_curves_for_concat` method.
    &#34;&#34;&#34;
    def __init__(self):
        self.curves = []
        self.indexes = []
        self.flips = []
        self.sum_error = 0</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvDeformedByFieldCurve"><code class="flex name class">
<span>class <span class="ident">SvDeformedByFieldCurve</span></span>
<span>(</span><span>curve, field, coefficient=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvDeformedByFieldCurve(SvCurve):
    def __init__(self, curve, field, coefficient=1.0):
        self.curve = curve
        self.field = field
        self.coefficient = coefficient
        self.tangent_delta = 0.001
        self.__description__ = &#34;{}({})&#34;.format(field, curve)

    def get_u_bounds(self):
        return self.curve.get_u_bounds()

    def evaluate(self, t):
        v = self.curve.evaluate(t)
        vec = self.field.evaluate(*tuple(v))
        return v + self.coefficient * vec

    def evaluate_array(self, ts):
        vs = self.curve.evaluate_array(ts)
        xs, ys, zs = vs[:,0], vs[:,1], vs[:,2]
        vxs, vys, vzs = self.field.evaluate_grid(xs, ys, zs)
        vecs = np.stack((vxs, vys, vzs)).T
        return vs + self.coefficient * vecs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvIsoUvCurve"><code class="flex name class">
<span>class <span class="ident">SvIsoUvCurve</span></span>
<span>(</span><span>surface, fixed_axis, value, flip=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvIsoUvCurve(SvCurve):
    def __init__(self, surface, fixed_axis, value, flip=False):
        self.surface = surface
        self.fixed_axis = fixed_axis
        self.value = value
        self.flip = flip
        self.tangent_delta = 0.001
        self.__description__ = &#34;{} at {} = {}&#34;.format(surface, fixed_axis, value)

    @staticmethod
    def take(surface, fixed_axis, value, flip=False):
        if hasattr(surface, &#39;iso_curve&#39;):
            try:
                return surface.iso_curve(fixed_axis, value, flip=flip)
            except UnsupportedSurfaceTypeException:
                pass
        return SvIsoUvCurve(surface, fixed_axis, value, flip=flip)

    def get_u_bounds(self):
        if self.fixed_axis == &#39;U&#39;:
            return self.surface.get_v_min(), self.surface.get_v_max()
        else:
            return self.surface.get_u_min(), self.surface.get_u_max()

    def evaluate(self, t):
        if self.fixed_axis == &#39;U&#39;:
            if self.flip:
                t = self.surface.get_v_max() - t + self.surface.get_v_min()
            return self.surface.evaluate(self.value, t)
        else:
            if self.flip:
                t = self.surface.get_u_max() - t + self.surface.get_u_min()
            return self.surface.evaluate(t, self.value)

    def evaluate_array(self, ts):
        if self.fixed_axis == &#39;U&#39;:
            if self.flip:
                ts = self.surface.get_v_max() - ts + self.surface.get_v_min()
            return self.surface.evaluate_array(np.repeat(self.value, len(ts)), ts)
        else:
            if self.flip:
                ts = self.surface.get_u_max() - ts + self.surface.get_u_min()
            return self.surface.evaluate_array(ts, np.repeat(self.value, len(ts)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvIsoUvCurve.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>surface, fixed_axis, value, flip=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvLengthRebuiltCurve"><code class="flex name class">
<span>class <span class="ident">SvLengthRebuiltCurve</span></span>
<span>(</span><span>curve, resolution, mode='SPL', tolerance=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvLengthRebuiltCurve(SvCurve):
    def __init__(self, curve, resolution, mode=&#39;SPL&#39;, tolerance=None):
        self.curve = curve
        self.resolution = resolution
        if hasattr(curve, &#39;tangent_delta&#39;):
            self.tangent_delta = curve.tangent_delta
        else:
            self.tangent_delta = 0.001
        self.mode = mode
        self.solver = SvCurveLengthSolver(curve)
        self.solver.prepare(self.mode, resolution, tolerance=tolerance)
        self.u_bounds = (0.0, self.solver.get_total_length())
        self.__description__ = &#34;{} rebuilt&#34;.format(curve)

    def get_u_bounds(self):
        return self.u_bounds

    def evaluate(self, t):
        c_ts = self.solver.solve(np.array([t]))
        return self.curve.evaluate(c_ts[0])

    def evaluate_array(self, ts):
        c_ts = self.solver.solve(ts)
        return self.curve.evaluate_array(c_ts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvNormalTrack"><code class="flex name class">
<span>class <span class="ident">SvNormalTrack</span></span>
<span>(</span><span>curve, resolution)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNormalTrack(object):
    def __init__(self, curve, resolution):
        self.curve = curve
        self.resolution = resolution
        self._pre_calc()

    def _make_quats(self, points, tangents, normals, binormals):
        matrices = np.dstack((normals, binormals, tangents))
        matrices = np.transpose(matrices, axes=(0,2,1))
        matrices = np.linalg.inv(matrices)
        return [Matrix(m).to_quaternion() for m in matrices]

    def _pre_calc(self):
        curve = self.curve
        t_min, t_max = curve.get_u_bounds()
        ts = np.linspace(t_min, t_max, num=self.resolution)

        points = curve.evaluate_array(ts)
        tangents, normals, binormals = curve.tangent_normal_binormal_array(ts)
        tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)

        normal = normals[0]
        if np.linalg.norm(normal) &gt; 1e-4:
            binormal = binormals[0]
            binormal /= np.linalg.norm(binormal)
        else:
            tangent = tangents[0]
            normal = Vector(tangent).orthogonal()
            normal = np.array(normal)
            binormal = np.cross(tangent, normal)
            binormal /= np.linalg.norm(binormal)

        out_normals = [normal]
        out_binormals = [binormal]

        for point, tangent in zip(points[1:], tangents[1:]):
            plane = PlaneEquation.from_normal_and_point(Vector(tangent), Vector(point))
            normal = plane.projection_of_vector(Vector(point), Vector(point + normal))
            normal = np.array(normal.normalized())
            binormal = np.cross(tangent, normal)
            binormal /= np.linalg.norm(binormal)
            out_normals.append(normal)
            out_binormals.append(binormal)

        self.quats = self._make_quats(points, tangents, np.array(out_normals), np.array(out_binormals))
        self.tknots = ts

    def evaluate_array(self, ts):
        &#34;&#34;&#34;
        Args:
            ts: np.array of snape (n,) or list of floats
        
        Returns:
            np.array of shape (n, 3, 3)
        &#34;&#34;&#34;
        ts = np.array(ts)
        tknots, quats = self.tknots, self.quats
        base_indexes = tknots.searchsorted(ts, side=&#39;left&#39;)-1
        t1s, t2s = tknots[base_indexes], tknots[base_indexes+1]
        dts = (ts - t1s) / (t2s - t1s)
        #dts = np.clip(dts, 0.0, 1.0) # Just in case...
        matrix_out = []
        # TODO: ideally this should be vectorized with numpy;
        # but that would require implementation of quaternion
        # interpolation in numpy.
        for dt, base_index in zip(dts, base_indexes):
            q1, q2 = quats[base_index], quats[base_index+1]
            # spherical linear interpolation.
            # TODO: implement `squad`.
            if dt &lt; 0:
                q = q1
            elif dt &gt; 1.0:
                q = q2
            else:
                q = q1.slerp(q2, dt)
            matrix = np.array(q.to_matrix())
            matrix_out.append(matrix)
        return np.array(matrix_out)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvNormalTrack.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>ts</code></strong></dt>
<dd>np.array of snape (n,) or list of floats</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.array of shape (n, 3, 3)</p></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvOffsetCurve"><code class="flex name class">
<span>class <span class="ident">SvOffsetCurve</span></span>
<span>(</span><span>curve, offset_vector, offset_amount=None, offset_curve=None, offset_curve_type='T', algorithm='FRENET', resolution=50)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvOffsetCurve(SvCurve):

    BY_PARAMETER = &#39;T&#39;
    BY_LENGTH = &#39;L&#39;

    def __init__(self, curve, offset_vector,
                    offset_amount=None,
                    offset_curve = None, offset_curve_type = BY_PARAMETER,
                    algorithm=FRENET, resolution=50):
        self.curve = curve
        if algorithm == NORMAL_DIR and (offset_amount is None and offset_curve is None):
            raise Exception(&#34;offset_amount or offset_curve is mandatory if algorithm is NORMAL_DIR&#34;)
        self.offset_amount = offset_amount
        self.offset_vector = offset_vector
        self.offset_curve = offset_curve
        self.offset_curve_type = offset_curve_type
        self.algorithm = algorithm
        if algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            self.calculator = DifferentialRotationCalculator(curve, algorithm, resolution)
        if offset_curve_type == SvOffsetCurve.BY_LENGTH:
            self.len_solver = SvCurveLengthSolver(curve)
            self.len_solver.prepare(&#39;SPL&#39;, resolution)
        self.tangent_delta = 0.001

    def get_u_bounds(self):
        return self.curve.get_u_bounds()

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def get_matrix(self, tangent):
        return MathutilsRotationCalculator.get_matrix(tangent, scale=1.0,
                axis=2,
                algorithm = self.algorithm,
                scale_all=False)

    def get_matrices(self, ts):
        if self.algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            return self.calculator.get_matrices(ts)
        elif self.algorithm in {HOUSEHOLDER, TRACK, DIFF}:
            tangents = self.curve.tangent_array(ts)
            matrices = np.vectorize(lambda t : self.get_matrix(t), signature=&#39;(3)-&gt;(3,3)&#39;)(tangents)
            return matrices
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)

    def get_offset(self, ts):
        u_min, u_max = self.curve.get_u_bounds()
        if self.offset_curve is None:
            if self.offset_amount is not None:
                return self.offset_amount
            else:
                return np.linalg.norm(self.offset_vector)
        elif self.offset_curve_type == SvOffsetCurve.BY_PARAMETER:
            off_u_min, off_u_max = self.offset_curve.get_u_bounds()
            ts = (off_u_max - off_u_min) * (ts - u_min) / (u_max - u_min) + off_u_min
            ps = self.offset_curve.evaluate_array(ts)
            return ps[:,1][np.newaxis].T
        else:
            off_u_max = self.len_solver.get_total_length()
            ts = off_u_max * (ts - u_min) / (u_max - u_min)
            ts = self.len_solver.solve(ts)
            ps = self.offset_curve.evaluate_array(ts)
            return ps[:,1][np.newaxis].T

    def evaluate_array(self, ts):
        n = len(ts)
        t_min, t_max = self.curve.get_u_bounds()
        extrusion_start = self.curve.evaluate(t_min)
        extrusion_points = self.curve.evaluate_array(ts)
        extrusion_vectors = extrusion_points - extrusion_start
        offset_vector = self.offset_vector / np.linalg.norm(self.offset_vector)
        if self.algorithm == NORMAL_DIR:
            offset_vectors = np.tile(offset_vector[np.newaxis].T, n).T
            tangents = self.curve.tangent_array(ts)
            offset_vectors = np.cross(tangents, offset_vectors)
            offset_norm = np.linalg.norm(offset_vectors, axis=1, keepdims=True)
            offset_amounts = self.get_offset(ts)
            offset_vectors = offset_amounts * offset_vectors / offset_norm
        else:
            offset_vectors = np.tile(offset_vector[np.newaxis].T, n)
            matrices = self.get_matrices(ts)
            offset_amounts = self.get_offset(ts)
            offset_vectors = offset_amounts * (matrices @ offset_vectors)[:,:,0]
        result = extrusion_vectors + offset_vectors
        result = result + extrusion_start
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvOffsetCurve.BY_LENGTH"><code class="name">var <span class="ident">BY_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvOffsetCurve.BY_PARAMETER"><code class="name">var <span class="ident">BY_PARAMETER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.algorithms.SvOffsetCurve.get_matrices"><code class="name flex">
<span>def <span class="ident">get_matrices</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvOffsetCurve.get_matrix"><code class="name flex">
<span>def <span class="ident">get_matrix</span></span>(<span>self, tangent)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.curve.algorithms.SvOffsetCurve.get_offset"><code class="name flex">
<span>def <span class="ident">get_offset</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.curve" href="index.html">sverchok.utils.curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.concatenate_curves" href="#sverchok.utils.curve.algorithms.concatenate_curves">concatenate_curves</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.curve_frame_on_surface_array" href="#sverchok.utils.curve.algorithms.curve_frame_on_surface_array">curve_frame_on_surface_array</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.curve_segment" href="#sverchok.utils.curve.algorithms.curve_segment">curve_segment</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.make_euclidean_ts" href="#sverchok.utils.curve.algorithms.make_euclidean_ts">make_euclidean_ts</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.reparametrize_curve" href="#sverchok.utils.curve.algorithms.reparametrize_curve">reparametrize_curve</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.reverse_curve" href="#sverchok.utils.curve.algorithms.reverse_curve">reverse_curve</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.sort_curves_for_concat" href="#sverchok.utils.curve.algorithms.sort_curves_for_concat">sort_curves_for_concat</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.split_curve" href="#sverchok.utils.curve.algorithms.split_curve">split_curve</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.unify_curves_degree" href="#sverchok.utils.curve.algorithms.unify_curves_degree">unify_curves_degree</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.DifferentialRotationCalculator" href="#sverchok.utils.curve.algorithms.DifferentialRotationCalculator">DifferentialRotationCalculator</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.DifferentialRotationCalculator.get_matrices" href="#sverchok.utils.curve.algorithms.DifferentialRotationCalculator.get_matrices">get_matrices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.MathutilsRotationCalculator" href="#sverchok.utils.curve.algorithms.MathutilsRotationCalculator">MathutilsRotationCalculator</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.MathutilsRotationCalculator.get_matrix" href="#sverchok.utils.curve.algorithms.MathutilsRotationCalculator.get_matrix">get_matrix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCastCurveToCylinder" href="#sverchok.utils.curve.algorithms.SvCastCurveToCylinder">SvCastCurveToCylinder</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCastCurveToPlane" href="#sverchok.utils.curve.algorithms.SvCastCurveToPlane">SvCastCurveToPlane</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCastCurveToSphere" href="#sverchok.utils.curve.algorithms.SvCastCurveToSphere">SvCastCurveToSphere</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCurveFrameCalculator" href="#sverchok.utils.curve.algorithms.SvCurveFrameCalculator">SvCurveFrameCalculator</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveFrameCalculator.get_matrices" href="#sverchok.utils.curve.algorithms.SvCurveFrameCalculator.get_matrices">get_matrices</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveFrameCalculator.get_matrix" href="#sverchok.utils.curve.algorithms.SvCurveFrameCalculator.get_matrix">get_matrix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCurveLengthSolver" href="#sverchok.utils.curve.algorithms.SvCurveLengthSolver">SvCurveLengthSolver</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length" href="#sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length_params" href="#sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length_params">calc_length_params</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length_segments" href="#sverchok.utils.curve.algorithms.SvCurveLengthSolver.calc_length_segments">calc_length_segments</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveLengthSolver.get_total_length" href="#sverchok.utils.curve.algorithms.SvCurveLengthSolver.get_total_length">get_total_length</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveLengthSolver.prepare" href="#sverchok.utils.curve.algorithms.SvCurveLengthSolver.prepare">prepare</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveLengthSolver.solve" href="#sverchok.utils.curve.algorithms.SvCurveLengthSolver.solve">solve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCurveLerpCurve" href="#sverchok.utils.curve.algorithms.SvCurveLerpCurve">SvCurveLerpCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveLerpCurve.build" href="#sverchok.utils.curve.algorithms.SvCurveLerpCurve.build">build</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface" href="#sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface">SvCurveOffsetOnSurface</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.BY_LENGTH" href="#sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.BY_LENGTH">BY_LENGTH</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.BY_PARAMETER" href="#sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.BY_PARAMETER">BY_PARAMETER</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.get_offset" href="#sverchok.utils.curve.algorithms.SvCurveOffsetOnSurface.get_offset">get_offset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurface" href="#sverchok.utils.curve.algorithms.SvCurveOnSurface">SvCurveOnSurface</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator">SvCurveOnSurfaceCurvaturesCalculator</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_curvatures_across_curve" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_curvatures_across_curve">calc_curvatures_across_curve</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_curvatures_along_curve" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_curvatures_along_curve">calc_curvatures_along_curve</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_tangent_cosines" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.calc_tangent_cosines">calc_tangent_cosines</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.curve_frame_on_surface_array" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.curve_frame_on_surface_array">curve_frame_on_surface_array</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.surface_calculator" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.surface_calculator">surface_calculator</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.tangents" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.tangents">tangents</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.unit_tangents" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.unit_tangents">unit_tangents</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_axes" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_axes">uv_axes</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_normals" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_normals">uv_normals</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_normals_in_3d" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_normals_in_3d">uv_normals_in_3d</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_points" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_points">uv_points</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_tangents" href="#sverchok.utils.curve.algorithms.SvCurveOnSurfaceCurvaturesCalculator.uv_tangents">uv_tangents</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvCurvesSortResult" href="#sverchok.utils.curve.algorithms.SvCurvesSortResult">SvCurvesSortResult</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvDeformedByFieldCurve" href="#sverchok.utils.curve.algorithms.SvDeformedByFieldCurve">SvDeformedByFieldCurve</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvIsoUvCurve" href="#sverchok.utils.curve.algorithms.SvIsoUvCurve">SvIsoUvCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvIsoUvCurve.take" href="#sverchok.utils.curve.algorithms.SvIsoUvCurve.take">take</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvLengthRebuiltCurve" href="#sverchok.utils.curve.algorithms.SvLengthRebuiltCurve">SvLengthRebuiltCurve</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvNormalTrack" href="#sverchok.utils.curve.algorithms.SvNormalTrack">SvNormalTrack</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvNormalTrack.evaluate_array" href="#sverchok.utils.curve.algorithms.SvNormalTrack.evaluate_array">evaluate_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.algorithms.SvOffsetCurve" href="#sverchok.utils.curve.algorithms.SvOffsetCurve">SvOffsetCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.algorithms.SvOffsetCurve.BY_LENGTH" href="#sverchok.utils.curve.algorithms.SvOffsetCurve.BY_LENGTH">BY_LENGTH</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvOffsetCurve.BY_PARAMETER" href="#sverchok.utils.curve.algorithms.SvOffsetCurve.BY_PARAMETER">BY_PARAMETER</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvOffsetCurve.get_matrices" href="#sverchok.utils.curve.algorithms.SvOffsetCurve.get_matrices">get_matrices</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvOffsetCurve.get_matrix" href="#sverchok.utils.curve.algorithms.SvOffsetCurve.get_matrix">get_matrix</a></code></li>
<li><code><a title="sverchok.utils.curve.algorithms.SvOffsetCurve.get_offset" href="#sverchok.utils.curve.algorithms.SvOffsetCurve.get_offset">get_offset</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
