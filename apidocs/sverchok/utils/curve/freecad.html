<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.curve.freecad API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.curve.freecad</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import numpy as np
import math

from sverchok.utils.nurbs_common import SvNurbsMaths
from sverchok.utils.curve.core import SvCurve, UnsupportedCurveTypeException
from sverchok.utils.curve.nurbs import SvNurbsCurve
from sverchok.utils.curve.nurbs_solver_applications import interpolate_nurbs_curve
from sverchok.utils.curve import knotvector as sv_knotvector
from sverchok.utils.curve.primitives import SvLine, SvCircle
from sverchok.utils.curve.biarc import SvBiArc
from sverchok.utils.sv_logging import sv_logger

from sverchok.dependencies import FreeCAD
if FreeCAD is not None:
    from FreeCAD import Base
    import Part
    from Part import Geom2d

curve_converters = dict()

def line_to_freecad(line):
    u_min, u_max = line.get_u_bounds()
    p1 = tuple(line.evaluate(u_min))
    p2 = tuple(line.evaluate(u_max))
    p1 = Base.Vector(*p1)
    p2 = Base.Vector(*p2)
    fc_line = Part.LineSegment(p1, p2)
    return [fc_line]

curve_converters[SvLine] = line_to_freecad

def circle_to_freecad(circle):
    center = tuple(circle.center)
    normal = tuple(circle.normal)
    #vectorx = tuple(circle.vectorx / np.linalg.norm(circle.vectorx))
    radius = circle.get_actual_radius()
    u_min, u_max = circle.get_u_bounds()
    vectorx = circle.evaluate(0) - circle.center
    vectorx /= np.linalg.norm(vectorx)
    vectorx = tuple(vectorx)

    fc_circle = Part.Circle(Base.Vector(*center), Base.Vector(*normal), radius)
    if u_min != 0 or u_max != 2*math.pi:
        fc_circle.XAxis = Base.Vector(*vectorx)
        fc_arc = fc_circle.trim(u_min, u_max)
        return [fc_arc]
    else:
        return [fc_circle]

curve_converters[SvCircle] = circle_to_freecad

def biarc_to_freecad(biarc):
    arc1 = circle_to_freecad(biarc.arc1)
    arc2 = circle_to_freecad(biarc.arc2)
    return arc1 + arc2

curve_converters[SvBiArc] = biarc_to_freecad

def curve_to_freecad_nurbs(sv_curve):
    &#34;&#34;&#34;
    Convert SvCurve to FreeCAD&#39;s NURBS curve.
    Raise an exception if it is not possible.

    input: SvCurve
    output: SvFreeCadNurbsCurve
    &#34;&#34;&#34;
    nurbs = SvNurbsCurve.to_nurbs(sv_curve)
    if nurbs is None:
        raise TypeError(f&#34;{sv_curve} is not a NURBS curve&#34;)
    fc_curve = SvNurbsMaths.build_curve(SvNurbsMaths.FREECAD,
                nurbs.get_degree(),
                nurbs.get_knotvector(),
                nurbs.get_control_points(),
                nurbs.get_weights())
    return fc_curve

def curves_to_wire(sv_curves):
    fc_curves = [curve_to_freecad_nurbs(curve).curve for curve in sv_curves]
    shapes = [Part.Edge(curve) for curve in fc_curves]
    wire = Part.Wire(shapes)
    return wire

def make_helix(pitch, height, radius, apex_angle=0):
    # FIXME: in FreeCAD pydoc, there is also &#34;makeLongHelix&#34;,
    # which seems to be more suitable here because it said to be &#34;multi-edge&#34;;
    # However, in my experiments, makeLongHelix always makes
    # a helix with exactly one turn, while makeHelix makes as many
    # turns as necessary.
    wire = Part.makeHelix(pitch, height, radius, apex_angle)
    fc_edge = wire.Edges[0]
    curve = SvSolidEdgeCurve(fc_edge)
    return curve

class SvSolidEdgeCurve(SvCurve):
    __description__ = &#34;Solid Edge&#34;
    def __init__(self, solid_edge):
        self.edge = solid_edge
        self.curve = solid_edge.Curve
        self.u_bounds = (self.edge.FirstParameter, self.edge.LastParameter)

    def evaluate(self, t):
        return np.array(self.curve.value(t))

    def evaluate_array(self, ts):
        t_out = []
        for t in ts:
            t_out.append(self.curve.value(t))
        return np.array(t_out)

    def tangent(self, t, tangent_delta=None):
        return np.array(self.edge.tangentAt(t))

    def tangent_array(self, ts, tangent_delta=None):
        tangents = []
        for t in ts:
            tangents.append(self.edge.tangentAt(t))
        return np.array(tangents)

    def get_u_bounds(self):
        return self.u_bounds

    def to_nurbs(self, implementation = SvNurbsMaths.FREECAD):
        curve = self.curve.toBSpline(*self.u_bounds)
        #curve.transform(self.edge.Matrix)
        control_points = np.array(curve.getPoles())
        weights = np.array(curve.getWeights())
        knotvector = np.array(curve.KnotSequence)
        curve = SvNurbsMaths.build_curve(implementation,
                    curve.Degree, knotvector,
                    control_points,
                    weights)
        #curve.u_bounds = self.u_bounds
        return curve

class SvFreeCadCurve(SvCurve):
    def __init__(self, curve, bounds, ndim=3):
        self.curve = curve
        self.u_bounds = bounds
        self.ndim = ndim
    
    def __repr__(self):
        return f&#34;&lt;FreeCAD {self.ndim}D curve, {type(self.curve).__name__}&gt;&#34;

    def _convert(self, p):
        if self.ndim == 2:
            return [p.x, p.y, 0]
        else:
            return [p.x, p.y, p.z]

    def evaluate(self, t):
        p = self.curve.value(t)
        return np.array(self._convert(p))

    def evaluate_array(self, ts):
        return np.vectorize(self.evaluate, signature=&#39;()-&gt;(3)&#39;)(ts)

    def tangent(self, t, tangent_delta=None):
        p = self.edge.tangentAt(t)
        return np.array(self._convert(p))

    def tangent_array(self, ts, tangent_delta=None):
        return np.vectorize(self.tangent, signature=&#39;()-&gt;(3)&#39;)(ts)

    def get_u_bounds(self):
        return self.u_bounds

    #def get_u_bounds(self):
    #    return (self.curve.FirstParameter, self.curve.LastParameter)

    def reverse(self):
        result = self.to_nurbs().reverse()
        if self.ndim == 2:
            result = result.to_2d()
        return result
        #curve = self.curve.copy()
        #curve.reverse()
        #return SvFreeCadCurve(curve, self.u_bounds, self.ndim)

    def concatenate(self, curve2, tolerance=1e-6):
        if isinstance(curve2, SvFreeCadCurve) and self.ndim == curve2.ndim == 2:
            curve1 = self.curve.toBSpline(*self.u_bounds)
            curve2 = curve2.curve.toBSpline()
            curve1.join(curve2)
            return SvFreeCadNurbsCurve(curve1, self.ndim)
        elif isinstance(curve2, SvFreeCadNurbsCurve) and self.ndim == curve2.ndim == 2:
            curve1 = self.curve.toBSpline(*self.u_bounds)
            curve2 = curve2.curve
            curve1.join(curve2)
            return SvFreeCadNurbsCurve(curve1, self.ndim)
        return self.to_nurbs().concatenate(curve2, tolerance)

    def to_nurbs(self, implementation = SvNurbsMaths.FREECAD):
        curve = self.curve.toBSpline(*self.u_bounds)

        if implementation == SvNurbsMaths.FREECAD:
            return SvFreeCadNurbsCurve(curve, self.ndim)

        #curve.transform(self.edge.Matrix)
        if self.ndim == 2:
            control_points = [(p.x, p.y, 0) for p in curve.getPoles()]
        else:
            control_points = [(p.x, p.y, p.z) for p in curve.getPoles()]
        control_points = np.array(control_points)
        weights = np.array(curve.getWeights())
        knotvector = np.array(curve.KnotSequence)

        curve = SvNurbsMaths.build_curve(implementation,
                    curve.Degree, knotvector,
                    control_points,
                    weights)
        #curve.u_bounds = self.u_bounds
        return curve

class SvFreeCadNurbsCurve(SvNurbsCurve):
    def __init__(self, curve, ndim=3):
        self.curve = curve
        self.ndim = ndim
        self.u_bounds = None # from FreeCAD data
        self.__description__ = f&#34;FreeCAD {ndim}D NURBS (degree={curve.Degree}, pts={curve.NbPoles})&#34;

    @classmethod
    def build(cls, implementation, degree, knotvector, control_points, weights=None, normalize_knots=False):
        n = len(control_points)
        if weights is None:
            weights = np.ones((n,))

        if normalize_knots:
            knotvector = sv_knotvector.normalize(knotvector)

        pts = [Base.Vector(t[0], t[1], t[2]) for t in control_points]
        ms = sv_knotvector.to_multiplicity(knotvector)
        knots = [p[0] for p in ms]
        mults = [p[1] for p in ms]

        curve = Part.BSplineCurve()
        curve.buildFromPolesMultsKnots(pts, mults, knots, False, degree, weights)
        return SvFreeCadNurbsCurve(curve)

    @classmethod
    def build_2d(cls, degree, knotvector, control_points, weights=None):
        n = len(control_points)
        if weights is None:
            weights = np.ones((n,))

        pts = [Base.Vector2d(t[0], t[1]) for t in control_points]
        ms = sv_knotvector.to_multiplicity(knotvector)
        knots = [p[0] for p in ms]
        mults = [p[1] for p in ms]

        curve = Geom2d.BSplineCurve2d()
        curve.buildFromPolesMultsKnots(pts, mults, knots, False, degree, weights)
        return SvFreeCadNurbsCurve(curve, ndim=2)

    @classmethod
    def interpolate(cls, degree, points, metric=&#39;DISTANCE&#39;, tknots=None, cyclic=False, logger=None, **kwargs):
        curve = interpolate_nurbs_curve(degree, points, metric=metric, tknots=tknots, cyclic=cyclic, logger=logger)
        return curve.copy(implementation = SvNurbsMaths.FREECAD)

    def to_2d(self):
        return SvFreeCadNurbsCurve.build_2d(self.get_degree(), self.get_knotvector(),
                    self.get_control_points(), self.get_weights())
    
    @classmethod
    def from_any_nurbs(cls, curve):
        if not isinstance(curve, SvNurbsCurve):
            raise TypeError(&#34;Invalid curve type&#34;)
        if isinstance(curve, SvFreeCadNurbsCurve):
            return curve
        return SvFreeCadNurbsCurve.build(SvNurbsMaths.FREECAD,
                    curve.get_degree(), curve.get_knotvector(),
                    curve.get_control_points(), 
                    curve.get_weights())

    @classmethod
    def get_nurbs_implementation(cls):
        return SvNurbsMaths.FREECAD

    def is_closed(self, eps=None):
        return self.curve.isClosed()
    
    def _convert(self, p):
        if self.ndim == 2:
            return [p.x, p.y, 0]
        else:
            return [p.x, p.y, p.z]

    def evaluate(self, t):
        pt = self.curve.value(t)
        return np.array(self._convert(pt))

    def evaluate_array(self, ts):
        return np.vectorize(self.evaluate, signature=&#39;()-&gt;(3)&#39;)(ts)
    
    def tangent(self, t, tangent_delta=None):
        p, v = self.curve.getD1(t)
        if not isinstance(v, tuple):
            v = self._convert(v)
        return np.array(v)
    
    def tangent_array(self, ts, tangent_delta=None):
        return np.vectorize(self.tangent, signature=&#39;()-&gt;(3)&#39;)(ts)    

    def second_derivative(self, t, tangent_delta = None):
        p, v1, v = self.curve.getD2(t)
        if not isinstance(v, tuple):
            v = self._convert(v)
        return np.array(v)

    def second_derivative_array(self, ts, tangent_delta=None):
        return np.vectorize(self.second_derivative, signature=&#39;()-&gt;(3)&#39;)(ts)    

    def third_derivative(self, t, tangent_delta = None):
        p, v1, v2, v = self.curve.getD3(t)
        if not isinstance(v, tuple):
            v = self._convert(v)
        return np.array(v)

    def third_derivative_array(self, ts, tangent_delta=None):
        return np.vectorize(self.third_derivative, signature=&#39;()-&gt;(3)&#39;)(ts)    

    def derivatives_array(self, n, ts, tangent_delta=None):
        first_derivatives = []
        second_derivatives = []
        third_derivatives = []

        for t in ts:
            p, v1, v2, v3 = self.curve.getD3(t)
            first_derivatives.append(self._convert(v1))
            second_derivatives.append(self._convert(v2))
            third_derivatives.append(self._convert(v3))

        first_derivatives = np.array(first_derivatives)
        second_derivatives = np.array(second_derivatives)
        third_derivatives = np.array(third_derivatives)

        return [first_derivatives, second_derivatives, third_derivatives][:n]

    def get_u_bounds(self):
        if self.u_bounds is None:
            return (self.curve.KnotSequence[0], self.curve.KnotSequence[-1])
        else:
            return self.u_bounds

    def get_knotvector(self):
        knots = self.curve.getKnots()
        mults = self.curve.getMultiplicities()
        ms = zip(knots, mults)
        return sv_knotvector.from_multiplicity(ms)

    def get_degree(self):
        return self.curve.Degree

    def get_control_points(self):
        poles = self.curve.getPoles()
        poles = [self._convert(p) for p in poles]
        return np.array(poles)

    def get_weights(self):
        return np.array(self.curve.getWeights())

    def insert_knot(self, u, count=1, if_possible=False):
        curve = SvFreeCadNurbsCurve(self.curve.copy(), self.ndim) # copy
        curve.curve.insertKnot(u, count)
        return curve

    def remove_knot(self, u, count=1, tolerance=1e-4, if_possible=False):
        curve = SvFreeCadNurbsCurve(self.curve.copy(), self.ndim) # copy
        ms = sv_knotvector.to_multiplicity(self.get_knotvector())
        idx = None
        M = None
        for i, (u1, m) in enumerate(ms):
            if u1 == u:
                idx = i
                if count == &#39;ALL&#39;:
                    M = 0
                elif count == &#39;ALL_BUT_ONE&#39;:
                    M = 1
                else:
                    M = m - count
                break
        if idx is not None:
            curve.curve.removeKnot(idx+1, M, tolerance)
        return curve

SvNurbsMaths.curve_classes[SvNurbsMaths.FREECAD] = SvFreeCadNurbsCurve

def curve_to_freecad(sv_curve):
    converter = curve_converters.get(type(sv_curve), None)
    if converter is not None:
        try:
            fc_curves = converter(sv_curve)
            result = []
            for fc_curve in fc_curves:
                bounds = fc_curve.FirstParameter, fc_curve.LastParameter
                sv_curve = SvFreeCadCurve(fc_curve, bounds)
                result.append(sv_curve)
            return result
        except UnsupportedCurveTypeException as e:
            sv_logger.info(f&#34;Can&#39;t convert {sv_curve} to native FreeCAD curve: {e}&#34;)
            pass
    return [curve_to_freecad_nurbs(sv_curve)]

def get_curve_endpoints(fc_curve):
    if hasattr(fc_curve, &#39;StartPoint&#39;):
        p1, p2 = fc_curve.StartPoint, fc_curve.EndPoint
    else:
        t1, t2 = fc_curve.FirstParameter, fc_curve.LastParameter
        if hasattr(fc_curve, &#39;valueAt&#39;):
            p1, p2 = fc_curve.valueAt(t1), fc_curve.valueAt(t2)
        else:
            p1, p2 = fc_curve.value(t1), fc_curve.value(t2)
    return p1, p2

def get_edge_endpoints(fc_edge):
    t1, t2 = fc_edge.ParameterRange
    fc_curve = fc_edge.Curve
    if hasattr(fc_curve, &#39;valueAt&#39;):
        p1, p2 = fc_curve.valueAt(t1), fc_curve.valueAt(t2)
    else:
        p1, p2 = fc_curve.value(t1), fc_curve.value(t2)
    return p1, p2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.curve.freecad.biarc_to_freecad"><code class="name flex">
<span>def <span class="ident">biarc_to_freecad</span></span>(<span>biarc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def biarc_to_freecad(biarc):
    arc1 = circle_to_freecad(biarc.arc1)
    arc2 = circle_to_freecad(biarc.arc2)
    return arc1 + arc2</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.circle_to_freecad"><code class="name flex">
<span>def <span class="ident">circle_to_freecad</span></span>(<span>circle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_to_freecad(circle):
    center = tuple(circle.center)
    normal = tuple(circle.normal)
    #vectorx = tuple(circle.vectorx / np.linalg.norm(circle.vectorx))
    radius = circle.get_actual_radius()
    u_min, u_max = circle.get_u_bounds()
    vectorx = circle.evaluate(0) - circle.center
    vectorx /= np.linalg.norm(vectorx)
    vectorx = tuple(vectorx)

    fc_circle = Part.Circle(Base.Vector(*center), Base.Vector(*normal), radius)
    if u_min != 0 or u_max != 2*math.pi:
        fc_circle.XAxis = Base.Vector(*vectorx)
        fc_arc = fc_circle.trim(u_min, u_max)
        return [fc_arc]
    else:
        return [fc_circle]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.curve_to_freecad"><code class="name flex">
<span>def <span class="ident">curve_to_freecad</span></span>(<span>sv_curve)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curve_to_freecad(sv_curve):
    converter = curve_converters.get(type(sv_curve), None)
    if converter is not None:
        try:
            fc_curves = converter(sv_curve)
            result = []
            for fc_curve in fc_curves:
                bounds = fc_curve.FirstParameter, fc_curve.LastParameter
                sv_curve = SvFreeCadCurve(fc_curve, bounds)
                result.append(sv_curve)
            return result
        except UnsupportedCurveTypeException as e:
            sv_logger.info(f&#34;Can&#39;t convert {sv_curve} to native FreeCAD curve: {e}&#34;)
            pass
    return [curve_to_freecad_nurbs(sv_curve)]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.curve_to_freecad_nurbs"><code class="name flex">
<span>def <span class="ident">curve_to_freecad_nurbs</span></span>(<span>sv_curve)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert SvCurve to FreeCAD's NURBS curve.
Raise an exception if it is not possible.</p>
<p>input: SvCurve
output: SvFreeCadNurbsCurve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curve_to_freecad_nurbs(sv_curve):
    &#34;&#34;&#34;
    Convert SvCurve to FreeCAD&#39;s NURBS curve.
    Raise an exception if it is not possible.

    input: SvCurve
    output: SvFreeCadNurbsCurve
    &#34;&#34;&#34;
    nurbs = SvNurbsCurve.to_nurbs(sv_curve)
    if nurbs is None:
        raise TypeError(f&#34;{sv_curve} is not a NURBS curve&#34;)
    fc_curve = SvNurbsMaths.build_curve(SvNurbsMaths.FREECAD,
                nurbs.get_degree(),
                nurbs.get_knotvector(),
                nurbs.get_control_points(),
                nurbs.get_weights())
    return fc_curve</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.curves_to_wire"><code class="name flex">
<span>def <span class="ident">curves_to_wire</span></span>(<span>sv_curves)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curves_to_wire(sv_curves):
    fc_curves = [curve_to_freecad_nurbs(curve).curve for curve in sv_curves]
    shapes = [Part.Edge(curve) for curve in fc_curves]
    wire = Part.Wire(shapes)
    return wire</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.get_curve_endpoints"><code class="name flex">
<span>def <span class="ident">get_curve_endpoints</span></span>(<span>fc_curve)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_curve_endpoints(fc_curve):
    if hasattr(fc_curve, &#39;StartPoint&#39;):
        p1, p2 = fc_curve.StartPoint, fc_curve.EndPoint
    else:
        t1, t2 = fc_curve.FirstParameter, fc_curve.LastParameter
        if hasattr(fc_curve, &#39;valueAt&#39;):
            p1, p2 = fc_curve.valueAt(t1), fc_curve.valueAt(t2)
        else:
            p1, p2 = fc_curve.value(t1), fc_curve.value(t2)
    return p1, p2</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.get_edge_endpoints"><code class="name flex">
<span>def <span class="ident">get_edge_endpoints</span></span>(<span>fc_edge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_endpoints(fc_edge):
    t1, t2 = fc_edge.ParameterRange
    fc_curve = fc_edge.Curve
    if hasattr(fc_curve, &#39;valueAt&#39;):
        p1, p2 = fc_curve.valueAt(t1), fc_curve.valueAt(t2)
    else:
        p1, p2 = fc_curve.value(t1), fc_curve.value(t2)
    return p1, p2</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.line_to_freecad"><code class="name flex">
<span>def <span class="ident">line_to_freecad</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line_to_freecad(line):
    u_min, u_max = line.get_u_bounds()
    p1 = tuple(line.evaluate(u_min))
    p2 = tuple(line.evaluate(u_max))
    p1 = Base.Vector(*p1)
    p2 = Base.Vector(*p2)
    fc_line = Part.LineSegment(p1, p2)
    return [fc_line]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.make_helix"><code class="name flex">
<span>def <span class="ident">make_helix</span></span>(<span>pitch, height, radius, apex_angle=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_helix(pitch, height, radius, apex_angle=0):
    # FIXME: in FreeCAD pydoc, there is also &#34;makeLongHelix&#34;,
    # which seems to be more suitable here because it said to be &#34;multi-edge&#34;;
    # However, in my experiments, makeLongHelix always makes
    # a helix with exactly one turn, while makeHelix makes as many
    # turns as necessary.
    wire = Part.makeHelix(pitch, height, radius, apex_angle)
    fc_edge = wire.Edges[0]
    curve = SvSolidEdgeCurve(fc_edge)
    return curve</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.curve.freecad.SvFreeCadCurve"><code class="flex name class">
<span>class <span class="ident">SvFreeCadCurve</span></span>
<span>(</span><span>curve, bounds, ndim=3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvFreeCadCurve(SvCurve):
    def __init__(self, curve, bounds, ndim=3):
        self.curve = curve
        self.u_bounds = bounds
        self.ndim = ndim
    
    def __repr__(self):
        return f&#34;&lt;FreeCAD {self.ndim}D curve, {type(self.curve).__name__}&gt;&#34;

    def _convert(self, p):
        if self.ndim == 2:
            return [p.x, p.y, 0]
        else:
            return [p.x, p.y, p.z]

    def evaluate(self, t):
        p = self.curve.value(t)
        return np.array(self._convert(p))

    def evaluate_array(self, ts):
        return np.vectorize(self.evaluate, signature=&#39;()-&gt;(3)&#39;)(ts)

    def tangent(self, t, tangent_delta=None):
        p = self.edge.tangentAt(t)
        return np.array(self._convert(p))

    def tangent_array(self, ts, tangent_delta=None):
        return np.vectorize(self.tangent, signature=&#39;()-&gt;(3)&#39;)(ts)

    def get_u_bounds(self):
        return self.u_bounds

    #def get_u_bounds(self):
    #    return (self.curve.FirstParameter, self.curve.LastParameter)

    def reverse(self):
        result = self.to_nurbs().reverse()
        if self.ndim == 2:
            result = result.to_2d()
        return result
        #curve = self.curve.copy()
        #curve.reverse()
        #return SvFreeCadCurve(curve, self.u_bounds, self.ndim)

    def concatenate(self, curve2, tolerance=1e-6):
        if isinstance(curve2, SvFreeCadCurve) and self.ndim == curve2.ndim == 2:
            curve1 = self.curve.toBSpline(*self.u_bounds)
            curve2 = curve2.curve.toBSpline()
            curve1.join(curve2)
            return SvFreeCadNurbsCurve(curve1, self.ndim)
        elif isinstance(curve2, SvFreeCadNurbsCurve) and self.ndim == curve2.ndim == 2:
            curve1 = self.curve.toBSpline(*self.u_bounds)
            curve2 = curve2.curve
            curve1.join(curve2)
            return SvFreeCadNurbsCurve(curve1, self.ndim)
        return self.to_nurbs().concatenate(curve2, tolerance)

    def to_nurbs(self, implementation = SvNurbsMaths.FREECAD):
        curve = self.curve.toBSpline(*self.u_bounds)

        if implementation == SvNurbsMaths.FREECAD:
            return SvFreeCadNurbsCurve(curve, self.ndim)

        #curve.transform(self.edge.Matrix)
        if self.ndim == 2:
            control_points = [(p.x, p.y, 0) for p in curve.getPoles()]
        else:
            control_points = [(p.x, p.y, p.z) for p in curve.getPoles()]
        control_points = np.array(control_points)
        weights = np.array(curve.getWeights())
        knotvector = np.array(curve.KnotSequence)

        curve = SvNurbsMaths.build_curve(implementation,
                    curve.Degree, knotvector,
                    control_points,
                    weights)
        #curve.u_bounds = self.u_bounds
        return curve</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.freecad.SvFreeCadCurve.concatenate"><code class="name flex">
<span>def <span class="ident">concatenate</span></span>(<span>self, curve2, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate(self, curve2, tolerance=1e-6):
    if isinstance(curve2, SvFreeCadCurve) and self.ndim == curve2.ndim == 2:
        curve1 = self.curve.toBSpline(*self.u_bounds)
        curve2 = curve2.curve.toBSpline()
        curve1.join(curve2)
        return SvFreeCadNurbsCurve(curve1, self.ndim)
    elif isinstance(curve2, SvFreeCadNurbsCurve) and self.ndim == curve2.ndim == 2:
        curve1 = self.curve.toBSpline(*self.u_bounds)
        curve2 = curve2.curve
        curve1.join(curve2)
        return SvFreeCadNurbsCurve(curve1, self.ndim)
    return self.to_nurbs().concatenate(curve2, tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadCurve.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    result = self.to_nurbs().reverse()
    if self.ndim == 2:
        result = result.to_2d()
    return result
    #curve = self.curve.copy()
    #curve.reverse()
    #return SvFreeCadCurve(curve, self.u_bounds, self.ndim)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadCurve.to_nurbs"><code class="name flex">
<span>def <span class="ident">to_nurbs</span></span>(<span>self, implementation='FREECAD')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nurbs(self, implementation = SvNurbsMaths.FREECAD):
    curve = self.curve.toBSpline(*self.u_bounds)

    if implementation == SvNurbsMaths.FREECAD:
        return SvFreeCadNurbsCurve(curve, self.ndim)

    #curve.transform(self.edge.Matrix)
    if self.ndim == 2:
        control_points = [(p.x, p.y, 0) for p in curve.getPoles()]
    else:
        control_points = [(p.x, p.y, p.z) for p in curve.getPoles()]
    control_points = np.array(control_points)
    weights = np.array(curve.getWeights())
    knotvector = np.array(curve.KnotSequence)

    curve = SvNurbsMaths.build_curve(implementation,
                curve.Degree, knotvector,
                control_points,
                weights)
    #curve.u_bounds = self.u_bounds
    return curve</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve"><code class="flex name class">
<span>class <span class="ident">SvFreeCadNurbsCurve</span></span>
<span>(</span><span>curve, ndim=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Base abstract class for all supported implementations of NURBS curves.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvFreeCadNurbsCurve(SvNurbsCurve):
    def __init__(self, curve, ndim=3):
        self.curve = curve
        self.ndim = ndim
        self.u_bounds = None # from FreeCAD data
        self.__description__ = f&#34;FreeCAD {ndim}D NURBS (degree={curve.Degree}, pts={curve.NbPoles})&#34;

    @classmethod
    def build(cls, implementation, degree, knotvector, control_points, weights=None, normalize_knots=False):
        n = len(control_points)
        if weights is None:
            weights = np.ones((n,))

        if normalize_knots:
            knotvector = sv_knotvector.normalize(knotvector)

        pts = [Base.Vector(t[0], t[1], t[2]) for t in control_points]
        ms = sv_knotvector.to_multiplicity(knotvector)
        knots = [p[0] for p in ms]
        mults = [p[1] for p in ms]

        curve = Part.BSplineCurve()
        curve.buildFromPolesMultsKnots(pts, mults, knots, False, degree, weights)
        return SvFreeCadNurbsCurve(curve)

    @classmethod
    def build_2d(cls, degree, knotvector, control_points, weights=None):
        n = len(control_points)
        if weights is None:
            weights = np.ones((n,))

        pts = [Base.Vector2d(t[0], t[1]) for t in control_points]
        ms = sv_knotvector.to_multiplicity(knotvector)
        knots = [p[0] for p in ms]
        mults = [p[1] for p in ms]

        curve = Geom2d.BSplineCurve2d()
        curve.buildFromPolesMultsKnots(pts, mults, knots, False, degree, weights)
        return SvFreeCadNurbsCurve(curve, ndim=2)

    @classmethod
    def interpolate(cls, degree, points, metric=&#39;DISTANCE&#39;, tknots=None, cyclic=False, logger=None, **kwargs):
        curve = interpolate_nurbs_curve(degree, points, metric=metric, tknots=tknots, cyclic=cyclic, logger=logger)
        return curve.copy(implementation = SvNurbsMaths.FREECAD)

    def to_2d(self):
        return SvFreeCadNurbsCurve.build_2d(self.get_degree(), self.get_knotvector(),
                    self.get_control_points(), self.get_weights())
    
    @classmethod
    def from_any_nurbs(cls, curve):
        if not isinstance(curve, SvNurbsCurve):
            raise TypeError(&#34;Invalid curve type&#34;)
        if isinstance(curve, SvFreeCadNurbsCurve):
            return curve
        return SvFreeCadNurbsCurve.build(SvNurbsMaths.FREECAD,
                    curve.get_degree(), curve.get_knotvector(),
                    curve.get_control_points(), 
                    curve.get_weights())

    @classmethod
    def get_nurbs_implementation(cls):
        return SvNurbsMaths.FREECAD

    def is_closed(self, eps=None):
        return self.curve.isClosed()
    
    def _convert(self, p):
        if self.ndim == 2:
            return [p.x, p.y, 0]
        else:
            return [p.x, p.y, p.z]

    def evaluate(self, t):
        pt = self.curve.value(t)
        return np.array(self._convert(pt))

    def evaluate_array(self, ts):
        return np.vectorize(self.evaluate, signature=&#39;()-&gt;(3)&#39;)(ts)
    
    def tangent(self, t, tangent_delta=None):
        p, v = self.curve.getD1(t)
        if not isinstance(v, tuple):
            v = self._convert(v)
        return np.array(v)
    
    def tangent_array(self, ts, tangent_delta=None):
        return np.vectorize(self.tangent, signature=&#39;()-&gt;(3)&#39;)(ts)    

    def second_derivative(self, t, tangent_delta = None):
        p, v1, v = self.curve.getD2(t)
        if not isinstance(v, tuple):
            v = self._convert(v)
        return np.array(v)

    def second_derivative_array(self, ts, tangent_delta=None):
        return np.vectorize(self.second_derivative, signature=&#39;()-&gt;(3)&#39;)(ts)    

    def third_derivative(self, t, tangent_delta = None):
        p, v1, v2, v = self.curve.getD3(t)
        if not isinstance(v, tuple):
            v = self._convert(v)
        return np.array(v)

    def third_derivative_array(self, ts, tangent_delta=None):
        return np.vectorize(self.third_derivative, signature=&#39;()-&gt;(3)&#39;)(ts)    

    def derivatives_array(self, n, ts, tangent_delta=None):
        first_derivatives = []
        second_derivatives = []
        third_derivatives = []

        for t in ts:
            p, v1, v2, v3 = self.curve.getD3(t)
            first_derivatives.append(self._convert(v1))
            second_derivatives.append(self._convert(v2))
            third_derivatives.append(self._convert(v3))

        first_derivatives = np.array(first_derivatives)
        second_derivatives = np.array(second_derivatives)
        third_derivatives = np.array(third_derivatives)

        return [first_derivatives, second_derivatives, third_derivatives][:n]

    def get_u_bounds(self):
        if self.u_bounds is None:
            return (self.curve.KnotSequence[0], self.curve.KnotSequence[-1])
        else:
            return self.u_bounds

    def get_knotvector(self):
        knots = self.curve.getKnots()
        mults = self.curve.getMultiplicities()
        ms = zip(knots, mults)
        return sv_knotvector.from_multiplicity(ms)

    def get_degree(self):
        return self.curve.Degree

    def get_control_points(self):
        poles = self.curve.getPoles()
        poles = [self._convert(p) for p in poles]
        return np.array(poles)

    def get_weights(self):
        return np.array(self.curve.getWeights())

    def insert_knot(self, u, count=1, if_possible=False):
        curve = SvFreeCadNurbsCurve(self.curve.copy(), self.ndim) # copy
        curve.curve.insertKnot(u, count)
        return curve

    def remove_knot(self, u, count=1, tolerance=1e-4, if_possible=False):
        curve = SvFreeCadNurbsCurve(self.curve.copy(), self.ndim) # copy
        ms = sv_knotvector.to_multiplicity(self.get_knotvector())
        idx = None
        M = None
        for i, (u1, m) in enumerate(ms):
            if u1 == u:
                idx = i
                if count == &#39;ALL&#39;:
                    M = 0
                elif count == &#39;ALL_BUT_ONE&#39;:
                    M = 1
                else:
                    M = m - count
                break
        if idx is not None:
            curve.curve.removeKnot(idx+1, M, tolerance)
        return curve</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.nurbs.SvNurbsCurve" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve">SvNurbsCurve</a></li>
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>implementation, degree, knotvector, control_points, weights=None, normalize_knots=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, implementation, degree, knotvector, control_points, weights=None, normalize_knots=False):
    n = len(control_points)
    if weights is None:
        weights = np.ones((n,))

    if normalize_knots:
        knotvector = sv_knotvector.normalize(knotvector)

    pts = [Base.Vector(t[0], t[1], t[2]) for t in control_points]
    ms = sv_knotvector.to_multiplicity(knotvector)
    knots = [p[0] for p in ms]
    mults = [p[1] for p in ms]

    curve = Part.BSplineCurve()
    curve.buildFromPolesMultsKnots(pts, mults, knots, False, degree, weights)
    return SvFreeCadNurbsCurve(curve)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.build_2d"><code class="name flex">
<span>def <span class="ident">build_2d</span></span>(<span>degree, knotvector, control_points, weights=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_2d(cls, degree, knotvector, control_points, weights=None):
    n = len(control_points)
    if weights is None:
        weights = np.ones((n,))

    pts = [Base.Vector2d(t[0], t[1]) for t in control_points]
    ms = sv_knotvector.to_multiplicity(knotvector)
    knots = [p[0] for p in ms]
    mults = [p[1] for p in ms]

    curve = Geom2d.BSplineCurve2d()
    curve.buildFromPolesMultsKnots(pts, mults, knots, False, degree, weights)
    return SvFreeCadNurbsCurve(curve, ndim=2)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.from_any_nurbs"><code class="name flex">
<span>def <span class="ident">from_any_nurbs</span></span>(<span>curve)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_any_nurbs(cls, curve):
    if not isinstance(curve, SvNurbsCurve):
        raise TypeError(&#34;Invalid curve type&#34;)
    if isinstance(curve, SvFreeCadNurbsCurve):
        return curve
    return SvFreeCadNurbsCurve.build(SvNurbsMaths.FREECAD,
                curve.get_degree(), curve.get_knotvector(),
                curve.get_control_points(), 
                curve.get_weights())</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>degree, points, metric='DISTANCE', tknots=None, cyclic=False, logger=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def interpolate(cls, degree, points, metric=&#39;DISTANCE&#39;, tknots=None, cyclic=False, logger=None, **kwargs):
    curve = interpolate_nurbs_curve(degree, points, metric=metric, tknots=tknots, cyclic=cyclic, logger=logger)
    return curve.copy(implementation = SvNurbsMaths.FREECAD)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.derivatives_array"><code class="name flex">
<span>def <span class="ident">derivatives_array</span></span>(<span>self, n, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivatives_array(self, n, ts, tangent_delta=None):
    first_derivatives = []
    second_derivatives = []
    third_derivatives = []

    for t in ts:
        p, v1, v2, v3 = self.curve.getD3(t)
        first_derivatives.append(self._convert(v1))
        second_derivatives.append(self._convert(v2))
        third_derivatives.append(self._convert(v3))

    first_derivatives = np.array(first_derivatives)
    second_derivatives = np.array(second_derivatives)
    third_derivatives = np.array(third_derivatives)

    return [first_derivatives, second_derivatives, third_derivatives][:n]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.insert_knot"><code class="name flex">
<span>def <span class="ident">insert_knot</span></span>(<span>self, u, count=1, if_possible=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_knot(self, u, count=1, if_possible=False):
    curve = SvFreeCadNurbsCurve(self.curve.copy(), self.ndim) # copy
    curve.curve.insertKnot(u, count)
    return curve</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self, eps=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closed(self, eps=None):
    return self.curve.isClosed()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.remove_knot"><code class="name flex">
<span>def <span class="ident">remove_knot</span></span>(<span>self, u, count=1, tolerance=0.0001, if_possible=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_knot(self, u, count=1, tolerance=1e-4, if_possible=False):
    curve = SvFreeCadNurbsCurve(self.curve.copy(), self.ndim) # copy
    ms = sv_knotvector.to_multiplicity(self.get_knotvector())
    idx = None
    M = None
    for i, (u1, m) in enumerate(ms):
        if u1 == u:
            idx = i
            if count == &#39;ALL&#39;:
                M = 0
            elif count == &#39;ALL_BUT_ONE&#39;:
                M = 1
            else:
                M = m - count
            break
    if idx is not None:
        curve.curve.removeKnot(idx+1, M, tolerance)
    return curve</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.second_derivative"><code class="name flex">
<span>def <span class="ident">second_derivative</span></span>(<span>self, t, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative(self, t, tangent_delta = None):
    p, v1, v = self.curve.getD2(t)
    if not isinstance(v, tuple):
        v = self._convert(v)
    return np.array(v)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.second_derivative_array"><code class="name flex">
<span>def <span class="ident">second_derivative_array</span></span>(<span>self, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative_array(self, ts, tangent_delta=None):
    return np.vectorize(self.second_derivative, signature=&#39;()-&gt;(3)&#39;)(ts)    </code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.third_derivative"><code class="name flex">
<span>def <span class="ident">third_derivative</span></span>(<span>self, t, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def third_derivative(self, t, tangent_delta = None):
    p, v1, v2, v = self.curve.getD3(t)
    if not isinstance(v, tuple):
        v = self._convert(v)
    return np.array(v)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.third_derivative_array"><code class="name flex">
<span>def <span class="ident">third_derivative_array</span></span>(<span>self, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def third_derivative_array(self, ts, tangent_delta=None):
    return np.vectorize(self.third_derivative, signature=&#39;()-&gt;(3)&#39;)(ts)    </code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.to_2d"><code class="name flex">
<span>def <span class="ident">to_2d</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_2d(self):
    return SvFreeCadNurbsCurve.build_2d(self.get_degree(), self.get_knotvector(),
                self.get_control_points(), self.get_weights())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.nurbs.SvNurbsCurve" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve">SvNurbsCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.calc_linear_segment_knots" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.calc_linear_segment_knots">calc_linear_segment_knots</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.cut_segment" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.cut_segment">cut_segment</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_homogenous_control_points" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.get_homogenous_control_points">get_homogenous_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_knotvector" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.get_knotvector">get_knotvector</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_min_continuity" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.get_min_continuity">get_min_continuity</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_nurbs_implementation" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.get_nurbs_implementation">get_nurbs_implementation</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.get_weights" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.is_inside_sphere" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.is_inside_sphere">is_inside_sphere</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.is_line" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.is_line">is_line</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.is_strongly_outside_sphere" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.is_strongly_outside_sphere">is_strongly_outside_sphere</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.to_bezier" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.to_bezier">to_bezier</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.to_bezier_segments" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.to_bezier_segments">to_bezier_segments</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.to_nurbs" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.to_nurbs">to_nurbs</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.transform" href="nurbs.html#sverchok.utils.curve.nurbs.SvNurbsCurve.transform">transform</a></code></li>
<li><code><a title="sverchok.utils.curve.nurbs.SvNurbsCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.freecad.SvSolidEdgeCurve"><code class="flex name class">
<span>class <span class="ident">SvSolidEdgeCurve</span></span>
<span>(</span><span>solid_edge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvSolidEdgeCurve(SvCurve):
    __description__ = &#34;Solid Edge&#34;
    def __init__(self, solid_edge):
        self.edge = solid_edge
        self.curve = solid_edge.Curve
        self.u_bounds = (self.edge.FirstParameter, self.edge.LastParameter)

    def evaluate(self, t):
        return np.array(self.curve.value(t))

    def evaluate_array(self, ts):
        t_out = []
        for t in ts:
            t_out.append(self.curve.value(t))
        return np.array(t_out)

    def tangent(self, t, tangent_delta=None):
        return np.array(self.edge.tangentAt(t))

    def tangent_array(self, ts, tangent_delta=None):
        tangents = []
        for t in ts:
            tangents.append(self.edge.tangentAt(t))
        return np.array(tangents)

    def get_u_bounds(self):
        return self.u_bounds

    def to_nurbs(self, implementation = SvNurbsMaths.FREECAD):
        curve = self.curve.toBSpline(*self.u_bounds)
        #curve.transform(self.edge.Matrix)
        control_points = np.array(curve.getPoles())
        weights = np.array(curve.getWeights())
        knotvector = np.array(curve.KnotSequence)
        curve = SvNurbsMaths.build_curve(implementation,
                    curve.Degree, knotvector,
                    control_points,
                    weights)
        #curve.u_bounds = self.u_bounds
        return curve</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.freecad.SvSolidEdgeCurve.to_nurbs"><code class="name flex">
<span>def <span class="ident">to_nurbs</span></span>(<span>self, implementation='FREECAD')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nurbs(self, implementation = SvNurbsMaths.FREECAD):
    curve = self.curve.toBSpline(*self.u_bounds)
    #curve.transform(self.edge.Matrix)
    control_points = np.array(curve.getPoles())
    weights = np.array(curve.getWeights())
    knotvector = np.array(curve.KnotSequence)
    curve = SvNurbsMaths.build_curve(implementation,
                curve.Degree, knotvector,
                control_points,
                weights)
    #curve.u_bounds = self.u_bounds
    return curve</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.curve" href="index.html">sverchok.utils.curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.curve.freecad.biarc_to_freecad" href="#sverchok.utils.curve.freecad.biarc_to_freecad">biarc_to_freecad</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.circle_to_freecad" href="#sverchok.utils.curve.freecad.circle_to_freecad">circle_to_freecad</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.curve_to_freecad" href="#sverchok.utils.curve.freecad.curve_to_freecad">curve_to_freecad</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.curve_to_freecad_nurbs" href="#sverchok.utils.curve.freecad.curve_to_freecad_nurbs">curve_to_freecad_nurbs</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.curves_to_wire" href="#sverchok.utils.curve.freecad.curves_to_wire">curves_to_wire</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.get_curve_endpoints" href="#sverchok.utils.curve.freecad.get_curve_endpoints">get_curve_endpoints</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.get_edge_endpoints" href="#sverchok.utils.curve.freecad.get_edge_endpoints">get_edge_endpoints</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.line_to_freecad" href="#sverchok.utils.curve.freecad.line_to_freecad">line_to_freecad</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.make_helix" href="#sverchok.utils.curve.freecad.make_helix">make_helix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.curve.freecad.SvFreeCadCurve" href="#sverchok.utils.curve.freecad.SvFreeCadCurve">SvFreeCadCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadCurve.concatenate" href="#sverchok.utils.curve.freecad.SvFreeCadCurve.concatenate">concatenate</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadCurve.reverse" href="#sverchok.utils.curve.freecad.SvFreeCadCurve.reverse">reverse</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadCurve.to_nurbs" href="#sverchok.utils.curve.freecad.SvFreeCadCurve.to_nurbs">to_nurbs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve">SvFreeCadNurbsCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.build" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.build">build</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.build_2d" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.build_2d">build_2d</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.derivatives_array" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.derivatives_array">derivatives_array</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.from_any_nurbs" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.from_any_nurbs">from_any_nurbs</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.insert_knot" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.insert_knot">insert_knot</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.interpolate" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.interpolate">interpolate</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.is_closed" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.is_closed">is_closed</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.remove_knot" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.remove_knot">remove_knot</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.second_derivative" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.second_derivative">second_derivative</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.second_derivative_array" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.second_derivative_array">second_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.third_derivative" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.third_derivative">third_derivative</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.third_derivative_array" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.third_derivative_array">third_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.to_2d" href="#sverchok.utils.curve.freecad.SvFreeCadNurbsCurve.to_2d">to_2d</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.freecad.SvSolidEdgeCurve" href="#sverchok.utils.curve.freecad.SvSolidEdgeCurve">SvSolidEdgeCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.freecad.SvSolidEdgeCurve.to_nurbs" href="#sverchok.utils.curve.freecad.SvSolidEdgeCurve.to_nurbs">to_nurbs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>