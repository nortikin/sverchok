<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.curve.bezier API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.curve.bezier</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import numpy as np
from math import sqrt

from sverchok.data_structure import zip_long_repeat
from sverchok.utils.math import binomial
from sverchok.utils.geom import Spline, bounding_box, are_points_coplanar, get_common_plane, PlaneEquation, LineEquation
from sverchok.utils.nurbs_common import SvNurbsMaths
from sverchok.utils.curve.core import SvCurve, UnsupportedCurveTypeException, calc_taylor_nurbs_matrices
from sverchok.utils.curve.algorithms import concatenate_curves
from sverchok.utils.curve import knotvector as sv_knotvector
from sverchok.utils.nurbs_common import elevate_bezier_degree

# Pure-python (+ numpy) Bezier curves implementation

class SvBezierSplitMixin:
    def de_casteljau_points(self, t):
        ndim = 3
        p = self.get_degree()
        n = p+1
        dpts = np.zeros((n, n, ndim))
        dpts[:] = self.get_control_points()
        for j in range(1, n):
            for k in range(n - j):
                dpts[j,k] = dpts[j-1, k] * (1 - t) + dpts[j-1, k+1] * t
        return dpts
    
#     DeCasteljau variant
#     def split_at(self, t):
#         dpts = self.de_casteljau_points(t)
#         cpts1 = dpts[:,0]
#         cpts2 = dpts[-1,:]
#         return SvBezierCurve.from_control_points(cpts1), SvBezierCurve.from_control_points(cpts2)

#   def cut_segment(self, new_t_min, new_t_max, rescale=False):
#         if new_t_min &gt;= 0:
#             c1, c2 = self.split_at(new_t_min)
#         else:
#             c2 = self
#         if new_t_max &lt;= 1.0:
#             t1 = (new_t_max - new_t_min) / (1.0 - new_t_min)
#             c3, c4 = c2.split_at(t1)
#         else:
#             c3 = c2
#         return c3

    def cut_segment(self, new_t_min, new_t_max, rescale=False):
        ndim = 3
        p = self.get_degree()
        cpts = self.get_control_points()

        matrices = calc_taylor_nurbs_matrices(p, u_bounds=(new_t_min, new_t_max), calc_M=True, calc_R=True, calc_M1=True, calc_R1=True)
        M = matrices[&#39;M&#39;]
        R1 = matrices[&#39;R1&#39;]
        M1 = matrices[&#39;M1&#39;]

        MR1M = M1 @ R1 @ M

        new_cpts = MR1M @ cpts
        return SvBezierCurve.from_control_points(new_cpts)

    def split_at(self, t):
        segment1 = self.cut_segment(0.0, t)
        segment2 = self.cut_segment(t, 1.0)
        return segment1, segment2

class SvBezierCurve(SvCurve, SvBezierSplitMixin):
    &#34;&#34;&#34;
    Bezier curve of arbitrary degree.
    &#34;&#34;&#34;
    def __init__(self, points):
        self.points = np.asarray(points)
        self.tangent_delta = 0.001
        n = self.degree = len(points) - 1
        self.__description__ = &#34;Bezier[{}]&#34;.format(n)

    @classmethod
    def from_control_points(cls, points):
        if len(points) == 4:
            return SvCubicBezierCurve(points[0], points[1], points[2], points[3])
        else:
            return SvBezierCurve(points)

    @classmethod
    def from_points_and_tangents(cls, p0, t0, t1, p1):
        &#34;&#34;&#34;
        Build cubic Bezier curve, which goes from p0 to p1,
        and has tangent at 0 equal to t0 and tangent at 1 equal to t1.
        This is also called Hermite spline.

        inputs: p0, t0, t1, p1 - numpy arrays of shape (3,).
        &#34;&#34;&#34;
        return SvCubicBezierCurve(
                p0,
                p0 + t0 / 3.0,
                p1 - t1 / 3.0,
                p1)

    @classmethod
    def blend_second_derivatives(cls, p0, v0, a0, p5, v5, a5):
        &#34;&#34;&#34;
        Build Bezier curve of 5th order, which goes from p0 to p5, and has:
        * first derivative at 0 = v0, second derivative at 0 = a0;
        * first derivative at 1 = v5, second derivative at 1 = a1.

        inputs: numpy arrays of shape (3,).
        &#34;&#34;&#34;
        p1 = p0 + v0 / 5.0
        p4 = p5 - v5 / 5.0
        p2 = p0 + 0.4*v0 + a0/20.0
        p3 = p5 - 0.4*v5 + a5/20.0
        return SvBezierCurve([p0, p1, p2, p3, p4, p5])

    @classmethod
    def blend_third_derivatives(cls, p0, v0, a0, k0, p7, v7, a7, k7):
        &#34;&#34;&#34;
        Build Bezier curve of 7th order, which goes from p0 to p7, and has:
        * first derivative at 0 = v0, second derivative at 0 = a0, third derivative at 0 = k0;
        * first derivative at 1 = v7, second derivative at 1 = a7, third derivative at 1 = k7.

        inputs: numpy arrays of shape (3,).
        &#34;&#34;&#34;
        p1 = p0 + v0 / 7.0
        p6 = p7 - v7 / 7.0
        p2 = a0/42.0 + 2*p1 - p0
        p5 = a7/42.0 + 2*p6 - p7
        p3 = k0/210.0 + 3*p2 - 3*p1 + p0
        p4 = -k7/210.0 + 3*p5 - 3*p6 + p7
        return SvBezierCurve([p0, p1, p2, p3, p4, p5, p6, p7])

#     @classmethod
#     def from_tangents_and_curvatures(cls, point1, point2, tangent1, tangent2, curvature1, curvature2):
#         A1 = point1
#         A2 = point2
#         B1 = point1 + tangent1 / 5
#         B2 = point2 - tangent2 / 5
#         t1dir = tangent1 / np.linalg.norm(tangent1)
#         t2dir = tangent2 / np.linalg.norm(tangent2)
#         B1B2 = B2 - B1
#         direction = B1B2 / np.linalg.norm(B1B2)
#         
#         r1 = curvature1 * np.linalg.norm(tangent1)**2 / 20
#         r2 = curvature2 * np.linalg.norm(tangent2)**2 / 20
#         
#         dot1 = (direction * t1dir).sum()
#         sin1 = sqrt(1 - dot1**2)
#         d1 = r1 / sin1
#         
#         dot2 = (-direction * t2dir).sum()
#         sin2 = sqrt(1 - dot2**2)
#         d2 = r2 / sin2
#         
#         C1 = B1 + d1 * direction
#         C2 = B2 - d2 * direction
#         
#         return SvBezierCurve([A1, B1, C1, C2, B2, A2])

    @classmethod
    def from_tangents_normals_curvatures(cls, point1, point2, tangent1, tangent2, normal1, normal2, curvature1, curvature2):
        &#34;&#34;&#34;
        Build Bezier curve of 5th degree, which:
            
            * starts at point1 and end at point2
            * at start has tangent1 and normal1, at end has tangent2 and normal2
            * at start has curvature1, at end has curvature2.
        &#34;&#34;&#34;
        A1 = point1
        A2 = point2
        B1 = point1 + tangent1 / 5
        B2 = point2 - tangent2 / 5
        t1dir = tangent1 / np.linalg.norm(tangent1)
        t2dir = tangent2 / np.linalg.norm(tangent2)
        n1dir = normal1 / np.linalg.norm(normal1)
        n2dir = normal2 / np.linalg.norm(normal2)

        r1 = curvature1 * np.linalg.norm(tangent1)**2 / 20
        r2 = curvature2 * np.linalg.norm(tangent2)**2 / 20

        C1 = B1 + r1 * n1dir
        C2 = B2 + r2 * n2dir

        return SvBezierCurve([A1, B1, C1, C2, B2, A2])

    @classmethod
    def build_tangent_curve(cls, points, tangents, hermite=True, cyclic=False, concat=False, as_nurbs=False):
        &#34;&#34;&#34;
        Build cubic Bezier curve spline, which goes through specified `points&#39;,
        having specified `tangents&#39; at these points.

        inputs:
        * points, tangents: lists of 3-tuples
        * cyclic: whether the curve should be closed (cyclic)
        * concat: whether to concatenate all curve segments into single Curve object
        * hermite: if true, use Hermite spline - divide tangent vector by 3 to
            obtain middle control points; otherwise, divide by 2.

        outputs: tuple:
        * list of curve control points - list of lists of 3-tuples
        * list of generated curves; if concat == True, then this list will contain single curve.
        &#34;&#34;&#34;
        new_curves = []
        new_controls = []

        pairs = list(zip_long_repeat(points, tangents))
        segments = list(zip(pairs, pairs[1:]))
        if cyclic:
            segments.append((pairs[-1], pairs[0]))
        if hermite:
            d = 3.0
        else:
            d = 2.0

        for pair1, pair2 in segments:
            point1, tangent1 = pair1
            point2, tangent2 = pair2
            point1, tangent1 = np.array(point1), np.array(tangent1)
            point2, tangent2 = np.array(point2), np.array(tangent2)
            tangent1, tangent2 = tangent1/d, tangent2/d
            curve = SvCubicBezierCurve(
                        point1,
                        point1 + tangent1,
                        point2 - tangent2,
                        point2)
            curve_controls = [curve.p0.tolist(), curve.p1.tolist(),
                              curve.p2.tolist(), curve.p3.tolist()]
            if as_nurbs:
                curve = curve.to_nurbs()
            new_curves.append(curve)
            new_controls.append(curve_controls)
        if concat:
            new_curve = concatenate_curves(new_curves)
            new_curves = [new_curve]
            if as_nurbs:
                new_controls = new_curve.get_control_points().tolist()

        return new_controls, new_curves

    @classmethod
    def interpolate(cls, points, metric=&#39;DISTANCE&#39;):
        n = len(points)
        tknots = Spline.create_knots(points, metric=metric)
        matrix = np.zeros((3*n, 3*n))
        for equation_idx, t in enumerate(tknots):
            for unknown_idx in range(n):
                coeff = SvBezierCurve.coefficient(n-1, unknown_idx, np.array([t]))[0]
                #print(f&#34;C[{equation_idx}][{unknown_idx}] = {coeff}&#34;)
                row = 3*equation_idx
                col = 3*unknown_idx
                matrix[row,col] = matrix[row+1, col+1] = matrix[row+2,col+2] = coeff
        #print(matrix)
        B = np.zeros((3*n, 1))
        for point_idx, point in enumerate(points):
            row = 3*point_idx
            B[row:row+3] = point[:,np.newaxis]
        #print(B)
        x = np.linalg.solve(matrix, B)
        #print(x)
        controls = []
        for i in range(n):
            row = i*3
            control = x[row:row+3,0].T
            controls.append(control)
            #print(control)
        return SvBezierCurve(controls)
    
    def is_line(self, tolerance=0.001):
        cpts = self.get_control_points()
        begin, end = cpts[0], cpts[-1]
        # direction from first to last point of the curve
        direction = end - begin
        if np.linalg.norm(direction) &lt; tolerance:
            return True
        line = LineEquation.from_direction_and_point(direction, begin)
        distances = line.distance_to_points(cpts[1:-1])
        # Technically, this means that all control points lie
        # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
        # As a consequence, the convex hull of control points lie in the
        # same cylinder; and the curve lies in that convex hull.
        return (distances &lt; tolerance).all()

    def get_end_points(self):
        return self.points[0], self.points[-1]

    @classmethod
    def coefficient(cls, n, k, ts):
        C = binomial(n, k)
        return C * ts**k * (1 - ts)**(n-k)

    def coeff(self, k, ts):
        n = self.degree
        return SvBezierCurve.coefficient(n, k, ts)

    def coeff_deriv1(self, k, t):
        n = self.degree
        C = binomial(n, k)
        if k &gt;= 1:
            s1 = k*(1-t)**(n-k)*t**(k-1)
        else:
            s1 = np.zeros_like(t)
        if n-k-1 &gt; 0:
            s2 = - (n-k)*(1-t)**(n-k-1)*t**k
        elif n-k == 1:
            s2 = - t**k
        else:
            s2 = np.zeros_like(t)
        coeff = s1 + s2
        return C*coeff

    def coeff_deriv2(self, k, t):
        n = self.degree
        C = binomial(n, k)
        if n-k-2 &gt; 0:
            s1 = (n-k-1)*(n-k)*(1-t)**(n-k-2)*t**k
        elif n-k == 2:
            s1 = 2*t**k
        else:
            s1 = np.zeros_like(t)
        if k &gt;= 1 and n-k-1 &gt; 0:
            s2 = - 2*k*(n-k)*(1-t)**(n-k-1)*t**(k-1)
        elif k &gt;= 1 and n-k == 1:
            s2 = - 2*k*t**(k-1)
        else:
            s2 = np.zeros_like(t)
        if k &gt;= 2:
            s3 = (k-1)*k*(1-t)**(n-k)*t**(k-2)
        else:
            s3 = np.zeros_like(t)
        coeff = s1 + s2 + s3
        return C*coeff

    def coeff_deriv3(self, k, t):
        n = self.degree
        C = binomial(n, k)
        if n-k-2 &gt; 0:
            s1 = -(n-k-2)*(n-k-1)*(n-k)*(1-t)**(n-k-3)*t**k
        else:
            s1 = np.zeros_like(t)
        if k &gt;= 1 and n-k-2 &gt; 0:
            s2 = 3*k*(n-k-1)*(n-k)*(1-t)**(n-k-2)*t**(k-1)
        elif k &gt;= 1 and n-k == 2:
            s2 = 6*k*t**(k-1)
        else:
            s2 = np.zeros_like(t)
        if k &gt;= 2 and n-k-1 &gt; 0:
            s3 = - 3*(k-1)*k*(n-k)*(1-t)**(n-k-1)*t**(k-2)
        elif k &gt;= 2 and n-k == 1:
            s3 = -3*(k-1)*k*t**(k-2)
        else:
            s3 = np.zeros_like(t)
        if k &gt;= 3:
            s4 = (k-2)*(k-1)*k*(1-t)**(n-k)*t**(k-3)
        else:
            s4 = np.zeros_like(t)
        coeff = s1 + s2 + s3 + s4
        return C*coeff

    def get_u_bounds(self):
        return (0.0, 1.0)

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        coeffs = [SvBezierCurve.coefficient(self.degree, k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        return np.dot(coeffs.T, self.points)

    def tangent(self, t, tangent_delta=None):
        return self.tangent_array(np.array([t]), tangent_delta=tangent_delta)[0]

    def tangent_array(self, ts, tangent_delta=None):
        coeffs = [self.coeff_deriv1(k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        #print(&#34;C1&#34;, coeffs)
        return np.dot(coeffs.T, self.points)

    def second_derivative(self, t, tangent_delta=None):
        return self.second_derivative_array(np.array([t]))[0]

    def second_derivative_array(self, ts, tangent_delta=None):
        coeffs = [self.coeff_deriv2(k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        #print(&#34;C2&#34;, coeffs)
        return np.dot(coeffs.T, self.points)

    def third_derivative_array(self, ts, tangent_delta=None):
        coeffs = [self.coeff_deriv3(k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        #print(&#34;C3&#34;, coeffs)
        return np.dot(coeffs.T, self.points)

    def derivatives_array(self, n, ts, tangent_delta=None):
        result = []
        if n &gt;= 1:
            first = self.tangent_array(ts, tangent_delta=tangent_delta)
            result.append(first)
        if n &gt;= 2:
            second = self.second_derivative_array(ts, tangent_delta=tangent_delta)
            result.append(second)
        if n &gt;= 3:
            third = self.third_derivative_array(ts, tangent_delta=tangent_delta)
            result.append(third)
        return result

    def reparametrize(self, new_t_min, new_t_max):
        return self.to_nurbs().reparametrize(new_t_min, new_t_max)

    def get_degree(self):
        return self.degree

    def is_rational(self):
        return False

    def is_planar(self, tolerance=1e-6):
        return are_points_coplanar(self.points, tolerance)

    def get_plane(self, tolerance=1e-6):
        return get_common_plane(self.points, tolerance)

    def get_control_points(self):
        return self.points

    def elevate_degree(self, delta=None, target=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        degree = self.get_degree()

        if delta is None:
            delta = target - degree
            if delta &lt; 0:
                raise Exception(f&#34;Curve already has degree {degree}, which is greater than target {target}&#34;)
        if delta == 0:
            return self

        points = elevate_bezier_degree(self.degree, self.points, delta)
        return SvBezierCurve(points)

    def get_bounding_box(self):
        return bounding_box(self.get_control_points())

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        knotvector = sv_knotvector.generate(self.degree, len(self.points))
        return SvNurbsMaths.build_curve(implementation,
                degree = self.degree, knotvector = knotvector,
                control_points = self.points)

    def concatenate(self, curve2, tolerance=None):
        curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
        if curve2 is None:
            raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
        return self.to_nurbs().concatenate(curve2, tolerance=tolerance)

    def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
        return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)
    
    def extrude_along_vector(self, vector):
        return self.to_nurbs().extrude_along_vector(vector)

    def make_ruled_surface(self, curve2, vmin, vmax):
        return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)

    def extrude_to_point(self, point):
        return self.to_nurbs().extrude_to_point(point)

    def lerp_to(self, curve2, coefficient):
        if isinstance(curve2, SvBezierCurve) and curve2.degree == self.degree:
            points = (1.0 - coefficient) * self.points + coefficient * curve2.points
            return SvBezierCurve(points)
        return self.to_nurbs().lerp_to(curve2, coefficient)
    

    def to_bezier(self):
        return self

    def to_bezier_segments(self):
        return [self]

    def reverse(self):
        return SvBezierCurve(self.points[::-1])

class SvCubicBezierCurve(SvCurve, SvBezierSplitMixin):
    __description__ = &#34;Bezier[3*]&#34;
    def __init__(self, p0, p1, p2, p3):
        self.p0 = np.array(p0)
        self.p1 = np.array(p1)
        self.p2 = np.array(p2)
        self.p3 = np.array(p3)
        self.tangent_delta = 0.001

    @classmethod
    def from_four_points(cls, v0, v1, v2, v3):
        v0 = np.array(v0)
        v1 = np.array(v1)
        v2 = np.array(v2)
        v3 = np.array(v3)

        p1 = (-5*v0 + 18*v1 - 9*v2 + 2*v3)/6.0
        p2 = (2*v0 - 9*v1 + 18*v2 - 5*v3)/6.0

        return SvCubicBezierCurve(v0, p1, p2, v3)

    def get_u_bounds(self):
        return (0.0, 1.0)

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        c0 = (1 - ts)**3
        c1 = 3*ts*(1-ts)**2
        c2 = 3*ts**2*(1-ts)
        c3 = ts**3
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3

        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def tangent(self, t, tangent_delta=None):
        return self.tangent_array(np.array([t]), tangent_delta=tangent_delta)[0]

    def tangent_array(self, ts, tangent_delta=None):
        c0 = -3*(1 - ts)**2
        c1 = 3*(1-ts)**2 - 6*(1-ts)*ts
        c2 = 6*(1-ts)*ts - 3*ts**2
        c3 = 3*ts**2
        #print(&#34;C/C1&#34;, np.array([c0, c1, c2, c3]))
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3

        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def second_derivative(self, t, tangent_delta=None):
        return self.second_derivative_array(np.array([t]))[0]

    def second_derivative_array(self, ts):
        c0 = 6*(1-ts)
        c1 = 6*ts - 12*(1-ts)
        c2 = 6*(1-ts) - 12*ts
        c3 = 6*ts
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3

        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def third_derivative_array(self, ts, tangent_delta=None):
        c0 = np.full_like(ts, -6)[:,np.newaxis]
        c1 = np.full_like(ts, 18)[:,np.newaxis]
        c2 = np.full_like(ts, -18)[:,np.newaxis]
        c3 = np.full_like(ts, 6)[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3
        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def derivatives_array(self, n, ts, tangent_delta=None):
        result = []
        if n &gt;= 1:
            first = self.tangent_array(ts)
            result.append(first)
        if n &gt;= 2:
            second = self.second_derivative_array(ts)
            result.append(second)
        if n &gt;= 3:
            third = self.third_derivative_array(ts)
            result.append(third)
        return result

    def get_degree(self):
        return 3

    def is_rational(self):
        return False

    def get_end_points(self):
        return self.p0, self.p3

    def get_control_points(self):
        return np.array([self.p0, self.p1, self.p2, self.p3])

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        knotvector = sv_knotvector.generate(3, 4)
        control_points = np.array([self.p0, self.p1, self.p2, self.p3])
        return SvNurbsMaths.build_curve(implementation,
                degree = 3, knotvector = knotvector,
                control_points = control_points)

    def elevate_degree(self, delta=None, target=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        degree = self.get_degree()

        if delta is None:
            delta = target - degree
            if delta &lt; 0:
                raise Exception(f&#34;Curve already has degree {degree}, which is greater than target {target}&#34;)
        if delta == 0:
            return self

        points = elevate_bezier_degree(3, self.get_control_points(), delta)
        return SvBezierCurve(points)

    def get_bounding_box(self):
        return bounding_box(self.get_control_points())

    def reparametrize(self, new_t_min, new_t_max):
        return self.to_nurbs().reparametrize(new_t_min, new_t_max)

    def concatenate(self, curve2, tolerance=None):
        curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
        if curve2 is None:
            raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
        return self.to_nurbs().concatenate(curve2, tolerance=tolerance)

    def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
        return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)

    def extrude_along_vector(self, vector):
        return self.to_nurbs().extrude_along_vector(vector)

    def make_ruled_surface(self, curve2, vmin, vmax):
        return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)
    
    def extrude_to_point(self, point):
        return self.to_nurbs().extrude_to_point(point)

    def lerp_to(self, curve2, coefficient):
        if isinstance(curve2, SvCubicBezierCurve):
            p0 = (1.0 - coefficient) * self.p0 + coefficient * curve2.p0
            p1 = (1.0 - coefficient) * self.p1 + coefficient * curve2.p1
            p2 = (1.0 - coefficient) * self.p2 + coefficient * curve2.p2
            p3 = (1.0 - coefficient) * self.p3 + coefficient * curve2.p3
            return SvCubicBezierCurve(p0, p1, p2, p3)
        return self.to_nurbs().lerp_to(curve2, coefficient)

    def is_line(self, tolerance=0.001):
        begin, end = self.p0, self.p3
        # direction from first to last point of the curve
        direction = end - begin
        if np.linalg.norm(direction) &lt; tolerance:
            return True
        line = LineEquation.from_direction_and_point(direction, begin)
        distances = line.distance_to_points([self.p1, self.p2])
        # Technically, this means that all control points lie
        # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
        # As a consequence, the convex hull of control points lie in the
        # same cylinder; and the curve lies in that convex hull.
        return (distances &lt; tolerance).all()

    def is_planar(self, tolerance=1e-6):
        plane = PlaneEquation.from_three_points(self.p0, self.p1, self.p2)
        return plane.distance_to_point(self.p3) &lt; tolerance

    def get_plane(self, tolerance=1e-6):
        plane = PlaneEquation.from_three_points(self.p0, self.p1, self.p2)
        if plane.distance_to_point(self.p3) &lt; tolerance:
            return plane
        else:
            return None

    def to_bezier(self):
        return self

    def to_bezier_segments(self):
        return [self]

    def reverse(self):
        return SvCubicBezierCurve(self.p3, self.p2, self.p1, self.p0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve"><code class="flex name class">
<span>class <span class="ident">SvBezierCurve</span></span>
<span>(</span><span>points)</span>
</code></dt>
<dd>
<div class="desc"><p>Bezier curve of arbitrary degree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvBezierCurve(SvCurve, SvBezierSplitMixin):
    &#34;&#34;&#34;
    Bezier curve of arbitrary degree.
    &#34;&#34;&#34;
    def __init__(self, points):
        self.points = np.asarray(points)
        self.tangent_delta = 0.001
        n = self.degree = len(points) - 1
        self.__description__ = &#34;Bezier[{}]&#34;.format(n)

    @classmethod
    def from_control_points(cls, points):
        if len(points) == 4:
            return SvCubicBezierCurve(points[0], points[1], points[2], points[3])
        else:
            return SvBezierCurve(points)

    @classmethod
    def from_points_and_tangents(cls, p0, t0, t1, p1):
        &#34;&#34;&#34;
        Build cubic Bezier curve, which goes from p0 to p1,
        and has tangent at 0 equal to t0 and tangent at 1 equal to t1.
        This is also called Hermite spline.

        inputs: p0, t0, t1, p1 - numpy arrays of shape (3,).
        &#34;&#34;&#34;
        return SvCubicBezierCurve(
                p0,
                p0 + t0 / 3.0,
                p1 - t1 / 3.0,
                p1)

    @classmethod
    def blend_second_derivatives(cls, p0, v0, a0, p5, v5, a5):
        &#34;&#34;&#34;
        Build Bezier curve of 5th order, which goes from p0 to p5, and has:
        * first derivative at 0 = v0, second derivative at 0 = a0;
        * first derivative at 1 = v5, second derivative at 1 = a1.

        inputs: numpy arrays of shape (3,).
        &#34;&#34;&#34;
        p1 = p0 + v0 / 5.0
        p4 = p5 - v5 / 5.0
        p2 = p0 + 0.4*v0 + a0/20.0
        p3 = p5 - 0.4*v5 + a5/20.0
        return SvBezierCurve([p0, p1, p2, p3, p4, p5])

    @classmethod
    def blend_third_derivatives(cls, p0, v0, a0, k0, p7, v7, a7, k7):
        &#34;&#34;&#34;
        Build Bezier curve of 7th order, which goes from p0 to p7, and has:
        * first derivative at 0 = v0, second derivative at 0 = a0, third derivative at 0 = k0;
        * first derivative at 1 = v7, second derivative at 1 = a7, third derivative at 1 = k7.

        inputs: numpy arrays of shape (3,).
        &#34;&#34;&#34;
        p1 = p0 + v0 / 7.0
        p6 = p7 - v7 / 7.0
        p2 = a0/42.0 + 2*p1 - p0
        p5 = a7/42.0 + 2*p6 - p7
        p3 = k0/210.0 + 3*p2 - 3*p1 + p0
        p4 = -k7/210.0 + 3*p5 - 3*p6 + p7
        return SvBezierCurve([p0, p1, p2, p3, p4, p5, p6, p7])

#     @classmethod
#     def from_tangents_and_curvatures(cls, point1, point2, tangent1, tangent2, curvature1, curvature2):
#         A1 = point1
#         A2 = point2
#         B1 = point1 + tangent1 / 5
#         B2 = point2 - tangent2 / 5
#         t1dir = tangent1 / np.linalg.norm(tangent1)
#         t2dir = tangent2 / np.linalg.norm(tangent2)
#         B1B2 = B2 - B1
#         direction = B1B2 / np.linalg.norm(B1B2)
#         
#         r1 = curvature1 * np.linalg.norm(tangent1)**2 / 20
#         r2 = curvature2 * np.linalg.norm(tangent2)**2 / 20
#         
#         dot1 = (direction * t1dir).sum()
#         sin1 = sqrt(1 - dot1**2)
#         d1 = r1 / sin1
#         
#         dot2 = (-direction * t2dir).sum()
#         sin2 = sqrt(1 - dot2**2)
#         d2 = r2 / sin2
#         
#         C1 = B1 + d1 * direction
#         C2 = B2 - d2 * direction
#         
#         return SvBezierCurve([A1, B1, C1, C2, B2, A2])

    @classmethod
    def from_tangents_normals_curvatures(cls, point1, point2, tangent1, tangent2, normal1, normal2, curvature1, curvature2):
        &#34;&#34;&#34;
        Build Bezier curve of 5th degree, which:
            
            * starts at point1 and end at point2
            * at start has tangent1 and normal1, at end has tangent2 and normal2
            * at start has curvature1, at end has curvature2.
        &#34;&#34;&#34;
        A1 = point1
        A2 = point2
        B1 = point1 + tangent1 / 5
        B2 = point2 - tangent2 / 5
        t1dir = tangent1 / np.linalg.norm(tangent1)
        t2dir = tangent2 / np.linalg.norm(tangent2)
        n1dir = normal1 / np.linalg.norm(normal1)
        n2dir = normal2 / np.linalg.norm(normal2)

        r1 = curvature1 * np.linalg.norm(tangent1)**2 / 20
        r2 = curvature2 * np.linalg.norm(tangent2)**2 / 20

        C1 = B1 + r1 * n1dir
        C2 = B2 + r2 * n2dir

        return SvBezierCurve([A1, B1, C1, C2, B2, A2])

    @classmethod
    def build_tangent_curve(cls, points, tangents, hermite=True, cyclic=False, concat=False, as_nurbs=False):
        &#34;&#34;&#34;
        Build cubic Bezier curve spline, which goes through specified `points&#39;,
        having specified `tangents&#39; at these points.

        inputs:
        * points, tangents: lists of 3-tuples
        * cyclic: whether the curve should be closed (cyclic)
        * concat: whether to concatenate all curve segments into single Curve object
        * hermite: if true, use Hermite spline - divide tangent vector by 3 to
            obtain middle control points; otherwise, divide by 2.

        outputs: tuple:
        * list of curve control points - list of lists of 3-tuples
        * list of generated curves; if concat == True, then this list will contain single curve.
        &#34;&#34;&#34;
        new_curves = []
        new_controls = []

        pairs = list(zip_long_repeat(points, tangents))
        segments = list(zip(pairs, pairs[1:]))
        if cyclic:
            segments.append((pairs[-1], pairs[0]))
        if hermite:
            d = 3.0
        else:
            d = 2.0

        for pair1, pair2 in segments:
            point1, tangent1 = pair1
            point2, tangent2 = pair2
            point1, tangent1 = np.array(point1), np.array(tangent1)
            point2, tangent2 = np.array(point2), np.array(tangent2)
            tangent1, tangent2 = tangent1/d, tangent2/d
            curve = SvCubicBezierCurve(
                        point1,
                        point1 + tangent1,
                        point2 - tangent2,
                        point2)
            curve_controls = [curve.p0.tolist(), curve.p1.tolist(),
                              curve.p2.tolist(), curve.p3.tolist()]
            if as_nurbs:
                curve = curve.to_nurbs()
            new_curves.append(curve)
            new_controls.append(curve_controls)
        if concat:
            new_curve = concatenate_curves(new_curves)
            new_curves = [new_curve]
            if as_nurbs:
                new_controls = new_curve.get_control_points().tolist()

        return new_controls, new_curves

    @classmethod
    def interpolate(cls, points, metric=&#39;DISTANCE&#39;):
        n = len(points)
        tknots = Spline.create_knots(points, metric=metric)
        matrix = np.zeros((3*n, 3*n))
        for equation_idx, t in enumerate(tknots):
            for unknown_idx in range(n):
                coeff = SvBezierCurve.coefficient(n-1, unknown_idx, np.array([t]))[0]
                #print(f&#34;C[{equation_idx}][{unknown_idx}] = {coeff}&#34;)
                row = 3*equation_idx
                col = 3*unknown_idx
                matrix[row,col] = matrix[row+1, col+1] = matrix[row+2,col+2] = coeff
        #print(matrix)
        B = np.zeros((3*n, 1))
        for point_idx, point in enumerate(points):
            row = 3*point_idx
            B[row:row+3] = point[:,np.newaxis]
        #print(B)
        x = np.linalg.solve(matrix, B)
        #print(x)
        controls = []
        for i in range(n):
            row = i*3
            control = x[row:row+3,0].T
            controls.append(control)
            #print(control)
        return SvBezierCurve(controls)
    
    def is_line(self, tolerance=0.001):
        cpts = self.get_control_points()
        begin, end = cpts[0], cpts[-1]
        # direction from first to last point of the curve
        direction = end - begin
        if np.linalg.norm(direction) &lt; tolerance:
            return True
        line = LineEquation.from_direction_and_point(direction, begin)
        distances = line.distance_to_points(cpts[1:-1])
        # Technically, this means that all control points lie
        # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
        # As a consequence, the convex hull of control points lie in the
        # same cylinder; and the curve lies in that convex hull.
        return (distances &lt; tolerance).all()

    def get_end_points(self):
        return self.points[0], self.points[-1]

    @classmethod
    def coefficient(cls, n, k, ts):
        C = binomial(n, k)
        return C * ts**k * (1 - ts)**(n-k)

    def coeff(self, k, ts):
        n = self.degree
        return SvBezierCurve.coefficient(n, k, ts)

    def coeff_deriv1(self, k, t):
        n = self.degree
        C = binomial(n, k)
        if k &gt;= 1:
            s1 = k*(1-t)**(n-k)*t**(k-1)
        else:
            s1 = np.zeros_like(t)
        if n-k-1 &gt; 0:
            s2 = - (n-k)*(1-t)**(n-k-1)*t**k
        elif n-k == 1:
            s2 = - t**k
        else:
            s2 = np.zeros_like(t)
        coeff = s1 + s2
        return C*coeff

    def coeff_deriv2(self, k, t):
        n = self.degree
        C = binomial(n, k)
        if n-k-2 &gt; 0:
            s1 = (n-k-1)*(n-k)*(1-t)**(n-k-2)*t**k
        elif n-k == 2:
            s1 = 2*t**k
        else:
            s1 = np.zeros_like(t)
        if k &gt;= 1 and n-k-1 &gt; 0:
            s2 = - 2*k*(n-k)*(1-t)**(n-k-1)*t**(k-1)
        elif k &gt;= 1 and n-k == 1:
            s2 = - 2*k*t**(k-1)
        else:
            s2 = np.zeros_like(t)
        if k &gt;= 2:
            s3 = (k-1)*k*(1-t)**(n-k)*t**(k-2)
        else:
            s3 = np.zeros_like(t)
        coeff = s1 + s2 + s3
        return C*coeff

    def coeff_deriv3(self, k, t):
        n = self.degree
        C = binomial(n, k)
        if n-k-2 &gt; 0:
            s1 = -(n-k-2)*(n-k-1)*(n-k)*(1-t)**(n-k-3)*t**k
        else:
            s1 = np.zeros_like(t)
        if k &gt;= 1 and n-k-2 &gt; 0:
            s2 = 3*k*(n-k-1)*(n-k)*(1-t)**(n-k-2)*t**(k-1)
        elif k &gt;= 1 and n-k == 2:
            s2 = 6*k*t**(k-1)
        else:
            s2 = np.zeros_like(t)
        if k &gt;= 2 and n-k-1 &gt; 0:
            s3 = - 3*(k-1)*k*(n-k)*(1-t)**(n-k-1)*t**(k-2)
        elif k &gt;= 2 and n-k == 1:
            s3 = -3*(k-1)*k*t**(k-2)
        else:
            s3 = np.zeros_like(t)
        if k &gt;= 3:
            s4 = (k-2)*(k-1)*k*(1-t)**(n-k)*t**(k-3)
        else:
            s4 = np.zeros_like(t)
        coeff = s1 + s2 + s3 + s4
        return C*coeff

    def get_u_bounds(self):
        return (0.0, 1.0)

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        coeffs = [SvBezierCurve.coefficient(self.degree, k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        return np.dot(coeffs.T, self.points)

    def tangent(self, t, tangent_delta=None):
        return self.tangent_array(np.array([t]), tangent_delta=tangent_delta)[0]

    def tangent_array(self, ts, tangent_delta=None):
        coeffs = [self.coeff_deriv1(k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        #print(&#34;C1&#34;, coeffs)
        return np.dot(coeffs.T, self.points)

    def second_derivative(self, t, tangent_delta=None):
        return self.second_derivative_array(np.array([t]))[0]

    def second_derivative_array(self, ts, tangent_delta=None):
        coeffs = [self.coeff_deriv2(k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        #print(&#34;C2&#34;, coeffs)
        return np.dot(coeffs.T, self.points)

    def third_derivative_array(self, ts, tangent_delta=None):
        coeffs = [self.coeff_deriv3(k, ts) for k in range(len(self.points))]
        coeffs = np.array(coeffs)
        #print(&#34;C3&#34;, coeffs)
        return np.dot(coeffs.T, self.points)

    def derivatives_array(self, n, ts, tangent_delta=None):
        result = []
        if n &gt;= 1:
            first = self.tangent_array(ts, tangent_delta=tangent_delta)
            result.append(first)
        if n &gt;= 2:
            second = self.second_derivative_array(ts, tangent_delta=tangent_delta)
            result.append(second)
        if n &gt;= 3:
            third = self.third_derivative_array(ts, tangent_delta=tangent_delta)
            result.append(third)
        return result

    def reparametrize(self, new_t_min, new_t_max):
        return self.to_nurbs().reparametrize(new_t_min, new_t_max)

    def get_degree(self):
        return self.degree

    def is_rational(self):
        return False

    def is_planar(self, tolerance=1e-6):
        return are_points_coplanar(self.points, tolerance)

    def get_plane(self, tolerance=1e-6):
        return get_common_plane(self.points, tolerance)

    def get_control_points(self):
        return self.points

    def elevate_degree(self, delta=None, target=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        degree = self.get_degree()

        if delta is None:
            delta = target - degree
            if delta &lt; 0:
                raise Exception(f&#34;Curve already has degree {degree}, which is greater than target {target}&#34;)
        if delta == 0:
            return self

        points = elevate_bezier_degree(self.degree, self.points, delta)
        return SvBezierCurve(points)

    def get_bounding_box(self):
        return bounding_box(self.get_control_points())

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        knotvector = sv_knotvector.generate(self.degree, len(self.points))
        return SvNurbsMaths.build_curve(implementation,
                degree = self.degree, knotvector = knotvector,
                control_points = self.points)

    def concatenate(self, curve2, tolerance=None):
        curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
        if curve2 is None:
            raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
        return self.to_nurbs().concatenate(curve2, tolerance=tolerance)

    def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
        return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)
    
    def extrude_along_vector(self, vector):
        return self.to_nurbs().extrude_along_vector(vector)

    def make_ruled_surface(self, curve2, vmin, vmax):
        return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)

    def extrude_to_point(self, point):
        return self.to_nurbs().extrude_to_point(point)

    def lerp_to(self, curve2, coefficient):
        if isinstance(curve2, SvBezierCurve) and curve2.degree == self.degree:
            points = (1.0 - coefficient) * self.points + coefficient * curve2.points
            return SvBezierCurve(points)
        return self.to_nurbs().lerp_to(curve2, coefficient)
    

    def to_bezier(self):
        return self

    def to_bezier_segments(self):
        return [self]

    def reverse(self):
        return SvBezierCurve(self.points[::-1])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
<li><a title="sverchok.utils.curve.bezier.SvBezierSplitMixin" href="#sverchok.utils.curve.bezier.SvBezierSplitMixin">SvBezierSplitMixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.blend_second_derivatives"><code class="name flex">
<span>def <span class="ident">blend_second_derivatives</span></span>(<span>p0, v0, a0, p5, v5, a5)</span>
</code></dt>
<dd>
<div class="desc"><p>Build Bezier curve of 5th order, which goes from p0 to p5, and has:
* first derivative at 0 = v0, second derivative at 0 = a0;
* first derivative at 1 = v5, second derivative at 1 = a1.</p>
<p>inputs: numpy arrays of shape (3,).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def blend_second_derivatives(cls, p0, v0, a0, p5, v5, a5):
    &#34;&#34;&#34;
    Build Bezier curve of 5th order, which goes from p0 to p5, and has:
    * first derivative at 0 = v0, second derivative at 0 = a0;
    * first derivative at 1 = v5, second derivative at 1 = a1.

    inputs: numpy arrays of shape (3,).
    &#34;&#34;&#34;
    p1 = p0 + v0 / 5.0
    p4 = p5 - v5 / 5.0
    p2 = p0 + 0.4*v0 + a0/20.0
    p3 = p5 - 0.4*v5 + a5/20.0
    return SvBezierCurve([p0, p1, p2, p3, p4, p5])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.blend_third_derivatives"><code class="name flex">
<span>def <span class="ident">blend_third_derivatives</span></span>(<span>p0, v0, a0, k0, p7, v7, a7, k7)</span>
</code></dt>
<dd>
<div class="desc"><p>Build Bezier curve of 7th order, which goes from p0 to p7, and has:
* first derivative at 0 = v0, second derivative at 0 = a0, third derivative at 0 = k0;
* first derivative at 1 = v7, second derivative at 1 = a7, third derivative at 1 = k7.</p>
<p>inputs: numpy arrays of shape (3,).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def blend_third_derivatives(cls, p0, v0, a0, k0, p7, v7, a7, k7):
    &#34;&#34;&#34;
    Build Bezier curve of 7th order, which goes from p0 to p7, and has:
    * first derivative at 0 = v0, second derivative at 0 = a0, third derivative at 0 = k0;
    * first derivative at 1 = v7, second derivative at 1 = a7, third derivative at 1 = k7.

    inputs: numpy arrays of shape (3,).
    &#34;&#34;&#34;
    p1 = p0 + v0 / 7.0
    p6 = p7 - v7 / 7.0
    p2 = a0/42.0 + 2*p1 - p0
    p5 = a7/42.0 + 2*p6 - p7
    p3 = k0/210.0 + 3*p2 - 3*p1 + p0
    p4 = -k7/210.0 + 3*p5 - 3*p6 + p7
    return SvBezierCurve([p0, p1, p2, p3, p4, p5, p6, p7])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.build_tangent_curve"><code class="name flex">
<span>def <span class="ident">build_tangent_curve</span></span>(<span>points, tangents, hermite=True, cyclic=False, concat=False, as_nurbs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Build cubic Bezier curve spline, which goes through specified <code>points',
having specified</code>tangents' at these points.</p>
<p>inputs:
* points, tangents: lists of 3-tuples
* cyclic: whether the curve should be closed (cyclic)
* concat: whether to concatenate all curve segments into single Curve object
* hermite: if true, use Hermite spline - divide tangent vector by 3 to
obtain middle control points; otherwise, divide by 2.</p>
<p>outputs: tuple:
* list of curve control points - list of lists of 3-tuples
* list of generated curves; if concat == True, then this list will contain single curve.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_tangent_curve(cls, points, tangents, hermite=True, cyclic=False, concat=False, as_nurbs=False):
    &#34;&#34;&#34;
    Build cubic Bezier curve spline, which goes through specified `points&#39;,
    having specified `tangents&#39; at these points.

    inputs:
    * points, tangents: lists of 3-tuples
    * cyclic: whether the curve should be closed (cyclic)
    * concat: whether to concatenate all curve segments into single Curve object
    * hermite: if true, use Hermite spline - divide tangent vector by 3 to
        obtain middle control points; otherwise, divide by 2.

    outputs: tuple:
    * list of curve control points - list of lists of 3-tuples
    * list of generated curves; if concat == True, then this list will contain single curve.
    &#34;&#34;&#34;
    new_curves = []
    new_controls = []

    pairs = list(zip_long_repeat(points, tangents))
    segments = list(zip(pairs, pairs[1:]))
    if cyclic:
        segments.append((pairs[-1], pairs[0]))
    if hermite:
        d = 3.0
    else:
        d = 2.0

    for pair1, pair2 in segments:
        point1, tangent1 = pair1
        point2, tangent2 = pair2
        point1, tangent1 = np.array(point1), np.array(tangent1)
        point2, tangent2 = np.array(point2), np.array(tangent2)
        tangent1, tangent2 = tangent1/d, tangent2/d
        curve = SvCubicBezierCurve(
                    point1,
                    point1 + tangent1,
                    point2 - tangent2,
                    point2)
        curve_controls = [curve.p0.tolist(), curve.p1.tolist(),
                          curve.p2.tolist(), curve.p3.tolist()]
        if as_nurbs:
            curve = curve.to_nurbs()
        new_curves.append(curve)
        new_controls.append(curve_controls)
    if concat:
        new_curve = concatenate_curves(new_curves)
        new_curves = [new_curve]
        if as_nurbs:
            new_controls = new_curve.get_control_points().tolist()

    return new_controls, new_curves</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.coefficient"><code class="name flex">
<span>def <span class="ident">coefficient</span></span>(<span>n, k, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def coefficient(cls, n, k, ts):
    C = binomial(n, k)
    return C * ts**k * (1 - ts)**(n-k)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.from_control_points"><code class="name flex">
<span>def <span class="ident">from_control_points</span></span>(<span>points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_control_points(cls, points):
    if len(points) == 4:
        return SvCubicBezierCurve(points[0], points[1], points[2], points[3])
    else:
        return SvBezierCurve(points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.from_points_and_tangents"><code class="name flex">
<span>def <span class="ident">from_points_and_tangents</span></span>(<span>p0, t0, t1, p1)</span>
</code></dt>
<dd>
<div class="desc"><p>Build cubic Bezier curve, which goes from p0 to p1,
and has tangent at 0 equal to t0 and tangent at 1 equal to t1.
This is also called Hermite spline.</p>
<p>inputs: p0, t0, t1, p1 - numpy arrays of shape (3,).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_points_and_tangents(cls, p0, t0, t1, p1):
    &#34;&#34;&#34;
    Build cubic Bezier curve, which goes from p0 to p1,
    and has tangent at 0 equal to t0 and tangent at 1 equal to t1.
    This is also called Hermite spline.

    inputs: p0, t0, t1, p1 - numpy arrays of shape (3,).
    &#34;&#34;&#34;
    return SvCubicBezierCurve(
            p0,
            p0 + t0 / 3.0,
            p1 - t1 / 3.0,
            p1)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.from_tangents_normals_curvatures"><code class="name flex">
<span>def <span class="ident">from_tangents_normals_curvatures</span></span>(<span>point1, point2, tangent1, tangent2, normal1, normal2, curvature1, curvature2)</span>
</code></dt>
<dd>
<div class="desc"><p>Build Bezier curve of 5th degree, which:</p>
<pre><code>* starts at point1 and end at point2
* at start has tangent1 and normal1, at end has tangent2 and normal2
* at start has curvature1, at end has curvature2.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_tangents_normals_curvatures(cls, point1, point2, tangent1, tangent2, normal1, normal2, curvature1, curvature2):
    &#34;&#34;&#34;
    Build Bezier curve of 5th degree, which:
        
        * starts at point1 and end at point2
        * at start has tangent1 and normal1, at end has tangent2 and normal2
        * at start has curvature1, at end has curvature2.
    &#34;&#34;&#34;
    A1 = point1
    A2 = point2
    B1 = point1 + tangent1 / 5
    B2 = point2 - tangent2 / 5
    t1dir = tangent1 / np.linalg.norm(tangent1)
    t2dir = tangent2 / np.linalg.norm(tangent2)
    n1dir = normal1 / np.linalg.norm(normal1)
    n2dir = normal2 / np.linalg.norm(normal2)

    r1 = curvature1 * np.linalg.norm(tangent1)**2 / 20
    r2 = curvature2 * np.linalg.norm(tangent2)**2 / 20

    C1 = B1 + r1 * n1dir
    C2 = B2 + r2 * n2dir

    return SvBezierCurve([A1, B1, C1, C2, B2, A2])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>points, metric='DISTANCE')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def interpolate(cls, points, metric=&#39;DISTANCE&#39;):
    n = len(points)
    tknots = Spline.create_knots(points, metric=metric)
    matrix = np.zeros((3*n, 3*n))
    for equation_idx, t in enumerate(tknots):
        for unknown_idx in range(n):
            coeff = SvBezierCurve.coefficient(n-1, unknown_idx, np.array([t]))[0]
            #print(f&#34;C[{equation_idx}][{unknown_idx}] = {coeff}&#34;)
            row = 3*equation_idx
            col = 3*unknown_idx
            matrix[row,col] = matrix[row+1, col+1] = matrix[row+2,col+2] = coeff
    #print(matrix)
    B = np.zeros((3*n, 1))
    for point_idx, point in enumerate(points):
        row = 3*point_idx
        B[row:row+3] = point[:,np.newaxis]
    #print(B)
    x = np.linalg.solve(matrix, B)
    #print(x)
    controls = []
    for i in range(n):
        row = i*3
        control = x[row:row+3,0].T
        controls.append(control)
        #print(control)
    return SvBezierCurve(controls)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.coeff"><code class="name flex">
<span>def <span class="ident">coeff</span></span>(<span>self, k, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coeff(self, k, ts):
    n = self.degree
    return SvBezierCurve.coefficient(n, k, ts)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv1"><code class="name flex">
<span>def <span class="ident">coeff_deriv1</span></span>(<span>self, k, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coeff_deriv1(self, k, t):
    n = self.degree
    C = binomial(n, k)
    if k &gt;= 1:
        s1 = k*(1-t)**(n-k)*t**(k-1)
    else:
        s1 = np.zeros_like(t)
    if n-k-1 &gt; 0:
        s2 = - (n-k)*(1-t)**(n-k-1)*t**k
    elif n-k == 1:
        s2 = - t**k
    else:
        s2 = np.zeros_like(t)
    coeff = s1 + s2
    return C*coeff</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv2"><code class="name flex">
<span>def <span class="ident">coeff_deriv2</span></span>(<span>self, k, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coeff_deriv2(self, k, t):
    n = self.degree
    C = binomial(n, k)
    if n-k-2 &gt; 0:
        s1 = (n-k-1)*(n-k)*(1-t)**(n-k-2)*t**k
    elif n-k == 2:
        s1 = 2*t**k
    else:
        s1 = np.zeros_like(t)
    if k &gt;= 1 and n-k-1 &gt; 0:
        s2 = - 2*k*(n-k)*(1-t)**(n-k-1)*t**(k-1)
    elif k &gt;= 1 and n-k == 1:
        s2 = - 2*k*t**(k-1)
    else:
        s2 = np.zeros_like(t)
    if k &gt;= 2:
        s3 = (k-1)*k*(1-t)**(n-k)*t**(k-2)
    else:
        s3 = np.zeros_like(t)
    coeff = s1 + s2 + s3
    return C*coeff</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv3"><code class="name flex">
<span>def <span class="ident">coeff_deriv3</span></span>(<span>self, k, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coeff_deriv3(self, k, t):
    n = self.degree
    C = binomial(n, k)
    if n-k-2 &gt; 0:
        s1 = -(n-k-2)*(n-k-1)*(n-k)*(1-t)**(n-k-3)*t**k
    else:
        s1 = np.zeros_like(t)
    if k &gt;= 1 and n-k-2 &gt; 0:
        s2 = 3*k*(n-k-1)*(n-k)*(1-t)**(n-k-2)*t**(k-1)
    elif k &gt;= 1 and n-k == 2:
        s2 = 6*k*t**(k-1)
    else:
        s2 = np.zeros_like(t)
    if k &gt;= 2 and n-k-1 &gt; 0:
        s3 = - 3*(k-1)*k*(n-k)*(1-t)**(n-k-1)*t**(k-2)
    elif k &gt;= 2 and n-k == 1:
        s3 = -3*(k-1)*k*t**(k-2)
    else:
        s3 = np.zeros_like(t)
    if k &gt;= 3:
        s4 = (k-2)*(k-1)*k*(1-t)**(n-k)*t**(k-3)
    else:
        s4 = np.zeros_like(t)
    coeff = s1 + s2 + s3 + s4
    return C*coeff</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.concatenate"><code class="name flex">
<span>def <span class="ident">concatenate</span></span>(<span>self, curve2, tolerance=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate(self, curve2, tolerance=None):
    curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
    if curve2 is None:
        raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
    return self.to_nurbs().concatenate(curve2, tolerance=tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.derivatives_array"><code class="name flex">
<span>def <span class="ident">derivatives_array</span></span>(<span>self, n, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivatives_array(self, n, ts, tangent_delta=None):
    result = []
    if n &gt;= 1:
        first = self.tangent_array(ts, tangent_delta=tangent_delta)
        result.append(first)
    if n &gt;= 2:
        second = self.second_derivative_array(ts, tangent_delta=tangent_delta)
        result.append(second)
    if n &gt;= 3:
        third = self.third_derivative_array(ts, tangent_delta=tangent_delta)
        result.append(third)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.elevate_degree"><code class="name flex">
<span>def <span class="ident">elevate_degree</span></span>(<span>self, delta=None, target=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elevate_degree(self, delta=None, target=None):
    if delta is None and target is None:
        delta = 1
    if delta is not None and target is not None:
        raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
    degree = self.get_degree()

    if delta is None:
        delta = target - degree
        if delta &lt; 0:
            raise Exception(f&#34;Curve already has degree {degree}, which is greater than target {target}&#34;)
    if delta == 0:
        return self

    points = elevate_bezier_degree(self.degree, self.points, delta)
    return SvBezierCurve(points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.extrude_along_vector"><code class="name flex">
<span>def <span class="ident">extrude_along_vector</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrude_along_vector(self, vector):
    return self.to_nurbs().extrude_along_vector(vector)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.extrude_to_point"><code class="name flex">
<span>def <span class="ident">extrude_to_point</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrude_to_point(self, point):
    return self.to_nurbs().extrude_to_point(point)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.get_bounding_box"><code class="name flex">
<span>def <span class="ident">get_bounding_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounding_box(self):
    return bounding_box(self.get_control_points())</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.get_end_points"><code class="name flex">
<span>def <span class="ident">get_end_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_points(self):
    return self.points[0], self.points[-1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.get_plane"><code class="name flex">
<span>def <span class="ident">get_plane</span></span>(<span>self, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plane(self, tolerance=1e-6):
    return get_common_plane(self.points, tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.is_line"><code class="name flex">
<span>def <span class="ident">is_line</span></span>(<span>self, tolerance=0.001)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_line(self, tolerance=0.001):
    cpts = self.get_control_points()
    begin, end = cpts[0], cpts[-1]
    # direction from first to last point of the curve
    direction = end - begin
    if np.linalg.norm(direction) &lt; tolerance:
        return True
    line = LineEquation.from_direction_and_point(direction, begin)
    distances = line.distance_to_points(cpts[1:-1])
    # Technically, this means that all control points lie
    # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
    # As a consequence, the convex hull of control points lie in the
    # same cylinder; and the curve lies in that convex hull.
    return (distances &lt; tolerance).all()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.is_planar"><code class="name flex">
<span>def <span class="ident">is_planar</span></span>(<span>self, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_planar(self, tolerance=1e-6):
    return are_points_coplanar(self.points, tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.is_rational"><code class="name flex">
<span>def <span class="ident">is_rational</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_rational(self):
    return False</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.lerp_to"><code class="name flex">
<span>def <span class="ident">lerp_to</span></span>(<span>self, curve2, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lerp_to(self, curve2, coefficient):
    if isinstance(curve2, SvBezierCurve) and curve2.degree == self.degree:
        points = (1.0 - coefficient) * self.points + coefficient * curve2.points
        return SvBezierCurve(points)
    return self.to_nurbs().lerp_to(curve2, coefficient)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.make_revolution_surface"><code class="name flex">
<span>def <span class="ident">make_revolution_surface</span></span>(<span>self, point, direction, v_min, v_max, global_origin)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
    return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.make_ruled_surface"><code class="name flex">
<span>def <span class="ident">make_ruled_surface</span></span>(<span>self, curve2, vmin, vmax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_ruled_surface(self, curve2, vmin, vmax):
    return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.reparametrize"><code class="name flex">
<span>def <span class="ident">reparametrize</span></span>(<span>self, new_t_min, new_t_max)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparametrize(self, new_t_min, new_t_max):
    return self.to_nurbs().reparametrize(new_t_min, new_t_max)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    return SvBezierCurve(self.points[::-1])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.second_derivative"><code class="name flex">
<span>def <span class="ident">second_derivative</span></span>(<span>self, t, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative(self, t, tangent_delta=None):
    return self.second_derivative_array(np.array([t]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.second_derivative_array"><code class="name flex">
<span>def <span class="ident">second_derivative_array</span></span>(<span>self, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative_array(self, ts, tangent_delta=None):
    coeffs = [self.coeff_deriv2(k, ts) for k in range(len(self.points))]
    coeffs = np.array(coeffs)
    #print(&#34;C2&#34;, coeffs)
    return np.dot(coeffs.T, self.points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.third_derivative_array"><code class="name flex">
<span>def <span class="ident">third_derivative_array</span></span>(<span>self, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def third_derivative_array(self, ts, tangent_delta=None):
    coeffs = [self.coeff_deriv3(k, ts) for k in range(len(self.points))]
    coeffs = np.array(coeffs)
    #print(&#34;C3&#34;, coeffs)
    return np.dot(coeffs.T, self.points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.to_bezier"><code class="name flex">
<span>def <span class="ident">to_bezier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bezier(self):
    return self</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.to_bezier_segments"><code class="name flex">
<span>def <span class="ident">to_bezier_segments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bezier_segments(self):
    return [self]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierCurve.to_nurbs"><code class="name flex">
<span>def <span class="ident">to_nurbs</span></span>(<span>self, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
    knotvector = sv_knotvector.generate(self.degree, len(self.points))
    return SvNurbsMaths.build_curve(implementation,
            degree = self.degree, knotvector = knotvector,
            control_points = self.points)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierSplitMixin"><code class="flex name class">
<span>class <span class="ident">SvBezierSplitMixin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvBezierSplitMixin:
    def de_casteljau_points(self, t):
        ndim = 3
        p = self.get_degree()
        n = p+1
        dpts = np.zeros((n, n, ndim))
        dpts[:] = self.get_control_points()
        for j in range(1, n):
            for k in range(n - j):
                dpts[j,k] = dpts[j-1, k] * (1 - t) + dpts[j-1, k+1] * t
        return dpts
    
#     DeCasteljau variant
#     def split_at(self, t):
#         dpts = self.de_casteljau_points(t)
#         cpts1 = dpts[:,0]
#         cpts2 = dpts[-1,:]
#         return SvBezierCurve.from_control_points(cpts1), SvBezierCurve.from_control_points(cpts2)

#   def cut_segment(self, new_t_min, new_t_max, rescale=False):
#         if new_t_min &gt;= 0:
#             c1, c2 = self.split_at(new_t_min)
#         else:
#             c2 = self
#         if new_t_max &lt;= 1.0:
#             t1 = (new_t_max - new_t_min) / (1.0 - new_t_min)
#             c3, c4 = c2.split_at(t1)
#         else:
#             c3 = c2
#         return c3

    def cut_segment(self, new_t_min, new_t_max, rescale=False):
        ndim = 3
        p = self.get_degree()
        cpts = self.get_control_points()

        matrices = calc_taylor_nurbs_matrices(p, u_bounds=(new_t_min, new_t_max), calc_M=True, calc_R=True, calc_M1=True, calc_R1=True)
        M = matrices[&#39;M&#39;]
        R1 = matrices[&#39;R1&#39;]
        M1 = matrices[&#39;M1&#39;]

        MR1M = M1 @ R1 @ M

        new_cpts = MR1M @ cpts
        return SvBezierCurve.from_control_points(new_cpts)

    def split_at(self, t):
        segment1 = self.cut_segment(0.0, t)
        segment2 = self.cut_segment(t, 1.0)
        return segment1, segment2</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.bezier.SvBezierCurve" href="#sverchok.utils.curve.bezier.SvBezierCurve">SvBezierCurve</a></li>
<li><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve">SvCubicBezierCurve</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.bezier.SvBezierSplitMixin.cut_segment"><code class="name flex">
<span>def <span class="ident">cut_segment</span></span>(<span>self, new_t_min, new_t_max, rescale=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_segment(self, new_t_min, new_t_max, rescale=False):
    ndim = 3
    p = self.get_degree()
    cpts = self.get_control_points()

    matrices = calc_taylor_nurbs_matrices(p, u_bounds=(new_t_min, new_t_max), calc_M=True, calc_R=True, calc_M1=True, calc_R1=True)
    M = matrices[&#39;M&#39;]
    R1 = matrices[&#39;R1&#39;]
    M1 = matrices[&#39;M1&#39;]

    MR1M = M1 @ R1 @ M

    new_cpts = MR1M @ cpts
    return SvBezierCurve.from_control_points(new_cpts)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierSplitMixin.de_casteljau_points"><code class="name flex">
<span>def <span class="ident">de_casteljau_points</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def de_casteljau_points(self, t):
    ndim = 3
    p = self.get_degree()
    n = p+1
    dpts = np.zeros((n, n, ndim))
    dpts[:] = self.get_control_points()
    for j in range(1, n):
        for k in range(n - j):
            dpts[j,k] = dpts[j-1, k] * (1 - t) + dpts[j-1, k+1] * t
    return dpts</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvBezierSplitMixin.split_at"><code class="name flex">
<span>def <span class="ident">split_at</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_at(self, t):
    segment1 = self.cut_segment(0.0, t)
    segment2 = self.cut_segment(t, 1.0)
    return segment1, segment2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve"><code class="flex name class">
<span>class <span class="ident">SvCubicBezierCurve</span></span>
<span>(</span><span>p0, p1, p2, p3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCubicBezierCurve(SvCurve, SvBezierSplitMixin):
    __description__ = &#34;Bezier[3*]&#34;
    def __init__(self, p0, p1, p2, p3):
        self.p0 = np.array(p0)
        self.p1 = np.array(p1)
        self.p2 = np.array(p2)
        self.p3 = np.array(p3)
        self.tangent_delta = 0.001

    @classmethod
    def from_four_points(cls, v0, v1, v2, v3):
        v0 = np.array(v0)
        v1 = np.array(v1)
        v2 = np.array(v2)
        v3 = np.array(v3)

        p1 = (-5*v0 + 18*v1 - 9*v2 + 2*v3)/6.0
        p2 = (2*v0 - 9*v1 + 18*v2 - 5*v3)/6.0

        return SvCubicBezierCurve(v0, p1, p2, v3)

    def get_u_bounds(self):
        return (0.0, 1.0)

    def evaluate(self, t):
        return self.evaluate_array(np.array([t]))[0]

    def evaluate_array(self, ts):
        c0 = (1 - ts)**3
        c1 = 3*ts*(1-ts)**2
        c2 = 3*ts**2*(1-ts)
        c3 = ts**3
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3

        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def tangent(self, t, tangent_delta=None):
        return self.tangent_array(np.array([t]), tangent_delta=tangent_delta)[0]

    def tangent_array(self, ts, tangent_delta=None):
        c0 = -3*(1 - ts)**2
        c1 = 3*(1-ts)**2 - 6*(1-ts)*ts
        c2 = 6*(1-ts)*ts - 3*ts**2
        c3 = 3*ts**2
        #print(&#34;C/C1&#34;, np.array([c0, c1, c2, c3]))
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3

        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def second_derivative(self, t, tangent_delta=None):
        return self.second_derivative_array(np.array([t]))[0]

    def second_derivative_array(self, ts):
        c0 = 6*(1-ts)
        c1 = 6*ts - 12*(1-ts)
        c2 = 6*(1-ts) - 12*ts
        c3 = 6*ts
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3

        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def third_derivative_array(self, ts, tangent_delta=None):
        c0 = np.full_like(ts, -6)[:,np.newaxis]
        c1 = np.full_like(ts, 18)[:,np.newaxis]
        c2 = np.full_like(ts, -18)[:,np.newaxis]
        c3 = np.full_like(ts, 6)[:,np.newaxis]
        p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3
        return c0*p0 + c1*p1 + c2*p2 + c3*p3

    def derivatives_array(self, n, ts, tangent_delta=None):
        result = []
        if n &gt;= 1:
            first = self.tangent_array(ts)
            result.append(first)
        if n &gt;= 2:
            second = self.second_derivative_array(ts)
            result.append(second)
        if n &gt;= 3:
            third = self.third_derivative_array(ts)
            result.append(third)
        return result

    def get_degree(self):
        return 3

    def is_rational(self):
        return False

    def get_end_points(self):
        return self.p0, self.p3

    def get_control_points(self):
        return np.array([self.p0, self.p1, self.p2, self.p3])

    def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
        knotvector = sv_knotvector.generate(3, 4)
        control_points = np.array([self.p0, self.p1, self.p2, self.p3])
        return SvNurbsMaths.build_curve(implementation,
                degree = 3, knotvector = knotvector,
                control_points = control_points)

    def elevate_degree(self, delta=None, target=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        degree = self.get_degree()

        if delta is None:
            delta = target - degree
            if delta &lt; 0:
                raise Exception(f&#34;Curve already has degree {degree}, which is greater than target {target}&#34;)
        if delta == 0:
            return self

        points = elevate_bezier_degree(3, self.get_control_points(), delta)
        return SvBezierCurve(points)

    def get_bounding_box(self):
        return bounding_box(self.get_control_points())

    def reparametrize(self, new_t_min, new_t_max):
        return self.to_nurbs().reparametrize(new_t_min, new_t_max)

    def concatenate(self, curve2, tolerance=None):
        curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
        if curve2 is None:
            raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
        return self.to_nurbs().concatenate(curve2, tolerance=tolerance)

    def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
        return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)

    def extrude_along_vector(self, vector):
        return self.to_nurbs().extrude_along_vector(vector)

    def make_ruled_surface(self, curve2, vmin, vmax):
        return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)
    
    def extrude_to_point(self, point):
        return self.to_nurbs().extrude_to_point(point)

    def lerp_to(self, curve2, coefficient):
        if isinstance(curve2, SvCubicBezierCurve):
            p0 = (1.0 - coefficient) * self.p0 + coefficient * curve2.p0
            p1 = (1.0 - coefficient) * self.p1 + coefficient * curve2.p1
            p2 = (1.0 - coefficient) * self.p2 + coefficient * curve2.p2
            p3 = (1.0 - coefficient) * self.p3 + coefficient * curve2.p3
            return SvCubicBezierCurve(p0, p1, p2, p3)
        return self.to_nurbs().lerp_to(curve2, coefficient)

    def is_line(self, tolerance=0.001):
        begin, end = self.p0, self.p3
        # direction from first to last point of the curve
        direction = end - begin
        if np.linalg.norm(direction) &lt; tolerance:
            return True
        line = LineEquation.from_direction_and_point(direction, begin)
        distances = line.distance_to_points([self.p1, self.p2])
        # Technically, this means that all control points lie
        # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
        # As a consequence, the convex hull of control points lie in the
        # same cylinder; and the curve lies in that convex hull.
        return (distances &lt; tolerance).all()

    def is_planar(self, tolerance=1e-6):
        plane = PlaneEquation.from_three_points(self.p0, self.p1, self.p2)
        return plane.distance_to_point(self.p3) &lt; tolerance

    def get_plane(self, tolerance=1e-6):
        plane = PlaneEquation.from_three_points(self.p0, self.p1, self.p2)
        if plane.distance_to_point(self.p3) &lt; tolerance:
            return plane
        else:
            return None

    def to_bezier(self):
        return self

    def to_bezier_segments(self):
        return [self]

    def reverse(self):
        return SvCubicBezierCurve(self.p3, self.p2, self.p1, self.p0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></li>
<li><a title="sverchok.utils.curve.bezier.SvBezierSplitMixin" href="#sverchok.utils.curve.bezier.SvBezierSplitMixin">SvBezierSplitMixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.from_four_points"><code class="name flex">
<span>def <span class="ident">from_four_points</span></span>(<span>v0, v1, v2, v3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_four_points(cls, v0, v1, v2, v3):
    v0 = np.array(v0)
    v1 = np.array(v1)
    v2 = np.array(v2)
    v3 = np.array(v3)

    p1 = (-5*v0 + 18*v1 - 9*v2 + 2*v3)/6.0
    p2 = (2*v0 - 9*v1 + 18*v2 - 5*v3)/6.0

    return SvCubicBezierCurve(v0, p1, p2, v3)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.concatenate"><code class="name flex">
<span>def <span class="ident">concatenate</span></span>(<span>self, curve2, tolerance=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate(self, curve2, tolerance=None):
    curve2 = SvNurbsMaths.to_nurbs_curve(curve2)
    if curve2 is None:
        raise UnsupportedCurveTypeException(&#34;Second curve is not a NURBS&#34;)
    return self.to_nurbs().concatenate(curve2, tolerance=tolerance)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.derivatives_array"><code class="name flex">
<span>def <span class="ident">derivatives_array</span></span>(<span>self, n, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivatives_array(self, n, ts, tangent_delta=None):
    result = []
    if n &gt;= 1:
        first = self.tangent_array(ts)
        result.append(first)
    if n &gt;= 2:
        second = self.second_derivative_array(ts)
        result.append(second)
    if n &gt;= 3:
        third = self.third_derivative_array(ts)
        result.append(third)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.elevate_degree"><code class="name flex">
<span>def <span class="ident">elevate_degree</span></span>(<span>self, delta=None, target=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elevate_degree(self, delta=None, target=None):
    if delta is None and target is None:
        delta = 1
    if delta is not None and target is not None:
        raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
    degree = self.get_degree()

    if delta is None:
        delta = target - degree
        if delta &lt; 0:
            raise Exception(f&#34;Curve already has degree {degree}, which is greater than target {target}&#34;)
    if delta == 0:
        return self

    points = elevate_bezier_degree(3, self.get_control_points(), delta)
    return SvBezierCurve(points)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.extrude_along_vector"><code class="name flex">
<span>def <span class="ident">extrude_along_vector</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrude_along_vector(self, vector):
    return self.to_nurbs().extrude_along_vector(vector)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.extrude_to_point"><code class="name flex">
<span>def <span class="ident">extrude_to_point</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrude_to_point(self, point):
    return self.to_nurbs().extrude_to_point(point)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.get_bounding_box"><code class="name flex">
<span>def <span class="ident">get_bounding_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounding_box(self):
    return bounding_box(self.get_control_points())</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.get_end_points"><code class="name flex">
<span>def <span class="ident">get_end_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_points(self):
    return self.p0, self.p3</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.get_plane"><code class="name flex">
<span>def <span class="ident">get_plane</span></span>(<span>self, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_plane(self, tolerance=1e-6):
    plane = PlaneEquation.from_three_points(self.p0, self.p1, self.p2)
    if plane.distance_to_point(self.p3) &lt; tolerance:
        return plane
    else:
        return None</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.is_line"><code class="name flex">
<span>def <span class="ident">is_line</span></span>(<span>self, tolerance=0.001)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_line(self, tolerance=0.001):
    begin, end = self.p0, self.p3
    # direction from first to last point of the curve
    direction = end - begin
    if np.linalg.norm(direction) &lt; tolerance:
        return True
    line = LineEquation.from_direction_and_point(direction, begin)
    distances = line.distance_to_points([self.p1, self.p2])
    # Technically, this means that all control points lie
    # inside the cylinder, defined as &#34;distance from line &lt; tolerance&#34;;
    # As a consequence, the convex hull of control points lie in the
    # same cylinder; and the curve lies in that convex hull.
    return (distances &lt; tolerance).all()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.is_planar"><code class="name flex">
<span>def <span class="ident">is_planar</span></span>(<span>self, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_planar(self, tolerance=1e-6):
    plane = PlaneEquation.from_three_points(self.p0, self.p1, self.p2)
    return plane.distance_to_point(self.p3) &lt; tolerance</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.is_rational"><code class="name flex">
<span>def <span class="ident">is_rational</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_rational(self):
    return False</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.lerp_to"><code class="name flex">
<span>def <span class="ident">lerp_to</span></span>(<span>self, curve2, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lerp_to(self, curve2, coefficient):
    if isinstance(curve2, SvCubicBezierCurve):
        p0 = (1.0 - coefficient) * self.p0 + coefficient * curve2.p0
        p1 = (1.0 - coefficient) * self.p1 + coefficient * curve2.p1
        p2 = (1.0 - coefficient) * self.p2 + coefficient * curve2.p2
        p3 = (1.0 - coefficient) * self.p3 + coefficient * curve2.p3
        return SvCubicBezierCurve(p0, p1, p2, p3)
    return self.to_nurbs().lerp_to(curve2, coefficient)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.make_revolution_surface"><code class="name flex">
<span>def <span class="ident">make_revolution_surface</span></span>(<span>self, point, direction, v_min, v_max, global_origin)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_revolution_surface(self, point, direction, v_min, v_max, global_origin):
    return self.to_nurbs().make_revolution_surface(point, direction, v_min, v_max, global_origin)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.make_ruled_surface"><code class="name flex">
<span>def <span class="ident">make_ruled_surface</span></span>(<span>self, curve2, vmin, vmax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_ruled_surface(self, curve2, vmin, vmax):
    return self.to_nurbs().make_ruled_surface(curve2, vmin, vmax)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.reparametrize"><code class="name flex">
<span>def <span class="ident">reparametrize</span></span>(<span>self, new_t_min, new_t_max)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparametrize(self, new_t_min, new_t_max):
    return self.to_nurbs().reparametrize(new_t_min, new_t_max)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    return SvCubicBezierCurve(self.p3, self.p2, self.p1, self.p0)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.second_derivative"><code class="name flex">
<span>def <span class="ident">second_derivative</span></span>(<span>self, t, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative(self, t, tangent_delta=None):
    return self.second_derivative_array(np.array([t]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.second_derivative_array"><code class="name flex">
<span>def <span class="ident">second_derivative_array</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative_array(self, ts):
    c0 = 6*(1-ts)
    c1 = 6*ts - 12*(1-ts)
    c2 = 6*(1-ts) - 12*ts
    c3 = 6*ts
    c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]
    p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3

    return c0*p0 + c1*p1 + c2*p2 + c3*p3</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.third_derivative_array"><code class="name flex">
<span>def <span class="ident">third_derivative_array</span></span>(<span>self, ts, tangent_delta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def third_derivative_array(self, ts, tangent_delta=None):
    c0 = np.full_like(ts, -6)[:,np.newaxis]
    c1 = np.full_like(ts, 18)[:,np.newaxis]
    c2 = np.full_like(ts, -18)[:,np.newaxis]
    c3 = np.full_like(ts, 6)[:,np.newaxis]
    p0, p1, p2, p3 = self.p0, self.p1, self.p2, self.p3
    return c0*p0 + c1*p1 + c2*p2 + c3*p3</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.to_bezier"><code class="name flex">
<span>def <span class="ident">to_bezier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bezier(self):
    return self</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.to_bezier_segments"><code class="name flex">
<span>def <span class="ident">to_bezier_segments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bezier_segments(self):
    return [self]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.curve.bezier.SvCubicBezierCurve.to_nurbs"><code class="name flex">
<span>def <span class="ident">to_nurbs</span></span>(<span>self, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_nurbs(self, implementation = SvNurbsMaths.NATIVE):
    knotvector = sv_knotvector.generate(3, 4)
    control_points = np.array([self.p0, self.p1, self.p2, self.p3])
    return SvNurbsMaths.build_curve(implementation,
            degree = 3, knotvector = knotvector,
            control_points = control_points)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.curve.core.SvCurve" href="core.html#sverchok.utils.curve.core.SvCurve">SvCurve</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.curve.core.SvCurve.calc_length" href="core.html#sverchok.utils.curve.core.SvCurve.calc_length">calc_length</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.evaluate_array" href="core.html#sverchok.utils.curve.core.SvCurve.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.frame_array">frame_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_control_points" href="core.html#sverchok.utils.curve.core.SvCurve.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_degree" href="core.html#sverchok.utils.curve.core.SvCurve.get_degree">get_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_tangent_delta" href="core.html#sverchok.utils.curve.core.SvCurve.get_tangent_delta">get_tangent_delta</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.get_u_bounds" href="core.html#sverchok.utils.curve.core.SvCurve.get_u_bounds">get_u_bounds</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent" href="core.html#sverchok.utils.curve.core.SvCurve.tangent">tangent</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.tangent_array" href="core.html#sverchok.utils.curve.core.SvCurve.tangent_array">tangent_array</a></code></li>
<li><code><a title="sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array" href="core.html#sverchok.utils.curve.core.SvCurve.zero_torsion_frame_array">zero_torsion_frame_array</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.curve" href="index.html">sverchok.utils.curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.curve.bezier.SvBezierCurve" href="#sverchok.utils.curve.bezier.SvBezierCurve">SvBezierCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.blend_second_derivatives" href="#sverchok.utils.curve.bezier.SvBezierCurve.blend_second_derivatives">blend_second_derivatives</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.blend_third_derivatives" href="#sverchok.utils.curve.bezier.SvBezierCurve.blend_third_derivatives">blend_third_derivatives</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.build_tangent_curve" href="#sverchok.utils.curve.bezier.SvBezierCurve.build_tangent_curve">build_tangent_curve</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.coeff" href="#sverchok.utils.curve.bezier.SvBezierCurve.coeff">coeff</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv1" href="#sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv1">coeff_deriv1</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv2" href="#sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv2">coeff_deriv2</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv3" href="#sverchok.utils.curve.bezier.SvBezierCurve.coeff_deriv3">coeff_deriv3</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.coefficient" href="#sverchok.utils.curve.bezier.SvBezierCurve.coefficient">coefficient</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.concatenate" href="#sverchok.utils.curve.bezier.SvBezierCurve.concatenate">concatenate</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.derivatives_array" href="#sverchok.utils.curve.bezier.SvBezierCurve.derivatives_array">derivatives_array</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.elevate_degree" href="#sverchok.utils.curve.bezier.SvBezierCurve.elevate_degree">elevate_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.extrude_along_vector" href="#sverchok.utils.curve.bezier.SvBezierCurve.extrude_along_vector">extrude_along_vector</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.extrude_to_point" href="#sverchok.utils.curve.bezier.SvBezierCurve.extrude_to_point">extrude_to_point</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.from_control_points" href="#sverchok.utils.curve.bezier.SvBezierCurve.from_control_points">from_control_points</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.from_points_and_tangents" href="#sverchok.utils.curve.bezier.SvBezierCurve.from_points_and_tangents">from_points_and_tangents</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.from_tangents_normals_curvatures" href="#sverchok.utils.curve.bezier.SvBezierCurve.from_tangents_normals_curvatures">from_tangents_normals_curvatures</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.get_bounding_box" href="#sverchok.utils.curve.bezier.SvBezierCurve.get_bounding_box">get_bounding_box</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.get_end_points" href="#sverchok.utils.curve.bezier.SvBezierCurve.get_end_points">get_end_points</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.get_plane" href="#sverchok.utils.curve.bezier.SvBezierCurve.get_plane">get_plane</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.interpolate" href="#sverchok.utils.curve.bezier.SvBezierCurve.interpolate">interpolate</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.is_line" href="#sverchok.utils.curve.bezier.SvBezierCurve.is_line">is_line</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.is_planar" href="#sverchok.utils.curve.bezier.SvBezierCurve.is_planar">is_planar</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.is_rational" href="#sverchok.utils.curve.bezier.SvBezierCurve.is_rational">is_rational</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.lerp_to" href="#sverchok.utils.curve.bezier.SvBezierCurve.lerp_to">lerp_to</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.make_revolution_surface" href="#sverchok.utils.curve.bezier.SvBezierCurve.make_revolution_surface">make_revolution_surface</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.make_ruled_surface" href="#sverchok.utils.curve.bezier.SvBezierCurve.make_ruled_surface">make_ruled_surface</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.reparametrize" href="#sverchok.utils.curve.bezier.SvBezierCurve.reparametrize">reparametrize</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.reverse" href="#sverchok.utils.curve.bezier.SvBezierCurve.reverse">reverse</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.second_derivative" href="#sverchok.utils.curve.bezier.SvBezierCurve.second_derivative">second_derivative</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.second_derivative_array" href="#sverchok.utils.curve.bezier.SvBezierCurve.second_derivative_array">second_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.third_derivative_array" href="#sverchok.utils.curve.bezier.SvBezierCurve.third_derivative_array">third_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.to_bezier" href="#sverchok.utils.curve.bezier.SvBezierCurve.to_bezier">to_bezier</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.to_bezier_segments" href="#sverchok.utils.curve.bezier.SvBezierCurve.to_bezier_segments">to_bezier_segments</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierCurve.to_nurbs" href="#sverchok.utils.curve.bezier.SvBezierCurve.to_nurbs">to_nurbs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.bezier.SvBezierSplitMixin" href="#sverchok.utils.curve.bezier.SvBezierSplitMixin">SvBezierSplitMixin</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.bezier.SvBezierSplitMixin.cut_segment" href="#sverchok.utils.curve.bezier.SvBezierSplitMixin.cut_segment">cut_segment</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierSplitMixin.de_casteljau_points" href="#sverchok.utils.curve.bezier.SvBezierSplitMixin.de_casteljau_points">de_casteljau_points</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvBezierSplitMixin.split_at" href="#sverchok.utils.curve.bezier.SvBezierSplitMixin.split_at">split_at</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve">SvCubicBezierCurve</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.concatenate" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.concatenate">concatenate</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.derivatives_array" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.derivatives_array">derivatives_array</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.elevate_degree" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.elevate_degree">elevate_degree</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.extrude_along_vector" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.extrude_along_vector">extrude_along_vector</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.extrude_to_point" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.extrude_to_point">extrude_to_point</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.from_four_points" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.from_four_points">from_four_points</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.get_bounding_box" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.get_bounding_box">get_bounding_box</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.get_end_points" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.get_end_points">get_end_points</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.get_plane" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.get_plane">get_plane</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.is_line" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.is_line">is_line</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.is_planar" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.is_planar">is_planar</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.is_rational" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.is_rational">is_rational</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.lerp_to" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.lerp_to">lerp_to</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.make_revolution_surface" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.make_revolution_surface">make_revolution_surface</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.make_ruled_surface" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.make_ruled_surface">make_ruled_surface</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.reparametrize" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.reparametrize">reparametrize</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.reverse" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.reverse">reverse</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.second_derivative" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.second_derivative">second_derivative</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.second_derivative_array" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.second_derivative_array">second_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.third_derivative_array" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.third_derivative_array">third_derivative_array</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.to_bezier" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.to_bezier">to_bezier</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.to_bezier_segments" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.to_bezier_segments">to_bezier_segments</a></code></li>
<li><code><a title="sverchok.utils.curve.bezier.SvCubicBezierCurve.to_nurbs" href="#sverchok.utils.curve.bezier.SvCubicBezierCurve.to_nurbs">to_nurbs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>