<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.vectorize API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.vectorize</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from functools import wraps
from typing import List, Tuple

import numpy as np

from mathutils import Matrix

from sverchok.data_structure import levels_of_list_or_np


SvVerts = List[Tuple[float, float, float]]
SvEdges = List[Tuple[int, int]]
SvPolys = List[List[int]]


def vectorize(func=None, *, match_mode=&#34;REPEAT&#34;):
    &#34;&#34;&#34;
    If there is function which takes some values
    with this decorator it&#39;s possible to call the function by passing list of values of any shape
    Take care of properly annotating of decorated function
    Use Tuple[] in return annotation only if you want the decorator splits the return values into different lists

    ++ Example ++

    from sverchok.utils import vectorize

    def main_node_logic(*, prop_a: List[float], prop_b: Matrix, mode_a: str) -&gt; Tuple[list, list]:
        ...
        return data1, data2

    class MyNode:
        ...
        def process(self):
            input_a = self.inputs[0].sv_get(default=None)
            input_b = self.inputs[1].sv_get(default=None)

            main_node_logic = vectorize(main_node_logic, match_mode=self.match_mode)
            out1, out2 = main_node_logic(input_a, input_b, mode_a = self.mode_a)

            self.outputs[0].sv_set(out1)
            self.outputs[1].sv_set(out2)
    &#34;&#34;&#34;

    # this condition only works when used via &#34;@&#34; syntax
    if func is None:
        return lambda f: vectorize(f, match_mode=match_mode)

    @wraps(func)
    def wrap(*args, **kwargs):

        # it&#39;s better not to use positional arguments for backward compatibility
        # in this case a function can get new arguments
        if args:
            raise TypeError(f&#39;Vectorized function {func.__name__} should not have positional arguments&#39;)

        walkers = []
        for key, data in zip(kwargs, kwargs.values()):
            if data is None or data == []:
                walkers.append(EmptyDataWalker(data, key))
            else:
                annotation = func.__annotations__.get(key)
                nesting_level = _get_nesting_level(annotation) if annotation else 0
                walkers.append(DataWalker(data, output_nesting=nesting_level, mode=match_mode, data_name=key))

        # this is corner case, it can&#39;t be handled via walk data iterator
        if all([w.what_is_next() == DataWalker.VALUE for w in walkers]):
            return func(*args, **kwargs)

        out_number = _get_output_number(func)

        # handle case when return value of decorated function is simple one value
        if out_number == 1:
            out_list = []
            for match_args, result in walk_data(walkers, [out_list]):
                match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
                match_kwargs = {n: d for n, d in zip(kwargs, match_kwargs)}
                func_out = func(*match_args, **match_kwargs)
                if not is_empty_out(func_out):
                    result[0].append(func_out)
            return out_list

        # the case when return value is tuple of multiple values
        else:
            out_lists = [[] for _ in range(out_number)]
            for match_args, result in walk_data(walkers, out_lists):
                match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
                match_kwargs = {n: d for n, d in zip(kwargs, match_kwargs)}
                func_out = func(*match_args, **match_kwargs)
                [r.append(out) for r, out in zip(result, func_out) if not is_empty_out(out)]
            return out_lists

    def is_empty_out(value):
        if value is None:
            return True
        try:
            return not bool(len(value))
        except TypeError:
            return False

    return wrap


def devectorize(func=None, *, match_mode=&#34;REPEAT&#34;):
    &#34;&#34;&#34;It takes list of values of arbitrary shape, flatten it
    and call the decorated function once with flattened data
    This needs for functions (nodes) which breaks vectorization&#34;&#34;&#34;

    # this condition only works when used via &#34;@&#34; syntax
    if func is None:
        return lambda f: vectorize(f, match_mode=match_mode)

    @wraps(func)
    def wrap(*args, **kwargs):

        # it&#39;s better not to use positional arguments for backward compatibility
        # in this case a function can get new arguments
        if args:
            raise TypeError(f&#39;Vectorized function {func.__name__} should not have positional arguments&#39;)

        walkers = []
        for key, data in zip(kwargs, kwargs.values()):
            if data is None or data == []:
                walkers.append(EmptyDataWalker(data, key))
            else:
                annotation = func.__annotations__.get(key)
                nesting_level = _get_nesting_level(annotation) if annotation else 0
                walkers.append(DataWalker(data, output_nesting=nesting_level - 1, mode=match_mode, data_name=key))

        flat_data = {key: [] for key in kwargs}
        for match_args, _ in walk_data(walkers, []):
            match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
            [container.append(data) for container, data in zip(flat_data.values(), match_kwargs)]

        return func(**flat_data)

    return wrap


def _get_nesting_level(annotation) -&gt; int:
    &#34;&#34;&#34;It measures how many nested types the annotation has
    simple annotations like string, float have 0 level
    list without arguments gives 1 level
    List[list] such thing returns 2 level&#34;&#34;&#34;
    if not hasattr(annotation, &#39;__origin__&#39;):
        if annotation in [list, tuple]:
            return 1
        elif annotation in [float, int, bool, Matrix, str]:
            return 0

    elif annotation.__origin__ is list:
        return 1 + _get_nesting_level(annotation.__args__[0])
    elif annotation.__origin__ is tuple:
        # not sure how this should act if arguments of the tuple have different level of nesting
        return 1 + max([_get_nesting_level(arg) for arg in annotation.__args__])

    raise NotImplementedError(f&#39;Given annotation: {annotation} is not supported yet&#39;)


def _get_output_number(function):
    &#34;&#34;&#34;Returns number of arguments returning by given function
    the function should have returning annotation with Tuple value - Tuple[list, list]&#34;&#34;&#34;
    annotation = function.__annotations__.get(&#39;return&#39;)
    if annotation:
        if hasattr(annotation, &#39;__origin__&#39;) and annotation.__origin__ == tuple:
            if hasattr(annotation, &#39;__args__&#39;):
                return len(annotation.__args__)
    return 1


def _what_is_next_catch(func):
    &#34;&#34;&#34;It&#39;s exclusively for using in DataWalker class for optimization performance&#34;&#34;&#34;

    @wraps(func)
    def what_is_next_catcher(self):
        next_val_id = id(self._stack[-1])
        if next_val_id not in self._catch:
            # this should not conflict with float, string, integer and other values
            self._catch[next_val_id] = func(self)
        return self._catch[next_val_id]

    return what_is_next_catcher


class DataWalker:
    &#34;&#34;&#34;This class allows walk over a list of arbitrary shape like over a tree data structure
    Input data can be a value or list
    the list can include values and / or other lists
    the value itself can be just a number, list of numbers, list of list of numbers etc.
    values should be consistent and should not include other values
    for example inside list of vertices there should be other lists of vertices or any thing else
    there is no way of handling such data structure efficiently&#34;&#34;&#34;

    # match modes
    SHORT, CYCLE, REPEAT, XREF, XREF2 = &#34;SHORT&#34;, &#34;CYCLE&#34;, &#34;REPEAT&#34;, &#34;XREF&#34;, &#34;XREF2&#34;

    # node types
    VALUE, END, SUB_TREE = &#34;VALUE&#34;, &#34;END&#34;, &#34;SUB_TREE&#34;

    EXIT_VALUE = type(&#39;ExitValue&#39;, (), {&#39;__repr__&#39;: lambda s: &#34;&lt;ExitValue&gt;&#34;})()

    def __init__(self, data, output_nesting=0, mode=REPEAT, data_name=None):
        self.match_mode = mode

        self._stack = [data]
        self._output_nesting = output_nesting
        self._name = data_name

        self._catch = dict()  # for optimization

    def step_down_matching(self, match_len, match_mode):
        # todo protection from little nesting
        if self.what_is_next() == DataWalker.SUB_TREE:
            current_node = self._stack.pop()
        elif self.what_is_next() == DataWalker.VALUE:
            current_node = [self._stack.pop()]
        else:
            raise RuntimeError(f&#39;Step down is impossible current position is: {self._stack[-1]}&#39;)

        self._stack.append(DataWalker.EXIT_VALUE)
        self._stack.extend(list(reversed(self._match_values(current_node, match_len, match_mode))))

    def step_up(self):
        if self.what_is_next() != DataWalker.END:
            raise RuntimeError(f&#39;There are still values to read: {self._stack}&#39;)
        self._stack.pop()

    def pop_next_value(self):
        return self._stack.pop()

    # this method is used most extensively
    @_what_is_next_catch
    def what_is_next(self):
        if self._stack[-1] is DataWalker.EXIT_VALUE:
            return DataWalker.END
        if isinstance(self._stack[-1], (list, tuple, np.ndarray)):
            nesting = levels_of_list_or_np(self._stack[-1])
        else:
            nesting = 0
        if nesting == self._output_nesting:
            return DataWalker.VALUE
        else:  # todo add the case when next element has too less nested levels
            return DataWalker.SUB_TREE

    @property
    def next_values_number(self):
        try:
            if self.what_is_next() == DataWalker.VALUE:
                return 1
            last = self._stack[-1]
            return len(last)
        except (IndexError, TypeError):
            return 0

    @property
    def is_exhausted(self):
        return not bool(self._stack)

    @staticmethod
    def _match_values(data, match_len, match_mode):
        if len(data) &gt; match_len:
            return data[:match_len]
        elif len(data) == match_len:
            return data
        else:
            if match_mode == DataWalker.REPEAT:
                return list(data) + [data[-1]] * (match_len - len(data))  # todo deepcopy ??
            # todo add other modes

    def __repr__(self):
        return f&#34;&lt;DataWalker {self._name if self._name else &#39;data&#39;}: {self._stack}&gt;&#34;


class EmptyDataWalker:
    &#34;&#34;&#34;Use this (instead of DataWalker) if a channel does not has any data
    It is needed not to overcomplicate logic of DataWalker&#34;&#34;&#34;

    def __init__(self, data=None, data_name=None):
        self._data = data
        self._name = data_name

    def step_down_matching(self, *_, **__):
        pass

    def step_up(self):
        pass

    def pop_next_value(self):
        return self._data

    def what_is_next(self):
        return DataWalker.VALUE

    @property
    def next_values_number(self):
        return 0

    @property
    def is_exhausted(self):
        return True

    def __repr__(self):
        return f&#34;&lt;EmptyDataWalker {self._name if self._name else &#39;data&#39;}: {self._data}&gt;&#34;


class ListTreeGenerator:
    &#34;&#34;&#34;Generates tree from nested lists with step up/down interface&#34;&#34;&#34;
    def __init__(self, root_list):
        self.data = root_list
        self._stack = [root_list]

    def step_down(self):
        new_node = []
        self._stack.append(new_node)

    def step_up(self):
        last_node = self._stack.pop()
        if last_node and self._stack:
            current_node = self._stack[-1]
            current_node.append(last_node)

    @property
    def current_list(self):
        return self._stack[-1]

    def __repr__(self):
        return f&#39;&lt;TreeGen data: {self.data}&gt;&#39;


def walk_data(walkers: List[DataWalker], out_list: List[list]) -&gt; Tuple[list, List[list]]:
    &#34;&#34;&#34;It walks over data in given walkers in proper order
    match data between each other if necessary
    and gives output containers where to put result of handled data&#34;&#34;&#34;
    match_mode = DataWalker.REPEAT  # todo should be determined by modes of input walkers
    result_data = [ListTreeGenerator(l) for l in out_list]

    # first step is always step down because walkers create extra wrapping list (for the algorithm simplicity)
    max_value_len = max(w.next_values_number for w in walkers)
    [w.step_down_matching(max_value_len, match_mode) for w in walkers]

    while any(not w.is_exhausted for w in walkers):
        if all(w.what_is_next() == DataWalker.VALUE for w in walkers):
            yield [w.pop_next_value() for w in walkers], [t.current_list for t in result_data]
        elif any(w.what_is_next() == DataWalker.END for w in walkers):
            [w.step_up() for w in walkers]
            [t.step_up() for t in result_data]
        elif any(w.what_is_next() == DataWalker.SUB_TREE for w in walkers):
            max_value_len = max(w.next_values_number for w in walkers)
            [w.step_down_matching(max_value_len, match_mode) for w in walkers]
            [t.step_down() for t in result_data]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.vectorize.devectorize"><code class="name flex">
<span>def <span class="ident">devectorize</span></span>(<span>func=None, *, match_mode='REPEAT')</span>
</code></dt>
<dd>
<div class="desc"><p>It takes list of values of arbitrary shape, flatten it
and call the decorated function once with flattened data
This needs for functions (nodes) which breaks vectorization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def devectorize(func=None, *, match_mode=&#34;REPEAT&#34;):
    &#34;&#34;&#34;It takes list of values of arbitrary shape, flatten it
    and call the decorated function once with flattened data
    This needs for functions (nodes) which breaks vectorization&#34;&#34;&#34;

    # this condition only works when used via &#34;@&#34; syntax
    if func is None:
        return lambda f: vectorize(f, match_mode=match_mode)

    @wraps(func)
    def wrap(*args, **kwargs):

        # it&#39;s better not to use positional arguments for backward compatibility
        # in this case a function can get new arguments
        if args:
            raise TypeError(f&#39;Vectorized function {func.__name__} should not have positional arguments&#39;)

        walkers = []
        for key, data in zip(kwargs, kwargs.values()):
            if data is None or data == []:
                walkers.append(EmptyDataWalker(data, key))
            else:
                annotation = func.__annotations__.get(key)
                nesting_level = _get_nesting_level(annotation) if annotation else 0
                walkers.append(DataWalker(data, output_nesting=nesting_level - 1, mode=match_mode, data_name=key))

        flat_data = {key: [] for key in kwargs}
        for match_args, _ in walk_data(walkers, []):
            match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
            [container.append(data) for container, data in zip(flat_data.values(), match_kwargs)]

        return func(**flat_data)

    return wrap</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.vectorize"><code class="name flex">
<span>def <span class="ident">vectorize</span></span>(<span>func=None, *, match_mode='REPEAT')</span>
</code></dt>
<dd>
<div class="desc"><p>If there is function which takes some values
with this decorator it's possible to call the function by passing list of values of any shape
Take care of properly annotating of decorated function
Use Tuple[] in return annotation only if you want the decorator splits the return values into different lists</p>
<p>++ Example ++</p>
<p>from sverchok.utils import vectorize</p>
<p>def main_node_logic(*, prop_a: List[float], prop_b: Matrix, mode_a: str) -&gt; Tuple[list, list]:
&hellip;
return data1, data2</p>
<p>class MyNode:
&hellip;
def process(self):
input_a = self.inputs[0].sv_get(default=None)
input_b = self.inputs[1].sv_get(default=None)</p>
<pre><code>    main_node_logic = vectorize(main_node_logic, match_mode=self.match_mode)
    out1, out2 = main_node_logic(input_a, input_b, mode_a = self.mode_a)

    self.outputs[0].sv_set(out1)
    self.outputs[1].sv_set(out2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectorize(func=None, *, match_mode=&#34;REPEAT&#34;):
    &#34;&#34;&#34;
    If there is function which takes some values
    with this decorator it&#39;s possible to call the function by passing list of values of any shape
    Take care of properly annotating of decorated function
    Use Tuple[] in return annotation only if you want the decorator splits the return values into different lists

    ++ Example ++

    from sverchok.utils import vectorize

    def main_node_logic(*, prop_a: List[float], prop_b: Matrix, mode_a: str) -&gt; Tuple[list, list]:
        ...
        return data1, data2

    class MyNode:
        ...
        def process(self):
            input_a = self.inputs[0].sv_get(default=None)
            input_b = self.inputs[1].sv_get(default=None)

            main_node_logic = vectorize(main_node_logic, match_mode=self.match_mode)
            out1, out2 = main_node_logic(input_a, input_b, mode_a = self.mode_a)

            self.outputs[0].sv_set(out1)
            self.outputs[1].sv_set(out2)
    &#34;&#34;&#34;

    # this condition only works when used via &#34;@&#34; syntax
    if func is None:
        return lambda f: vectorize(f, match_mode=match_mode)

    @wraps(func)
    def wrap(*args, **kwargs):

        # it&#39;s better not to use positional arguments for backward compatibility
        # in this case a function can get new arguments
        if args:
            raise TypeError(f&#39;Vectorized function {func.__name__} should not have positional arguments&#39;)

        walkers = []
        for key, data in zip(kwargs, kwargs.values()):
            if data is None or data == []:
                walkers.append(EmptyDataWalker(data, key))
            else:
                annotation = func.__annotations__.get(key)
                nesting_level = _get_nesting_level(annotation) if annotation else 0
                walkers.append(DataWalker(data, output_nesting=nesting_level, mode=match_mode, data_name=key))

        # this is corner case, it can&#39;t be handled via walk data iterator
        if all([w.what_is_next() == DataWalker.VALUE for w in walkers]):
            return func(*args, **kwargs)

        out_number = _get_output_number(func)

        # handle case when return value of decorated function is simple one value
        if out_number == 1:
            out_list = []
            for match_args, result in walk_data(walkers, [out_list]):
                match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
                match_kwargs = {n: d for n, d in zip(kwargs, match_kwargs)}
                func_out = func(*match_args, **match_kwargs)
                if not is_empty_out(func_out):
                    result[0].append(func_out)
            return out_list

        # the case when return value is tuple of multiple values
        else:
            out_lists = [[] for _ in range(out_number)]
            for match_args, result in walk_data(walkers, out_lists):
                match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
                match_kwargs = {n: d for n, d in zip(kwargs, match_kwargs)}
                func_out = func(*match_args, **match_kwargs)
                [r.append(out) for r, out in zip(result, func_out) if not is_empty_out(out)]
            return out_lists

    def is_empty_out(value):
        if value is None:
            return True
        try:
            return not bool(len(value))
        except TypeError:
            return False

    return wrap</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.walk_data"><code class="name flex">
<span>def <span class="ident">walk_data</span></span>(<span>walkers: List[<a title="sverchok.utils.vectorize.DataWalker" href="#sverchok.utils.vectorize.DataWalker">DataWalker</a>], out_list: List[list]) ‑> Tuple[list, List[list]]</span>
</code></dt>
<dd>
<div class="desc"><p>It walks over data in given walkers in proper order
match data between each other if necessary
and gives output containers where to put result of handled data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_data(walkers: List[DataWalker], out_list: List[list]) -&gt; Tuple[list, List[list]]:
    &#34;&#34;&#34;It walks over data in given walkers in proper order
    match data between each other if necessary
    and gives output containers where to put result of handled data&#34;&#34;&#34;
    match_mode = DataWalker.REPEAT  # todo should be determined by modes of input walkers
    result_data = [ListTreeGenerator(l) for l in out_list]

    # first step is always step down because walkers create extra wrapping list (for the algorithm simplicity)
    max_value_len = max(w.next_values_number for w in walkers)
    [w.step_down_matching(max_value_len, match_mode) for w in walkers]

    while any(not w.is_exhausted for w in walkers):
        if all(w.what_is_next() == DataWalker.VALUE for w in walkers):
            yield [w.pop_next_value() for w in walkers], [t.current_list for t in result_data]
        elif any(w.what_is_next() == DataWalker.END for w in walkers):
            [w.step_up() for w in walkers]
            [t.step_up() for t in result_data]
        elif any(w.what_is_next() == DataWalker.SUB_TREE for w in walkers):
            max_value_len = max(w.next_values_number for w in walkers)
            [w.step_down_matching(max_value_len, match_mode) for w in walkers]
            [t.step_down() for t in result_data]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker"><code class="flex name class">
<span>class <span class="ident">DataWalker</span></span>
<span>(</span><span>data, output_nesting=0, mode='REPEAT', data_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class allows walk over a list of arbitrary shape like over a tree data structure
Input data can be a value or list
the list can include values and / or other lists
the value itself can be just a number, list of numbers, list of list of numbers etc.
values should be consistent and should not include other values
for example inside list of vertices there should be other lists of vertices or any thing else
there is no way of handling such data structure efficiently</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataWalker:
    &#34;&#34;&#34;This class allows walk over a list of arbitrary shape like over a tree data structure
    Input data can be a value or list
    the list can include values and / or other lists
    the value itself can be just a number, list of numbers, list of list of numbers etc.
    values should be consistent and should not include other values
    for example inside list of vertices there should be other lists of vertices or any thing else
    there is no way of handling such data structure efficiently&#34;&#34;&#34;

    # match modes
    SHORT, CYCLE, REPEAT, XREF, XREF2 = &#34;SHORT&#34;, &#34;CYCLE&#34;, &#34;REPEAT&#34;, &#34;XREF&#34;, &#34;XREF2&#34;

    # node types
    VALUE, END, SUB_TREE = &#34;VALUE&#34;, &#34;END&#34;, &#34;SUB_TREE&#34;

    EXIT_VALUE = type(&#39;ExitValue&#39;, (), {&#39;__repr__&#39;: lambda s: &#34;&lt;ExitValue&gt;&#34;})()

    def __init__(self, data, output_nesting=0, mode=REPEAT, data_name=None):
        self.match_mode = mode

        self._stack = [data]
        self._output_nesting = output_nesting
        self._name = data_name

        self._catch = dict()  # for optimization

    def step_down_matching(self, match_len, match_mode):
        # todo protection from little nesting
        if self.what_is_next() == DataWalker.SUB_TREE:
            current_node = self._stack.pop()
        elif self.what_is_next() == DataWalker.VALUE:
            current_node = [self._stack.pop()]
        else:
            raise RuntimeError(f&#39;Step down is impossible current position is: {self._stack[-1]}&#39;)

        self._stack.append(DataWalker.EXIT_VALUE)
        self._stack.extend(list(reversed(self._match_values(current_node, match_len, match_mode))))

    def step_up(self):
        if self.what_is_next() != DataWalker.END:
            raise RuntimeError(f&#39;There are still values to read: {self._stack}&#39;)
        self._stack.pop()

    def pop_next_value(self):
        return self._stack.pop()

    # this method is used most extensively
    @_what_is_next_catch
    def what_is_next(self):
        if self._stack[-1] is DataWalker.EXIT_VALUE:
            return DataWalker.END
        if isinstance(self._stack[-1], (list, tuple, np.ndarray)):
            nesting = levels_of_list_or_np(self._stack[-1])
        else:
            nesting = 0
        if nesting == self._output_nesting:
            return DataWalker.VALUE
        else:  # todo add the case when next element has too less nested levels
            return DataWalker.SUB_TREE

    @property
    def next_values_number(self):
        try:
            if self.what_is_next() == DataWalker.VALUE:
                return 1
            last = self._stack[-1]
            return len(last)
        except (IndexError, TypeError):
            return 0

    @property
    def is_exhausted(self):
        return not bool(self._stack)

    @staticmethod
    def _match_values(data, match_len, match_mode):
        if len(data) &gt; match_len:
            return data[:match_len]
        elif len(data) == match_len:
            return data
        else:
            if match_mode == DataWalker.REPEAT:
                return list(data) + [data[-1]] * (match_len - len(data))  # todo deepcopy ??
            # todo add other modes

    def __repr__(self):
        return f&#34;&lt;DataWalker {self._name if self._name else &#39;data&#39;}: {self._stack}&gt;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker.CYCLE"><code class="name">var <span class="ident">CYCLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.EXIT_VALUE"><code class="name">var <span class="ident">EXIT_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.REPEAT"><code class="name">var <span class="ident">REPEAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.SHORT"><code class="name">var <span class="ident">SHORT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.SUB_TREE"><code class="name">var <span class="ident">SUB_TREE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.VALUE"><code class="name">var <span class="ident">VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.XREF"><code class="name">var <span class="ident">XREF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.XREF2"><code class="name">var <span class="ident">XREF2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker.is_exhausted"><code class="name">var <span class="ident">is_exhausted</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_exhausted(self):
    return not bool(self._stack)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.next_values_number"><code class="name">var <span class="ident">next_values_number</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next_values_number(self):
    try:
        if self.what_is_next() == DataWalker.VALUE:
            return 1
        last = self._stack[-1]
        return len(last)
    except (IndexError, TypeError):
        return 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker.pop_next_value"><code class="name flex">
<span>def <span class="ident">pop_next_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_next_value(self):
    return self._stack.pop()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.step_down_matching"><code class="name flex">
<span>def <span class="ident">step_down_matching</span></span>(<span>self, match_len, match_mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_down_matching(self, match_len, match_mode):
    # todo protection from little nesting
    if self.what_is_next() == DataWalker.SUB_TREE:
        current_node = self._stack.pop()
    elif self.what_is_next() == DataWalker.VALUE:
        current_node = [self._stack.pop()]
    else:
        raise RuntimeError(f&#39;Step down is impossible current position is: {self._stack[-1]}&#39;)

    self._stack.append(DataWalker.EXIT_VALUE)
    self._stack.extend(list(reversed(self._match_values(current_node, match_len, match_mode))))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.step_up"><code class="name flex">
<span>def <span class="ident">step_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_up(self):
    if self.what_is_next() != DataWalker.END:
        raise RuntimeError(f&#39;There are still values to read: {self._stack}&#39;)
    self._stack.pop()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.what_is_next"><code class="name flex">
<span>def <span class="ident">what_is_next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_what_is_next_catch
def what_is_next(self):
    if self._stack[-1] is DataWalker.EXIT_VALUE:
        return DataWalker.END
    if isinstance(self._stack[-1], (list, tuple, np.ndarray)):
        nesting = levels_of_list_or_np(self._stack[-1])
    else:
        nesting = 0
    if nesting == self._output_nesting:
        return DataWalker.VALUE
    else:  # todo add the case when next element has too less nested levels
        return DataWalker.SUB_TREE</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker"><code class="flex name class">
<span>class <span class="ident">EmptyDataWalker</span></span>
<span>(</span><span>data=None, data_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Use this (instead of DataWalker) if a channel does not has any data
It is needed not to overcomplicate logic of DataWalker</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyDataWalker:
    &#34;&#34;&#34;Use this (instead of DataWalker) if a channel does not has any data
    It is needed not to overcomplicate logic of DataWalker&#34;&#34;&#34;

    def __init__(self, data=None, data_name=None):
        self._data = data
        self._name = data_name

    def step_down_matching(self, *_, **__):
        pass

    def step_up(self):
        pass

    def pop_next_value(self):
        return self._data

    def what_is_next(self):
        return DataWalker.VALUE

    @property
    def next_values_number(self):
        return 0

    @property
    def is_exhausted(self):
        return True

    def __repr__(self):
        return f&#34;&lt;EmptyDataWalker {self._name if self._name else &#39;data&#39;}: {self._data}&gt;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.is_exhausted"><code class="name">var <span class="ident">is_exhausted</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_exhausted(self):
    return True</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.next_values_number"><code class="name">var <span class="ident">next_values_number</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next_values_number(self):
    return 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.pop_next_value"><code class="name flex">
<span>def <span class="ident">pop_next_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_next_value(self):
    return self._data</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.step_down_matching"><code class="name flex">
<span>def <span class="ident">step_down_matching</span></span>(<span>self, *_, **__)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_down_matching(self, *_, **__):
    pass</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.step_up"><code class="name flex">
<span>def <span class="ident">step_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_up(self):
    pass</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.what_is_next"><code class="name flex">
<span>def <span class="ident">what_is_next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def what_is_next(self):
    return DataWalker.VALUE</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.vectorize.ListTreeGenerator"><code class="flex name class">
<span>class <span class="ident">ListTreeGenerator</span></span>
<span>(</span><span>root_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates tree from nested lists with step up/down interface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListTreeGenerator:
    &#34;&#34;&#34;Generates tree from nested lists with step up/down interface&#34;&#34;&#34;
    def __init__(self, root_list):
        self.data = root_list
        self._stack = [root_list]

    def step_down(self):
        new_node = []
        self._stack.append(new_node)

    def step_up(self):
        last_node = self._stack.pop()
        if last_node and self._stack:
            current_node = self._stack[-1]
            current_node.append(last_node)

    @property
    def current_list(self):
        return self._stack[-1]

    def __repr__(self):
        return f&#39;&lt;TreeGen data: {self.data}&gt;&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.ListTreeGenerator.current_list"><code class="name">var <span class="ident">current_list</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_list(self):
    return self._stack[-1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.vectorize.ListTreeGenerator.step_down"><code class="name flex">
<span>def <span class="ident">step_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_down(self):
    new_node = []
    self._stack.append(new_node)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.vectorize.ListTreeGenerator.step_up"><code class="name flex">
<span>def <span class="ident">step_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_up(self):
    last_node = self._stack.pop()
    if last_node and self._stack:
        current_node = self._stack[-1]
        current_node.append(last_node)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.vectorize.devectorize" href="#sverchok.utils.vectorize.devectorize">devectorize</a></code></li>
<li><code><a title="sverchok.utils.vectorize.vectorize" href="#sverchok.utils.vectorize.vectorize">vectorize</a></code></li>
<li><code><a title="sverchok.utils.vectorize.walk_data" href="#sverchok.utils.vectorize.walk_data">walk_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.vectorize.DataWalker" href="#sverchok.utils.vectorize.DataWalker">DataWalker</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.vectorize.DataWalker.CYCLE" href="#sverchok.utils.vectorize.DataWalker.CYCLE">CYCLE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.END" href="#sverchok.utils.vectorize.DataWalker.END">END</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.EXIT_VALUE" href="#sverchok.utils.vectorize.DataWalker.EXIT_VALUE">EXIT_VALUE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.REPEAT" href="#sverchok.utils.vectorize.DataWalker.REPEAT">REPEAT</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.SHORT" href="#sverchok.utils.vectorize.DataWalker.SHORT">SHORT</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.SUB_TREE" href="#sverchok.utils.vectorize.DataWalker.SUB_TREE">SUB_TREE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.VALUE" href="#sverchok.utils.vectorize.DataWalker.VALUE">VALUE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.XREF" href="#sverchok.utils.vectorize.DataWalker.XREF">XREF</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.XREF2" href="#sverchok.utils.vectorize.DataWalker.XREF2">XREF2</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.is_exhausted" href="#sverchok.utils.vectorize.DataWalker.is_exhausted">is_exhausted</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.next_values_number" href="#sverchok.utils.vectorize.DataWalker.next_values_number">next_values_number</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.pop_next_value" href="#sverchok.utils.vectorize.DataWalker.pop_next_value">pop_next_value</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.step_down_matching" href="#sverchok.utils.vectorize.DataWalker.step_down_matching">step_down_matching</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.step_up" href="#sverchok.utils.vectorize.DataWalker.step_up">step_up</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.what_is_next" href="#sverchok.utils.vectorize.DataWalker.what_is_next">what_is_next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.vectorize.EmptyDataWalker" href="#sverchok.utils.vectorize.EmptyDataWalker">EmptyDataWalker</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.is_exhausted" href="#sverchok.utils.vectorize.EmptyDataWalker.is_exhausted">is_exhausted</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.next_values_number" href="#sverchok.utils.vectorize.EmptyDataWalker.next_values_number">next_values_number</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.pop_next_value" href="#sverchok.utils.vectorize.EmptyDataWalker.pop_next_value">pop_next_value</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.step_down_matching" href="#sverchok.utils.vectorize.EmptyDataWalker.step_down_matching">step_down_matching</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.step_up" href="#sverchok.utils.vectorize.EmptyDataWalker.step_up">step_up</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.what_is_next" href="#sverchok.utils.vectorize.EmptyDataWalker.what_is_next">what_is_next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.vectorize.ListTreeGenerator" href="#sverchok.utils.vectorize.ListTreeGenerator">ListTreeGenerator</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.vectorize.ListTreeGenerator.current_list" href="#sverchok.utils.vectorize.ListTreeGenerator.current_list">current_list</a></code></li>
<li><code><a title="sverchok.utils.vectorize.ListTreeGenerator.step_down" href="#sverchok.utils.vectorize.ListTreeGenerator.step_down">step_down</a></code></li>
<li><code><a title="sverchok.utils.vectorize.ListTreeGenerator.step_up" href="#sverchok.utils.vectorize.ListTreeGenerator.step_up">step_up</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>