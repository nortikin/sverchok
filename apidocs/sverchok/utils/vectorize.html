<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sverchok.utils.vectorize API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.vectorize</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.vectorize.devectorize"><code class="name flex">
<span>def <span class="ident">devectorize</span></span>(<span>func=None, *, match_mode='REPEAT')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def devectorize(func=None, *, match_mode=&#34;REPEAT&#34;):
    &#34;&#34;&#34;It takes list of values of arbitrary shape, flatten it
    and call the decorated function once with flattened data
    This needs for functions (nodes) which breaks vectorization&#34;&#34;&#34;

    # this condition only works when used via &#34;@&#34; syntax
    if func is None:
        return lambda f: vectorize(f, match_mode=match_mode)

    @wraps(func)
    def wrap(*args, **kwargs):

        # it&#39;s better not to use positional arguments for backward compatibility
        # in this case a function can get new arguments
        if args:
            raise TypeError(f&#39;Vectorized function {func.__name__} should not have positional arguments&#39;)

        walkers = []
        for key, data in zip(kwargs, kwargs.values()):
            if data is None or data == []:
                walkers.append(EmptyDataWalker(data, key))
            else:
                annotation = func.__annotations__.get(key)
                nesting_level = _get_nesting_level(annotation) if annotation else 0
                walkers.append(DataWalker(data, output_nesting=nesting_level - 1, mode=match_mode, data_name=key))

        flat_data = {key: [] for key in kwargs}
        for match_args, _ in walk_data(walkers, []):
            match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
            [container.append(data) for container, data in zip(flat_data.values(), match_kwargs)]

        return func(**flat_data)

    return wrap</code></pre>
</details>
<div class="desc"><p>It takes list of values of arbitrary shape, flatten it
and call the decorated function once with flattened data
This needs for functions (nodes) which breaks vectorization</p></div>
</dd>
<dt id="sverchok.utils.vectorize.match_sockets"><code class="name flex">
<span>def <span class="ident">match_sockets</span></span>(<span>*sockets_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_sockets(*sockets_data):
    &#34;&#34;&#34;
    data1 = [[1,2,3]]
    data2 = [[4,5], [6,7]]
    data3 = [[8]]
    for d1, d2, d3 in match_sockets(data1, data2, data3):
        print(f&#34;{d1=}, {d2=}, {d3=}&#34;)
    # print(1) d1=[1,2,3], d2=[4,5,5], d3=[8]
    # print(2) d2=[1,2,3], d2=[6,7,7], d3=[8]
    &#34;&#34;&#34;
    obj_len = max(len(data) for data in sockets_data) if sockets_data else 0
    sockets_data = [fixed_iter(d, obj_len) for d in sockets_data]
    for objects in zip(*sockets_data):
        data_len = max(len(d) for d in objects)
        layer_data = []
        for data in objects:
            if len(data) != data_len and len(data) &gt; 1:
                if isinstance(data, np.ndarray):
                    data = numpy_full_list(data, data_len)
                else:  # Python list?
                    data = list(fixed_iter(data, data_len))
            layer_data.append(data)
        yield layer_data</code></pre>
</details>
<div class="desc"><p>data1 = [[1,2,3]]
data2 = [[4,5], [6,7]]
data3 = [[8]]
for d1, d2, d3 in match_sockets(data1, data2, data3):
print(f"{d1=}, {d2=}, {d3=}")</p>
<h1 id="print1-d1123-d2455-d38">print(1) d1=[1,2,3], d2=[4,5,5], d3=[8]</h1>
<h1 id="print2-d2123-d2677-d38">print(2) d2=[1,2,3], d2=[6,7,7], d3=[8]</h1></div>
</dd>
<dt id="sverchok.utils.vectorize.vectorize"><code class="name flex">
<span>def <span class="ident">vectorize</span></span>(<span>func=None, *, match_mode='REPEAT')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectorize(func=None, *, match_mode=&#34;REPEAT&#34;):
    &#34;&#34;&#34;
    If there is function which takes some values
    with this decorator it&#39;s possible to call the function by passing list of values of any shape
    Take care of properly annotating of decorated function
    Use Tuple[] in return annotation only if you want the decorator splits the return values into different lists

    ++ Example ++

    from sverchok.utils import vectorize

    def main_node_logic(*, prop_a: List[float], prop_b: Matrix, mode_a: str) -&gt; Tuple[list, list]:
        ...
        return data1, data2

    class MyNode:
        ...
        def process(self):
            input_a = self.inputs[0].sv_get(default=None)
            input_b = self.inputs[1].sv_get(default=None)

            main_node_logic = vectorize(main_node_logic, match_mode=self.match_mode)
            out1, out2 = main_node_logic(input_a, input_b, mode_a = self.mode_a)

            self.outputs[0].sv_set(out1)
            self.outputs[1].sv_set(out2)
    &#34;&#34;&#34;

    # this condition only works when used via &#34;@&#34; syntax
    if func is None:
        return lambda f: vectorize(f, match_mode=match_mode)

    @wraps(func)
    def wrap(*args, **kwargs):

        # it&#39;s better not to use positional arguments for backward compatibility
        # in this case a function can get new arguments
        if args:
            raise TypeError(f&#39;Vectorized function {func.__name__} should not have positional arguments&#39;)

        walkers = []
        for key, data in zip(kwargs, kwargs.values()):
            if data is None or data == []:
                walkers.append(EmptyDataWalker(data, key))
            else:
                annotation = func.__annotations__.get(key)
                nesting_level = _get_nesting_level(annotation) if annotation else 0
                walkers.append(DataWalker(data, output_nesting=nesting_level, mode=match_mode, data_name=key))

        # this is corner case, it can&#39;t be handled via walk data iterator
        if all([w.what_is_next() == DataWalker.VALUE for w in walkers]):
            return func(*args, **kwargs)

        out_number = _get_output_number(func)

        # handle case when return value of decorated function is simple one value
        if out_number == 1:
            out_list = []
            for match_args, result in walk_data(walkers, [out_list]):
                match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
                match_kwargs = {n: d for n, d in zip(kwargs, match_kwargs)}
                func_out = func(*match_args, **match_kwargs)
                if not is_empty_out(func_out):
                    result[0].append(func_out)
            return out_list

        # the case when return value is tuple of multiple values
        else:
            out_lists = [[] for _ in range(out_number)]
            for match_args, result in walk_data(walkers, out_lists):
                match_args, match_kwargs = match_args[:len(args)], match_args[len(args):]
                match_kwargs = {n: d for n, d in zip(kwargs, match_kwargs)}
                func_out = func(*match_args, **match_kwargs)
                [r.append(out) for r, out in zip(result, func_out) if not is_empty_out(out)]
            return out_lists

    def is_empty_out(value):
        if value is None:
            return True
        try:
            return not bool(len(value))
        except TypeError:
            return False

    return wrap</code></pre>
</details>
<div class="desc"><p>If there is function which takes some values
with this decorator it's possible to call the function by passing list of values of any shape
Take care of properly annotating of decorated function
Use Tuple[] in return annotation only if you want the decorator splits the return values into different lists</p>
<p>++ Example ++</p>
<p>from sverchok.utils import vectorize</p>
<p>def main_node_logic(*, prop_a: List[float], prop_b: Matrix, mode_a: str) -&gt; Tuple[list, list]:
&hellip;
return data1, data2</p>
<p>class MyNode:
&hellip;
def process(self):
input_a = self.inputs[0].sv_get(default=None)
input_b = self.inputs[1].sv_get(default=None)</p>
<pre><code>    main_node_logic = vectorize(main_node_logic, match_mode=self.match_mode)
    out1, out2 = main_node_logic(input_a, input_b, mode_a = self.mode_a)

    self.outputs[0].sv_set(out1)
    self.outputs[1].sv_set(out2)
</code></pre></div>
</dd>
<dt id="sverchok.utils.vectorize.walk_data"><code class="name flex">
<span>def <span class="ident">walk_data</span></span>(<span>walkers: List[<a title="sverchok.utils.vectorize.DataWalker" href="#sverchok.utils.vectorize.DataWalker">DataWalker</a>],<br>out_list: List[list]) ‑> Tuple[list, List[list]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_data(walkers: List[DataWalker], out_list: List[list]) -&gt; Tuple[list, List[list]]:
    &#34;&#34;&#34;It walks over data in given walkers in proper order
    match data between each other if necessary
    and gives output containers where to put result of handled data&#34;&#34;&#34;
    match_mode = DataWalker.REPEAT  # todo should be determined by modes of input walkers
    result_data = [ListTreeGenerator(l) for l in out_list]

    # first step is always step down because walkers create extra wrapping list (for the algorithm simplicity)
    max_value_len = max(w.next_values_number for w in walkers)
    [w.step_down_matching(max_value_len, match_mode) for w in walkers]

    while any(not w.is_exhausted for w in walkers):
        if all(w.what_is_next() == DataWalker.VALUE for w in walkers):
            yield [w.pop_next_value() for w in walkers], [t.current_list for t in result_data]
        elif any(w.what_is_next() == DataWalker.END for w in walkers):
            [w.step_up() for w in walkers]
            [t.step_up() for t in result_data]
        elif any(w.what_is_next() == DataWalker.SUB_TREE for w in walkers):
            max_value_len = max(w.next_values_number for w in walkers)
            [w.step_down_matching(max_value_len, match_mode) for w in walkers]
            [t.step_down() for t in result_data]</code></pre>
</details>
<div class="desc"><p>It walks over data in given walkers in proper order
match data between each other if necessary
and gives output containers where to put result of handled data</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker"><code class="flex name class">
<span>class <span class="ident">DataWalker</span></span>
<span>(</span><span>data, output_nesting=0, mode='REPEAT', data_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataWalker:
    &#34;&#34;&#34;This class allows walk over a list of arbitrary shape like over a tree data structure
    Input data can be a value or list
    the list can include values and / or other lists
    the value itself can be just a number, list of numbers, list of list of numbers etc.
    values should be consistent and should not include other values
    for example inside list of vertices there should be other lists of vertices or any thing else
    there is no way of handling such data structure efficiently&#34;&#34;&#34;

    # match modes
    SHORT, CYCLE, REPEAT, XREF, XREF2 = &#34;SHORT&#34;, &#34;CYCLE&#34;, &#34;REPEAT&#34;, &#34;XREF&#34;, &#34;XREF2&#34;

    # node types
    VALUE, END, SUB_TREE = &#34;VALUE&#34;, &#34;END&#34;, &#34;SUB_TREE&#34;

    EXIT_VALUE = type(&#39;ExitValue&#39;, (), {&#39;__repr__&#39;: lambda s: &#34;&lt;ExitValue&gt;&#34;})()

    def __init__(self, data, output_nesting=0, mode=REPEAT, data_name=None):
        self.match_mode = mode

        self._stack = [data]
        self._output_nesting = output_nesting
        self._name = data_name

        self._catch = dict()  # for optimization

    def step_down_matching(self, match_len, match_mode):
        # todo protection from little nesting
        if self.what_is_next() == DataWalker.SUB_TREE:
            current_node = self._stack.pop()
        elif self.what_is_next() == DataWalker.VALUE:
            current_node = [self._stack.pop()]
        else:
            raise RuntimeError(f&#39;Step down is impossible current position is: {self._stack[-1]}&#39;)

        self._stack.append(DataWalker.EXIT_VALUE)
        self._stack.extend(list(reversed(self._match_values(current_node, match_len, match_mode))))

    def step_up(self):
        if self.what_is_next() != DataWalker.END:
            raise RuntimeError(f&#39;There are still values to read: {self._stack}&#39;)
        self._stack.pop()

    def pop_next_value(self):
        return self._stack.pop()

    # this method is used most extensively
    @_what_is_next_catch
    def what_is_next(self):
        if self._stack[-1] is DataWalker.EXIT_VALUE:
            return DataWalker.END
        if isinstance(self._stack[-1], (list, tuple, np.ndarray)):
            nesting = levels_of_list_or_np(self._stack[-1])
        else:
            nesting = 0
        if nesting == self._output_nesting:
            return DataWalker.VALUE
        else:  # todo add the case when next element has too less nested levels
            return DataWalker.SUB_TREE

    @property
    def next_values_number(self):
        try:
            if self.what_is_next() == DataWalker.VALUE:
                return 1
            last = self._stack[-1]
            return len(last)
        except (IndexError, TypeError):
            return 0

    @property
    def is_exhausted(self):
        return not bool(self._stack)

    @staticmethod
    def _match_values(data, match_len, match_mode):
        if len(data) &gt; match_len:
            return data[:match_len]
        elif len(data) == match_len:
            return data
        else:
            if match_mode == DataWalker.REPEAT:
                return list(data) + [data[-1]] * (match_len - len(data))  # todo deepcopy ??
            # todo add other modes

    def __repr__(self):
        return f&#34;&lt;DataWalker {self._name if self._name else &#39;data&#39;}: {self._stack}&gt;&#34;</code></pre>
</details>
<div class="desc"><p>This class allows walk over a list of arbitrary shape like over a tree data structure
Input data can be a value or list
the list can include values and / or other lists
the value itself can be just a number, list of numbers, list of list of numbers etc.
values should be consistent and should not include other values
for example inside list of vertices there should be other lists of vertices or any thing else
there is no way of handling such data structure efficiently</p></div>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker.CYCLE"><code class="name">var <span class="ident">CYCLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.EXIT_VALUE"><code class="name">var <span class="ident">EXIT_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.REPEAT"><code class="name">var <span class="ident">REPEAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.SHORT"><code class="name">var <span class="ident">SHORT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.SUB_TREE"><code class="name">var <span class="ident">SUB_TREE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.VALUE"><code class="name">var <span class="ident">VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.XREF"><code class="name">var <span class="ident">XREF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.XREF2"><code class="name">var <span class="ident">XREF2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker.is_exhausted"><code class="name">prop <span class="ident">is_exhausted</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_exhausted(self):
    return not bool(self._stack)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.next_values_number"><code class="name">prop <span class="ident">next_values_number</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next_values_number(self):
    try:
        if self.what_is_next() == DataWalker.VALUE:
            return 1
        last = self._stack[-1]
        return len(last)
    except (IndexError, TypeError):
        return 0</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.vectorize.DataWalker.pop_next_value"><code class="name flex">
<span>def <span class="ident">pop_next_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_next_value(self):
    return self._stack.pop()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.step_down_matching"><code class="name flex">
<span>def <span class="ident">step_down_matching</span></span>(<span>self, match_len, match_mode)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_down_matching(self, match_len, match_mode):
    # todo protection from little nesting
    if self.what_is_next() == DataWalker.SUB_TREE:
        current_node = self._stack.pop()
    elif self.what_is_next() == DataWalker.VALUE:
        current_node = [self._stack.pop()]
    else:
        raise RuntimeError(f&#39;Step down is impossible current position is: {self._stack[-1]}&#39;)

    self._stack.append(DataWalker.EXIT_VALUE)
    self._stack.extend(list(reversed(self._match_values(current_node, match_len, match_mode))))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.step_up"><code class="name flex">
<span>def <span class="ident">step_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_up(self):
    if self.what_is_next() != DataWalker.END:
        raise RuntimeError(f&#39;There are still values to read: {self._stack}&#39;)
    self._stack.pop()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.DataWalker.what_is_next"><code class="name flex">
<span>def <span class="ident">what_is_next</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_what_is_next_catch
def what_is_next(self):
    if self._stack[-1] is DataWalker.EXIT_VALUE:
        return DataWalker.END
    if isinstance(self._stack[-1], (list, tuple, np.ndarray)):
        nesting = levels_of_list_or_np(self._stack[-1])
    else:
        nesting = 0
    if nesting == self._output_nesting:
        return DataWalker.VALUE
    else:  # todo add the case when next element has too less nested levels
        return DataWalker.SUB_TREE</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker"><code class="flex name class">
<span>class <span class="ident">EmptyDataWalker</span></span>
<span>(</span><span>data=None, data_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyDataWalker:
    &#34;&#34;&#34;Use this (instead of DataWalker) if a channel does not has any data
    It is needed not to overcomplicate logic of DataWalker&#34;&#34;&#34;

    def __init__(self, data=None, data_name=None):
        self._data = data
        self._name = data_name

    def step_down_matching(self, *_, **__):
        pass

    def step_up(self):
        pass

    def pop_next_value(self):
        return self._data

    def what_is_next(self):
        return DataWalker.VALUE

    @property
    def next_values_number(self):
        return 0

    @property
    def is_exhausted(self):
        return True

    def __repr__(self):
        return f&#34;&lt;EmptyDataWalker {self._name if self._name else &#39;data&#39;}: {self._data}&gt;&#34;</code></pre>
</details>
<div class="desc"><p>Use this (instead of DataWalker) if a channel does not has any data
It is needed not to overcomplicate logic of DataWalker</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.is_exhausted"><code class="name">prop <span class="ident">is_exhausted</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_exhausted(self):
    return True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.next_values_number"><code class="name">prop <span class="ident">next_values_number</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def next_values_number(self):
    return 0</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.pop_next_value"><code class="name flex">
<span>def <span class="ident">pop_next_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_next_value(self):
    return self._data</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.step_down_matching"><code class="name flex">
<span>def <span class="ident">step_down_matching</span></span>(<span>self, *_, **__)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_down_matching(self, *_, **__):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.step_up"><code class="name flex">
<span>def <span class="ident">step_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_up(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.EmptyDataWalker.what_is_next"><code class="name flex">
<span>def <span class="ident">what_is_next</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def what_is_next(self):
    return DataWalker.VALUE</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.vectorize.ListTreeGenerator"><code class="flex name class">
<span>class <span class="ident">ListTreeGenerator</span></span>
<span>(</span><span>root_list)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListTreeGenerator:
    &#34;&#34;&#34;Generates tree from nested lists with step up/down interface&#34;&#34;&#34;
    def __init__(self, root_list):
        self.data = root_list
        self._stack = [root_list]

    def step_down(self):
        new_node = []
        self._stack.append(new_node)

    def step_up(self):
        last_node = self._stack.pop()
        if last_node and self._stack:
            current_node = self._stack[-1]
            current_node.append(last_node)

    @property
    def current_list(self):
        return self._stack[-1]

    def __repr__(self):
        return f&#39;&lt;TreeGen data: {self.data}&gt;&#39;</code></pre>
</details>
<div class="desc"><p>Generates tree from nested lists with step up/down interface</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.vectorize.ListTreeGenerator.current_list"><code class="name">prop <span class="ident">current_list</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_list(self):
    return self._stack[-1]</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.vectorize.ListTreeGenerator.step_down"><code class="name flex">
<span>def <span class="ident">step_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_down(self):
    new_node = []
    self._stack.append(new_node)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.vectorize.ListTreeGenerator.step_up"><code class="name flex">
<span>def <span class="ident">step_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_up(self):
    last_node = self._stack.pop()
    if last_node and self._stack:
        current_node = self._stack[-1]
        current_node.append(last_node)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.vectorize.devectorize" href="#sverchok.utils.vectorize.devectorize">devectorize</a></code></li>
<li><code><a title="sverchok.utils.vectorize.match_sockets" href="#sverchok.utils.vectorize.match_sockets">match_sockets</a></code></li>
<li><code><a title="sverchok.utils.vectorize.vectorize" href="#sverchok.utils.vectorize.vectorize">vectorize</a></code></li>
<li><code><a title="sverchok.utils.vectorize.walk_data" href="#sverchok.utils.vectorize.walk_data">walk_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.vectorize.DataWalker" href="#sverchok.utils.vectorize.DataWalker">DataWalker</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.vectorize.DataWalker.CYCLE" href="#sverchok.utils.vectorize.DataWalker.CYCLE">CYCLE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.END" href="#sverchok.utils.vectorize.DataWalker.END">END</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.EXIT_VALUE" href="#sverchok.utils.vectorize.DataWalker.EXIT_VALUE">EXIT_VALUE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.REPEAT" href="#sverchok.utils.vectorize.DataWalker.REPEAT">REPEAT</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.SHORT" href="#sverchok.utils.vectorize.DataWalker.SHORT">SHORT</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.SUB_TREE" href="#sverchok.utils.vectorize.DataWalker.SUB_TREE">SUB_TREE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.VALUE" href="#sverchok.utils.vectorize.DataWalker.VALUE">VALUE</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.XREF" href="#sverchok.utils.vectorize.DataWalker.XREF">XREF</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.XREF2" href="#sverchok.utils.vectorize.DataWalker.XREF2">XREF2</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.is_exhausted" href="#sverchok.utils.vectorize.DataWalker.is_exhausted">is_exhausted</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.next_values_number" href="#sverchok.utils.vectorize.DataWalker.next_values_number">next_values_number</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.pop_next_value" href="#sverchok.utils.vectorize.DataWalker.pop_next_value">pop_next_value</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.step_down_matching" href="#sverchok.utils.vectorize.DataWalker.step_down_matching">step_down_matching</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.step_up" href="#sverchok.utils.vectorize.DataWalker.step_up">step_up</a></code></li>
<li><code><a title="sverchok.utils.vectorize.DataWalker.what_is_next" href="#sverchok.utils.vectorize.DataWalker.what_is_next">what_is_next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.vectorize.EmptyDataWalker" href="#sverchok.utils.vectorize.EmptyDataWalker">EmptyDataWalker</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.is_exhausted" href="#sverchok.utils.vectorize.EmptyDataWalker.is_exhausted">is_exhausted</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.next_values_number" href="#sverchok.utils.vectorize.EmptyDataWalker.next_values_number">next_values_number</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.pop_next_value" href="#sverchok.utils.vectorize.EmptyDataWalker.pop_next_value">pop_next_value</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.step_down_matching" href="#sverchok.utils.vectorize.EmptyDataWalker.step_down_matching">step_down_matching</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.step_up" href="#sverchok.utils.vectorize.EmptyDataWalker.step_up">step_up</a></code></li>
<li><code><a title="sverchok.utils.vectorize.EmptyDataWalker.what_is_next" href="#sverchok.utils.vectorize.EmptyDataWalker.what_is_next">what_is_next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.vectorize.ListTreeGenerator" href="#sverchok.utils.vectorize.ListTreeGenerator">ListTreeGenerator</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.vectorize.ListTreeGenerator.current_list" href="#sverchok.utils.vectorize.ListTreeGenerator.current_list">current_list</a></code></li>
<li><code><a title="sverchok.utils.vectorize.ListTreeGenerator.step_down" href="#sverchok.utils.vectorize.ListTreeGenerator.step_down">step_down</a></code></li>
<li><code><a title="sverchok.utils.vectorize.ListTreeGenerator.step_up" href="#sverchok.utils.vectorize.ListTreeGenerator.step_up">step_up</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
