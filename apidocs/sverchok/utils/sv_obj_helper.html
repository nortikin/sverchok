<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.sv_obj_helper API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.sv_obj_helper</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

import random
import string

import bmesh
import bpy
from bpy.props import (BoolProperty, StringProperty, FloatProperty, IntProperty, BoolVectorProperty)
from mathutils import Matrix

from sverchok.data_structure import updateNode
from sverchok.utils.sv_viewer_utils import (
    matrix_sanitizer, natural_plus_one, greek_alphabet)

sv_caps = set(string.ascii_uppercase)

def enum_from_list(*item_list):
    &#34;&#34;&#34;
    usage:   var = enum_from_list(&#39;TOP_BASELINE&#39;, &#39;TOP&#39;)
    produces:  [(&#39;TOP_BASELINE&#39;, &#39;TOP_BASELINE&#39;, &#39;&#39;, 0), (&#39;TOP&#39;, &#39;TOP&#39;, &#39;&#39;, 1)]
    &#34;&#34;&#34;
    return [(item, item, &#34;&#34;, idx) for idx, item in enumerate(item_list)]

def enum_from_list_idx(*item_list):
    &#34;&#34;&#34;
    usage:   var = enum_from_list_idx(&#39;0:TOP_BASELINE&#39;, &#39;7:TOP&#39;)
    produces:  [(&#39;TOP_BASELINE&#39;, &#39;TOP_BASELINE&#39;, &#39;&#39;, 0), (&#39;TOP&#39;, &#39;TOP&#39;, &#39;&#39;, 7)]

    &#34;&#34;&#34;
    return [(n, n, &#34;&#34;, int(i)) for i, n in [item.split(&#39;:&#39;) for item in item_list]]



common_ops = [&#39;object_hide_viewport&#39;, &#39;object_hide_select&#39;, &#39;object_hide_render&#39;]
CALLBACK_OP = &#39;node.sv_callback_svobjects_helper&#39;

def get_random_init_v3():
    &#34;&#34;&#34; it&#39;s not random &#34;&#34;&#34;
    idx = bpy.context.scene.SvGreekAlphabet_index
    if idx &lt;= 23:
        name = greek_alphabet[idx]
        bpy.context.scene.SvGreekAlphabet_index += 1
    else:
        name = &#39;&#39;.join(random.sample(sv_caps, 6))

    return name


def tracked_operator(node, layout_element, fn_name=&#39;&#39;, text=&#39;&#39;, icon=None):
    &#34;&#34;&#34;
    this is a wrapper around the layout.operator(CALLBACK_OP....), it allows
    us to track the nodetree and nodename origins of the callback.

    // Without treename and nodename it&#39;s not possible to tell where the button press comes from
    // and now you can just press the button, without first making a node selected or active.

    &#34;&#34;&#34;
    operator_props = dict(text=text)
    if icon:
        operator_props[&#39;icon&#39;] = icon

    button = layout_element.operator(CALLBACK_OP, **operator_props)
    button.fn_name = fn_name
    button.node_name = node.name
    button.tree_name = node.id_data.name


class SvObjectsHelperCallback(bpy.types.Operator):

    bl_idname = CALLBACK_OP
    bl_label = &#34;Sverchok objects helper&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}

    fn_name: StringProperty(default=&#39;&#39;)

    # The imformation of &#34;which node this button was pressed on&#34;
    # is not communicated unless you do it explicitly.
    tree_name: StringProperty(default=&#39;&#39;)
    node_name: StringProperty(default=&#39;&#39;)

    def execute(self, context):
        type_op = self.fn_name

        if self.tree_name and self.node_name:
            n = bpy.data.node_groups[self.tree_name].nodes[self.node_name]
        else:
            n = context.node

        objs = n.get_children()

        if type_op in {&#39;object_hide_viewport&#39;, &#39;object_hide_render&#39;, &#39;object_hide_select&#39;}:
            for obj in objs:
                stripped_op_name = type_op.replace(&#34;object_&#34;, &#39;&#39;)
                setattr(obj, stripped_op_name, getattr(n, type_op))
            setattr(n, type_op, not getattr(n, type_op))

        elif type_op == &#34;object_select&#34;:
            for obj in objs:
                obj.select_set(n.object_select)
            n.object_select = not n.object_select

        elif type_op == &#39;random_basedata_name&#39;:   # random_data_name  ?
            n.basedata_name = get_random_init_v3()

        elif type_op == &#39;add_material&#39;:
            if hasattr(n, type_op):
                # some nodes will define their own add_material..
                getattr(n, type_op)()
            else:
                # this is the simplest automatic material generator.
                mat = bpy.data.materials.new(&#39;sv_material&#39;)
                mat.use_nodes = True
                n.material = mat.name

        return {&#39;FINISHED&#39;}


class SvObjHelper():

    # hints found at ba.org/forum/showthread.php?290106
    # - this will not allow objects on multiple layers, yet.
    def g(self):
        self[&#39;lp&#39;] = self.get(&#39;lp&#39;, [False] * 20)
        return self[&#39;lp&#39;]

    def s(self, value):
        val = []
        for b in zip(self[&#39;lp&#39;], value):
            val.append(b[0] != b[1])
        self[&#39;lp&#39;] = val

    def layer_updateNode(self, context):
        &#39;&#39;&#39;will update in place without geometry updates&#39;&#39;&#39;
        for obj in self.get_children():
            obj.layers = self.layer_choice[:]

    def get_children(self):
        # criteria: basedata_name must be in object.keys and the value must be self.basedata_name
        objects = bpy.data.objects
        objs = [obj for obj in objects if obj.type == self.data_kind]
        return [o for o in objs if o.get(&#39;basedata_name&#39;) == self.basedata_name]

    def group_state_update_handler(self, context):
        &#34;&#34;&#34;
        since this is technically a scene/admin code controlling hierarchy, pressing
        the button should result in asymmetric behaviour depending on the new state of
        &#34;self.grouping&#34;.

        + - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        | state | desired behaviour                                             |
        + ----- + --------------------------------------------------------------+
        | True  | add all objects associated with the node to the collection    |
        + ----- + --------------------------------------------------------------+
        | False | remove collection, if present, and association with object    |
        + - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        &#34;&#34;&#34;
        if self.grouping:
            updateNode(self, context)
        else:
            self.clear_collection()

    def to_collection(self, objs):
        collections = bpy.data.collections
        named = self.custom_collection_name or self.basedata_name

        # alias collection, or generate new collection and alias that
        collection = collections.get(named)
        if not collection:
            collection = collections.new(named)
            bpy.context.scene.collection.children.link(collection)

        for obj in objs:
            if obj.name not in collection.objects:
                collection.objects.link(obj)
            if obj.name in bpy.context.scene.collection.objects:
                bpy.context.scene.collection.objects.unlink(obj)

    def clear_collection(self):
        collections = bpy.data.collections
        named = self.custom_collection_name or self.basedata_name

        # alias collection, or generate new collection and alias that
        collection = collections.get(named)
        if not collection:
            &#34;&#34;&#34; seems the collection is already gone, this is a no op &#34;&#34;&#34;
            return
        else:
            for obj in collection.objects:
                bpy.context.scene.collection.objects.link(obj)
            collections.remove(collection)

    def ensure_parent(self):
        if self.parent_to_empty:
            self.parent_name = &#39;Empty_&#39; + self.basedata_name
            collection = bpy.context.scene.collection
            scene = bpy.context.scene
            if not self.parent_name in bpy.data.objects:
                empty = bpy.data.objects.new(self.parent_name, None)
                collection.objects.link(empty)
                scene.update()

    def to_parent(self, objs):
        for obj in objs:
            if self.parent_to_empty:
                obj.parent = bpy.data.objects[self.parent_name]
            elif obj.parent:
                obj.parent = None

    layer_choice: BoolVectorProperty(
        subtype=&#39;LAYER&#39;, size=20, name=&#34;Layer Choice&#34;,
        update=layer_updateNode,
        description=&#34;This sets which layer objects are placed on&#34;,
        get=g, set=s)

    activate: BoolProperty(
        name=&#39;activate&#39;,
        description=&#34;When enabled this will process incoming data&#34;,
        default=True,
        update=updateNode)

    basedata_name: StringProperty(
        name=&#39;basedata name&#39;,
        default=&#39;Alpha&#39;,
        description=&#34;which base name the object and data will use&#34;,
        update=updateNode
    )

    # most importantly, what kind of base data are we making?
    data_kind: StringProperty(name=&#39;data kind&#39;, default=&#39;MESH&#39;)

    # to be used if the node has no material input.
    material: StringProperty(name=&#39;material&#39;, default=&#39;&#39;)
    material_pointer: bpy.props.PointerProperty(
        type=bpy.types.Material, poll=lambda s, o: True, update=updateNode)

    # to be used as standard toggles for object attributes of same name
    object_hide_viewport: BoolProperty(name=&#39;object hide viewport&#39;, default=True)
    object_hide_render: BoolProperty(name=&#39;object hide render&#39;, default=True)
    object_hide_select: BoolProperty(name=&#39;object hide select&#39;, default=False)

    object_select: BoolProperty(name=&#39;object select&#39;, default=True)

    show_wire: BoolProperty(name=&#39;show wire&#39;, update=updateNode)
    use_smooth: BoolProperty(name=&#39;use smooth&#39;, default=True, update=updateNode)

    parent_to_empty: BoolProperty(name=&#39;parent to empty&#39;, default=False, update=updateNode)
    parent_name: StringProperty(name=&#39;parent name&#39;)  # calling updateNode would recurse.

    custom_collection_name: StringProperty(
        name=&#39;collection name&#39;, update=updateNode,
        description=&#39;custom collection name, will default to the basename of the node first&#39;)

    def sv_init_helper_basedata_name(self):
        &#34;&#34;&#34;
        this is to be used in sv_init, at the top
        &#34;&#34;&#34;
        dname = bpy.context.scene.sv_object_names.get_available_name()
        self.basedata_name = dname
        self.use_custom_color = True


    def icons(self, TYPE):
        NAMED_ICON = {
            &#39;object_hide_viewport&#39;: &#39;RESTRICT_VIEW&#39;,
            &#39;object_hide_render&#39;: &#39;RESTRICT_RENDER&#39;,
            &#39;object_hide_select&#39;: &#39;RESTRICT_SELECT&#39;}.get(TYPE)
        if not NAMED_ICON:
            return &#39;ERROR&#39;
        return NAMED_ICON + [&#39;_ON&#39;, &#39;_OFF&#39;][getattr(self, TYPE)]

    def draw_live_and_outliner(self, context, layout):
        col = layout.column(align=True)
        row = col.row(align=True)
        row.column().prop(self, &#34;activate&#34;, text=&#34;LIVE&#34;, toggle=True)

        for op_name in common_ops:
            tracked_operator(self, row, fn_name=op_name, icon=self.icons(op_name))

    def draw_object_buttons(self, context, layout):

        col = layout.column(align=True)
        if col:
            row = col.row(align=True)
            row.scale_y = 1
            row.prop(self, &#34;basedata_name&#34;, text=&#34;&#34;, icon=self.bl_icon)

            row = col.row(align=True)
            row.scale_y = 2
            tracked_operator(self, row, fn_name=&#39;object_select&#39;, text=&#39;Select / Deselect&#39;)

            row = col.row(align=True)
            row.scale_y = 1
            row.prop_search(self, &#39;material_pointer&#39;, bpy.data, &#39;materials&#39;, text=&#39;&#39;, icon=&#39;MATERIAL_DATA&#39;)
            tracked_operator(self, row, fn_name=&#39;add_material&#39;, icon=&#34;ZOOM_IN&#34;)

    def draw_ext_object_buttons(self, context, layout):
        layout.separator()
        row = layout.row(align=True)
        tracked_operator(self, row, fn_name=&#39;random_basedata_name&#39;, text=&#39;Rnd Name&#39;)
        tracked_operator(self, row, fn_name=&#39;add_material&#39;, text=&#39;+Material&#39;, icon=&#34;ZOOM_IN&#34;)

    def set_corresponding_materials(self):
        if self.material_pointer:
            for obj in self.get_children():
                obj.active_material = self.material_pointer

    def remove_non_updated_objects(self, obj_index):
        objs = self.get_children()
        obj_names = [obj.name for obj in objs if obj[&#39;idx&#39;] &gt; obj_index]
        if not obj_names:
            return

        if self.data_kind == &#39;MESH&#39;:
            kinds = bpy.data.meshes
        elif self.data_kind == &#39;CURVE&#39;:
            kinds = bpy.data.curves
        elif self.data_kind == &#39;META&#39;:
            kinds = bpy.data.metaballs
        elif self.data_kind == &#39;FONT&#39;:
            kinds = bpy.data.curves


        objects = bpy.data.objects
        collection = bpy.context.scene.collection

        if hasattr(self, &#34;grouping&#34;) and self.grouping:
            # if a node employs &#34;grouping&#34; it must also provide
            # - self.custom_collection_name (even if not directly used)
            # - self.basedata_name
            named = self.custom_collection_name or self.basedata_name
            collection = bpy.data.collections.get(named)

        # remove excess objects
        for object_name in obj_names:
            obj = objects[object_name]
            obj.hide_select = False
            collection.objects.unlink(obj)
            objects.remove(obj, do_unlink=True)

        # delete associated meshes/curves etc
        for object_name in obj_names:
            kinds.remove(kinds[object_name])

    def create_object(self, object_name, obj_index, data):
        &#34;&#34;&#34;
        Create a new object and link it into collection.
        &#34;&#34;&#34;
        obj = bpy.data.objects.new(object_name, data)
        obj[&#39;basedata_name&#39;] = self.basedata_name
        obj[&#39;madeby&#39;] = self.name
        obj[&#39;idx&#39;] = obj_index
        bpy.context.scene.collection.objects.link(obj)
        return obj

    def get_or_create_object(self, object_name, obj_index, data):
        &#34;&#34;&#34;
        Return existing Object or create new one.
        : if object reference exists, pick it up else make a new one
        &#34;&#34;&#34;
        obj = bpy.data.objects.get(object_name)
        if not obj:
            obj = self.create_object(object_name, obj_index, data)
        return obj

    def get_obj_curve(self, obj_index):
        curves = bpy.data.curves
        objects = bpy.data.objects
        collection = bpy.context.scene.collection

        curve_name = f&#39;{self.basedata_name}.{obj_index:04d}&#39;

        # if curve data exists, pick it up else make new curve
        cu = curves.get(curve_name)
        if not cu:
            cu = curves.new(name=curve_name, type=&#39;CURVE&#39;)
        obj = self.get_or_create_object(curve_name, obj_index, cu)

        # break down existing splines entirely.
        if cu.splines:
            cu.splines.clear()

        return obj, cu


    def clear_current_mesh(self, data):
        bm = bmesh.new()
        bm.to_mesh(data)
        bm.free()
        data.update()

    def get_alphabet(self):
        return greek_alphabet


    def push_custom_matrix_if_present(self, sv_object, matrix):
        if matrix:
            # matrix = matrix_sanitizer(matrix)
            sv_object.matrix_local = matrix
        else:
            sv_object.matrix_local = Matrix.Identity(4)


def register():
    bpy.utils.register_class(SvObjectsHelperCallback)


def unregister():
    bpy.utils.unregister_class(SvObjectsHelperCallback)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.sv_obj_helper.enum_from_list"><code class="name flex">
<span>def <span class="ident">enum_from_list</span></span>(<span>*item_list)</span>
</code></dt>
<dd>
<div class="desc"><p>usage:
var = enum_from_list('TOP_BASELINE', 'TOP')
produces:
[('TOP_BASELINE', 'TOP_BASELINE', '', 0), ('TOP', 'TOP', '', 1)]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enum_from_list(*item_list):
    &#34;&#34;&#34;
    usage:   var = enum_from_list(&#39;TOP_BASELINE&#39;, &#39;TOP&#39;)
    produces:  [(&#39;TOP_BASELINE&#39;, &#39;TOP_BASELINE&#39;, &#39;&#39;, 0), (&#39;TOP&#39;, &#39;TOP&#39;, &#39;&#39;, 1)]
    &#34;&#34;&#34;
    return [(item, item, &#34;&#34;, idx) for idx, item in enumerate(item_list)]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.enum_from_list_idx"><code class="name flex">
<span>def <span class="ident">enum_from_list_idx</span></span>(<span>*item_list)</span>
</code></dt>
<dd>
<div class="desc"><p>usage:
var = enum_from_list_idx('0:TOP_BASELINE', '7:TOP')
produces:
[('TOP_BASELINE', 'TOP_BASELINE', '', 0), ('TOP', 'TOP', '', 7)]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enum_from_list_idx(*item_list):
    &#34;&#34;&#34;
    usage:   var = enum_from_list_idx(&#39;0:TOP_BASELINE&#39;, &#39;7:TOP&#39;)
    produces:  [(&#39;TOP_BASELINE&#39;, &#39;TOP_BASELINE&#39;, &#39;&#39;, 0), (&#39;TOP&#39;, &#39;TOP&#39;, &#39;&#39;, 7)]

    &#34;&#34;&#34;
    return [(n, n, &#34;&#34;, int(i)) for i, n in [item.split(&#39;:&#39;) for item in item_list]]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.get_random_init_v3"><code class="name flex">
<span>def <span class="ident">get_random_init_v3</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>it's not random</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_random_init_v3():
    &#34;&#34;&#34; it&#39;s not random &#34;&#34;&#34;
    idx = bpy.context.scene.SvGreekAlphabet_index
    if idx &lt;= 23:
        name = greek_alphabet[idx]
        bpy.context.scene.SvGreekAlphabet_index += 1
    else:
        name = &#39;&#39;.join(random.sample(sv_caps, 6))

    return name</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register():
    bpy.utils.register_class(SvObjectsHelperCallback)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.tracked_operator"><code class="name flex">
<span>def <span class="ident">tracked_operator</span></span>(<span>node, layout_element, fn_name='', text='', icon=None)</span>
</code></dt>
<dd>
<div class="desc"><p>this is a wrapper around the layout.operator(CALLBACK_OP....), it allows
us to track the nodetree and nodename origins of the callback.</p>
<p>// Without treename and nodename it's not possible to tell where the button press comes from
// and now you can just press the button, without first making a node selected or active.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tracked_operator(node, layout_element, fn_name=&#39;&#39;, text=&#39;&#39;, icon=None):
    &#34;&#34;&#34;
    this is a wrapper around the layout.operator(CALLBACK_OP....), it allows
    us to track the nodetree and nodename origins of the callback.

    // Without treename and nodename it&#39;s not possible to tell where the button press comes from
    // and now you can just press the button, without first making a node selected or active.

    &#34;&#34;&#34;
    operator_props = dict(text=text)
    if icon:
        operator_props[&#39;icon&#39;] = icon

    button = layout_element.operator(CALLBACK_OP, **operator_props)
    button.fn_name = fn_name
    button.node_name = node.name
    button.tree_name = node.id_data.name</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister():
    bpy.utils.unregister_class(SvObjectsHelperCallback)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper"><code class="flex name class">
<span>class <span class="ident">SvObjHelper</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvObjHelper():

    # hints found at ba.org/forum/showthread.php?290106
    # - this will not allow objects on multiple layers, yet.
    def g(self):
        self[&#39;lp&#39;] = self.get(&#39;lp&#39;, [False] * 20)
        return self[&#39;lp&#39;]

    def s(self, value):
        val = []
        for b in zip(self[&#39;lp&#39;], value):
            val.append(b[0] != b[1])
        self[&#39;lp&#39;] = val

    def layer_updateNode(self, context):
        &#39;&#39;&#39;will update in place without geometry updates&#39;&#39;&#39;
        for obj in self.get_children():
            obj.layers = self.layer_choice[:]

    def get_children(self):
        # criteria: basedata_name must be in object.keys and the value must be self.basedata_name
        objects = bpy.data.objects
        objs = [obj for obj in objects if obj.type == self.data_kind]
        return [o for o in objs if o.get(&#39;basedata_name&#39;) == self.basedata_name]

    def group_state_update_handler(self, context):
        &#34;&#34;&#34;
        since this is technically a scene/admin code controlling hierarchy, pressing
        the button should result in asymmetric behaviour depending on the new state of
        &#34;self.grouping&#34;.

        + - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        | state | desired behaviour                                             |
        + ----- + --------------------------------------------------------------+
        | True  | add all objects associated with the node to the collection    |
        + ----- + --------------------------------------------------------------+
        | False | remove collection, if present, and association with object    |
        + - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        &#34;&#34;&#34;
        if self.grouping:
            updateNode(self, context)
        else:
            self.clear_collection()

    def to_collection(self, objs):
        collections = bpy.data.collections
        named = self.custom_collection_name or self.basedata_name

        # alias collection, or generate new collection and alias that
        collection = collections.get(named)
        if not collection:
            collection = collections.new(named)
            bpy.context.scene.collection.children.link(collection)

        for obj in objs:
            if obj.name not in collection.objects:
                collection.objects.link(obj)
            if obj.name in bpy.context.scene.collection.objects:
                bpy.context.scene.collection.objects.unlink(obj)

    def clear_collection(self):
        collections = bpy.data.collections
        named = self.custom_collection_name or self.basedata_name

        # alias collection, or generate new collection and alias that
        collection = collections.get(named)
        if not collection:
            &#34;&#34;&#34; seems the collection is already gone, this is a no op &#34;&#34;&#34;
            return
        else:
            for obj in collection.objects:
                bpy.context.scene.collection.objects.link(obj)
            collections.remove(collection)

    def ensure_parent(self):
        if self.parent_to_empty:
            self.parent_name = &#39;Empty_&#39; + self.basedata_name
            collection = bpy.context.scene.collection
            scene = bpy.context.scene
            if not self.parent_name in bpy.data.objects:
                empty = bpy.data.objects.new(self.parent_name, None)
                collection.objects.link(empty)
                scene.update()

    def to_parent(self, objs):
        for obj in objs:
            if self.parent_to_empty:
                obj.parent = bpy.data.objects[self.parent_name]
            elif obj.parent:
                obj.parent = None

    layer_choice: BoolVectorProperty(
        subtype=&#39;LAYER&#39;, size=20, name=&#34;Layer Choice&#34;,
        update=layer_updateNode,
        description=&#34;This sets which layer objects are placed on&#34;,
        get=g, set=s)

    activate: BoolProperty(
        name=&#39;activate&#39;,
        description=&#34;When enabled this will process incoming data&#34;,
        default=True,
        update=updateNode)

    basedata_name: StringProperty(
        name=&#39;basedata name&#39;,
        default=&#39;Alpha&#39;,
        description=&#34;which base name the object and data will use&#34;,
        update=updateNode
    )

    # most importantly, what kind of base data are we making?
    data_kind: StringProperty(name=&#39;data kind&#39;, default=&#39;MESH&#39;)

    # to be used if the node has no material input.
    material: StringProperty(name=&#39;material&#39;, default=&#39;&#39;)
    material_pointer: bpy.props.PointerProperty(
        type=bpy.types.Material, poll=lambda s, o: True, update=updateNode)

    # to be used as standard toggles for object attributes of same name
    object_hide_viewport: BoolProperty(name=&#39;object hide viewport&#39;, default=True)
    object_hide_render: BoolProperty(name=&#39;object hide render&#39;, default=True)
    object_hide_select: BoolProperty(name=&#39;object hide select&#39;, default=False)

    object_select: BoolProperty(name=&#39;object select&#39;, default=True)

    show_wire: BoolProperty(name=&#39;show wire&#39;, update=updateNode)
    use_smooth: BoolProperty(name=&#39;use smooth&#39;, default=True, update=updateNode)

    parent_to_empty: BoolProperty(name=&#39;parent to empty&#39;, default=False, update=updateNode)
    parent_name: StringProperty(name=&#39;parent name&#39;)  # calling updateNode would recurse.

    custom_collection_name: StringProperty(
        name=&#39;collection name&#39;, update=updateNode,
        description=&#39;custom collection name, will default to the basename of the node first&#39;)

    def sv_init_helper_basedata_name(self):
        &#34;&#34;&#34;
        this is to be used in sv_init, at the top
        &#34;&#34;&#34;
        dname = bpy.context.scene.sv_object_names.get_available_name()
        self.basedata_name = dname
        self.use_custom_color = True


    def icons(self, TYPE):
        NAMED_ICON = {
            &#39;object_hide_viewport&#39;: &#39;RESTRICT_VIEW&#39;,
            &#39;object_hide_render&#39;: &#39;RESTRICT_RENDER&#39;,
            &#39;object_hide_select&#39;: &#39;RESTRICT_SELECT&#39;}.get(TYPE)
        if not NAMED_ICON:
            return &#39;ERROR&#39;
        return NAMED_ICON + [&#39;_ON&#39;, &#39;_OFF&#39;][getattr(self, TYPE)]

    def draw_live_and_outliner(self, context, layout):
        col = layout.column(align=True)
        row = col.row(align=True)
        row.column().prop(self, &#34;activate&#34;, text=&#34;LIVE&#34;, toggle=True)

        for op_name in common_ops:
            tracked_operator(self, row, fn_name=op_name, icon=self.icons(op_name))

    def draw_object_buttons(self, context, layout):

        col = layout.column(align=True)
        if col:
            row = col.row(align=True)
            row.scale_y = 1
            row.prop(self, &#34;basedata_name&#34;, text=&#34;&#34;, icon=self.bl_icon)

            row = col.row(align=True)
            row.scale_y = 2
            tracked_operator(self, row, fn_name=&#39;object_select&#39;, text=&#39;Select / Deselect&#39;)

            row = col.row(align=True)
            row.scale_y = 1
            row.prop_search(self, &#39;material_pointer&#39;, bpy.data, &#39;materials&#39;, text=&#39;&#39;, icon=&#39;MATERIAL_DATA&#39;)
            tracked_operator(self, row, fn_name=&#39;add_material&#39;, icon=&#34;ZOOM_IN&#34;)

    def draw_ext_object_buttons(self, context, layout):
        layout.separator()
        row = layout.row(align=True)
        tracked_operator(self, row, fn_name=&#39;random_basedata_name&#39;, text=&#39;Rnd Name&#39;)
        tracked_operator(self, row, fn_name=&#39;add_material&#39;, text=&#39;+Material&#39;, icon=&#34;ZOOM_IN&#34;)

    def set_corresponding_materials(self):
        if self.material_pointer:
            for obj in self.get_children():
                obj.active_material = self.material_pointer

    def remove_non_updated_objects(self, obj_index):
        objs = self.get_children()
        obj_names = [obj.name for obj in objs if obj[&#39;idx&#39;] &gt; obj_index]
        if not obj_names:
            return

        if self.data_kind == &#39;MESH&#39;:
            kinds = bpy.data.meshes
        elif self.data_kind == &#39;CURVE&#39;:
            kinds = bpy.data.curves
        elif self.data_kind == &#39;META&#39;:
            kinds = bpy.data.metaballs
        elif self.data_kind == &#39;FONT&#39;:
            kinds = bpy.data.curves


        objects = bpy.data.objects
        collection = bpy.context.scene.collection

        if hasattr(self, &#34;grouping&#34;) and self.grouping:
            # if a node employs &#34;grouping&#34; it must also provide
            # - self.custom_collection_name (even if not directly used)
            # - self.basedata_name
            named = self.custom_collection_name or self.basedata_name
            collection = bpy.data.collections.get(named)

        # remove excess objects
        for object_name in obj_names:
            obj = objects[object_name]
            obj.hide_select = False
            collection.objects.unlink(obj)
            objects.remove(obj, do_unlink=True)

        # delete associated meshes/curves etc
        for object_name in obj_names:
            kinds.remove(kinds[object_name])

    def create_object(self, object_name, obj_index, data):
        &#34;&#34;&#34;
        Create a new object and link it into collection.
        &#34;&#34;&#34;
        obj = bpy.data.objects.new(object_name, data)
        obj[&#39;basedata_name&#39;] = self.basedata_name
        obj[&#39;madeby&#39;] = self.name
        obj[&#39;idx&#39;] = obj_index
        bpy.context.scene.collection.objects.link(obj)
        return obj

    def get_or_create_object(self, object_name, obj_index, data):
        &#34;&#34;&#34;
        Return existing Object or create new one.
        : if object reference exists, pick it up else make a new one
        &#34;&#34;&#34;
        obj = bpy.data.objects.get(object_name)
        if not obj:
            obj = self.create_object(object_name, obj_index, data)
        return obj

    def get_obj_curve(self, obj_index):
        curves = bpy.data.curves
        objects = bpy.data.objects
        collection = bpy.context.scene.collection

        curve_name = f&#39;{self.basedata_name}.{obj_index:04d}&#39;

        # if curve data exists, pick it up else make new curve
        cu = curves.get(curve_name)
        if not cu:
            cu = curves.new(name=curve_name, type=&#39;CURVE&#39;)
        obj = self.get_or_create_object(curve_name, obj_index, cu)

        # break down existing splines entirely.
        if cu.splines:
            cu.splines.clear()

        return obj, cu


    def clear_current_mesh(self, data):
        bm = bmesh.new()
        bm.to_mesh(data)
        bm.free()
        data.update()

    def get_alphabet(self):
        return greek_alphabet


    def push_custom_matrix_if_present(self, sv_object, matrix):
        if matrix:
            # matrix = matrix_sanitizer(matrix)
            sv_object.matrix_local = matrix
        else:
            sv_object.matrix_local = Matrix.Identity(4)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>sverchok.nodes.viz.viewer_bezier_curve.SvBezierCurveOutNode</li>
<li>sverchok.nodes.viz.viewer_curves.SvCurveViewerNodeV28</li>
<li>sverchok.nodes.viz.viewer_metaball.SvMetaballOutNode</li>
<li>sverchok.nodes.viz.viewer_nurbs_curve.SvNurbsCurveOutNode</li>
<li>sverchok.nodes.viz.viewer_nurbs_surface.SvNurbsSurfaceOutNode</li>
<li>sverchok.nodes.viz.viewer_skin.SvSkinViewerNodeV28</li>
<li>sverchok.nodes.viz.viewer_typography.SvTypeViewerNodeV28</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.activate"><code class="name">var <span class="ident">activate</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'activate', 'description': 'When enabled this will process incoming data', 'default': True, 'update': <function updateNode at 0x7f2f81c8cf70>, 'attr': 'activate'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.basedata_name"><code class="name">var <span class="ident">basedata_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'name': 'basedata name', 'default': 'Alpha', 'description': 'which base name the object and data will use', 'update': <function updateNode at 0x7f2f81c8cf70>, 'attr': 'basedata_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.custom_collection_name"><code class="name">var <span class="ident">custom_collection_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'name': 'collection name', 'update': <function updateNode at 0x7f2f81c8cf70>, 'description': 'custom collection name, will default to the basename of the node first', 'attr': 'custom_collection_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.data_kind"><code class="name">var <span class="ident">data_kind</span> : <_PropertyDeferred, <built-in function StringProperty>, {'name': 'data kind', 'default': 'MESH', 'attr': 'data_kind'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.layer_choice"><code class="name">var <span class="ident">layer_choice</span> : <_PropertyDeferred, <built-in function BoolVectorProperty>, {'subtype': 'LAYER', 'size': 20, 'name': 'Layer Choice', 'update': <function <a title="sverchok.utils.sv_obj_helper.SvObjHelper.layer_updateNode" href="#sverchok.utils.sv_obj_helper.SvObjHelper.layer_updateNode">SvObjHelper.layer_updateNode()</a> at 0x7f2f76c22c10>, 'description': 'This sets which layer objects are placed on', 'get': <function <a title="sverchok.utils.sv_obj_helper.SvObjHelper.g" href="#sverchok.utils.sv_obj_helper.SvObjHelper.g">SvObjHelper.g()</a> at 0x7f2f76c22af0>, 'set': <function <a title="sverchok.utils.sv_obj_helper.SvObjHelper.s" href="#sverchok.utils.sv_obj_helper.SvObjHelper.s">SvObjHelper.s()</a> at 0x7f2f76c22b80>, 'attr': 'layer_choice'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.material"><code class="name">var <span class="ident">material</span> : <_PropertyDeferred, <built-in function StringProperty>, {'name': 'material', 'default': '', 'attr': 'material'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.material_pointer"><code class="name">var <span class="ident">material_pointer</span> : <_PropertyDeferred, <built-in function PointerProperty>, {'type': <class 'bpy.types.Material'>, 'poll': <function <a title="sverchok.utils.sv_obj_helper.SvObjHelper" href="#sverchok.utils.sv_obj_helper.SvObjHelper">SvObjHelper</a>.<lambda> at 0x7f2f76c24040>, 'update': <function updateNode at 0x7f2f81c8cf70>, 'attr': 'material_pointer'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_render"><code class="name">var <span class="ident">object_hide_render</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'object hide render', 'default': True, 'attr': 'object_hide_render'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_select"><code class="name">var <span class="ident">object_hide_select</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'object hide select', 'default': False, 'attr': 'object_hide_select'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_viewport"><code class="name">var <span class="ident">object_hide_viewport</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'object hide viewport', 'default': True, 'attr': 'object_hide_viewport'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.object_select"><code class="name">var <span class="ident">object_select</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'object select', 'default': True, 'attr': 'object_select'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.parent_name"><code class="name">var <span class="ident">parent_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'name': 'parent name', 'attr': 'parent_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.parent_to_empty"><code class="name">var <span class="ident">parent_to_empty</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'parent to empty', 'default': False, 'update': <function updateNode at 0x7f2f81c8cf70>, 'attr': 'parent_to_empty'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.show_wire"><code class="name">var <span class="ident">show_wire</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'show wire', 'update': <function updateNode at 0x7f2f81c8cf70>, 'attr': 'show_wire'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.use_smooth"><code class="name">var <span class="ident">use_smooth</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'use smooth', 'default': True, 'update': <function updateNode at 0x7f2f81c8cf70>, 'attr': 'use_smooth'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.clear_collection"><code class="name flex">
<span>def <span class="ident">clear_collection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_collection(self):
    collections = bpy.data.collections
    named = self.custom_collection_name or self.basedata_name

    # alias collection, or generate new collection and alias that
    collection = collections.get(named)
    if not collection:
        &#34;&#34;&#34; seems the collection is already gone, this is a no op &#34;&#34;&#34;
        return
    else:
        for obj in collection.objects:
            bpy.context.scene.collection.objects.link(obj)
        collections.remove(collection)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.clear_current_mesh"><code class="name flex">
<span>def <span class="ident">clear_current_mesh</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_current_mesh(self, data):
    bm = bmesh.new()
    bm.to_mesh(data)
    bm.free()
    data.update()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.create_object"><code class="name flex">
<span>def <span class="ident">create_object</span></span>(<span>self, object_name, obj_index, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new object and link it into collection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_object(self, object_name, obj_index, data):
    &#34;&#34;&#34;
    Create a new object and link it into collection.
    &#34;&#34;&#34;
    obj = bpy.data.objects.new(object_name, data)
    obj[&#39;basedata_name&#39;] = self.basedata_name
    obj[&#39;madeby&#39;] = self.name
    obj[&#39;idx&#39;] = obj_index
    bpy.context.scene.collection.objects.link(obj)
    return obj</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.draw_ext_object_buttons"><code class="name flex">
<span>def <span class="ident">draw_ext_object_buttons</span></span>(<span>self, context, layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ext_object_buttons(self, context, layout):
    layout.separator()
    row = layout.row(align=True)
    tracked_operator(self, row, fn_name=&#39;random_basedata_name&#39;, text=&#39;Rnd Name&#39;)
    tracked_operator(self, row, fn_name=&#39;add_material&#39;, text=&#39;+Material&#39;, icon=&#34;ZOOM_IN&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.draw_live_and_outliner"><code class="name flex">
<span>def <span class="ident">draw_live_and_outliner</span></span>(<span>self, context, layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_live_and_outliner(self, context, layout):
    col = layout.column(align=True)
    row = col.row(align=True)
    row.column().prop(self, &#34;activate&#34;, text=&#34;LIVE&#34;, toggle=True)

    for op_name in common_ops:
        tracked_operator(self, row, fn_name=op_name, icon=self.icons(op_name))</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.draw_object_buttons"><code class="name flex">
<span>def <span class="ident">draw_object_buttons</span></span>(<span>self, context, layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_object_buttons(self, context, layout):

    col = layout.column(align=True)
    if col:
        row = col.row(align=True)
        row.scale_y = 1
        row.prop(self, &#34;basedata_name&#34;, text=&#34;&#34;, icon=self.bl_icon)

        row = col.row(align=True)
        row.scale_y = 2
        tracked_operator(self, row, fn_name=&#39;object_select&#39;, text=&#39;Select / Deselect&#39;)

        row = col.row(align=True)
        row.scale_y = 1
        row.prop_search(self, &#39;material_pointer&#39;, bpy.data, &#39;materials&#39;, text=&#39;&#39;, icon=&#39;MATERIAL_DATA&#39;)
        tracked_operator(self, row, fn_name=&#39;add_material&#39;, icon=&#34;ZOOM_IN&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.ensure_parent"><code class="name flex">
<span>def <span class="ident">ensure_parent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_parent(self):
    if self.parent_to_empty:
        self.parent_name = &#39;Empty_&#39; + self.basedata_name
        collection = bpy.context.scene.collection
        scene = bpy.context.scene
        if not self.parent_name in bpy.data.objects:
            empty = bpy.data.objects.new(self.parent_name, None)
            collection.objects.link(empty)
            scene.update()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.g"><code class="name flex">
<span>def <span class="ident">g</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(self):
    self[&#39;lp&#39;] = self.get(&#39;lp&#39;, [False] * 20)
    return self[&#39;lp&#39;]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.get_alphabet"><code class="name flex">
<span>def <span class="ident">get_alphabet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alphabet(self):
    return greek_alphabet</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.get_children"><code class="name flex">
<span>def <span class="ident">get_children</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_children(self):
    # criteria: basedata_name must be in object.keys and the value must be self.basedata_name
    objects = bpy.data.objects
    objs = [obj for obj in objects if obj.type == self.data_kind]
    return [o for o in objs if o.get(&#39;basedata_name&#39;) == self.basedata_name]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.get_obj_curve"><code class="name flex">
<span>def <span class="ident">get_obj_curve</span></span>(<span>self, obj_index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_obj_curve(self, obj_index):
    curves = bpy.data.curves
    objects = bpy.data.objects
    collection = bpy.context.scene.collection

    curve_name = f&#39;{self.basedata_name}.{obj_index:04d}&#39;

    # if curve data exists, pick it up else make new curve
    cu = curves.get(curve_name)
    if not cu:
        cu = curves.new(name=curve_name, type=&#39;CURVE&#39;)
    obj = self.get_or_create_object(curve_name, obj_index, cu)

    # break down existing splines entirely.
    if cu.splines:
        cu.splines.clear()

    return obj, cu</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.get_or_create_object"><code class="name flex">
<span>def <span class="ident">get_or_create_object</span></span>(<span>self, object_name, obj_index, data)</span>
</code></dt>
<dd>
<div class="desc"><dl>
<dt>Return existing Object or create new one.</dt>
<dd>if object reference exists, pick it up else make a new one</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_object(self, object_name, obj_index, data):
    &#34;&#34;&#34;
    Return existing Object or create new one.
    : if object reference exists, pick it up else make a new one
    &#34;&#34;&#34;
    obj = bpy.data.objects.get(object_name)
    if not obj:
        obj = self.create_object(object_name, obj_index, data)
    return obj</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.group_state_update_handler"><code class="name flex">
<span>def <span class="ident">group_state_update_handler</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>since this is technically a scene/admin code controlling hierarchy, pressing
the button should result in asymmetric behaviour depending on the new state of
"self.grouping".</p>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>+
| state | desired behaviour
|</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>----- + --------------------------------------------------------------+
| True
| add all objects associated with the node to the collection
|</li>
<li>----- + --------------------------------------------------------------+
| False | remove collection, if present, and association with object
|</li>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li>+</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_state_update_handler(self, context):
    &#34;&#34;&#34;
    since this is technically a scene/admin code controlling hierarchy, pressing
    the button should result in asymmetric behaviour depending on the new state of
    &#34;self.grouping&#34;.

    + - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    | state | desired behaviour                                             |
    + ----- + --------------------------------------------------------------+
    | True  | add all objects associated with the node to the collection    |
    + ----- + --------------------------------------------------------------+
    | False | remove collection, if present, and association with object    |
    + - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    &#34;&#34;&#34;
    if self.grouping:
        updateNode(self, context)
    else:
        self.clear_collection()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.icons"><code class="name flex">
<span>def <span class="ident">icons</span></span>(<span>self, TYPE)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def icons(self, TYPE):
    NAMED_ICON = {
        &#39;object_hide_viewport&#39;: &#39;RESTRICT_VIEW&#39;,
        &#39;object_hide_render&#39;: &#39;RESTRICT_RENDER&#39;,
        &#39;object_hide_select&#39;: &#39;RESTRICT_SELECT&#39;}.get(TYPE)
    if not NAMED_ICON:
        return &#39;ERROR&#39;
    return NAMED_ICON + [&#39;_ON&#39;, &#39;_OFF&#39;][getattr(self, TYPE)]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.layer_updateNode"><code class="name flex">
<span>def <span class="ident">layer_updateNode</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>will update in place without geometry updates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_updateNode(self, context):
    &#39;&#39;&#39;will update in place without geometry updates&#39;&#39;&#39;
    for obj in self.get_children():
        obj.layers = self.layer_choice[:]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.push_custom_matrix_if_present"><code class="name flex">
<span>def <span class="ident">push_custom_matrix_if_present</span></span>(<span>self, sv_object, matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_custom_matrix_if_present(self, sv_object, matrix):
    if matrix:
        # matrix = matrix_sanitizer(matrix)
        sv_object.matrix_local = matrix
    else:
        sv_object.matrix_local = Matrix.Identity(4)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.remove_non_updated_objects"><code class="name flex">
<span>def <span class="ident">remove_non_updated_objects</span></span>(<span>self, obj_index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_non_updated_objects(self, obj_index):
    objs = self.get_children()
    obj_names = [obj.name for obj in objs if obj[&#39;idx&#39;] &gt; obj_index]
    if not obj_names:
        return

    if self.data_kind == &#39;MESH&#39;:
        kinds = bpy.data.meshes
    elif self.data_kind == &#39;CURVE&#39;:
        kinds = bpy.data.curves
    elif self.data_kind == &#39;META&#39;:
        kinds = bpy.data.metaballs
    elif self.data_kind == &#39;FONT&#39;:
        kinds = bpy.data.curves


    objects = bpy.data.objects
    collection = bpy.context.scene.collection

    if hasattr(self, &#34;grouping&#34;) and self.grouping:
        # if a node employs &#34;grouping&#34; it must also provide
        # - self.custom_collection_name (even if not directly used)
        # - self.basedata_name
        named = self.custom_collection_name or self.basedata_name
        collection = bpy.data.collections.get(named)

    # remove excess objects
    for object_name in obj_names:
        obj = objects[object_name]
        obj.hide_select = False
        collection.objects.unlink(obj)
        objects.remove(obj, do_unlink=True)

    # delete associated meshes/curves etc
    for object_name in obj_names:
        kinds.remove(kinds[object_name])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.s"><code class="name flex">
<span>def <span class="ident">s</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def s(self, value):
    val = []
    for b in zip(self[&#39;lp&#39;], value):
        val.append(b[0] != b[1])
    self[&#39;lp&#39;] = val</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.set_corresponding_materials"><code class="name flex">
<span>def <span class="ident">set_corresponding_materials</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_corresponding_materials(self):
    if self.material_pointer:
        for obj in self.get_children():
            obj.active_material = self.material_pointer</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.sv_init_helper_basedata_name"><code class="name flex">
<span>def <span class="ident">sv_init_helper_basedata_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this is to be used in sv_init, at the top</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sv_init_helper_basedata_name(self):
    &#34;&#34;&#34;
    this is to be used in sv_init, at the top
    &#34;&#34;&#34;
    dname = bpy.context.scene.sv_object_names.get_available_name()
    self.basedata_name = dname
    self.use_custom_color = True</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.to_collection"><code class="name flex">
<span>def <span class="ident">to_collection</span></span>(<span>self, objs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_collection(self, objs):
    collections = bpy.data.collections
    named = self.custom_collection_name or self.basedata_name

    # alias collection, or generate new collection and alias that
    collection = collections.get(named)
    if not collection:
        collection = collections.new(named)
        bpy.context.scene.collection.children.link(collection)

    for obj in objs:
        if obj.name not in collection.objects:
            collection.objects.link(obj)
        if obj.name in bpy.context.scene.collection.objects:
            bpy.context.scene.collection.objects.unlink(obj)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjHelper.to_parent"><code class="name flex">
<span>def <span class="ident">to_parent</span></span>(<span>self, objs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_parent(self, objs):
    for obj in objs:
        if self.parent_to_empty:
            obj.parent = bpy.data.objects[self.parent_name]
        elif obj.parent:
            obj.parent = None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback"><code class="flex name class">
<span>class <span class="ident">SvObjectsHelperCallback</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvObjectsHelperCallback(bpy.types.Operator):

    bl_idname = CALLBACK_OP
    bl_label = &#34;Sverchok objects helper&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}

    fn_name: StringProperty(default=&#39;&#39;)

    # The imformation of &#34;which node this button was pressed on&#34;
    # is not communicated unless you do it explicitly.
    tree_name: StringProperty(default=&#39;&#39;)
    node_name: StringProperty(default=&#39;&#39;)

    def execute(self, context):
        type_op = self.fn_name

        if self.tree_name and self.node_name:
            n = bpy.data.node_groups[self.tree_name].nodes[self.node_name]
        else:
            n = context.node

        objs = n.get_children()

        if type_op in {&#39;object_hide_viewport&#39;, &#39;object_hide_render&#39;, &#39;object_hide_select&#39;}:
            for obj in objs:
                stripped_op_name = type_op.replace(&#34;object_&#34;, &#39;&#39;)
                setattr(obj, stripped_op_name, getattr(n, type_op))
            setattr(n, type_op, not getattr(n, type_op))

        elif type_op == &#34;object_select&#34;:
            for obj in objs:
                obj.select_set(n.object_select)
            n.object_select = not n.object_select

        elif type_op == &#39;random_basedata_name&#39;:   # random_data_name  ?
            n.basedata_name = get_random_init_v3()

        elif type_op == &#39;add_material&#39;:
            if hasattr(n, type_op):
                # some nodes will define their own add_material..
                getattr(n, type_op)()
            else:
                # this is the simplest automatic material generator.
                mat = bpy.data.materials.new(&#39;sv_material&#39;)
                mat.use_nodes = True
                n.material = mat.name

        return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.Operator</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_idname"><code class="name">var <span class="ident">bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_label"><code class="name">var <span class="ident">bl_label</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_options"><code class="name">var <span class="ident">bl_options</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.fn_name"><code class="name">var <span class="ident">fn_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'default': '', 'attr': 'fn_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.node_name"><code class="name">var <span class="ident">node_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'default': '', 'attr': 'node_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.tree_name"><code class="name">var <span class="ident">tree_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'default': '', 'attr': 'tree_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    type_op = self.fn_name

    if self.tree_name and self.node_name:
        n = bpy.data.node_groups[self.tree_name].nodes[self.node_name]
    else:
        n = context.node

    objs = n.get_children()

    if type_op in {&#39;object_hide_viewport&#39;, &#39;object_hide_render&#39;, &#39;object_hide_select&#39;}:
        for obj in objs:
            stripped_op_name = type_op.replace(&#34;object_&#34;, &#39;&#39;)
            setattr(obj, stripped_op_name, getattr(n, type_op))
        setattr(n, type_op, not getattr(n, type_op))

    elif type_op == &#34;object_select&#34;:
        for obj in objs:
            obj.select_set(n.object_select)
        n.object_select = not n.object_select

    elif type_op == &#39;random_basedata_name&#39;:   # random_data_name  ?
        n.basedata_name = get_random_init_v3()

    elif type_op == &#39;add_material&#39;:
        if hasattr(n, type_op):
            # some nodes will define their own add_material..
            getattr(n, type_op)()
        else:
            # this is the simplest automatic material generator.
            mat = bpy.data.materials.new(&#39;sv_material&#39;)
            mat.use_nodes = True
            n.material = mat.name

    return {&#39;FINISHED&#39;}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="sverchok.utils.sv_obj_helper.enum_from_list" href="#sverchok.utils.sv_obj_helper.enum_from_list">enum_from_list</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.enum_from_list_idx" href="#sverchok.utils.sv_obj_helper.enum_from_list_idx">enum_from_list_idx</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.get_random_init_v3" href="#sverchok.utils.sv_obj_helper.get_random_init_v3">get_random_init_v3</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.register" href="#sverchok.utils.sv_obj_helper.register">register</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.tracked_operator" href="#sverchok.utils.sv_obj_helper.tracked_operator">tracked_operator</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.unregister" href="#sverchok.utils.sv_obj_helper.unregister">unregister</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper" href="#sverchok.utils.sv_obj_helper.SvObjHelper">SvObjHelper</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.activate" href="#sverchok.utils.sv_obj_helper.SvObjHelper.activate">activate</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.basedata_name" href="#sverchok.utils.sv_obj_helper.SvObjHelper.basedata_name">basedata_name</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.clear_collection" href="#sverchok.utils.sv_obj_helper.SvObjHelper.clear_collection">clear_collection</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.clear_current_mesh" href="#sverchok.utils.sv_obj_helper.SvObjHelper.clear_current_mesh">clear_current_mesh</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.create_object" href="#sverchok.utils.sv_obj_helper.SvObjHelper.create_object">create_object</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.custom_collection_name" href="#sverchok.utils.sv_obj_helper.SvObjHelper.custom_collection_name">custom_collection_name</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.data_kind" href="#sverchok.utils.sv_obj_helper.SvObjHelper.data_kind">data_kind</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.draw_ext_object_buttons" href="#sverchok.utils.sv_obj_helper.SvObjHelper.draw_ext_object_buttons">draw_ext_object_buttons</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.draw_live_and_outliner" href="#sverchok.utils.sv_obj_helper.SvObjHelper.draw_live_and_outliner">draw_live_and_outliner</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.draw_object_buttons" href="#sverchok.utils.sv_obj_helper.SvObjHelper.draw_object_buttons">draw_object_buttons</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.ensure_parent" href="#sverchok.utils.sv_obj_helper.SvObjHelper.ensure_parent">ensure_parent</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.g" href="#sverchok.utils.sv_obj_helper.SvObjHelper.g">g</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.get_alphabet" href="#sverchok.utils.sv_obj_helper.SvObjHelper.get_alphabet">get_alphabet</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.get_children" href="#sverchok.utils.sv_obj_helper.SvObjHelper.get_children">get_children</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.get_obj_curve" href="#sverchok.utils.sv_obj_helper.SvObjHelper.get_obj_curve">get_obj_curve</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.get_or_create_object" href="#sverchok.utils.sv_obj_helper.SvObjHelper.get_or_create_object">get_or_create_object</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.group_state_update_handler" href="#sverchok.utils.sv_obj_helper.SvObjHelper.group_state_update_handler">group_state_update_handler</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.icons" href="#sverchok.utils.sv_obj_helper.SvObjHelper.icons">icons</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.layer_choice" href="#sverchok.utils.sv_obj_helper.SvObjHelper.layer_choice">layer_choice</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.layer_updateNode" href="#sverchok.utils.sv_obj_helper.SvObjHelper.layer_updateNode">layer_updateNode</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.material" href="#sverchok.utils.sv_obj_helper.SvObjHelper.material">material</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.material_pointer" href="#sverchok.utils.sv_obj_helper.SvObjHelper.material_pointer">material_pointer</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_render" href="#sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_render">object_hide_render</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_select" href="#sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_select">object_hide_select</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_viewport" href="#sverchok.utils.sv_obj_helper.SvObjHelper.object_hide_viewport">object_hide_viewport</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.object_select" href="#sverchok.utils.sv_obj_helper.SvObjHelper.object_select">object_select</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.parent_name" href="#sverchok.utils.sv_obj_helper.SvObjHelper.parent_name">parent_name</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.parent_to_empty" href="#sverchok.utils.sv_obj_helper.SvObjHelper.parent_to_empty">parent_to_empty</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.push_custom_matrix_if_present" href="#sverchok.utils.sv_obj_helper.SvObjHelper.push_custom_matrix_if_present">push_custom_matrix_if_present</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.remove_non_updated_objects" href="#sverchok.utils.sv_obj_helper.SvObjHelper.remove_non_updated_objects">remove_non_updated_objects</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.s" href="#sverchok.utils.sv_obj_helper.SvObjHelper.s">s</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.set_corresponding_materials" href="#sverchok.utils.sv_obj_helper.SvObjHelper.set_corresponding_materials">set_corresponding_materials</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.show_wire" href="#sverchok.utils.sv_obj_helper.SvObjHelper.show_wire">show_wire</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.sv_init_helper_basedata_name" href="#sverchok.utils.sv_obj_helper.SvObjHelper.sv_init_helper_basedata_name">sv_init_helper_basedata_name</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.to_collection" href="#sverchok.utils.sv_obj_helper.SvObjHelper.to_collection">to_collection</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.to_parent" href="#sverchok.utils.sv_obj_helper.SvObjHelper.to_parent">to_parent</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjHelper.use_smooth" href="#sverchok.utils.sv_obj_helper.SvObjHelper.use_smooth">use_smooth</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback">SvObjectsHelperCallback</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_idname" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_idname">bl_idname</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_label" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_label">bl_label</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_options" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_options">bl_options</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_rna" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.execute" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.execute">execute</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.fn_name" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.fn_name">fn_name</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.node_name" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.node_name">node_name</a></code></li>
<li><code><a title="sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.tree_name" href="#sverchok.utils.sv_obj_helper.SvObjectsHelperCallback.tree_name">tree_name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>