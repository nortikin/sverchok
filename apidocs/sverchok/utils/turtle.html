<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.turtle API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.turtle</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

from collections import defaultdict

from sverchok.utils.sv_logging import sv_logger


class Turtle(object):
    &#34;&#34;&#34;
    Face walking turtle API.

    At each moment in time, a turtle stays on one of the mesh faces,
    and looks towards one of edges of the face:

        +---+---+---+
        |   |   |   |
        +---+---+---+
        |   | ^ |   |
        |   | @ |   |
        +---+---+---+
        |   |   |   |
        +---+---+---+

    Walking primitives are turn_next(), turn_prev() and click().
    Other methods are build from these primitives.
    One of the most used methods is step().

    For selecting faces, there are two sets of methods:

    1. select(), unselect() and toggle() to set selection state of the current face.
    2. start_selecting() and stop_selecting() to select all faces which the
       turtle is passing. The selection mask can be specified, to select, for example,
       each second face.

    This class also provides the API to &#34;paint&#34; on custom data layers of the faces.
    Three types of &#34;paints&#34; are supported: int, float and str.
    Each painting layer is identified by it&#39;s name. The turtle can paint on several
    layers at the same time.
    By default, there is only one painting layer, of type int, named Turtle.PAINT.
    One can add other painting layers by calling declare_painting_layer().
    NB 1: All painting layers must be declared BEFORE any commands to the turtle, i.e.
    right after constructor was called.
    NB 2: If you wish to use other custom data layers on the same bmesh, for purposes
    other than painting by turtle, then you have to create them BEFORE calling the Turtle
    constructor.

    One can mark some faces as obstacles. The turtle will pass through obstacles, if you
    say it to step() on it; but you can explicitly check if the turtle is going to
    enter the obstacle face with turtle.is_looking_at_obstacle, or check if the turtle
    is already at obstacle with turtle.is_at_obstacle.
    &#34;&#34;&#34;

    PREVIOUS = &#39;PREVIOUS&#39;
    NEXT = &#39;NEXT&#39;

    SELECT = &#39;SELECT&#39;
    UNSELECT = &#39;UNSELECT&#39;
    TOGGLE = &#39;TOGGLE&#39;
    MASK = &#39;MASK&#39;

    PAINT = &#39;turtle_paint&#39;

    def __init__(self, bm, bm_face = None):
        self.bmesh = bm
        # Creation of the custom data layer invalidates all
        # references to mesh&#39;s BMFaces!
        self.index_layer = bm.faces.layers.int.new(&#34;turtle_index&#34;)
        self.obstacle_layer = bm.faces.layers.int.new(&#34;turtle_obstacle&#34;)
        bm.faces.ensure_lookup_table()
        bm.faces.index_update()
        self.current_face = bm.faces[0] if bm_face is None else bm_face
        self.current_loop = self.current_face.loops[0]
        self.opposite_bias = self.PREVIOUS
        self.selection_mode = None
        self.selection_mask = None
        self.selection_cycle_index = 0
        self.current_index = 1

        self.painting_layer = dict()
        self.painting_mask = dict()
        self.painting_index = defaultdict(int)
        self.is_painting = False

        self.current_face[self.index_layer] = self.current_index
        self.declare_painting_layer(self.PAINT)

    def declare_painting_layer(self, layer_name, data_type = int):
        &#34;&#34;&#34;
        Create a custom data layer for painting.

        NB 1: All painting layers must be declared BEFORE any commands to the turtle, i.e.
        right after constructor was called.

        NB 2: If you wish to use other custom data layers on the same bmesh, for purposes
        other than painting by turtle, then you have to create them BEFORE calling the Turtle
        constructor.
        &#34;&#34;&#34;
        if data_type == int:
            layers = self.bmesh.faces.layers.int
        elif data_type == float:
            layers = self.bmesh.faces.layers.float
        elif data_type == str:
            layers = self.bmesh.faces.layers.string

        # Creation of the custom data layer invalidates all
        # references to mesh&#39;s BMFaces!
        face_index = self.current_face.index
        loop_index = self.current_loop.index
        layer = layers.new(layer_name)
        self.bmesh.faces.ensure_lookup_table()
        self.bmesh.faces.index_update()
        self.painting_layer[layer_name] = layer
        self.current_face = self.bmesh.faces[face_index]
        self.current_loop = self.current_face.loops[loop_index]

    def turn_next(self, count=1):
        &#34;&#34;&#34;
        Turn towards the next edge in the sequence.
        If face normal is oriented &#34;as usual&#34;, then this
        means &#34;turn counterclockwise&#34;.

            +----+      +----+
            |  ^ |  --&gt; |    |
            |  @ |      | &lt;@ |
            +----+      +----+

        If count is more than 1, then repeat this turn specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.current_loop = self.current_loop.link_loop_next

    def turn_prev(self, count=1):
        &#34;&#34;&#34;
        Turn towards the previous edge in the sequence.
        If face normal is oriented &#34;as usual&#34;, then this
        means &#34;turn clockwise&#34;.

            +----+      +----+
            | ^  |  --&gt; |    |
            | @  |      | @&gt; |
            +----+      +----+

        If count is more than 1, then repeat this turn specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.current_loop = self.current_loop.link_loop_prev

    def click(self):
        &#34;&#34;&#34;
        Jump to the face which is beyond the edge
        at which the turtle is looking currently.
        This turtle is a bit strange, because when it jumps it
        turns around, to look at the same edge it was looking, but
        from another side:

            +----+----+      +----+----+
            | @&gt; |    |  --&gt; |    | &lt;@ |
            +----+----+      +----+----+

        This changes the selection state of the face where the turtle
        stepped, if it is in &#34;start_selecting()&#34; mode, according to selection
        mask.

        This updates custom data layers of the face where the turtle stepped,
        if it is in &#34;start_painting()&#34; mode, according to painting masks.
        &#34;&#34;&#34;
        self.current_index += 1
        self.current_face[self.index_layer] = self.current_index
        next_loop = self.current_loop.link_loop_radial_next
        self.current_loop = next_loop
        self.current_face = next_loop.face

        sv_logger.debug(&#34;Current face # := %s&#34;, self.current_face.index)

        if self.selection_mode == self.MASK:
            if not self.selection_mask:
                raise Exception(&#34;Selection mode is set to MASK, but mask is not specified&#34;)
            n = len(self.selection_mask)
            self.selection_cycle_index = (self.selection_cycle_index + 1) % n
            mode = self.selection_mask[self.selection_cycle_index]
            if mode not in [self.SELECT, self.UNSELECT, self.TOGGLE, 0, 1, False, True]:
                raise Exception(&#34;Unsupported flag in the selection mask&#34;)
            if mode == True or mode == 1:
                mode = self.SELECT
            elif mode == False or mode == 0:
                mode = self.UNSELECT
        else:
            mode = self.selection_mode
        if mode == self.SELECT:
            self.select()
        elif mode == self.UNSELECT:
            self.unselect()
        elif mode == self.TOGGLE:
            self.toggle()

        if self.is_painting:
            for painting_layer in self.painting_layer.values():
                painting_mask = self.painting_mask.get(painting_layer.name)
                if not painting_mask:
                    raise Exception(&#34;Painting layer is set, but painting mask is not&#34;)
                n = len(painting_mask)
                self.painting_index[painting_layer.name] = (self.painting_index[painting_layer.name] + 1) % n
                value = painting_mask[self.painting_index[painting_layer.name]]
                self.current_face[painting_layer] = value
                sv_logger.debug(&#34;Paint face #%s, layer `%s&#39; with value `%s&#39;&#34;, self.current_face.index, painting_layer.name, value)

    def get_opposite_loop(self, loop, bias=None):
        &#34;&#34;&#34;
        Get the BMLoop opposite to the current one.
        This does not change current turtle or mesh state.
        &#34;&#34;&#34;
        if bias is None:
            bias = self.opposite_bias
        face = loop.face
        n = len(face.loops)
        if n % 2 == 0:
            steps = n // 2
        else:
            if bias == self.PREVIOUS:
                steps = n // 2
            else:
                steps = n // 2 + 1
        for i in range(steps):
            loop = loop.link_loop_next
        return loop

    def turn_opposite(self, bias=None):
        &#34;&#34;&#34;
        Turn the turtle around, to look at the opposite edge:

            +----+       +----+
            | @&gt; |  --&gt;  | &lt;@ |
            +----+       +----+

        If the current face has odd count of edges, then the term
        &#34;around&#34; is ambiguous:

                        +----+
                        |   &gt; \
                        |  @   *
                        |     /
                      &gt; +----+
                     /
            +----+  /
            |     \
            | &lt;@   *   ? OR ?
            |     / 
            +----+  \
                     \
                      &gt; +----+
                        |     \
                        |  @   *
                        |   &gt; /
                        +----+

        To decide in such cases, there is `bias` parameter; it can have
        one of two values: Turtle.PREVIOUS and Turtle.NEXT.
        The default value of `bias` parameter can be set as &#34;turtle.opposite_bias&#34;.
        By default it is set to Turtle.PREVIOUS.
        &#34;&#34;&#34;
        self.current_loop = self.get_opposite_loop(self.current_loop)

    def get_next_face(self, count=1, bias=None):
        &#34;&#34;&#34;
        Get the face (BMFace) which is beyond that edge at which turtle is
        currently looking. If count is greater than 1, then look for the next
        face in the same direction.
        Bias can be provided for cases of odd count of edges in the face.
        This does not change turtle or face state.
        &#34;&#34;&#34;
        face = self.current_face
        loop = self.current_loop
        for i in range(count):
            # click
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            # opposite
            loop = self.get_opposite_loop(next_loop, bias)
        return face

    def get_face_at_next(self):
        loop = self.current_loop.link_loop_next
        next_loop = loop.link_loop_radial_next
        return next_loop.face

    def get_face_at_prev(self):
        loop = self.current_loop.link_loop_prev
        next_loop = loop.link_loop_radial_next
        return next_loop.face

    def get_direct_distance_to_edge(self, check_loop, maximum = None, bias=None):
        &#34;&#34;&#34;
        Find distance to some &#34;good&#34; edge, if the turtle will step forward
        each time.

        Args:
            check_loop: function taking BMLoop and returning boolean.
            maximum: maximum number of faces to check (to prevent possible infinite loop,
                        or too long paths). None means the total number of faces in the mesh.
            bias: bias for get_next_face().

        Returns:
            number of steps to reach a &#34;good&#34; edge, or None if such edge is too far.
        &#34;&#34;&#34;
        if maximum is None:
            maximum = len(self.bmesh.faces)
        i = 0
        face = self.current_face
        loop = self.current_loop
        while True:
            if i &gt; maximum:
                return None
            if check_loop(loop):
                return i
            # click
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            # opposite
            loop = self.get_opposite_loop(next_loop, bias)
            i += 1
        return None
    
    def get_direct_distance_to_boundary(self, maximum = None, bias = None):
        &#34;&#34;&#34;
        Find distance to a boundary edge, if the turtle will step forward
        each time.

        Args:
            maximum: maximum number of faces to check (to prevent possible infinite loop,
                        or too long paths). None means the total number of faces in the mesh.
            bias: bias for get_next_face().

        Returns:
            number of steps to reach a boundary edge, or None if such edge is too far.
        &#34;&#34;&#34;
        return self.get_direct_distance_to_edge(lambda loop: loop.edge.is_boundary, maximum, bias)

    def get_direct_distance_to_obstacle(self, maximum = None, bias = None):
        &#34;&#34;&#34;
        Find distance to an edge near an obstacle, if the turtle will step forward
        each time.

        Args:
            maximum: maximum number of faces to check (to prevent possible infinite loop,
                        or too long paths). None means the total number of faces in the mesh.
            bias: bias for get_next_face().

        Returns:
            number of steps to reach an edge of an obstacle, or None if such edge is too far.
        &#34;&#34;&#34;
        if maximum is None:
            maximum = len(self.bmesh.faces)
        i = 0
        face = self.current_face
        loop = self.current_loop
        while True:
            if i &gt; maximum:
                return None
            # click
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            if face[self.obstacle_layer]:
                return i
            # opposite
            loop = self.get_opposite_loop(next_loop, bias)
            i += 1
        return None

    def step(self, count=1, bias=None, stop_at_boundary = False, stop_at_obstacle = False):
        &#34;&#34;&#34;
        Step to the next face, i.e. the face which is beyond the edge
        at which the turtle is currently looking, without changing 
        turtle&#39;s orientation.

            +----+----+      +----+----+
            | @&gt; |    |  --&gt; |    | @&gt; |
            +----+----+      +----+----+

        If count is greater than 1, then repeat this step the specified
        number of times.
        Bias can be provided for cases of odd count of edges in the face.
        &#34;&#34;&#34;
        for i in range(count):
            self.click()
            self.turn_opposite(bias=bias)
            if stop_at_boundary:
                if self.is_looking_at_boundary:
                    break
            if stop_at_obstacle:
                if self.is_looking_at_obstacle:
                    break

    def step_back(self, count=1, bias=None):
        &#34;&#34;&#34;
        Similar to step(), but step backwards:

            +----+----+      +----+----+
            |    | @&gt; |  --&gt; | @&gt; |    |
            +----+----+      +----+----+
        &#34;&#34;&#34;
        for i in range(count):
            self.turn_opposite(bias=bias)
            self.click()

    def strafe_next(self, count=1, stop_at_boundary = False, stop_at_obstacle = False):
        &#34;&#34;&#34;
        Step to the face which is in the &#34;next&#34; (i.e. usually counterclockwise)
        direction, without changing turtle&#39;s orientation:

            +----+----+      +----+----+
            |    |  ^ |      |  ^ |    |
            |    |  @ |  --&gt; |  @ |    |
            +----+----+      +----+----+

        If count is greater than 1, then repeat this step the specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.turn_next()
            if stop_at_boundary:
                if self.is_looking_at_boundary:
                    self.turn_prev()
                    break
            if stop_at_obstacle:
                if self.is_looking_at_obstacle:
                    self.turn_prev()
                    break
            self.click()
            self.turn_next()

    def strafe_prev(self, count=1, stop_at_boundary = False, stop_at_obstacle = False):
        &#34;&#34;&#34;
        Step to the face which is in the &#34;prev&#34; (i.e. usually clockwise)
        direction, without changing turtle&#39;s orientation:

            +----+----+      +----+----+
            |  ^ |    |      |    |  ^ |
            |  @ |    |  --&gt; |    |  @ |
            +----+----+      +----+----+

        If count is greater than 1, then repeat this step the specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.turn_prev()
            if stop_at_boundary:
                if self.is_looking_at_boundary:
                    self.turn_next()
                    break
            if stop_at_obstacle:
                if self.is_looking_at_obstacle:
                    self.turn_next()
                    break
            self.click()
            self.turn_prev()

    def zig_zag(self, steps=1, leg=0, turns=1):
        for i in range(steps):
            self.step(count=leg)
            self.click()
            self.turn_next(turns)
            self.step(count=leg)
            self.click()
            self.turn_prev(turns)

    def select(self):
        &#34;&#34;&#34;
        Mark the current face as selected.
        &#34;&#34;&#34;
        self.current_face.select = True
        sv_logger.debug(&#34;Selecting face #%s&#34;, self.current_face.index)

    def unselect(self):
        &#34;&#34;&#34;
        Mark the current face as not selected.
        &#34;&#34;&#34;
        self.current_face.select = False
        sv_logger.debug(&#34;Unselecting face #%s&#34;, self.current_face.index)

    def toggle(self):
        &#34;&#34;&#34;
        Toggle the selection state of the current face.
        &#34;&#34;&#34;
        self.current_face.select = not self.current_face.select
        sv_logger.debug(&#34;Set face #%s selection := %s&#34;, self.current_face.index, self.current_face.select)

    def start_selecting(self, mode = None, mask=None):
        &#34;&#34;&#34;
        Start selecting faces which the turtle passes.
        This mode can be stopped by calling stop_selecting().

        Args:
            mode: selection mode. Can be Turtle.SELECT, Turtle.UNSELECT, Turtle.TOGGLE or Turtle.MASK.
            mask: selection mask. Used with mode == Turtle.MASK. The mask is used with
                  infinite repetition. For example:

                      turtle.start_selecting(mode = Turtle.MASK, mask = [0, 1])
                      turtle.step(6)
                      turtle.stop_selecting()

                  This will select each other face: 0[1]2[3]4[5].

        If mask is not specified, then the mask used with the previous start_selecting() call
        will be used. If the mask was never provided, there will be an exception.
        &#34;&#34;&#34;
        if mode is None:
            mode = self.SELECT
        self.selection_mode = mode
        if mode == self.MASK:
            if not mask and not self.selection_mask:
                raise Exception(&#34;You have to specify the mask when setting selection mode to MASK&#34;)
            if mask:
                self.selection_mask = mask

    def stop_selecting(self):
        &#34;&#34;&#34;
        Stop selecting faces which the turtle passes.
        &#34;&#34;&#34;
        self.selection_mode = None

    def paint(self, value, layer_name = PAINT):
        &#34;&#34;&#34;
        Paint the current face with specified value, on specified layer.
        The painting layer must be defined by calling declare_painting_layer()
        right after calling the Turtle() constructor. By default, there is
        one painting layer, named Turtle.PAINT.
        &#34;&#34;&#34;
        layer = self.painting_layer[layer_name]
        self.current_face[layer] = value

    def start_painting(self, value = None, layer_name = PAINT):
        &#34;&#34;&#34;
        Start painting faces which the turtle passes.
        If value is not specified, then the value used with previous
        start_painting() call will be used. If the value was never provided,
        there will be an exception.

        A list of values can be specified instead of the single value. In this
        case, these values will be used in order, with repetition.
        The painting layer must be defined by calling declare_painting_layer()
        right after calling the Turtle() constructor. By default, there is
        one painting layer, named Turtle.PAINT.
        &#34;&#34;&#34;
        if value is not None and not isinstance(value, (list, tuple)):
            value = [value]
        layer = self.painting_layer.get(layer_name)
        if layer is None:
            raise Exception(&#34;This layer was not declared&#34;)
        if value is None and self.painting_mask.get(layer_name) is None:
            raise Exception(&#34;Painting mask was not specified&#34;)
        if value is not None:
            self.painting_mask[layer_name] = value
        self.is_painting = True

    def stop_painting(self, layer_name = PAINT):
        &#34;&#34;&#34;
        Stop painting faces which the turtle passes.
        &#34;&#34;&#34;
        self.is_painting = False

    def reset_selection_cycle(self):
        self.selection_cycle_index = 0

    def reset_painting_cycle(self, layer_name = PAINT):
        self.painting_index[layer_name] = 0

    def set_is_obstacle(self, is_obstacle):
        &#34;&#34;&#34;
        Mark current face as an obstacle.
        &#34;Obstacle&#34; is just a boolean indicator, that can be
        checked with turtle.get_is_obstacle or turtle.is_looking_at_obstacle.

        Args:
            is_obstacle : boolean or int, 1 or True for marking face as obstacle.
        &#34;&#34;&#34;
        self.current_face[self.obstacle_layer] = int(is_obstacle)

    def get_is_obstacle(self, face):
        return bool(face[self.obstacle_layer])

    @property
    def is_at_obstacle(self):
        &#34;&#34;&#34;
        Contains True if the turtle is currently at face which was marked
        as an obstacle.
        &#34;&#34;&#34;
        return bool(self.current_face[self.obstacle_layer])

    def set_obstacle_mask(self, face_mask, invert=False):
        &#34;&#34;&#34;
        Set obstacle indicators for all faces of the mesh.

        Args:
            face_mask: list of booleans or ints, True or 1 to mark face as an obstacle.
            invert: boolean, default false: set to True to invert the meaning of face_mask.
        &#34;&#34;&#34;
        for is_obstacle, face in zip(face_mask, self.bmesh.faces):
            if invert:
                face[self.obstacle_layer] = 1 - int(is_obstacle)
            else:
                face[self.obstacle_layer] = int(is_obstacle)

    @property
    def is_looking_at_obstacle(self):
        &#34;&#34;&#34;
        Contains True if the face beyond the edge at which the turtle is currently
        looking was marked as an obstacle.
        &#34;&#34;&#34;
        face = self.get_next_face()
        return bool(face[self.obstacle_layer])

    def get_selected_faces_pydata(self):
        &#34;&#34;&#34;
        Return list of selected faces in Sverchok format.
        &#34;&#34;&#34;
        return [[vert.index for vert in face.verts] for face in self.bmesh.faces if face.select]

    def get_selected_faces(self):
        &#34;&#34;&#34;
        Return list of selected faces.
        returns: list of BMFace.
        &#34;&#34;&#34;
        return [face for face in self.bmesh.faces if face.select]

    def get_selection_mask(self):
        &#34;&#34;&#34;
        Returns selection mask.
        result: list of booleans.
        &#34;&#34;&#34;
        return [face.select for face in self.bmesh.faces]

    def get_painting_value(self, face, layer_name = PAINT):
        layer = self.painting_layer[layer_name]
        return face[layer]

    def get_painting_data(self, layer_name = PAINT):
        layer = self.painting_layer[layer_name]
        return [face[layer] for face in self.bmesh.faces]

    def get_is_looking_at_face_ring(self, max_length = None, consider_obstacles = True, bias = None):
        if max_length is None:
            max_length = len(self.bmesh.faces)
        loop = self.current_loop
        face = self.current_face
        i = 0
        while True:
            if i &gt; max_length:
                return False
            i += 1
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            if consider_obstacles and face[self.obstacle_layer]:
                return False
            loop = self.get_opposite_loop(next_loop, bias)
            if loop.edge.is_boundary:
                return False
            if face == self.current_face:
                return True
        return False

    def was_at_face(self, face):
        &#34;&#34;&#34;
        Whether the turtle already has previously visited the given face.

        Args:
            face : BMFace

        Returns:
            boolean
        &#34;&#34;&#34;
        v = face[self.index_layer]
        return (v != 0)

    @property
    def is_looking_at_boundary(self):
        &#34;&#34;&#34;
        Contains True if the edge at which the turtle is currently looking
        is a boundary edge.
        &#34;&#34;&#34;
        return self.current_loop.edge.is_boundary

    @property
    def is_at_boundary(self):
        &#34;&#34;&#34;
        Contains True if the current face is a boundary face.
        &#34;&#34;&#34;
        return any(edge.is_boundary for edge in self.current_face.edges)

    @property
    def was_here(self):
        &#34;&#34;&#34;
        Contains True if the turtle has previously visited the current face.
        &#34;&#34;&#34;
        return self.was_at_face(self.current_face)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.turtle.Turtle"><code class="flex name class">
<span>class <span class="ident">Turtle</span></span>
<span>(</span><span>bm, bm_face=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Face walking turtle API.</p>
<p>At each moment in time, a turtle stays on one of the mesh faces,
and looks towards one of edges of the face:</p>
<pre><code>+---+---+---+
|   |   |   |
+---+---+---+
|   | ^ |   |
|   | @ |   |
+---+---+---+
|   |   |   |
+---+---+---+
</code></pre>
<p>Walking primitives are turn_next(), turn_prev() and click().
Other methods are build from these primitives.
One of the most used methods is step().</p>
<p>For selecting faces, there are two sets of methods:</p>
<ol>
<li>select(), unselect() and toggle() to set selection state of the current face.</li>
<li>start_selecting() and stop_selecting() to select all faces which the
turtle is passing. The selection mask can be specified, to select, for example,
each second face.</li>
</ol>
<p>This class also provides the API to "paint" on custom data layers of the faces.
Three types of "paints" are supported: int, float and str.
Each painting layer is identified by it's name. The turtle can paint on several
layers at the same time.
By default, there is only one painting layer, of type int, named Turtle.PAINT.
One can add other painting layers by calling declare_painting_layer().
NB 1: All painting layers must be declared BEFORE any commands to the turtle, i.e.
right after constructor was called.
NB 2: If you wish to use other custom data layers on the same bmesh, for purposes
other than painting by turtle, then you have to create them BEFORE calling the Turtle
constructor.</p>
<p>One can mark some faces as obstacles. The turtle will pass through obstacles, if you
say it to step() on it; but you can explicitly check if the turtle is going to
enter the obstacle face with turtle.is_looking_at_obstacle, or check if the turtle
is already at obstacle with turtle.is_at_obstacle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Turtle(object):
    &#34;&#34;&#34;
    Face walking turtle API.

    At each moment in time, a turtle stays on one of the mesh faces,
    and looks towards one of edges of the face:

        +---+---+---+
        |   |   |   |
        +---+---+---+
        |   | ^ |   |
        |   | @ |   |
        +---+---+---+
        |   |   |   |
        +---+---+---+

    Walking primitives are turn_next(), turn_prev() and click().
    Other methods are build from these primitives.
    One of the most used methods is step().

    For selecting faces, there are two sets of methods:

    1. select(), unselect() and toggle() to set selection state of the current face.
    2. start_selecting() and stop_selecting() to select all faces which the
       turtle is passing. The selection mask can be specified, to select, for example,
       each second face.

    This class also provides the API to &#34;paint&#34; on custom data layers of the faces.
    Three types of &#34;paints&#34; are supported: int, float and str.
    Each painting layer is identified by it&#39;s name. The turtle can paint on several
    layers at the same time.
    By default, there is only one painting layer, of type int, named Turtle.PAINT.
    One can add other painting layers by calling declare_painting_layer().
    NB 1: All painting layers must be declared BEFORE any commands to the turtle, i.e.
    right after constructor was called.
    NB 2: If you wish to use other custom data layers on the same bmesh, for purposes
    other than painting by turtle, then you have to create them BEFORE calling the Turtle
    constructor.

    One can mark some faces as obstacles. The turtle will pass through obstacles, if you
    say it to step() on it; but you can explicitly check if the turtle is going to
    enter the obstacle face with turtle.is_looking_at_obstacle, or check if the turtle
    is already at obstacle with turtle.is_at_obstacle.
    &#34;&#34;&#34;

    PREVIOUS = &#39;PREVIOUS&#39;
    NEXT = &#39;NEXT&#39;

    SELECT = &#39;SELECT&#39;
    UNSELECT = &#39;UNSELECT&#39;
    TOGGLE = &#39;TOGGLE&#39;
    MASK = &#39;MASK&#39;

    PAINT = &#39;turtle_paint&#39;

    def __init__(self, bm, bm_face = None):
        self.bmesh = bm
        # Creation of the custom data layer invalidates all
        # references to mesh&#39;s BMFaces!
        self.index_layer = bm.faces.layers.int.new(&#34;turtle_index&#34;)
        self.obstacle_layer = bm.faces.layers.int.new(&#34;turtle_obstacle&#34;)
        bm.faces.ensure_lookup_table()
        bm.faces.index_update()
        self.current_face = bm.faces[0] if bm_face is None else bm_face
        self.current_loop = self.current_face.loops[0]
        self.opposite_bias = self.PREVIOUS
        self.selection_mode = None
        self.selection_mask = None
        self.selection_cycle_index = 0
        self.current_index = 1

        self.painting_layer = dict()
        self.painting_mask = dict()
        self.painting_index = defaultdict(int)
        self.is_painting = False

        self.current_face[self.index_layer] = self.current_index
        self.declare_painting_layer(self.PAINT)

    def declare_painting_layer(self, layer_name, data_type = int):
        &#34;&#34;&#34;
        Create a custom data layer for painting.

        NB 1: All painting layers must be declared BEFORE any commands to the turtle, i.e.
        right after constructor was called.

        NB 2: If you wish to use other custom data layers on the same bmesh, for purposes
        other than painting by turtle, then you have to create them BEFORE calling the Turtle
        constructor.
        &#34;&#34;&#34;
        if data_type == int:
            layers = self.bmesh.faces.layers.int
        elif data_type == float:
            layers = self.bmesh.faces.layers.float
        elif data_type == str:
            layers = self.bmesh.faces.layers.string

        # Creation of the custom data layer invalidates all
        # references to mesh&#39;s BMFaces!
        face_index = self.current_face.index
        loop_index = self.current_loop.index
        layer = layers.new(layer_name)
        self.bmesh.faces.ensure_lookup_table()
        self.bmesh.faces.index_update()
        self.painting_layer[layer_name] = layer
        self.current_face = self.bmesh.faces[face_index]
        self.current_loop = self.current_face.loops[loop_index]

    def turn_next(self, count=1):
        &#34;&#34;&#34;
        Turn towards the next edge in the sequence.
        If face normal is oriented &#34;as usual&#34;, then this
        means &#34;turn counterclockwise&#34;.

            +----+      +----+
            |  ^ |  --&gt; |    |
            |  @ |      | &lt;@ |
            +----+      +----+

        If count is more than 1, then repeat this turn specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.current_loop = self.current_loop.link_loop_next

    def turn_prev(self, count=1):
        &#34;&#34;&#34;
        Turn towards the previous edge in the sequence.
        If face normal is oriented &#34;as usual&#34;, then this
        means &#34;turn clockwise&#34;.

            +----+      +----+
            | ^  |  --&gt; |    |
            | @  |      | @&gt; |
            +----+      +----+

        If count is more than 1, then repeat this turn specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.current_loop = self.current_loop.link_loop_prev

    def click(self):
        &#34;&#34;&#34;
        Jump to the face which is beyond the edge
        at which the turtle is looking currently.
        This turtle is a bit strange, because when it jumps it
        turns around, to look at the same edge it was looking, but
        from another side:

            +----+----+      +----+----+
            | @&gt; |    |  --&gt; |    | &lt;@ |
            +----+----+      +----+----+

        This changes the selection state of the face where the turtle
        stepped, if it is in &#34;start_selecting()&#34; mode, according to selection
        mask.

        This updates custom data layers of the face where the turtle stepped,
        if it is in &#34;start_painting()&#34; mode, according to painting masks.
        &#34;&#34;&#34;
        self.current_index += 1
        self.current_face[self.index_layer] = self.current_index
        next_loop = self.current_loop.link_loop_radial_next
        self.current_loop = next_loop
        self.current_face = next_loop.face

        sv_logger.debug(&#34;Current face # := %s&#34;, self.current_face.index)

        if self.selection_mode == self.MASK:
            if not self.selection_mask:
                raise Exception(&#34;Selection mode is set to MASK, but mask is not specified&#34;)
            n = len(self.selection_mask)
            self.selection_cycle_index = (self.selection_cycle_index + 1) % n
            mode = self.selection_mask[self.selection_cycle_index]
            if mode not in [self.SELECT, self.UNSELECT, self.TOGGLE, 0, 1, False, True]:
                raise Exception(&#34;Unsupported flag in the selection mask&#34;)
            if mode == True or mode == 1:
                mode = self.SELECT
            elif mode == False or mode == 0:
                mode = self.UNSELECT
        else:
            mode = self.selection_mode
        if mode == self.SELECT:
            self.select()
        elif mode == self.UNSELECT:
            self.unselect()
        elif mode == self.TOGGLE:
            self.toggle()

        if self.is_painting:
            for painting_layer in self.painting_layer.values():
                painting_mask = self.painting_mask.get(painting_layer.name)
                if not painting_mask:
                    raise Exception(&#34;Painting layer is set, but painting mask is not&#34;)
                n = len(painting_mask)
                self.painting_index[painting_layer.name] = (self.painting_index[painting_layer.name] + 1) % n
                value = painting_mask[self.painting_index[painting_layer.name]]
                self.current_face[painting_layer] = value
                sv_logger.debug(&#34;Paint face #%s, layer `%s&#39; with value `%s&#39;&#34;, self.current_face.index, painting_layer.name, value)

    def get_opposite_loop(self, loop, bias=None):
        &#34;&#34;&#34;
        Get the BMLoop opposite to the current one.
        This does not change current turtle or mesh state.
        &#34;&#34;&#34;
        if bias is None:
            bias = self.opposite_bias
        face = loop.face
        n = len(face.loops)
        if n % 2 == 0:
            steps = n // 2
        else:
            if bias == self.PREVIOUS:
                steps = n // 2
            else:
                steps = n // 2 + 1
        for i in range(steps):
            loop = loop.link_loop_next
        return loop

    def turn_opposite(self, bias=None):
        &#34;&#34;&#34;
        Turn the turtle around, to look at the opposite edge:

            +----+       +----+
            | @&gt; |  --&gt;  | &lt;@ |
            +----+       +----+

        If the current face has odd count of edges, then the term
        &#34;around&#34; is ambiguous:

                        +----+
                        |   &gt; \
                        |  @   *
                        |     /
                      &gt; +----+
                     /
            +----+  /
            |     \
            | &lt;@   *   ? OR ?
            |     / 
            +----+  \
                     \
                      &gt; +----+
                        |     \
                        |  @   *
                        |   &gt; /
                        +----+

        To decide in such cases, there is `bias` parameter; it can have
        one of two values: Turtle.PREVIOUS and Turtle.NEXT.
        The default value of `bias` parameter can be set as &#34;turtle.opposite_bias&#34;.
        By default it is set to Turtle.PREVIOUS.
        &#34;&#34;&#34;
        self.current_loop = self.get_opposite_loop(self.current_loop)

    def get_next_face(self, count=1, bias=None):
        &#34;&#34;&#34;
        Get the face (BMFace) which is beyond that edge at which turtle is
        currently looking. If count is greater than 1, then look for the next
        face in the same direction.
        Bias can be provided for cases of odd count of edges in the face.
        This does not change turtle or face state.
        &#34;&#34;&#34;
        face = self.current_face
        loop = self.current_loop
        for i in range(count):
            # click
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            # opposite
            loop = self.get_opposite_loop(next_loop, bias)
        return face

    def get_face_at_next(self):
        loop = self.current_loop.link_loop_next
        next_loop = loop.link_loop_radial_next
        return next_loop.face

    def get_face_at_prev(self):
        loop = self.current_loop.link_loop_prev
        next_loop = loop.link_loop_radial_next
        return next_loop.face

    def get_direct_distance_to_edge(self, check_loop, maximum = None, bias=None):
        &#34;&#34;&#34;
        Find distance to some &#34;good&#34; edge, if the turtle will step forward
        each time.

        Args:
            check_loop: function taking BMLoop and returning boolean.
            maximum: maximum number of faces to check (to prevent possible infinite loop,
                        or too long paths). None means the total number of faces in the mesh.
            bias: bias for get_next_face().

        Returns:
            number of steps to reach a &#34;good&#34; edge, or None if such edge is too far.
        &#34;&#34;&#34;
        if maximum is None:
            maximum = len(self.bmesh.faces)
        i = 0
        face = self.current_face
        loop = self.current_loop
        while True:
            if i &gt; maximum:
                return None
            if check_loop(loop):
                return i
            # click
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            # opposite
            loop = self.get_opposite_loop(next_loop, bias)
            i += 1
        return None
    
    def get_direct_distance_to_boundary(self, maximum = None, bias = None):
        &#34;&#34;&#34;
        Find distance to a boundary edge, if the turtle will step forward
        each time.

        Args:
            maximum: maximum number of faces to check (to prevent possible infinite loop,
                        or too long paths). None means the total number of faces in the mesh.
            bias: bias for get_next_face().

        Returns:
            number of steps to reach a boundary edge, or None if such edge is too far.
        &#34;&#34;&#34;
        return self.get_direct_distance_to_edge(lambda loop: loop.edge.is_boundary, maximum, bias)

    def get_direct_distance_to_obstacle(self, maximum = None, bias = None):
        &#34;&#34;&#34;
        Find distance to an edge near an obstacle, if the turtle will step forward
        each time.

        Args:
            maximum: maximum number of faces to check (to prevent possible infinite loop,
                        or too long paths). None means the total number of faces in the mesh.
            bias: bias for get_next_face().

        Returns:
            number of steps to reach an edge of an obstacle, or None if such edge is too far.
        &#34;&#34;&#34;
        if maximum is None:
            maximum = len(self.bmesh.faces)
        i = 0
        face = self.current_face
        loop = self.current_loop
        while True:
            if i &gt; maximum:
                return None
            # click
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            if face[self.obstacle_layer]:
                return i
            # opposite
            loop = self.get_opposite_loop(next_loop, bias)
            i += 1
        return None

    def step(self, count=1, bias=None, stop_at_boundary = False, stop_at_obstacle = False):
        &#34;&#34;&#34;
        Step to the next face, i.e. the face which is beyond the edge
        at which the turtle is currently looking, without changing 
        turtle&#39;s orientation.

            +----+----+      +----+----+
            | @&gt; |    |  --&gt; |    | @&gt; |
            +----+----+      +----+----+

        If count is greater than 1, then repeat this step the specified
        number of times.
        Bias can be provided for cases of odd count of edges in the face.
        &#34;&#34;&#34;
        for i in range(count):
            self.click()
            self.turn_opposite(bias=bias)
            if stop_at_boundary:
                if self.is_looking_at_boundary:
                    break
            if stop_at_obstacle:
                if self.is_looking_at_obstacle:
                    break

    def step_back(self, count=1, bias=None):
        &#34;&#34;&#34;
        Similar to step(), but step backwards:

            +----+----+      +----+----+
            |    | @&gt; |  --&gt; | @&gt; |    |
            +----+----+      +----+----+
        &#34;&#34;&#34;
        for i in range(count):
            self.turn_opposite(bias=bias)
            self.click()

    def strafe_next(self, count=1, stop_at_boundary = False, stop_at_obstacle = False):
        &#34;&#34;&#34;
        Step to the face which is in the &#34;next&#34; (i.e. usually counterclockwise)
        direction, without changing turtle&#39;s orientation:

            +----+----+      +----+----+
            |    |  ^ |      |  ^ |    |
            |    |  @ |  --&gt; |  @ |    |
            +----+----+      +----+----+

        If count is greater than 1, then repeat this step the specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.turn_next()
            if stop_at_boundary:
                if self.is_looking_at_boundary:
                    self.turn_prev()
                    break
            if stop_at_obstacle:
                if self.is_looking_at_obstacle:
                    self.turn_prev()
                    break
            self.click()
            self.turn_next()

    def strafe_prev(self, count=1, stop_at_boundary = False, stop_at_obstacle = False):
        &#34;&#34;&#34;
        Step to the face which is in the &#34;prev&#34; (i.e. usually clockwise)
        direction, without changing turtle&#39;s orientation:

            +----+----+      +----+----+
            |  ^ |    |      |    |  ^ |
            |  @ |    |  --&gt; |    |  @ |
            +----+----+      +----+----+

        If count is greater than 1, then repeat this step the specified
        number of times.
        &#34;&#34;&#34;
        for i in range(count):
            self.turn_prev()
            if stop_at_boundary:
                if self.is_looking_at_boundary:
                    self.turn_next()
                    break
            if stop_at_obstacle:
                if self.is_looking_at_obstacle:
                    self.turn_next()
                    break
            self.click()
            self.turn_prev()

    def zig_zag(self, steps=1, leg=0, turns=1):
        for i in range(steps):
            self.step(count=leg)
            self.click()
            self.turn_next(turns)
            self.step(count=leg)
            self.click()
            self.turn_prev(turns)

    def select(self):
        &#34;&#34;&#34;
        Mark the current face as selected.
        &#34;&#34;&#34;
        self.current_face.select = True
        sv_logger.debug(&#34;Selecting face #%s&#34;, self.current_face.index)

    def unselect(self):
        &#34;&#34;&#34;
        Mark the current face as not selected.
        &#34;&#34;&#34;
        self.current_face.select = False
        sv_logger.debug(&#34;Unselecting face #%s&#34;, self.current_face.index)

    def toggle(self):
        &#34;&#34;&#34;
        Toggle the selection state of the current face.
        &#34;&#34;&#34;
        self.current_face.select = not self.current_face.select
        sv_logger.debug(&#34;Set face #%s selection := %s&#34;, self.current_face.index, self.current_face.select)

    def start_selecting(self, mode = None, mask=None):
        &#34;&#34;&#34;
        Start selecting faces which the turtle passes.
        This mode can be stopped by calling stop_selecting().

        Args:
            mode: selection mode. Can be Turtle.SELECT, Turtle.UNSELECT, Turtle.TOGGLE or Turtle.MASK.
            mask: selection mask. Used with mode == Turtle.MASK. The mask is used with
                  infinite repetition. For example:

                      turtle.start_selecting(mode = Turtle.MASK, mask = [0, 1])
                      turtle.step(6)
                      turtle.stop_selecting()

                  This will select each other face: 0[1]2[3]4[5].

        If mask is not specified, then the mask used with the previous start_selecting() call
        will be used. If the mask was never provided, there will be an exception.
        &#34;&#34;&#34;
        if mode is None:
            mode = self.SELECT
        self.selection_mode = mode
        if mode == self.MASK:
            if not mask and not self.selection_mask:
                raise Exception(&#34;You have to specify the mask when setting selection mode to MASK&#34;)
            if mask:
                self.selection_mask = mask

    def stop_selecting(self):
        &#34;&#34;&#34;
        Stop selecting faces which the turtle passes.
        &#34;&#34;&#34;
        self.selection_mode = None

    def paint(self, value, layer_name = PAINT):
        &#34;&#34;&#34;
        Paint the current face with specified value, on specified layer.
        The painting layer must be defined by calling declare_painting_layer()
        right after calling the Turtle() constructor. By default, there is
        one painting layer, named Turtle.PAINT.
        &#34;&#34;&#34;
        layer = self.painting_layer[layer_name]
        self.current_face[layer] = value

    def start_painting(self, value = None, layer_name = PAINT):
        &#34;&#34;&#34;
        Start painting faces which the turtle passes.
        If value is not specified, then the value used with previous
        start_painting() call will be used. If the value was never provided,
        there will be an exception.

        A list of values can be specified instead of the single value. In this
        case, these values will be used in order, with repetition.
        The painting layer must be defined by calling declare_painting_layer()
        right after calling the Turtle() constructor. By default, there is
        one painting layer, named Turtle.PAINT.
        &#34;&#34;&#34;
        if value is not None and not isinstance(value, (list, tuple)):
            value = [value]
        layer = self.painting_layer.get(layer_name)
        if layer is None:
            raise Exception(&#34;This layer was not declared&#34;)
        if value is None and self.painting_mask.get(layer_name) is None:
            raise Exception(&#34;Painting mask was not specified&#34;)
        if value is not None:
            self.painting_mask[layer_name] = value
        self.is_painting = True

    def stop_painting(self, layer_name = PAINT):
        &#34;&#34;&#34;
        Stop painting faces which the turtle passes.
        &#34;&#34;&#34;
        self.is_painting = False

    def reset_selection_cycle(self):
        self.selection_cycle_index = 0

    def reset_painting_cycle(self, layer_name = PAINT):
        self.painting_index[layer_name] = 0

    def set_is_obstacle(self, is_obstacle):
        &#34;&#34;&#34;
        Mark current face as an obstacle.
        &#34;Obstacle&#34; is just a boolean indicator, that can be
        checked with turtle.get_is_obstacle or turtle.is_looking_at_obstacle.

        Args:
            is_obstacle : boolean or int, 1 or True for marking face as obstacle.
        &#34;&#34;&#34;
        self.current_face[self.obstacle_layer] = int(is_obstacle)

    def get_is_obstacle(self, face):
        return bool(face[self.obstacle_layer])

    @property
    def is_at_obstacle(self):
        &#34;&#34;&#34;
        Contains True if the turtle is currently at face which was marked
        as an obstacle.
        &#34;&#34;&#34;
        return bool(self.current_face[self.obstacle_layer])

    def set_obstacle_mask(self, face_mask, invert=False):
        &#34;&#34;&#34;
        Set obstacle indicators for all faces of the mesh.

        Args:
            face_mask: list of booleans or ints, True or 1 to mark face as an obstacle.
            invert: boolean, default false: set to True to invert the meaning of face_mask.
        &#34;&#34;&#34;
        for is_obstacle, face in zip(face_mask, self.bmesh.faces):
            if invert:
                face[self.obstacle_layer] = 1 - int(is_obstacle)
            else:
                face[self.obstacle_layer] = int(is_obstacle)

    @property
    def is_looking_at_obstacle(self):
        &#34;&#34;&#34;
        Contains True if the face beyond the edge at which the turtle is currently
        looking was marked as an obstacle.
        &#34;&#34;&#34;
        face = self.get_next_face()
        return bool(face[self.obstacle_layer])

    def get_selected_faces_pydata(self):
        &#34;&#34;&#34;
        Return list of selected faces in Sverchok format.
        &#34;&#34;&#34;
        return [[vert.index for vert in face.verts] for face in self.bmesh.faces if face.select]

    def get_selected_faces(self):
        &#34;&#34;&#34;
        Return list of selected faces.
        returns: list of BMFace.
        &#34;&#34;&#34;
        return [face for face in self.bmesh.faces if face.select]

    def get_selection_mask(self):
        &#34;&#34;&#34;
        Returns selection mask.
        result: list of booleans.
        &#34;&#34;&#34;
        return [face.select for face in self.bmesh.faces]

    def get_painting_value(self, face, layer_name = PAINT):
        layer = self.painting_layer[layer_name]
        return face[layer]

    def get_painting_data(self, layer_name = PAINT):
        layer = self.painting_layer[layer_name]
        return [face[layer] for face in self.bmesh.faces]

    def get_is_looking_at_face_ring(self, max_length = None, consider_obstacles = True, bias = None):
        if max_length is None:
            max_length = len(self.bmesh.faces)
        loop = self.current_loop
        face = self.current_face
        i = 0
        while True:
            if i &gt; max_length:
                return False
            i += 1
            next_loop = loop.link_loop_radial_next
            face = next_loop.face
            if consider_obstacles and face[self.obstacle_layer]:
                return False
            loop = self.get_opposite_loop(next_loop, bias)
            if loop.edge.is_boundary:
                return False
            if face == self.current_face:
                return True
        return False

    def was_at_face(self, face):
        &#34;&#34;&#34;
        Whether the turtle already has previously visited the given face.

        Args:
            face : BMFace

        Returns:
            boolean
        &#34;&#34;&#34;
        v = face[self.index_layer]
        return (v != 0)

    @property
    def is_looking_at_boundary(self):
        &#34;&#34;&#34;
        Contains True if the edge at which the turtle is currently looking
        is a boundary edge.
        &#34;&#34;&#34;
        return self.current_loop.edge.is_boundary

    @property
    def is_at_boundary(self):
        &#34;&#34;&#34;
        Contains True if the current face is a boundary face.
        &#34;&#34;&#34;
        return any(edge.is_boundary for edge in self.current_face.edges)

    @property
    def was_here(self):
        &#34;&#34;&#34;
        Contains True if the turtle has previously visited the current face.
        &#34;&#34;&#34;
        return self.was_at_face(self.current_face)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.turtle.Turtle.MASK"><code class="name">var <span class="ident">MASK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.turtle.Turtle.NEXT"><code class="name">var <span class="ident">NEXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.turtle.Turtle.PAINT"><code class="name">var <span class="ident">PAINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.turtle.Turtle.PREVIOUS"><code class="name">var <span class="ident">PREVIOUS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.turtle.Turtle.SELECT"><code class="name">var <span class="ident">SELECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.turtle.Turtle.TOGGLE"><code class="name">var <span class="ident">TOGGLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.turtle.Turtle.UNSELECT"><code class="name">var <span class="ident">UNSELECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.turtle.Turtle.is_at_boundary"><code class="name">var <span class="ident">is_at_boundary</span></code></dt>
<dd>
<div class="desc"><p>Contains True if the current face is a boundary face.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_at_boundary(self):
    &#34;&#34;&#34;
    Contains True if the current face is a boundary face.
    &#34;&#34;&#34;
    return any(edge.is_boundary for edge in self.current_face.edges)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.is_at_obstacle"><code class="name">var <span class="ident">is_at_obstacle</span></code></dt>
<dd>
<div class="desc"><p>Contains True if the turtle is currently at face which was marked
as an obstacle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_at_obstacle(self):
    &#34;&#34;&#34;
    Contains True if the turtle is currently at face which was marked
    as an obstacle.
    &#34;&#34;&#34;
    return bool(self.current_face[self.obstacle_layer])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.is_looking_at_boundary"><code class="name">var <span class="ident">is_looking_at_boundary</span></code></dt>
<dd>
<div class="desc"><p>Contains True if the edge at which the turtle is currently looking
is a boundary edge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_looking_at_boundary(self):
    &#34;&#34;&#34;
    Contains True if the edge at which the turtle is currently looking
    is a boundary edge.
    &#34;&#34;&#34;
    return self.current_loop.edge.is_boundary</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.is_looking_at_obstacle"><code class="name">var <span class="ident">is_looking_at_obstacle</span></code></dt>
<dd>
<div class="desc"><p>Contains True if the face beyond the edge at which the turtle is currently
looking was marked as an obstacle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_looking_at_obstacle(self):
    &#34;&#34;&#34;
    Contains True if the face beyond the edge at which the turtle is currently
    looking was marked as an obstacle.
    &#34;&#34;&#34;
    face = self.get_next_face()
    return bool(face[self.obstacle_layer])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.was_here"><code class="name">var <span class="ident">was_here</span></code></dt>
<dd>
<div class="desc"><p>Contains True if the turtle has previously visited the current face.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def was_here(self):
    &#34;&#34;&#34;
    Contains True if the turtle has previously visited the current face.
    &#34;&#34;&#34;
    return self.was_at_face(self.current_face)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.turtle.Turtle.click"><code class="name flex">
<span>def <span class="ident">click</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Jump to the face which is beyond the edge
at which the turtle is looking currently.
This turtle is a bit strange, because when it jumps it
turns around, to look at the same edge it was looking, but
from another side:</p>
<pre><code>+----+----+      +----+----+
| @&gt; |    |  --&gt; |    | &lt;@ |
+----+----+      +----+----+
</code></pre>
<p>This changes the selection state of the face where the turtle
stepped, if it is in "start_selecting()" mode, according to selection
mask.</p>
<p>This updates custom data layers of the face where the turtle stepped,
if it is in "start_painting()" mode, according to painting masks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click(self):
    &#34;&#34;&#34;
    Jump to the face which is beyond the edge
    at which the turtle is looking currently.
    This turtle is a bit strange, because when it jumps it
    turns around, to look at the same edge it was looking, but
    from another side:

        +----+----+      +----+----+
        | @&gt; |    |  --&gt; |    | &lt;@ |
        +----+----+      +----+----+

    This changes the selection state of the face where the turtle
    stepped, if it is in &#34;start_selecting()&#34; mode, according to selection
    mask.

    This updates custom data layers of the face where the turtle stepped,
    if it is in &#34;start_painting()&#34; mode, according to painting masks.
    &#34;&#34;&#34;
    self.current_index += 1
    self.current_face[self.index_layer] = self.current_index
    next_loop = self.current_loop.link_loop_radial_next
    self.current_loop = next_loop
    self.current_face = next_loop.face

    sv_logger.debug(&#34;Current face # := %s&#34;, self.current_face.index)

    if self.selection_mode == self.MASK:
        if not self.selection_mask:
            raise Exception(&#34;Selection mode is set to MASK, but mask is not specified&#34;)
        n = len(self.selection_mask)
        self.selection_cycle_index = (self.selection_cycle_index + 1) % n
        mode = self.selection_mask[self.selection_cycle_index]
        if mode not in [self.SELECT, self.UNSELECT, self.TOGGLE, 0, 1, False, True]:
            raise Exception(&#34;Unsupported flag in the selection mask&#34;)
        if mode == True or mode == 1:
            mode = self.SELECT
        elif mode == False or mode == 0:
            mode = self.UNSELECT
    else:
        mode = self.selection_mode
    if mode == self.SELECT:
        self.select()
    elif mode == self.UNSELECT:
        self.unselect()
    elif mode == self.TOGGLE:
        self.toggle()

    if self.is_painting:
        for painting_layer in self.painting_layer.values():
            painting_mask = self.painting_mask.get(painting_layer.name)
            if not painting_mask:
                raise Exception(&#34;Painting layer is set, but painting mask is not&#34;)
            n = len(painting_mask)
            self.painting_index[painting_layer.name] = (self.painting_index[painting_layer.name] + 1) % n
            value = painting_mask[self.painting_index[painting_layer.name]]
            self.current_face[painting_layer] = value
            sv_logger.debug(&#34;Paint face #%s, layer `%s&#39; with value `%s&#39;&#34;, self.current_face.index, painting_layer.name, value)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.declare_painting_layer"><code class="name flex">
<span>def <span class="ident">declare_painting_layer</span></span>(<span>self, layer_name, data_type=builtins.int)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a custom data layer for painting.</p>
<p>NB 1: All painting layers must be declared BEFORE any commands to the turtle, i.e.
right after constructor was called.</p>
<p>NB 2: If you wish to use other custom data layers on the same bmesh, for purposes
other than painting by turtle, then you have to create them BEFORE calling the Turtle
constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_painting_layer(self, layer_name, data_type = int):
    &#34;&#34;&#34;
    Create a custom data layer for painting.

    NB 1: All painting layers must be declared BEFORE any commands to the turtle, i.e.
    right after constructor was called.

    NB 2: If you wish to use other custom data layers on the same bmesh, for purposes
    other than painting by turtle, then you have to create them BEFORE calling the Turtle
    constructor.
    &#34;&#34;&#34;
    if data_type == int:
        layers = self.bmesh.faces.layers.int
    elif data_type == float:
        layers = self.bmesh.faces.layers.float
    elif data_type == str:
        layers = self.bmesh.faces.layers.string

    # Creation of the custom data layer invalidates all
    # references to mesh&#39;s BMFaces!
    face_index = self.current_face.index
    loop_index = self.current_loop.index
    layer = layers.new(layer_name)
    self.bmesh.faces.ensure_lookup_table()
    self.bmesh.faces.index_update()
    self.painting_layer[layer_name] = layer
    self.current_face = self.bmesh.faces[face_index]
    self.current_loop = self.current_face.loops[loop_index]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_direct_distance_to_boundary"><code class="name flex">
<span>def <span class="ident">get_direct_distance_to_boundary</span></span>(<span>self, maximum=None, bias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find distance to a boundary edge, if the turtle will step forward
each time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>maximum</code></strong></dt>
<dd>maximum number of faces to check (to prevent possible infinite loop,
or too long paths). None means the total number of faces in the mesh.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>bias for get_next_face().</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>number of steps to reach a boundary edge, or None if such edge is too far.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_direct_distance_to_boundary(self, maximum = None, bias = None):
    &#34;&#34;&#34;
    Find distance to a boundary edge, if the turtle will step forward
    each time.

    Args:
        maximum: maximum number of faces to check (to prevent possible infinite loop,
                    or too long paths). None means the total number of faces in the mesh.
        bias: bias for get_next_face().

    Returns:
        number of steps to reach a boundary edge, or None if such edge is too far.
    &#34;&#34;&#34;
    return self.get_direct_distance_to_edge(lambda loop: loop.edge.is_boundary, maximum, bias)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_direct_distance_to_edge"><code class="name flex">
<span>def <span class="ident">get_direct_distance_to_edge</span></span>(<span>self, check_loop, maximum=None, bias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find distance to some "good" edge, if the turtle will step forward
each time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>check_loop</code></strong></dt>
<dd>function taking BMLoop and returning boolean.</dd>
<dt><strong><code>maximum</code></strong></dt>
<dd>maximum number of faces to check (to prevent possible infinite loop,
or too long paths). None means the total number of faces in the mesh.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>bias for get_next_face().</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>number of steps to reach a "good" edge, or None if such edge is too far.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_direct_distance_to_edge(self, check_loop, maximum = None, bias=None):
    &#34;&#34;&#34;
    Find distance to some &#34;good&#34; edge, if the turtle will step forward
    each time.

    Args:
        check_loop: function taking BMLoop and returning boolean.
        maximum: maximum number of faces to check (to prevent possible infinite loop,
                    or too long paths). None means the total number of faces in the mesh.
        bias: bias for get_next_face().

    Returns:
        number of steps to reach a &#34;good&#34; edge, or None if such edge is too far.
    &#34;&#34;&#34;
    if maximum is None:
        maximum = len(self.bmesh.faces)
    i = 0
    face = self.current_face
    loop = self.current_loop
    while True:
        if i &gt; maximum:
            return None
        if check_loop(loop):
            return i
        # click
        next_loop = loop.link_loop_radial_next
        face = next_loop.face
        # opposite
        loop = self.get_opposite_loop(next_loop, bias)
        i += 1
    return None</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_direct_distance_to_obstacle"><code class="name flex">
<span>def <span class="ident">get_direct_distance_to_obstacle</span></span>(<span>self, maximum=None, bias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find distance to an edge near an obstacle, if the turtle will step forward
each time.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>maximum</code></strong></dt>
<dd>maximum number of faces to check (to prevent possible infinite loop,
or too long paths). None means the total number of faces in the mesh.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>bias for get_next_face().</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>number of steps to reach an edge of an obstacle, or None if such edge is too far.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_direct_distance_to_obstacle(self, maximum = None, bias = None):
    &#34;&#34;&#34;
    Find distance to an edge near an obstacle, if the turtle will step forward
    each time.

    Args:
        maximum: maximum number of faces to check (to prevent possible infinite loop,
                    or too long paths). None means the total number of faces in the mesh.
        bias: bias for get_next_face().

    Returns:
        number of steps to reach an edge of an obstacle, or None if such edge is too far.
    &#34;&#34;&#34;
    if maximum is None:
        maximum = len(self.bmesh.faces)
    i = 0
    face = self.current_face
    loop = self.current_loop
    while True:
        if i &gt; maximum:
            return None
        # click
        next_loop = loop.link_loop_radial_next
        face = next_loop.face
        if face[self.obstacle_layer]:
            return i
        # opposite
        loop = self.get_opposite_loop(next_loop, bias)
        i += 1
    return None</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_face_at_next"><code class="name flex">
<span>def <span class="ident">get_face_at_next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_face_at_next(self):
    loop = self.current_loop.link_loop_next
    next_loop = loop.link_loop_radial_next
    return next_loop.face</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_face_at_prev"><code class="name flex">
<span>def <span class="ident">get_face_at_prev</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_face_at_prev(self):
    loop = self.current_loop.link_loop_prev
    next_loop = loop.link_loop_radial_next
    return next_loop.face</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_is_looking_at_face_ring"><code class="name flex">
<span>def <span class="ident">get_is_looking_at_face_ring</span></span>(<span>self, max_length=None, consider_obstacles=True, bias=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_is_looking_at_face_ring(self, max_length = None, consider_obstacles = True, bias = None):
    if max_length is None:
        max_length = len(self.bmesh.faces)
    loop = self.current_loop
    face = self.current_face
    i = 0
    while True:
        if i &gt; max_length:
            return False
        i += 1
        next_loop = loop.link_loop_radial_next
        face = next_loop.face
        if consider_obstacles and face[self.obstacle_layer]:
            return False
        loop = self.get_opposite_loop(next_loop, bias)
        if loop.edge.is_boundary:
            return False
        if face == self.current_face:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_is_obstacle"><code class="name flex">
<span>def <span class="ident">get_is_obstacle</span></span>(<span>self, face)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_is_obstacle(self, face):
    return bool(face[self.obstacle_layer])</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_next_face"><code class="name flex">
<span>def <span class="ident">get_next_face</span></span>(<span>self, count=1, bias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the face (BMFace) which is beyond that edge at which turtle is
currently looking. If count is greater than 1, then look for the next
face in the same direction.
Bias can be provided for cases of odd count of edges in the face.
This does not change turtle or face state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_face(self, count=1, bias=None):
    &#34;&#34;&#34;
    Get the face (BMFace) which is beyond that edge at which turtle is
    currently looking. If count is greater than 1, then look for the next
    face in the same direction.
    Bias can be provided for cases of odd count of edges in the face.
    This does not change turtle or face state.
    &#34;&#34;&#34;
    face = self.current_face
    loop = self.current_loop
    for i in range(count):
        # click
        next_loop = loop.link_loop_radial_next
        face = next_loop.face
        # opposite
        loop = self.get_opposite_loop(next_loop, bias)
    return face</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_opposite_loop"><code class="name flex">
<span>def <span class="ident">get_opposite_loop</span></span>(<span>self, loop, bias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the BMLoop opposite to the current one.
This does not change current turtle or mesh state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_opposite_loop(self, loop, bias=None):
    &#34;&#34;&#34;
    Get the BMLoop opposite to the current one.
    This does not change current turtle or mesh state.
    &#34;&#34;&#34;
    if bias is None:
        bias = self.opposite_bias
    face = loop.face
    n = len(face.loops)
    if n % 2 == 0:
        steps = n // 2
    else:
        if bias == self.PREVIOUS:
            steps = n // 2
        else:
            steps = n // 2 + 1
    for i in range(steps):
        loop = loop.link_loop_next
    return loop</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_painting_data"><code class="name flex">
<span>def <span class="ident">get_painting_data</span></span>(<span>self, layer_name='turtle_paint')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_painting_data(self, layer_name = PAINT):
    layer = self.painting_layer[layer_name]
    return [face[layer] for face in self.bmesh.faces]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_painting_value"><code class="name flex">
<span>def <span class="ident">get_painting_value</span></span>(<span>self, face, layer_name='turtle_paint')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_painting_value(self, face, layer_name = PAINT):
    layer = self.painting_layer[layer_name]
    return face[layer]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_selected_faces"><code class="name flex">
<span>def <span class="ident">get_selected_faces</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return list of selected faces.
returns: list of BMFace.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selected_faces(self):
    &#34;&#34;&#34;
    Return list of selected faces.
    returns: list of BMFace.
    &#34;&#34;&#34;
    return [face for face in self.bmesh.faces if face.select]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_selected_faces_pydata"><code class="name flex">
<span>def <span class="ident">get_selected_faces_pydata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return list of selected faces in Sverchok format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selected_faces_pydata(self):
    &#34;&#34;&#34;
    Return list of selected faces in Sverchok format.
    &#34;&#34;&#34;
    return [[vert.index for vert in face.verts] for face in self.bmesh.faces if face.select]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.get_selection_mask"><code class="name flex">
<span>def <span class="ident">get_selection_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns selection mask.
result: list of booleans.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selection_mask(self):
    &#34;&#34;&#34;
    Returns selection mask.
    result: list of booleans.
    &#34;&#34;&#34;
    return [face.select for face in self.bmesh.faces]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.paint"><code class="name flex">
<span>def <span class="ident">paint</span></span>(<span>self, value, layer_name='turtle_paint')</span>
</code></dt>
<dd>
<div class="desc"><p>Paint the current face with specified value, on specified layer.
The painting layer must be defined by calling declare_painting_layer()
right after calling the Turtle() constructor. By default, there is
one painting layer, named Turtle.PAINT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paint(self, value, layer_name = PAINT):
    &#34;&#34;&#34;
    Paint the current face with specified value, on specified layer.
    The painting layer must be defined by calling declare_painting_layer()
    right after calling the Turtle() constructor. By default, there is
    one painting layer, named Turtle.PAINT.
    &#34;&#34;&#34;
    layer = self.painting_layer[layer_name]
    self.current_face[layer] = value</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.reset_painting_cycle"><code class="name flex">
<span>def <span class="ident">reset_painting_cycle</span></span>(<span>self, layer_name='turtle_paint')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_painting_cycle(self, layer_name = PAINT):
    self.painting_index[layer_name] = 0</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.reset_selection_cycle"><code class="name flex">
<span>def <span class="ident">reset_selection_cycle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_selection_cycle(self):
    self.selection_cycle_index = 0</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the current face as selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self):
    &#34;&#34;&#34;
    Mark the current face as selected.
    &#34;&#34;&#34;
    self.current_face.select = True
    sv_logger.debug(&#34;Selecting face #%s&#34;, self.current_face.index)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.set_is_obstacle"><code class="name flex">
<span>def <span class="ident">set_is_obstacle</span></span>(<span>self, is_obstacle)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark current face as an obstacle.
"Obstacle" is just a boolean indicator, that can be
checked with turtle.get_is_obstacle or turtle.is_looking_at_obstacle.</p>
<h2 id="args">Args</h2>
<p>is_obstacle : boolean or int, 1 or True for marking face as obstacle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_obstacle(self, is_obstacle):
    &#34;&#34;&#34;
    Mark current face as an obstacle.
    &#34;Obstacle&#34; is just a boolean indicator, that can be
    checked with turtle.get_is_obstacle or turtle.is_looking_at_obstacle.

    Args:
        is_obstacle : boolean or int, 1 or True for marking face as obstacle.
    &#34;&#34;&#34;
    self.current_face[self.obstacle_layer] = int(is_obstacle)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.set_obstacle_mask"><code class="name flex">
<span>def <span class="ident">set_obstacle_mask</span></span>(<span>self, face_mask, invert=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set obstacle indicators for all faces of the mesh.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>face_mask</code></strong></dt>
<dd>list of booleans or ints, True or 1 to mark face as an obstacle.</dd>
<dt><strong><code>invert</code></strong></dt>
<dd>boolean, default false: set to True to invert the meaning of face_mask.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_obstacle_mask(self, face_mask, invert=False):
    &#34;&#34;&#34;
    Set obstacle indicators for all faces of the mesh.

    Args:
        face_mask: list of booleans or ints, True or 1 to mark face as an obstacle.
        invert: boolean, default false: set to True to invert the meaning of face_mask.
    &#34;&#34;&#34;
    for is_obstacle, face in zip(face_mask, self.bmesh.faces):
        if invert:
            face[self.obstacle_layer] = 1 - int(is_obstacle)
        else:
            face[self.obstacle_layer] = int(is_obstacle)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.start_painting"><code class="name flex">
<span>def <span class="ident">start_painting</span></span>(<span>self, value=None, layer_name='turtle_paint')</span>
</code></dt>
<dd>
<div class="desc"><p>Start painting faces which the turtle passes.
If value is not specified, then the value used with previous
start_painting() call will be used. If the value was never provided,
there will be an exception.</p>
<p>A list of values can be specified instead of the single value. In this
case, these values will be used in order, with repetition.
The painting layer must be defined by calling declare_painting_layer()
right after calling the Turtle() constructor. By default, there is
one painting layer, named Turtle.PAINT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_painting(self, value = None, layer_name = PAINT):
    &#34;&#34;&#34;
    Start painting faces which the turtle passes.
    If value is not specified, then the value used with previous
    start_painting() call will be used. If the value was never provided,
    there will be an exception.

    A list of values can be specified instead of the single value. In this
    case, these values will be used in order, with repetition.
    The painting layer must be defined by calling declare_painting_layer()
    right after calling the Turtle() constructor. By default, there is
    one painting layer, named Turtle.PAINT.
    &#34;&#34;&#34;
    if value is not None and not isinstance(value, (list, tuple)):
        value = [value]
    layer = self.painting_layer.get(layer_name)
    if layer is None:
        raise Exception(&#34;This layer was not declared&#34;)
    if value is None and self.painting_mask.get(layer_name) is None:
        raise Exception(&#34;Painting mask was not specified&#34;)
    if value is not None:
        self.painting_mask[layer_name] = value
    self.is_painting = True</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.start_selecting"><code class="name flex">
<span>def <span class="ident">start_selecting</span></span>(<span>self, mode=None, mask=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Start selecting faces which the turtle passes.
This mode can be stopped by calling stop_selecting().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong></dt>
<dd>selection mode. Can be Turtle.SELECT, Turtle.UNSELECT, Turtle.TOGGLE or Turtle.MASK.</dd>
<dt><strong><code>mask</code></strong></dt>
<dd>
<p>selection mask. Used with mode == Turtle.MASK. The mask is used with
infinite repetition. For example:</p>
<pre><code>  turtle.start_selecting(mode = Turtle.MASK, mask = [0, 1])
  turtle.step(6)
  turtle.stop_selecting()
</code></pre>
<p>This will select each other face: 0[1]2[3]4[5].</p>
</dd>
</dl>
<p>If mask is not specified, then the mask used with the previous start_selecting() call
will be used. If the mask was never provided, there will be an exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_selecting(self, mode = None, mask=None):
    &#34;&#34;&#34;
    Start selecting faces which the turtle passes.
    This mode can be stopped by calling stop_selecting().

    Args:
        mode: selection mode. Can be Turtle.SELECT, Turtle.UNSELECT, Turtle.TOGGLE or Turtle.MASK.
        mask: selection mask. Used with mode == Turtle.MASK. The mask is used with
              infinite repetition. For example:

                  turtle.start_selecting(mode = Turtle.MASK, mask = [0, 1])
                  turtle.step(6)
                  turtle.stop_selecting()

              This will select each other face: 0[1]2[3]4[5].

    If mask is not specified, then the mask used with the previous start_selecting() call
    will be used. If the mask was never provided, there will be an exception.
    &#34;&#34;&#34;
    if mode is None:
        mode = self.SELECT
    self.selection_mode = mode
    if mode == self.MASK:
        if not mask and not self.selection_mask:
            raise Exception(&#34;You have to specify the mask when setting selection mode to MASK&#34;)
        if mask:
            self.selection_mask = mask</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, count=1, bias=None, stop_at_boundary=False, stop_at_obstacle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Step to the next face, i.e. the face which is beyond the edge
at which the turtle is currently looking, without changing
turtle's orientation.</p>
<pre><code>+----+----+      +----+----+
| @&gt; |    |  --&gt; |    | @&gt; |
+----+----+      +----+----+
</code></pre>
<p>If count is greater than 1, then repeat this step the specified
number of times.
Bias can be provided for cases of odd count of edges in the face.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, count=1, bias=None, stop_at_boundary = False, stop_at_obstacle = False):
    &#34;&#34;&#34;
    Step to the next face, i.e. the face which is beyond the edge
    at which the turtle is currently looking, without changing 
    turtle&#39;s orientation.

        +----+----+      +----+----+
        | @&gt; |    |  --&gt; |    | @&gt; |
        +----+----+      +----+----+

    If count is greater than 1, then repeat this step the specified
    number of times.
    Bias can be provided for cases of odd count of edges in the face.
    &#34;&#34;&#34;
    for i in range(count):
        self.click()
        self.turn_opposite(bias=bias)
        if stop_at_boundary:
            if self.is_looking_at_boundary:
                break
        if stop_at_obstacle:
            if self.is_looking_at_obstacle:
                break</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.step_back"><code class="name flex">
<span>def <span class="ident">step_back</span></span>(<span>self, count=1, bias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to step(), but step backwards:</p>
<pre><code>+----+----+      +----+----+
|    | @&gt; |  --&gt; | @&gt; |    |
+----+----+      +----+----+
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_back(self, count=1, bias=None):
    &#34;&#34;&#34;
    Similar to step(), but step backwards:

        +----+----+      +----+----+
        |    | @&gt; |  --&gt; | @&gt; |    |
        +----+----+      +----+----+
    &#34;&#34;&#34;
    for i in range(count):
        self.turn_opposite(bias=bias)
        self.click()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.stop_painting"><code class="name flex">
<span>def <span class="ident">stop_painting</span></span>(<span>self, layer_name='turtle_paint')</span>
</code></dt>
<dd>
<div class="desc"><p>Stop painting faces which the turtle passes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_painting(self, layer_name = PAINT):
    &#34;&#34;&#34;
    Stop painting faces which the turtle passes.
    &#34;&#34;&#34;
    self.is_painting = False</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.stop_selecting"><code class="name flex">
<span>def <span class="ident">stop_selecting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop selecting faces which the turtle passes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_selecting(self):
    &#34;&#34;&#34;
    Stop selecting faces which the turtle passes.
    &#34;&#34;&#34;
    self.selection_mode = None</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.strafe_next"><code class="name flex">
<span>def <span class="ident">strafe_next</span></span>(<span>self, count=1, stop_at_boundary=False, stop_at_obstacle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Step to the face which is in the "next" (i.e. usually counterclockwise)
direction, without changing turtle's orientation:</p>
<pre><code>+----+----+      +----+----+
|    |  ^ |      |  ^ |    |
|    |  @ |  --&gt; |  @ |    |
+----+----+      +----+----+
</code></pre>
<p>If count is greater than 1, then repeat this step the specified
number of times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strafe_next(self, count=1, stop_at_boundary = False, stop_at_obstacle = False):
    &#34;&#34;&#34;
    Step to the face which is in the &#34;next&#34; (i.e. usually counterclockwise)
    direction, without changing turtle&#39;s orientation:

        +----+----+      +----+----+
        |    |  ^ |      |  ^ |    |
        |    |  @ |  --&gt; |  @ |    |
        +----+----+      +----+----+

    If count is greater than 1, then repeat this step the specified
    number of times.
    &#34;&#34;&#34;
    for i in range(count):
        self.turn_next()
        if stop_at_boundary:
            if self.is_looking_at_boundary:
                self.turn_prev()
                break
        if stop_at_obstacle:
            if self.is_looking_at_obstacle:
                self.turn_prev()
                break
        self.click()
        self.turn_next()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.strafe_prev"><code class="name flex">
<span>def <span class="ident">strafe_prev</span></span>(<span>self, count=1, stop_at_boundary=False, stop_at_obstacle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Step to the face which is in the "prev" (i.e. usually clockwise)
direction, without changing turtle's orientation:</p>
<pre><code>+----+----+      +----+----+
|  ^ |    |      |    |  ^ |
|  @ |    |  --&gt; |    |  @ |
+----+----+      +----+----+
</code></pre>
<p>If count is greater than 1, then repeat this step the specified
number of times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strafe_prev(self, count=1, stop_at_boundary = False, stop_at_obstacle = False):
    &#34;&#34;&#34;
    Step to the face which is in the &#34;prev&#34; (i.e. usually clockwise)
    direction, without changing turtle&#39;s orientation:

        +----+----+      +----+----+
        |  ^ |    |      |    |  ^ |
        |  @ |    |  --&gt; |    |  @ |
        +----+----+      +----+----+

    If count is greater than 1, then repeat this step the specified
    number of times.
    &#34;&#34;&#34;
    for i in range(count):
        self.turn_prev()
        if stop_at_boundary:
            if self.is_looking_at_boundary:
                self.turn_next()
                break
        if stop_at_obstacle:
            if self.is_looking_at_obstacle:
                self.turn_next()
                break
        self.click()
        self.turn_prev()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.toggle"><code class="name flex">
<span>def <span class="ident">toggle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle the selection state of the current face.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle(self):
    &#34;&#34;&#34;
    Toggle the selection state of the current face.
    &#34;&#34;&#34;
    self.current_face.select = not self.current_face.select
    sv_logger.debug(&#34;Set face #%s selection := %s&#34;, self.current_face.index, self.current_face.select)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.turn_next"><code class="name flex">
<span>def <span class="ident">turn_next</span></span>(<span>self, count=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn towards the next edge in the sequence.
If face normal is oriented "as usual", then this
means "turn counterclockwise".</p>
<pre><code>+----+      +----+
|  ^ |  --&gt; |    |
|  @ |      | &lt;@ |
+----+      +----+
</code></pre>
<p>If count is more than 1, then repeat this turn specified
number of times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_next(self, count=1):
    &#34;&#34;&#34;
    Turn towards the next edge in the sequence.
    If face normal is oriented &#34;as usual&#34;, then this
    means &#34;turn counterclockwise&#34;.

        +----+      +----+
        |  ^ |  --&gt; |    |
        |  @ |      | &lt;@ |
        +----+      +----+

    If count is more than 1, then repeat this turn specified
    number of times.
    &#34;&#34;&#34;
    for i in range(count):
        self.current_loop = self.current_loop.link_loop_next</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.turn_opposite"><code class="name flex">
<span>def <span class="ident">turn_opposite</span></span>(<span>self, bias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn the turtle around, to look at the opposite edge:</p>
<pre><code>+----+       +----+
| @&gt; |  --&gt;  | &lt;@ |
+----+       +----+
</code></pre>
<p>If the current face has odd count of edges, then the term
"around" is ambiguous:</p>
<pre><code>            +----+
            |   &gt;                         |  @   *
            |     /
          &gt; +----+
         /
+----+  /
|                 | &lt;@   *   ? OR ?
|     / 
+----+                                             &gt; +----+
            |                             |  @   *
            |   &gt; /
            +----+
</code></pre>
<p>To decide in such cases, there is <code>bias</code> parameter; it can have
one of two values: Turtle.PREVIOUS and Turtle.NEXT.
The default value of <code>bias</code> parameter can be set as "turtle.opposite_bias".
By default it is set to Turtle.PREVIOUS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_opposite(self, bias=None):
    &#34;&#34;&#34;
    Turn the turtle around, to look at the opposite edge:

        +----+       +----+
        | @&gt; |  --&gt;  | &lt;@ |
        +----+       +----+

    If the current face has odd count of edges, then the term
    &#34;around&#34; is ambiguous:

                    +----+
                    |   &gt; \
                    |  @   *
                    |     /
                  &gt; +----+
                 /
        +----+  /
        |     \
        | &lt;@   *   ? OR ?
        |     / 
        +----+  \
                 \
                  &gt; +----+
                    |     \
                    |  @   *
                    |   &gt; /
                    +----+

    To decide in such cases, there is `bias` parameter; it can have
    one of two values: Turtle.PREVIOUS and Turtle.NEXT.
    The default value of `bias` parameter can be set as &#34;turtle.opposite_bias&#34;.
    By default it is set to Turtle.PREVIOUS.
    &#34;&#34;&#34;
    self.current_loop = self.get_opposite_loop(self.current_loop)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.turn_prev"><code class="name flex">
<span>def <span class="ident">turn_prev</span></span>(<span>self, count=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn towards the previous edge in the sequence.
If face normal is oriented "as usual", then this
means "turn clockwise".</p>
<pre><code>+----+      +----+
| ^  |  --&gt; |    |
| @  |      | @&gt; |
+----+      +----+
</code></pre>
<p>If count is more than 1, then repeat this turn specified
number of times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_prev(self, count=1):
    &#34;&#34;&#34;
    Turn towards the previous edge in the sequence.
    If face normal is oriented &#34;as usual&#34;, then this
    means &#34;turn clockwise&#34;.

        +----+      +----+
        | ^  |  --&gt; |    |
        | @  |      | @&gt; |
        +----+      +----+

    If count is more than 1, then repeat this turn specified
    number of times.
    &#34;&#34;&#34;
    for i in range(count):
        self.current_loop = self.current_loop.link_loop_prev</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.unselect"><code class="name flex">
<span>def <span class="ident">unselect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the current face as not selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unselect(self):
    &#34;&#34;&#34;
    Mark the current face as not selected.
    &#34;&#34;&#34;
    self.current_face.select = False
    sv_logger.debug(&#34;Unselecting face #%s&#34;, self.current_face.index)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.was_at_face"><code class="name flex">
<span>def <span class="ident">was_at_face</span></span>(<span>self, face)</span>
</code></dt>
<dd>
<div class="desc"><p>Whether the turtle already has previously visited the given face.</p>
<h2 id="args">Args</h2>
<p>face : BMFace</p>
<h2 id="returns">Returns</h2>
<p>boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def was_at_face(self, face):
    &#34;&#34;&#34;
    Whether the turtle already has previously visited the given face.

    Args:
        face : BMFace

    Returns:
        boolean
    &#34;&#34;&#34;
    v = face[self.index_layer]
    return (v != 0)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.turtle.Turtle.zig_zag"><code class="name flex">
<span>def <span class="ident">zig_zag</span></span>(<span>self, steps=1, leg=0, turns=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zig_zag(self, steps=1, leg=0, turns=1):
    for i in range(steps):
        self.step(count=leg)
        self.click()
        self.turn_next(turns)
        self.step(count=leg)
        self.click()
        self.turn_prev(turns)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils" href="index.html">sverchok.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.turtle.Turtle" href="#sverchok.utils.turtle.Turtle">Turtle</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.turtle.Turtle.MASK" href="#sverchok.utils.turtle.Turtle.MASK">MASK</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.NEXT" href="#sverchok.utils.turtle.Turtle.NEXT">NEXT</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.PAINT" href="#sverchok.utils.turtle.Turtle.PAINT">PAINT</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.PREVIOUS" href="#sverchok.utils.turtle.Turtle.PREVIOUS">PREVIOUS</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.SELECT" href="#sverchok.utils.turtle.Turtle.SELECT">SELECT</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.TOGGLE" href="#sverchok.utils.turtle.Turtle.TOGGLE">TOGGLE</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.UNSELECT" href="#sverchok.utils.turtle.Turtle.UNSELECT">UNSELECT</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.click" href="#sverchok.utils.turtle.Turtle.click">click</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.declare_painting_layer" href="#sverchok.utils.turtle.Turtle.declare_painting_layer">declare_painting_layer</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_direct_distance_to_boundary" href="#sverchok.utils.turtle.Turtle.get_direct_distance_to_boundary">get_direct_distance_to_boundary</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_direct_distance_to_edge" href="#sverchok.utils.turtle.Turtle.get_direct_distance_to_edge">get_direct_distance_to_edge</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_direct_distance_to_obstacle" href="#sverchok.utils.turtle.Turtle.get_direct_distance_to_obstacle">get_direct_distance_to_obstacle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_face_at_next" href="#sverchok.utils.turtle.Turtle.get_face_at_next">get_face_at_next</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_face_at_prev" href="#sverchok.utils.turtle.Turtle.get_face_at_prev">get_face_at_prev</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_is_looking_at_face_ring" href="#sverchok.utils.turtle.Turtle.get_is_looking_at_face_ring">get_is_looking_at_face_ring</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_is_obstacle" href="#sverchok.utils.turtle.Turtle.get_is_obstacle">get_is_obstacle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_next_face" href="#sverchok.utils.turtle.Turtle.get_next_face">get_next_face</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_opposite_loop" href="#sverchok.utils.turtle.Turtle.get_opposite_loop">get_opposite_loop</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_painting_data" href="#sverchok.utils.turtle.Turtle.get_painting_data">get_painting_data</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_painting_value" href="#sverchok.utils.turtle.Turtle.get_painting_value">get_painting_value</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_selected_faces" href="#sverchok.utils.turtle.Turtle.get_selected_faces">get_selected_faces</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_selected_faces_pydata" href="#sverchok.utils.turtle.Turtle.get_selected_faces_pydata">get_selected_faces_pydata</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.get_selection_mask" href="#sverchok.utils.turtle.Turtle.get_selection_mask">get_selection_mask</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.is_at_boundary" href="#sverchok.utils.turtle.Turtle.is_at_boundary">is_at_boundary</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.is_at_obstacle" href="#sverchok.utils.turtle.Turtle.is_at_obstacle">is_at_obstacle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.is_looking_at_boundary" href="#sverchok.utils.turtle.Turtle.is_looking_at_boundary">is_looking_at_boundary</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.is_looking_at_obstacle" href="#sverchok.utils.turtle.Turtle.is_looking_at_obstacle">is_looking_at_obstacle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.paint" href="#sverchok.utils.turtle.Turtle.paint">paint</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.reset_painting_cycle" href="#sverchok.utils.turtle.Turtle.reset_painting_cycle">reset_painting_cycle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.reset_selection_cycle" href="#sverchok.utils.turtle.Turtle.reset_selection_cycle">reset_selection_cycle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.select" href="#sverchok.utils.turtle.Turtle.select">select</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.set_is_obstacle" href="#sverchok.utils.turtle.Turtle.set_is_obstacle">set_is_obstacle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.set_obstacle_mask" href="#sverchok.utils.turtle.Turtle.set_obstacle_mask">set_obstacle_mask</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.start_painting" href="#sverchok.utils.turtle.Turtle.start_painting">start_painting</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.start_selecting" href="#sverchok.utils.turtle.Turtle.start_selecting">start_selecting</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.step" href="#sverchok.utils.turtle.Turtle.step">step</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.step_back" href="#sverchok.utils.turtle.Turtle.step_back">step_back</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.stop_painting" href="#sverchok.utils.turtle.Turtle.stop_painting">stop_painting</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.stop_selecting" href="#sverchok.utils.turtle.Turtle.stop_selecting">stop_selecting</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.strafe_next" href="#sverchok.utils.turtle.Turtle.strafe_next">strafe_next</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.strafe_prev" href="#sverchok.utils.turtle.Turtle.strafe_prev">strafe_prev</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.toggle" href="#sverchok.utils.turtle.Turtle.toggle">toggle</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.turn_next" href="#sverchok.utils.turtle.Turtle.turn_next">turn_next</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.turn_opposite" href="#sverchok.utils.turtle.Turtle.turn_opposite">turn_opposite</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.turn_prev" href="#sverchok.utils.turtle.Turtle.turn_prev">turn_prev</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.unselect" href="#sverchok.utils.turtle.Turtle.unselect">unselect</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.was_at_face" href="#sverchok.utils.turtle.Turtle.was_at_face">was_at_face</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.was_here" href="#sverchok.utils.turtle.Turtle.was_here">was_here</a></code></li>
<li><code><a title="sverchok.utils.turtle.Turtle.zig_zag" href="#sverchok.utils.turtle.Turtle.zig_zag">zig_zag</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>