<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.nodes_mixins.generating_objects API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.nodes_mixins.generating_objects</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import random
import string
from itertools import cycle
from typing import List, Union

import numpy as np

import bpy
from bpy.props import StringProperty
from mathutils import Matrix

from sverchok.data_structure import updateNode, update_with_kwargs, numpy_full_list, repeat_last
from sverchok.utils.handle_blender_data import correct_collection_length, delete_data_block
from sverchok.utils.sv_bmesh_utils import add_mesh_to_bmesh, bmesh_from_edit_mesh, EmptyBmesh


class SvObjectData(bpy.types.PropertyGroup):
    obj: bpy.props.PointerProperty(type=bpy.types.Object)

    # Object have not information about in which collection it is located
    # Keep here information about collection for performance reasons
    # Now object can be only in on collection
    collection: bpy.props.PointerProperty(type=bpy.types.Collection)

    def ensure_object(self, data_block, name: str, object_template: bpy.types.Object = None):
        &#34;&#34;&#34;Add object if it does not exist, if object_template is given new object will be copied from it&#34;&#34;&#34;
        if not self.obj:
            # it looks like it means only that the property group item was created newly
            if object_template:
                self.obj = object_template.copy()
                self.obj.data = data_block
            else:
                self.obj = bpy.data.objects.new(name=name, object_data=data_block)
        else:
            # in case if data block was changed
            if self.obj.data != data_block:
                self.obj.data = data_block  # EXPENSIVE

    def select(self):
        &#34;&#34;&#34;Just select the object&#34;&#34;&#34;
        if self.obj:
            self.obj.select_set(True)

    def ensure_link_to_collection(self, collection: bpy.types.Collection = None):
        &#34;&#34;&#34;Links object to scene or given collection, unlink from previous collection&#34;&#34;&#34;
        try:
            if collection:
                collection.objects.link(self.obj)
            else:
                # default collection
                bpy.context.scene.collection.objects.link(self.obj)
        except RuntimeError:
            # then the object already added, it looks like more faster way to ensure object is in the scene
            pass

        if self.collection != collection:
            # new collection was given, object should be removed from previous one
            if self.collection is None:
                # it means that it is scene default collection
                # from other hand if item only was created it also will be None but object is not in any collection yet
                try:
                    bpy.context.scene.collection.objects.unlink(self.obj)
                except RuntimeError:
                    pass
            else:
                try:
                    self.collection.objects.unlink(self.obj)
                except RuntimeError:
                    # collection was already unliked by user or another node
                    pass

            self.collection = collection

    def check_object_name(self, name: str) -&gt; None:
        &#34;&#34;&#34;If base name of an object was changed names of all instances also should be changed&#34;&#34;&#34;
        real_name = self.obj.name.rsplit(&#39;.&#39;, 1)[0]
        if real_name != name:
            self.obj.name = name

    def check_object_show_state(self, to_show: bool):
        # hide_viewport is faster than hide_set and hide_viewport is stable
        # when objects are assigned to a collection
        hide = not to_show
        if self.obj.hide_viewport != hide:
            self.obj.hide_viewport = hide

    def recreate_object(self, object_template: bpy.types.Object = None):
        &#34;&#34;&#34;
        Object will be replaced by new object recreated from scratch or copied from given object_template if given
        Previous object will be removed, data block remains unchanged
        &#34;&#34;&#34;
        # in case recreated object should have a chance to get the same name of previous object
        # previous object should be deleted first
        data_block = self.obj.data
        obj_name = self.obj.name
        bpy.data.objects.remove(self.obj)
        if object_template:
            new_obj = object_template.copy()
            new_obj.data = data_block
        else:
            new_obj = bpy.data.objects.new(name=obj_name, object_data=data_block)
        self.obj = new_obj

    def copy(self) -&gt; bpy.types.Object:
        &#34;&#34;&#34;Return copy of object which is assigned to a collection&#34;&#34;&#34;
        obj = self.obj.copy()
        for collection in self.obj.users_collection:
            collection.objects.link(obj)
        return obj

    def remove_data(self):
        &#34;&#34;&#34;Should be called before removing item&#34;&#34;&#34;
        if self.obj:
            delete_data_block(self.obj)


class BlenderObjects:
    &#34;&#34;&#34;Should be used for generating list of objects&#34;&#34;&#34;
    def show_objects_update(self, context, to_show: bool = None):
        &#34;&#34;&#34;Hide / show objects. It should be only place to hide objects&#34;&#34;&#34;
        to_show = to_show if to_show is not None else self.show_objects
        [setattr(prop.obj, &#39;hide_viewport&#39;, not to_show) for prop in self.object_data]

    def selectable_objects_update(self, context):
        [setattr(prop.obj, &#39;hide_select&#39;, False if self.selectable_objects else True) for prop in self.object_data]

    def render_objects_update(self, context):
        [setattr(prop.obj, &#39;hide_render&#39;, False if self.render_objects else True) for prop in self.object_data]

    object_data: bpy.props.CollectionProperty(type=SvObjectData, options={&#39;SKIP_SAVE&#39;})

    show_objects: bpy.props.BoolProperty(
        default=True,
        description=&#34;Show / hide objects in viewport&#34;,
        update=update_with_kwargs(show_objects_update))

    selectable_objects: bpy.props.BoolProperty(
        default=True,
        description=&#34;Make objects selectable / unselectable&#34;,
        update=selectable_objects_update)

    render_objects: bpy.props.BoolProperty(
        default=True,
        description=&#34;Show / hide objects for render engines&#34;,
        update=render_objects_update)

    def regenerate_objects(self,
                           object_names: List[str],
                           data_blocks,
                           collections: List[bpy.types.Collection] = None,
                           object_template: List[bpy.types.Object] = None,
                           to_show: list[bool] = None,
                           ):
        &#34;&#34;&#34;
        It will generate new or remove old objects, number of generated objects will be equal to given data_blocks
        Object_names list can contain one name. In this case Blender will add suffix to next objects (.001, .002,...)
        :param object_template: optionally, object which properties should be grabbed for instanced object
        :param collections: objects will be putted into collections if given, only one in list can be given
        :param data_blocks: nearly any data blocks - mesh, curves, lights ...
        :param object_names: usually equal to name of data block
        :param data_blocks: for now it is support only be bpy.types.Mesh
        :param to_show: whether to show objects in viewport.
        &#34;&#34;&#34;
        if collections is None:
            collections = [None]
        if object_template is None:
            object_template = [None]
        if to_show is None:
            to_show = [True]

        correct_collection_length(self.object_data, len(data_blocks))
        prop_group: SvObjectData
        input_data = zip(self.object_data,
                         data_blocks,
                         cycle(object_names),
                         cycle(collections),
                         cycle(object_template),
                         cycle(to_show),
                         )
        for prop_group, data_block, name, collection, template, show in input_data:
            prop_group.ensure_object(data_block, name, template)
            prop_group.ensure_link_to_collection(collection)
            prop_group.check_object_name(name)
            prop_group.check_object_show_state(show)

    def draw_object_properties(self, layout):
        &#34;&#34;&#34;Should be used for adding hide, select, render objects properties&#34;&#34;&#34;
        layout.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_VIEW_{&#39;OFF&#39; if self.show_objects else &#39;ON&#39;}&#34;)
        layout.prop(self, &#39;selectable_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_SELECT_{&#39;OFF&#39; if self.selectable_objects else &#39;ON&#39;}&#34;)
        layout.prop(self, &#39;render_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_RENDER_{&#39;OFF&#39; if self.render_objects else &#39;ON&#39;}&#34;)


class SvMeshData(bpy.types.PropertyGroup):
    mesh: bpy.props.PointerProperty(type=bpy.types.Mesh, options={&#39;SKIP_SAVE&#39;})

    def regenerate_mesh(self, mesh_name: str, verts, edges=None, faces=None, matrix: Matrix = None,
                        make_changes_test=True):
        &#34;&#34;&#34;
        It takes vertices, edges and faces and updates mesh data block
        If it assume that topology is unchanged only position of vertices will be changed
        In this case it will be more efficient if vertices are given in np.array float32 format
        Can apply matrix to mesh optionally
        &#34;&#34;&#34;
        if edges is None:
            edges = []
        if faces is None:
            faces = []

        if not self.mesh:
            # new mesh should be created
            self.mesh = bpy.data.meshes.new(name=mesh_name)

        if not make_changes_test or self.is_topology_changed(verts, edges, faces):

            if self.mesh.is_editmode:
                with bmesh_from_edit_mesh(self.mesh) as bm:
                    bm.clear()
                    add_mesh_to_bmesh(bm, verts, edges, faces, update_indexes=False, update_normals=False)
                    bm.normal_update()
                    if matrix:
                        bm.transform(matrix)
            else:
                with EmptyBmesh(False) as bm:
                    add_mesh_to_bmesh(bm, verts, edges, faces, update_indexes=False, update_normals=False)
                    if matrix:
                        bm.transform(matrix)
                    bm.to_mesh(self.mesh)

        else:

            if self.mesh.is_editmode:
                with bmesh_from_edit_mesh(self.mesh) as bm:
                    for bv, v in zip(bm.verts, verts):
                        bv.co = v
                    if matrix:
                        bm.transform(matrix)
            else:
                self.update_vertices(verts)
                if matrix:
                    self.mesh.transform(matrix)

        self.mesh.update()

    def set_smooth(self, is_smooth_mesh):
        &#34;&#34;&#34;Make mesh smooth or flat&#34;&#34;&#34;
        if is_smooth_mesh:
            is_smooth = np.ones(len(self.mesh.polygons), dtype=bool)
        else:
            is_smooth = np.zeros(len(self.mesh.polygons), dtype=bool)
        self.mesh.polygons.foreach_set(&#39;use_smooth&#39;, is_smooth)

    def is_topology_changed(self, verts: list, edges: list, faces: list) -&gt; bool:
        &#34;&#34;&#34;
        Simple and fast test but not 100% robust.
        If number of vertices and faces are unchanged it assumes that topology is not changed
        This test is useful if mesh just changed its location.
        It is much faster just set new coordinate for each vector then recreate whole object
        &#34;&#34;&#34;
        if not faces:
            # edges can be take in account if mesh does not have polygons
            # because Sverchok edges can exclude edges within polygons
            return len(self.mesh.vertices) != len(verts) or len(self.mesh.edges) != len(edges)
        else:
            number_is_changed = len(self.mesh.vertices) != len(verts) or len(self.mesh.polygons) != len(faces)
            # check several polygons indexes
            are_polygons_changed = any([list(p.vertices) != f for _, p, f in zip(range(5), self.mesh.polygons, faces)])
            return number_is_changed or are_polygons_changed

    def update_vertices(self, verts: Union[list, np.ndarray]):
        &#34;&#34;&#34;
        Just update position of mesh vertices, order and number of given vertices should be the same as mesh
        numpy array with float32 type will be 10 times faster than any other input data
        &#34;&#34;&#34;
        verts = np.array(verts, dtype=np.float32)  # todo will be this fast if it is already array float 32?
        self.mesh.vertices.foreach_set(&#39;co&#39;, np.ravel(verts))

    def copy(self) -&gt; bpy.types.Mesh:
        return self.mesh.copy()

    def remove_data(self):
        &#34;&#34;&#34;
        This method should be called before deleting the property
        The mesh is belonged only to this property and should be deleted with it
        &#34;&#34;&#34;
        if self.mesh:
            delete_data_block(self.mesh)


class SvLightData(bpy.types.PropertyGroup):
    light: bpy.props.PointerProperty(type=bpy.types.Light)

    def regenerate_light(self, light_name: str, light_type: str):
        if not self.light:
            # new mesh should be created
            self.light = bpy.data.lights.new(name=light_name, type=light_type)
        elif self.light.type != light_type:
            # in case if type was changed
            self.light.type = light_type

    def remove_data(self):
        &#34;&#34;&#34;
        This method should be called before deleting the property
        The mesh is belonged only to this property and should be deleted with it
        &#34;&#34;&#34;
        if self.light:
            delete_data_block(self.light)


class SvCurveData(bpy.types.PropertyGroup):
    &#34;&#34;&#34;For now it is supporting only one spline per curve&#34;&#34;&#34;
    curve: bpy.props.PointerProperty(type=bpy.types.Curve)

    def regenerate_curve(self,
                         curve_name: str,
                         vertices: Union[List[list], List[np.ndarray]],
                         spline_type: str = &#39;POLY&#39;,
                         vertices_radius: Union[List[list], List[np.ndarray]] = None,
                         close_spline: Union[List[bool], List[int]] = None,
                         use_smooth: bool = True,
                         tilt: Union[List[list], List[np.ndarray]] = None):
        # Be aware that curve consists multiple splines
        if not self.curve:
            self.curve = bpy.data.curves.new(name=curve_name, type=&#39;CURVE&#39;)  # type [&#39;CURVE&#39;, &#39;SURFACE&#39;, &#39;FONT&#39;]
        if len(self.curve.splines) != len(vertices) \
                or any(len(s.points) != len(v) for s, v in zip(self.curve.splines, vertices)):
            # if at least on spline has wrong number of points whole list of splines should be recreated
            # thanks to Blender API
            self.curve.splines.clear()
            [self.curve.splines.new(spline_type) for _ in range(len(vertices))]
            [s.points.add(len(v) - 1) for s, v in zip(self.curve.splines, vertices)]

        for s, v, r, t, c in zip(self.curve.splines, vertices,
                              repeat_last(vertices_radius or [None]),
                              repeat_last(tilt or [None]),
                              repeat_last(close_spline)):
            v = np.asarray(v, dtype=np.float32)
            if r is None:
                r = np.ones(len(v), dtype=np.float32)
            r = np.asarray(r, dtype=np.float32)
            self._regenerate_spline(s, v, spline_type, r, t, c, use_smooth)

    def remove_data(self):
        &#34;&#34;&#34;
        This method should be called before deleting the property
        The mesh is belonged only to this property and should be deleted with it
        &#34;&#34;&#34;
        if self.curve:
            delete_data_block(self.curve)

    @staticmethod
    def _regenerate_spline(spline: bpy.types.Spline,
                           vertices: np.ndarray,
                           spline_type: str = &#39;POLY&#39;,
                           vertices_radius: np.ndarray = None,
                           tilt: np.ndarray = None,
                           close_spline: bool = False,
                           use_smooth: bool = True):
        spline.type = spline_type
        spline.use_cyclic_u = close_spline
        spline.use_smooth = use_smooth

        # flatten vertices array and add W component (X, Y, Z, W), W is responsible for drawing NURBS curves
        w_vertices = np.concatenate((vertices, np.ones((len(vertices), 1), dtype=np.float32)), axis=1)
        flatten_vertices = np.ravel(w_vertices)
        spline.points.foreach_set(&#39;co&#39;, flatten_vertices)
        if vertices_radius is not None:
            spline.points.foreach_set(&#39;radius&#39;, numpy_full_list(vertices_radius, len(vertices)))
        if tilt is not None:
            spline.points.foreach_set(&#39;tilt&#39;, numpy_full_list(tilt, len(vertices)))


class SvViewerNode(BlenderObjects):
    &#34;&#34;&#34;
    Mixin for all nodes which displays any objects in viewport
    &#34;&#34;&#34;

    is_active: bpy.props.BoolProperty(name=&#39;Live&#39;, default=True, update=updateNode,
                                      description=&#34;When enabled this will process incoming data&#34;,)

    base_data_name: bpy.props.StringProperty(
        default=&#39;Alpha&#39;,
        description=&#39;stores the mesh name found in the object, this mesh is instanced&#39;,
        update=updateNode)

    collection: bpy.props.PointerProperty(type=bpy.types.Collection, update=updateNode,
                                          description=&#34;Collection where to put objects&#34;)

    def draw_viewer_properties(self, layout):
        col = layout.column(align=True)
        row = col.row(align=True)
        row.column().prop(self, &#39;is_active&#39;, toggle=True)

        self.draw_object_properties(row)  # hide, selectable, render

        col = layout.column(align=True)
        row = col.row(align=True)
        row.prop(self, &#34;base_data_name&#34;, text=&#34;&#34;, icon=&#39;OUTLINER_OB_MESH&#39;)
        row.operator(&#39;node.sv_generate_random_object_name&#39;, text=&#39;&#39;, icon=&#39;FILE_REFRESH&#39;)

        row = col.row(align=True)
        row.scale_y = 2
        row.operator(&#39;node.sv_select_objects&#39;, text=&#34;Select&#34;)

        col.prop_search(self, &#39;collection&#39;, bpy.data, &#39;collections&#39;, text=&#39;&#39;, icon=&#39;GROUP&#39;)

    def init_viewer(self):
        &#34;&#34;&#34;Should be called from descendant class&#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        self.use_custom_color = True

        self.outputs.new(&#39;SvObjectSocket&#39;, &#34;Objects&#34;)

    def sv_copy(self, other):
        &#34;&#34;&#34;
        Regenerate object names, and clean data
        Use super().sv_copy(other) to override this method
        &#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        # object and mesh lists should be clear other wise two nodes would have links to the same objects
        self.object_data.clear()

    def show_viewport(self, is_show: bool):
        &#34;&#34;&#34;It should be called by node tree to show/hide objects&#34;&#34;&#34;
        if not self.show_objects:
            # just ignore request
            pass
        else:
            self.show_objects_update(None, is_show)

    def load_from_json(self, node_data: dict, import_version: float):
        &#34;&#34;&#34;
        Manually serialization node properties
        Should be overridden in zis way: super().storage_get_data(storage); self.my_prop = storage[&#39;my_prop&#39;]
        &#34;&#34;&#34;
        if import_version &lt;= 0.08:
            collection_name = node_data[&#39;collection&#39;]
            if collection_name:
                collection = (bpy.data.collections.get(collection_name))
                if not collection:
                    collection = bpy.data.collections.new(collection_name)
                    bpy.context.collection.children.link(collection)
                self.collection = collection

    def draw_label(self):
        if self.hide:
            return f&#34;{self.bl_label[:2]}V {self.base_data_name}&#34;
        else:
            return self.bl_label


class SvViewerLightNode(BlenderObjects):
    &#34;&#34;&#34;
    Mixin for all nodes which displays any objects in viewport
    &#34;&#34;&#34;

    is_active: bpy.props.BoolProperty(
        name=&#39;Live&#39;,
        default=True,
        update=updateNode,
        description=&#34;When enabled this will process incoming data&#34;)

    base_data_name: bpy.props.StringProperty(
        default=&#39;Alpha&#39;,
        description=&#39;stores the mesh name found in the object, this mesh is instanced&#39;,
        update=updateNode)

    def draw_viewer_properties(self, layout):
        col = layout.column(align=True)
        row = col.row()

        row_show = row.row(align=True)
        row_show.prop(self, &#39;is_active&#39;, toggle=True)
        row_show.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                      icon=f&#39;HIDE_{&#34;OFF&#34; if self.show_objects else &#34;ON&#34;}&#39;)

        row.operator(SvShowFlyPanelOpeartor.bl_idname, text=&#34;Options&#34;)

    def draw_buttons_fly(self, layout):
        col = layout.column()
        row = col.row()

        row_show = row.row(align=True)

        row_show.prop(self, &#39;is_active&#39;, toggle=True)
        row_show.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                      icon=f&#39;HIDE_{&#34;OFF&#34; if self.show_objects else &#34;ON&#34;}&#39;)
        row = row.row(align=True)
        row.prop(self, &#39;selectable_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_SELECT_{&#39;OFF&#39; if self.selectable_objects else &#39;ON&#39;}&#34;)
        row.prop(self, &#39;render_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_RENDER_{&#39;OFF&#39; if self.render_objects else &#39;ON&#39;}&#34;)

        row = col.row(align=True)
        row.prop(self, &#34;base_data_name&#34;, text=&#34;&#34;, icon=&#39;OUTLINER_OB_MESH&#39;)
        op = row.operator(SvGenerateRandomObjectName.bl_idname, text=&#39;&#39;, icon=&#39;FILE_REFRESH&#39;)
        op.node_name = self.name
        op.tree_name = self.id_data.name
        row = col.row(align=True)
        row.scale_y = 2
        op = row.operator(&#39;node.sv_select_objects&#39;, text=&#34;Select&#34;)
        op.node_name = self.name
        op.tree_name = self.id_data.name
        op = row.operator(SvBakeObjectsOperator.bl_idname, text=&#34;Bake&#34;)
        op.node_name = self.name
        op.tree_name = self.id_data.name

    def init_viewer(self):
        &#34;&#34;&#34;Should be called from descendant class&#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        self.use_custom_color = True

        self.outputs.new(&#39;SvObjectSocket&#39;, &#34;Objects&#34;)

    def sv_copy(self, other):
        &#34;&#34;&#34;
        Regenerate object names, and clean data
        Use super().sv_copy(other) to override this method
        &#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        # object and mesh lists should be clear other wise two nodes would have links to the same objects
        self.object_data.clear()

    def sv_free(self):
        for data in self.object_data:
            data.remove_data()

    def bake(self):
        raise NotImplemented

    def show_viewport(self, is_show: bool):
        &#34;&#34;&#34;It should be called by node tree to show/hide objects&#34;&#34;&#34;
        if not self.show_objects:
            # just ignore request
            pass
        else:
            self.show_objects_update(None, is_show)

    def draw_label(self):
        if self.hide:
            return f&#34;{self.bl_label[:2]}V {self.base_data_name}&#34;
        else:
            return self.bl_label


class SvObjectNames(bpy.types.PropertyGroup):
    available_name_number: bpy.props.IntProperty(default=0, min=0, max=24)
    greek_alphabet = [
        &#39;Alpha&#39;, &#39;Beta&#39;, &#39;Gamma&#39;, &#39;Delta&#39;,
        &#39;Epsilon&#39;, &#39;Zeta&#39;, &#39;Eta&#39;, &#39;Theta&#39;,
        &#39;Iota&#39;, &#39;Kappa&#39;, &#39;Lamda&#39;, &#39;Mu&#39;,
        &#39;Nu&#39;, &#39;Xi&#39;, &#39;Omicron&#39;, &#39;Pi&#39;,
        &#39;Rho&#39;, &#39;Sigma&#39;, &#39;Tau&#39;, &#39;Upsilon&#39;,
        &#39;Phi&#39;, &#39;Chi&#39;, &#39;Psi&#39;, &#39;Omega&#39;]

    def get_available_name(self):
        &#34;&#34;&#34;It returns name from greek alphabet, if all names was used it returns random letters&#34;&#34;&#34;
        if self.available_name_number &lt;= 23:
            name = self.greek_alphabet[self.available_name_number]
            self.available_name_number += 1
        else:
            name = self.get_random_name()

        return name

    @staticmethod
    def get_random_name():
        &#34;&#34;&#34;Generate random name from random letters&#34;&#34;&#34;
        return &#39;&#39;.join(random.sample(set(string.ascii_uppercase), 6))


class SearchNode:
    node_name: StringProperty()
    tree_name: StringProperty()

    @property
    def node(self):
        if not hasattr(self, &#39;_node&#39;):
            self._node = bpy.data.node_groups[self.tree_name].nodes[self.node_name]
        return self._node

    def invoke(self, context, event):
        if hasattr(context, &#39;node&#39;):
            self._node = context.node
        return self.execute(context)


class SvShowFlyPanelOpeartor(bpy.types.Operator):
    &#34;&#34;&#34;Shows extra node options&#34;&#34;&#34;
    bl_idname = &#39;node.sv_show_fly_panel&#39;
    bl_label = &#34;Node Options&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    def execute(self, context):
        return {&#39;FINISHED&#39;}

    def invoke(self, context, event):
        self.node = context.node
        wm = context.window_manager
        return wm.invoke_popup(self, width=200)

    def draw(self, context):
        self.node.draw_buttons_fly(self.layout)


class SvSelectObjects(SearchNode, bpy.types.Operator):
    &#34;&#34;&#34;It calls `select` method of every item in `object_data` collection of node&#34;&#34;&#34;
    bl_idname = &#39;node.sv_select_objects&#39;
    bl_label = &#34;Select objects&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    @classmethod
    def description(cls, context, properties):
        return &#34;Select generated objects&#34;

    def execute(self, context):
        prop: SvObjectData
        for prop in self.node.object_data:
            prop.select()
        return {&#39;FINISHED&#39;}


class SvGenerateRandomObjectName(SearchNode, bpy.types.Operator):
    &#34;&#34;&#34;
    It calls get_random_name fo sv_object_names property in scene
    and assign it to base_data_name property of node
    &#34;&#34;&#34;
    bl_idname = &#39;node.sv_generate_random_object_name&#39;
    bl_label = &#34;Random name&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    @classmethod
    def description(cls, context, properties):
        return &#34;Generate random name&#34;

    def execute(self, context):
        self.node.base_data_name = bpy.context.scene.sv_object_names.get_random_name()
        return {&#39;FINISHED&#39;}


class SvCreateMaterial(bpy.types.Operator):
    &#34;&#34;&#34;It creates and add new material to a node&#34;&#34;&#34;
    bl_idname = &#39;node.sv_create_material&#39;
    bl_label = &#34;Create material&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    @classmethod
    def description(cls, context, properties):
        return &#34;Create new material&#34;

    def execute(self, context):
        mat = bpy.data.materials.new(&#39;sv_material&#39;)
        mat.use_nodes = True
        context.node.material = mat
        return {&#39;FINISHED&#39;}

    @classmethod
    def poll(cls, context):
        return hasattr(context.node, &#39;material&#39;)


class SvBakeObjectsOperator(SearchNode, bpy.types.Operator):
    &#34;&#34;&#34;Create object copies independent of the node&#34;&#34;&#34;
    bl_idname = &#39;node.sv_bake_objects&#39;
    bl_label = &#34;Bake objects&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    def execute(self, context):
        self.node.bake()
        return {&#39;FINISHED&#39;}


module_classes = [
    SvObjectData,
    SvMeshData,
    SvSelectObjects,
    SvObjectNames,
    SvGenerateRandomObjectName,
    SvLightData,
    SvCurveData,
    SvCreateMaterial,
    SvShowFlyPanelOpeartor,
    SvBakeObjectsOperator,
]


def register():
    [bpy.utils.register_class(cls) for cls in module_classes]
    bpy.types.Scene.sv_object_names = bpy.props.PointerProperty(type=SvObjectNames)


def unregister():
    [bpy.utils.unregister_class(cls) for cls in module_classes[::-1]]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register():
    [bpy.utils.register_class(cls) for cls in module_classes]
    bpy.types.Scene.sv_object_names = bpy.props.PointerProperty(type=SvObjectNames)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister():
    [bpy.utils.unregister_class(cls) for cls in module_classes[::-1]]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects"><code class="flex name class">
<span>class <span class="ident">BlenderObjects</span></span>
</code></dt>
<dd>
<div class="desc"><p>Should be used for generating list of objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlenderObjects:
    &#34;&#34;&#34;Should be used for generating list of objects&#34;&#34;&#34;
    def show_objects_update(self, context, to_show: bool = None):
        &#34;&#34;&#34;Hide / show objects. It should be only place to hide objects&#34;&#34;&#34;
        to_show = to_show if to_show is not None else self.show_objects
        [setattr(prop.obj, &#39;hide_viewport&#39;, not to_show) for prop in self.object_data]

    def selectable_objects_update(self, context):
        [setattr(prop.obj, &#39;hide_select&#39;, False if self.selectable_objects else True) for prop in self.object_data]

    def render_objects_update(self, context):
        [setattr(prop.obj, &#39;hide_render&#39;, False if self.render_objects else True) for prop in self.object_data]

    object_data: bpy.props.CollectionProperty(type=SvObjectData, options={&#39;SKIP_SAVE&#39;})

    show_objects: bpy.props.BoolProperty(
        default=True,
        description=&#34;Show / hide objects in viewport&#34;,
        update=update_with_kwargs(show_objects_update))

    selectable_objects: bpy.props.BoolProperty(
        default=True,
        description=&#34;Make objects selectable / unselectable&#34;,
        update=selectable_objects_update)

    render_objects: bpy.props.BoolProperty(
        default=True,
        description=&#34;Show / hide objects for render engines&#34;,
        update=render_objects_update)

    def regenerate_objects(self,
                           object_names: List[str],
                           data_blocks,
                           collections: List[bpy.types.Collection] = None,
                           object_template: List[bpy.types.Object] = None,
                           to_show: list[bool] = None,
                           ):
        &#34;&#34;&#34;
        It will generate new or remove old objects, number of generated objects will be equal to given data_blocks
        Object_names list can contain one name. In this case Blender will add suffix to next objects (.001, .002,...)
        :param object_template: optionally, object which properties should be grabbed for instanced object
        :param collections: objects will be putted into collections if given, only one in list can be given
        :param data_blocks: nearly any data blocks - mesh, curves, lights ...
        :param object_names: usually equal to name of data block
        :param data_blocks: for now it is support only be bpy.types.Mesh
        :param to_show: whether to show objects in viewport.
        &#34;&#34;&#34;
        if collections is None:
            collections = [None]
        if object_template is None:
            object_template = [None]
        if to_show is None:
            to_show = [True]

        correct_collection_length(self.object_data, len(data_blocks))
        prop_group: SvObjectData
        input_data = zip(self.object_data,
                         data_blocks,
                         cycle(object_names),
                         cycle(collections),
                         cycle(object_template),
                         cycle(to_show),
                         )
        for prop_group, data_block, name, collection, template, show in input_data:
            prop_group.ensure_object(data_block, name, template)
            prop_group.ensure_link_to_collection(collection)
            prop_group.check_object_name(name)
            prop_group.check_object_show_state(show)

    def draw_object_properties(self, layout):
        &#34;&#34;&#34;Should be used for adding hide, select, render objects properties&#34;&#34;&#34;
        layout.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_VIEW_{&#39;OFF&#39; if self.show_objects else &#39;ON&#39;}&#34;)
        layout.prop(self, &#39;selectable_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_SELECT_{&#39;OFF&#39; if self.selectable_objects else &#39;ON&#39;}&#34;)
        layout.prop(self, &#39;render_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_RENDER_{&#39;OFF&#39; if self.render_objects else &#39;ON&#39;}&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode">SvViewerLightNode</a></li>
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode">SvViewerNode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.object_data"><code class="name">var <span class="ident">object_data</span> : <_PropertyDeferred, <built-in function CollectionProperty>, {'type': <class '<a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData">SvObjectData</a>'>, 'options': {'SKIP_SAVE'}, 'attr': 'object_data'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects"><code class="name">var <span class="ident">render_objects</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'default': True, 'description': 'Show / hide objects for render engines', 'update': <function <a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects_update">BlenderObjects.render_objects_update()</a> at 0x7f2ed8c86670>, 'attr': 'render_objects'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects"><code class="name">var <span class="ident">selectable_objects</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'default': True, 'description': 'Make objects selectable / unselectable', 'update': <function <a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects_update">BlenderObjects.selectable_objects_update()</a> at 0x7f2ed8c865e0>, 'attr': 'selectable_objects'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects"><code class="name">var <span class="ident">show_objects</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'default': True, 'description': 'Show / hide objects in viewport', 'update': <function <a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update">BlenderObjects.show_objects_update()</a> at 0x7f2ed8c86700>, 'attr': 'show_objects'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.draw_object_properties"><code class="name flex">
<span>def <span class="ident">draw_object_properties</span></span>(<span>self, layout)</span>
</code></dt>
<dd>
<div class="desc"><p>Should be used for adding hide, select, render objects properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_object_properties(self, layout):
    &#34;&#34;&#34;Should be used for adding hide, select, render objects properties&#34;&#34;&#34;
    layout.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                icon=f&#34;RESTRICT_VIEW_{&#39;OFF&#39; if self.show_objects else &#39;ON&#39;}&#34;)
    layout.prop(self, &#39;selectable_objects&#39;, toggle=True, text=&#39;&#39;,
                icon=f&#34;RESTRICT_SELECT_{&#39;OFF&#39; if self.selectable_objects else &#39;ON&#39;}&#34;)
    layout.prop(self, &#39;render_objects&#39;, toggle=True, text=&#39;&#39;,
                icon=f&#34;RESTRICT_RENDER_{&#39;OFF&#39; if self.render_objects else &#39;ON&#39;}&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.regenerate_objects"><code class="name flex">
<span>def <span class="ident">regenerate_objects</span></span>(<span>self, object_names: List[str], data_blocks, collections: List[bpy_types.Collection] = None, object_template: List[bpy_types.Object] = None, to_show: list = None)</span>
</code></dt>
<dd>
<div class="desc"><p>It will generate new or remove old objects, number of generated objects will be equal to given data_blocks
Object_names list can contain one name. In this case Blender will add suffix to next objects (.001, .002,&hellip;)
:param object_template: optionally, object which properties should be grabbed for instanced object
:param collections: objects will be putted into collections if given, only one in list can be given
:param data_blocks: nearly any data blocks - mesh, curves, lights &hellip;
:param object_names: usually equal to name of data block
:param data_blocks: for now it is support only be bpy.types.Mesh
:param to_show: whether to show objects in viewport.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regenerate_objects(self,
                       object_names: List[str],
                       data_blocks,
                       collections: List[bpy.types.Collection] = None,
                       object_template: List[bpy.types.Object] = None,
                       to_show: list[bool] = None,
                       ):
    &#34;&#34;&#34;
    It will generate new or remove old objects, number of generated objects will be equal to given data_blocks
    Object_names list can contain one name. In this case Blender will add suffix to next objects (.001, .002,...)
    :param object_template: optionally, object which properties should be grabbed for instanced object
    :param collections: objects will be putted into collections if given, only one in list can be given
    :param data_blocks: nearly any data blocks - mesh, curves, lights ...
    :param object_names: usually equal to name of data block
    :param data_blocks: for now it is support only be bpy.types.Mesh
    :param to_show: whether to show objects in viewport.
    &#34;&#34;&#34;
    if collections is None:
        collections = [None]
    if object_template is None:
        object_template = [None]
    if to_show is None:
        to_show = [True]

    correct_collection_length(self.object_data, len(data_blocks))
    prop_group: SvObjectData
    input_data = zip(self.object_data,
                     data_blocks,
                     cycle(object_names),
                     cycle(collections),
                     cycle(object_template),
                     cycle(to_show),
                     )
    for prop_group, data_block, name, collection, template, show in input_data:
        prop_group.ensure_object(data_block, name, template)
        prop_group.ensure_link_to_collection(collection)
        prop_group.check_object_name(name)
        prop_group.check_object_show_state(show)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects_update"><code class="name flex">
<span>def <span class="ident">render_objects_update</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_objects_update(self, context):
    [setattr(prop.obj, &#39;hide_render&#39;, False if self.render_objects else True) for prop in self.object_data]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects_update"><code class="name flex">
<span>def <span class="ident">selectable_objects_update</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectable_objects_update(self, context):
    [setattr(prop.obj, &#39;hide_select&#39;, False if self.selectable_objects else True) for prop in self.object_data]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update"><code class="name flex">
<span>def <span class="ident">show_objects_update</span></span>(<span>self, context, to_show: bool = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide / show objects. It should be only place to hide objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_objects_update(self, context, to_show: bool = None):
    &#34;&#34;&#34;Hide / show objects. It should be only place to hide objects&#34;&#34;&#34;
    to_show = to_show if to_show is not None else self.show_objects
    [setattr(prop.obj, &#39;hide_viewport&#39;, not to_show) for prop in self.object_data]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SearchNode"><code class="flex name class">
<span>class <span class="ident">SearchNode</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchNode:
    node_name: StringProperty()
    tree_name: StringProperty()

    @property
    def node(self):
        if not hasattr(self, &#39;_node&#39;):
            self._node = bpy.data.node_groups[self.tree_name].nodes[self.node_name]
        return self._node

    def invoke(self, context, event):
        if hasattr(context, &#39;node&#39;):
            self._node = context.node
        return self.execute(context)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>sverchok.nodes.viz.geo_nodes_viewer.SvAddNewGNTree</li>
<li>sverchok.nodes.viz.geo_nodes_viewer.SvEditGNTree</li>
<li>sverchok.nodes.viz.geo_nodes_viewer.SvUpdateNodeInterface</li>
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator">SvBakeObjectsOperator</a></li>
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName">SvGenerateRandomObjectName</a></li>
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects">SvSelectObjects</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SearchNode.node_name"><code class="name">var <span class="ident">node_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'node_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SearchNode.tree_name"><code class="name">var <span class="ident">tree_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'tree_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SearchNode.node"><code class="name">var <span class="ident">node</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node(self):
    if not hasattr(self, &#39;_node&#39;):
        self._node = bpy.data.node_groups[self.tree_name].nodes[self.node_name]
    return self._node</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SearchNode.invoke"><code class="name flex">
<span>def <span class="ident">invoke</span></span>(<span>self, context, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invoke(self, context, event):
    if hasattr(context, &#39;node&#39;):
        self._node = context.node
    return self.execute(context)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator"><code class="flex name class">
<span>class <span class="ident">SvBakeObjectsOperator</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Create object copies independent of the node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvBakeObjectsOperator(SearchNode, bpy.types.Operator):
    &#34;&#34;&#34;Create object copies independent of the node&#34;&#34;&#34;
    bl_idname = &#39;node.sv_bake_objects&#39;
    bl_label = &#34;Bake objects&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    def execute(self, context):
        self.node.bake()
        return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode">SearchNode</a></li>
<li>bpy_types.Operator</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_idname"><code class="name">var <span class="ident">bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_label"><code class="name">var <span class="ident">bl_label</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_options"><code class="name">var <span class="ident">bl_options</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.node_name"><code class="name">var <span class="ident">node_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'node_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.tree_name"><code class="name">var <span class="ident">tree_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'tree_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    self.node.bake()
    return {&#39;FINISHED&#39;}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial"><code class="flex name class">
<span>class <span class="ident">SvCreateMaterial</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>It creates and add new material to a node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCreateMaterial(bpy.types.Operator):
    &#34;&#34;&#34;It creates and add new material to a node&#34;&#34;&#34;
    bl_idname = &#39;node.sv_create_material&#39;
    bl_label = &#34;Create material&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    @classmethod
    def description(cls, context, properties):
        return &#34;Create new material&#34;

    def execute(self, context):
        mat = bpy.data.materials.new(&#39;sv_material&#39;)
        mat.use_nodes = True
        context.node.material = mat
        return {&#39;FINISHED&#39;}

    @classmethod
    def poll(cls, context):
        return hasattr(context.node, &#39;material&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.Operator</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_idname"><code class="name">var <span class="ident">bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_label"><code class="name">var <span class="ident">bl_label</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_options"><code class="name">var <span class="ident">bl_options</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>context, properties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def description(cls, context, properties):
    return &#34;Create new material&#34;</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.poll"><code class="name flex">
<span>def <span class="ident">poll</span></span>(<span>context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def poll(cls, context):
    return hasattr(context.node, &#39;material&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    mat = bpy.data.materials.new(&#39;sv_material&#39;)
    mat.use_nodes = True
    context.node.material = mat
    return {&#39;FINISHED&#39;}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCurveData"><code class="flex name class">
<span>class <span class="ident">SvCurveData</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>For now it is supporting only one spline per curve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveData(bpy.types.PropertyGroup):
    &#34;&#34;&#34;For now it is supporting only one spline per curve&#34;&#34;&#34;
    curve: bpy.props.PointerProperty(type=bpy.types.Curve)

    def regenerate_curve(self,
                         curve_name: str,
                         vertices: Union[List[list], List[np.ndarray]],
                         spline_type: str = &#39;POLY&#39;,
                         vertices_radius: Union[List[list], List[np.ndarray]] = None,
                         close_spline: Union[List[bool], List[int]] = None,
                         use_smooth: bool = True,
                         tilt: Union[List[list], List[np.ndarray]] = None):
        # Be aware that curve consists multiple splines
        if not self.curve:
            self.curve = bpy.data.curves.new(name=curve_name, type=&#39;CURVE&#39;)  # type [&#39;CURVE&#39;, &#39;SURFACE&#39;, &#39;FONT&#39;]
        if len(self.curve.splines) != len(vertices) \
                or any(len(s.points) != len(v) for s, v in zip(self.curve.splines, vertices)):
            # if at least on spline has wrong number of points whole list of splines should be recreated
            # thanks to Blender API
            self.curve.splines.clear()
            [self.curve.splines.new(spline_type) for _ in range(len(vertices))]
            [s.points.add(len(v) - 1) for s, v in zip(self.curve.splines, vertices)]

        for s, v, r, t, c in zip(self.curve.splines, vertices,
                              repeat_last(vertices_radius or [None]),
                              repeat_last(tilt or [None]),
                              repeat_last(close_spline)):
            v = np.asarray(v, dtype=np.float32)
            if r is None:
                r = np.ones(len(v), dtype=np.float32)
            r = np.asarray(r, dtype=np.float32)
            self._regenerate_spline(s, v, spline_type, r, t, c, use_smooth)

    def remove_data(self):
        &#34;&#34;&#34;
        This method should be called before deleting the property
        The mesh is belonged only to this property and should be deleted with it
        &#34;&#34;&#34;
        if self.curve:
            delete_data_block(self.curve)

    @staticmethod
    def _regenerate_spline(spline: bpy.types.Spline,
                           vertices: np.ndarray,
                           spline_type: str = &#39;POLY&#39;,
                           vertices_radius: np.ndarray = None,
                           tilt: np.ndarray = None,
                           close_spline: bool = False,
                           use_smooth: bool = True):
        spline.type = spline_type
        spline.use_cyclic_u = close_spline
        spline.use_smooth = use_smooth

        # flatten vertices array and add W component (X, Y, Z, W), W is responsible for drawing NURBS curves
        w_vertices = np.concatenate((vertices, np.ones((len(vertices), 1), dtype=np.float32)), axis=1)
        flatten_vertices = np.ravel(w_vertices)
        spline.points.foreach_set(&#39;co&#39;, flatten_vertices)
        if vertices_radius is not None:
            spline.points.foreach_set(&#39;radius&#39;, numpy_full_list(vertices_radius, len(vertices)))
        if tilt is not None:
            spline.points.foreach_set(&#39;tilt&#39;, numpy_full_list(tilt, len(vertices)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.PropertyGroup</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.curve"><code class="name">var <span class="ident">curve</span> : <_PropertyDeferred, <built-in function PointerProperty>, {'type': <class 'bpy.types.Curve'>, 'attr': 'curve'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.regenerate_curve"><code class="name flex">
<span>def <span class="ident">regenerate_curve</span></span>(<span>self, curve_name: str, vertices: Union[List[list], List[numpy.ndarray]], spline_type: str = 'POLY', vertices_radius: Union[List[list], List[numpy.ndarray]] = None, close_spline: Union[List[bool], List[int]] = None, use_smooth: bool = True, tilt: Union[List[list], List[numpy.ndarray]] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regenerate_curve(self,
                     curve_name: str,
                     vertices: Union[List[list], List[np.ndarray]],
                     spline_type: str = &#39;POLY&#39;,
                     vertices_radius: Union[List[list], List[np.ndarray]] = None,
                     close_spline: Union[List[bool], List[int]] = None,
                     use_smooth: bool = True,
                     tilt: Union[List[list], List[np.ndarray]] = None):
    # Be aware that curve consists multiple splines
    if not self.curve:
        self.curve = bpy.data.curves.new(name=curve_name, type=&#39;CURVE&#39;)  # type [&#39;CURVE&#39;, &#39;SURFACE&#39;, &#39;FONT&#39;]
    if len(self.curve.splines) != len(vertices) \
            or any(len(s.points) != len(v) for s, v in zip(self.curve.splines, vertices)):
        # if at least on spline has wrong number of points whole list of splines should be recreated
        # thanks to Blender API
        self.curve.splines.clear()
        [self.curve.splines.new(spline_type) for _ in range(len(vertices))]
        [s.points.add(len(v) - 1) for s, v in zip(self.curve.splines, vertices)]

    for s, v, r, t, c in zip(self.curve.splines, vertices,
                          repeat_last(vertices_radius or [None]),
                          repeat_last(tilt or [None]),
                          repeat_last(close_spline)):
        v = np.asarray(v, dtype=np.float32)
        if r is None:
            r = np.ones(len(v), dtype=np.float32)
        r = np.asarray(r, dtype=np.float32)
        self._regenerate_spline(s, v, spline_type, r, t, c, use_smooth)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.remove_data"><code class="name flex">
<span>def <span class="ident">remove_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method should be called before deleting the property
The mesh is belonged only to this property and should be deleted with it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_data(self):
    &#34;&#34;&#34;
    This method should be called before deleting the property
    The mesh is belonged only to this property and should be deleted with it
    &#34;&#34;&#34;
    if self.curve:
        delete_data_block(self.curve)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName"><code class="flex name class">
<span>class <span class="ident">SvGenerateRandomObjectName</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>It calls get_random_name fo sv_object_names property in scene
and assign it to base_data_name property of node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvGenerateRandomObjectName(SearchNode, bpy.types.Operator):
    &#34;&#34;&#34;
    It calls get_random_name fo sv_object_names property in scene
    and assign it to base_data_name property of node
    &#34;&#34;&#34;
    bl_idname = &#39;node.sv_generate_random_object_name&#39;
    bl_label = &#34;Random name&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    @classmethod
    def description(cls, context, properties):
        return &#34;Generate random name&#34;

    def execute(self, context):
        self.node.base_data_name = bpy.context.scene.sv_object_names.get_random_name()
        return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode">SearchNode</a></li>
<li>bpy_types.Operator</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_idname"><code class="name">var <span class="ident">bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_label"><code class="name">var <span class="ident">bl_label</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_options"><code class="name">var <span class="ident">bl_options</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.node_name"><code class="name">var <span class="ident">node_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'node_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.tree_name"><code class="name">var <span class="ident">tree_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'tree_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>context, properties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def description(cls, context, properties):
    return &#34;Generate random name&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    self.node.base_data_name = bpy.context.scene.sv_object_names.get_random_name()
    return {&#39;FINISHED&#39;}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvLightData"><code class="flex name class">
<span>class <span class="ident">SvLightData</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvLightData(bpy.types.PropertyGroup):
    light: bpy.props.PointerProperty(type=bpy.types.Light)

    def regenerate_light(self, light_name: str, light_type: str):
        if not self.light:
            # new mesh should be created
            self.light = bpy.data.lights.new(name=light_name, type=light_type)
        elif self.light.type != light_type:
            # in case if type was changed
            self.light.type = light_type

    def remove_data(self):
        &#34;&#34;&#34;
        This method should be called before deleting the property
        The mesh is belonged only to this property and should be deleted with it
        &#34;&#34;&#34;
        if self.light:
            delete_data_block(self.light)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.PropertyGroup</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvLightData.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvLightData.light"><code class="name">var <span class="ident">light</span> : <_PropertyDeferred, <built-in function PointerProperty>, {'type': <class 'bpy.types.Light'>, 'attr': 'light'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvLightData.regenerate_light"><code class="name flex">
<span>def <span class="ident">regenerate_light</span></span>(<span>self, light_name: str, light_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regenerate_light(self, light_name: str, light_type: str):
    if not self.light:
        # new mesh should be created
        self.light = bpy.data.lights.new(name=light_name, type=light_type)
    elif self.light.type != light_type:
        # in case if type was changed
        self.light.type = light_type</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvLightData.remove_data"><code class="name flex">
<span>def <span class="ident">remove_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method should be called before deleting the property
The mesh is belonged only to this property and should be deleted with it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_data(self):
    &#34;&#34;&#34;
    This method should be called before deleting the property
    The mesh is belonged only to this property and should be deleted with it
    &#34;&#34;&#34;
    if self.light:
        delete_data_block(self.light)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData"><code class="flex name class">
<span>class <span class="ident">SvMeshData</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvMeshData(bpy.types.PropertyGroup):
    mesh: bpy.props.PointerProperty(type=bpy.types.Mesh, options={&#39;SKIP_SAVE&#39;})

    def regenerate_mesh(self, mesh_name: str, verts, edges=None, faces=None, matrix: Matrix = None,
                        make_changes_test=True):
        &#34;&#34;&#34;
        It takes vertices, edges and faces and updates mesh data block
        If it assume that topology is unchanged only position of vertices will be changed
        In this case it will be more efficient if vertices are given in np.array float32 format
        Can apply matrix to mesh optionally
        &#34;&#34;&#34;
        if edges is None:
            edges = []
        if faces is None:
            faces = []

        if not self.mesh:
            # new mesh should be created
            self.mesh = bpy.data.meshes.new(name=mesh_name)

        if not make_changes_test or self.is_topology_changed(verts, edges, faces):

            if self.mesh.is_editmode:
                with bmesh_from_edit_mesh(self.mesh) as bm:
                    bm.clear()
                    add_mesh_to_bmesh(bm, verts, edges, faces, update_indexes=False, update_normals=False)
                    bm.normal_update()
                    if matrix:
                        bm.transform(matrix)
            else:
                with EmptyBmesh(False) as bm:
                    add_mesh_to_bmesh(bm, verts, edges, faces, update_indexes=False, update_normals=False)
                    if matrix:
                        bm.transform(matrix)
                    bm.to_mesh(self.mesh)

        else:

            if self.mesh.is_editmode:
                with bmesh_from_edit_mesh(self.mesh) as bm:
                    for bv, v in zip(bm.verts, verts):
                        bv.co = v
                    if matrix:
                        bm.transform(matrix)
            else:
                self.update_vertices(verts)
                if matrix:
                    self.mesh.transform(matrix)

        self.mesh.update()

    def set_smooth(self, is_smooth_mesh):
        &#34;&#34;&#34;Make mesh smooth or flat&#34;&#34;&#34;
        if is_smooth_mesh:
            is_smooth = np.ones(len(self.mesh.polygons), dtype=bool)
        else:
            is_smooth = np.zeros(len(self.mesh.polygons), dtype=bool)
        self.mesh.polygons.foreach_set(&#39;use_smooth&#39;, is_smooth)

    def is_topology_changed(self, verts: list, edges: list, faces: list) -&gt; bool:
        &#34;&#34;&#34;
        Simple and fast test but not 100% robust.
        If number of vertices and faces are unchanged it assumes that topology is not changed
        This test is useful if mesh just changed its location.
        It is much faster just set new coordinate for each vector then recreate whole object
        &#34;&#34;&#34;
        if not faces:
            # edges can be take in account if mesh does not have polygons
            # because Sverchok edges can exclude edges within polygons
            return len(self.mesh.vertices) != len(verts) or len(self.mesh.edges) != len(edges)
        else:
            number_is_changed = len(self.mesh.vertices) != len(verts) or len(self.mesh.polygons) != len(faces)
            # check several polygons indexes
            are_polygons_changed = any([list(p.vertices) != f for _, p, f in zip(range(5), self.mesh.polygons, faces)])
            return number_is_changed or are_polygons_changed

    def update_vertices(self, verts: Union[list, np.ndarray]):
        &#34;&#34;&#34;
        Just update position of mesh vertices, order and number of given vertices should be the same as mesh
        numpy array with float32 type will be 10 times faster than any other input data
        &#34;&#34;&#34;
        verts = np.array(verts, dtype=np.float32)  # todo will be this fast if it is already array float 32?
        self.mesh.vertices.foreach_set(&#39;co&#39;, np.ravel(verts))

    def copy(self) -&gt; bpy.types.Mesh:
        return self.mesh.copy()

    def remove_data(self):
        &#34;&#34;&#34;
        This method should be called before deleting the property
        The mesh is belonged only to this property and should be deleted with it
        &#34;&#34;&#34;
        if self.mesh:
            delete_data_block(self.mesh)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.PropertyGroup</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.mesh"><code class="name">var <span class="ident">mesh</span> : <_PropertyDeferred, <built-in function PointerProperty>, {'type': <class 'bpy_types.Mesh'>, 'options': {'SKIP_SAVE'}, 'attr': 'mesh'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> bpy_types.Mesh</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; bpy.types.Mesh:
    return self.mesh.copy()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.is_topology_changed"><code class="name flex">
<span>def <span class="ident">is_topology_changed</span></span>(<span>self, verts: list, edges: list, faces: list) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Simple and fast test but not 100% robust.
If number of vertices and faces are unchanged it assumes that topology is not changed
This test is useful if mesh just changed its location.
It is much faster just set new coordinate for each vector then recreate whole object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_topology_changed(self, verts: list, edges: list, faces: list) -&gt; bool:
    &#34;&#34;&#34;
    Simple and fast test but not 100% robust.
    If number of vertices and faces are unchanged it assumes that topology is not changed
    This test is useful if mesh just changed its location.
    It is much faster just set new coordinate for each vector then recreate whole object
    &#34;&#34;&#34;
    if not faces:
        # edges can be take in account if mesh does not have polygons
        # because Sverchok edges can exclude edges within polygons
        return len(self.mesh.vertices) != len(verts) or len(self.mesh.edges) != len(edges)
    else:
        number_is_changed = len(self.mesh.vertices) != len(verts) or len(self.mesh.polygons) != len(faces)
        # check several polygons indexes
        are_polygons_changed = any([list(p.vertices) != f for _, p, f in zip(range(5), self.mesh.polygons, faces)])
        return number_is_changed or are_polygons_changed</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.regenerate_mesh"><code class="name flex">
<span>def <span class="ident">regenerate_mesh</span></span>(<span>self, mesh_name: str, verts, edges=None, faces=None, matrix: Matrix = None, make_changes_test=True)</span>
</code></dt>
<dd>
<div class="desc"><p>It takes vertices, edges and faces and updates mesh data block
If it assume that topology is unchanged only position of vertices will be changed
In this case it will be more efficient if vertices are given in np.array float32 format
Can apply matrix to mesh optionally</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regenerate_mesh(self, mesh_name: str, verts, edges=None, faces=None, matrix: Matrix = None,
                    make_changes_test=True):
    &#34;&#34;&#34;
    It takes vertices, edges and faces and updates mesh data block
    If it assume that topology is unchanged only position of vertices will be changed
    In this case it will be more efficient if vertices are given in np.array float32 format
    Can apply matrix to mesh optionally
    &#34;&#34;&#34;
    if edges is None:
        edges = []
    if faces is None:
        faces = []

    if not self.mesh:
        # new mesh should be created
        self.mesh = bpy.data.meshes.new(name=mesh_name)

    if not make_changes_test or self.is_topology_changed(verts, edges, faces):

        if self.mesh.is_editmode:
            with bmesh_from_edit_mesh(self.mesh) as bm:
                bm.clear()
                add_mesh_to_bmesh(bm, verts, edges, faces, update_indexes=False, update_normals=False)
                bm.normal_update()
                if matrix:
                    bm.transform(matrix)
        else:
            with EmptyBmesh(False) as bm:
                add_mesh_to_bmesh(bm, verts, edges, faces, update_indexes=False, update_normals=False)
                if matrix:
                    bm.transform(matrix)
                bm.to_mesh(self.mesh)

    else:

        if self.mesh.is_editmode:
            with bmesh_from_edit_mesh(self.mesh) as bm:
                for bv, v in zip(bm.verts, verts):
                    bv.co = v
                if matrix:
                    bm.transform(matrix)
        else:
            self.update_vertices(verts)
            if matrix:
                self.mesh.transform(matrix)

    self.mesh.update()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.remove_data"><code class="name flex">
<span>def <span class="ident">remove_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method should be called before deleting the property
The mesh is belonged only to this property and should be deleted with it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_data(self):
    &#34;&#34;&#34;
    This method should be called before deleting the property
    The mesh is belonged only to this property and should be deleted with it
    &#34;&#34;&#34;
    if self.mesh:
        delete_data_block(self.mesh)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.set_smooth"><code class="name flex">
<span>def <span class="ident">set_smooth</span></span>(<span>self, is_smooth_mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Make mesh smooth or flat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_smooth(self, is_smooth_mesh):
    &#34;&#34;&#34;Make mesh smooth or flat&#34;&#34;&#34;
    if is_smooth_mesh:
        is_smooth = np.ones(len(self.mesh.polygons), dtype=bool)
    else:
        is_smooth = np.zeros(len(self.mesh.polygons), dtype=bool)
    self.mesh.polygons.foreach_set(&#39;use_smooth&#39;, is_smooth)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.update_vertices"><code class="name flex">
<span>def <span class="ident">update_vertices</span></span>(<span>self, verts: Union[list, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Just update position of mesh vertices, order and number of given vertices should be the same as mesh
numpy array with float32 type will be 10 times faster than any other input data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_vertices(self, verts: Union[list, np.ndarray]):
    &#34;&#34;&#34;
    Just update position of mesh vertices, order and number of given vertices should be the same as mesh
    numpy array with float32 type will be 10 times faster than any other input data
    &#34;&#34;&#34;
    verts = np.array(verts, dtype=np.float32)  # todo will be this fast if it is already array float 32?
    self.mesh.vertices.foreach_set(&#39;co&#39;, np.ravel(verts))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData"><code class="flex name class">
<span>class <span class="ident">SvObjectData</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvObjectData(bpy.types.PropertyGroup):
    obj: bpy.props.PointerProperty(type=bpy.types.Object)

    # Object have not information about in which collection it is located
    # Keep here information about collection for performance reasons
    # Now object can be only in on collection
    collection: bpy.props.PointerProperty(type=bpy.types.Collection)

    def ensure_object(self, data_block, name: str, object_template: bpy.types.Object = None):
        &#34;&#34;&#34;Add object if it does not exist, if object_template is given new object will be copied from it&#34;&#34;&#34;
        if not self.obj:
            # it looks like it means only that the property group item was created newly
            if object_template:
                self.obj = object_template.copy()
                self.obj.data = data_block
            else:
                self.obj = bpy.data.objects.new(name=name, object_data=data_block)
        else:
            # in case if data block was changed
            if self.obj.data != data_block:
                self.obj.data = data_block  # EXPENSIVE

    def select(self):
        &#34;&#34;&#34;Just select the object&#34;&#34;&#34;
        if self.obj:
            self.obj.select_set(True)

    def ensure_link_to_collection(self, collection: bpy.types.Collection = None):
        &#34;&#34;&#34;Links object to scene or given collection, unlink from previous collection&#34;&#34;&#34;
        try:
            if collection:
                collection.objects.link(self.obj)
            else:
                # default collection
                bpy.context.scene.collection.objects.link(self.obj)
        except RuntimeError:
            # then the object already added, it looks like more faster way to ensure object is in the scene
            pass

        if self.collection != collection:
            # new collection was given, object should be removed from previous one
            if self.collection is None:
                # it means that it is scene default collection
                # from other hand if item only was created it also will be None but object is not in any collection yet
                try:
                    bpy.context.scene.collection.objects.unlink(self.obj)
                except RuntimeError:
                    pass
            else:
                try:
                    self.collection.objects.unlink(self.obj)
                except RuntimeError:
                    # collection was already unliked by user or another node
                    pass

            self.collection = collection

    def check_object_name(self, name: str) -&gt; None:
        &#34;&#34;&#34;If base name of an object was changed names of all instances also should be changed&#34;&#34;&#34;
        real_name = self.obj.name.rsplit(&#39;.&#39;, 1)[0]
        if real_name != name:
            self.obj.name = name

    def check_object_show_state(self, to_show: bool):
        # hide_viewport is faster than hide_set and hide_viewport is stable
        # when objects are assigned to a collection
        hide = not to_show
        if self.obj.hide_viewport != hide:
            self.obj.hide_viewport = hide

    def recreate_object(self, object_template: bpy.types.Object = None):
        &#34;&#34;&#34;
        Object will be replaced by new object recreated from scratch or copied from given object_template if given
        Previous object will be removed, data block remains unchanged
        &#34;&#34;&#34;
        # in case recreated object should have a chance to get the same name of previous object
        # previous object should be deleted first
        data_block = self.obj.data
        obj_name = self.obj.name
        bpy.data.objects.remove(self.obj)
        if object_template:
            new_obj = object_template.copy()
            new_obj.data = data_block
        else:
            new_obj = bpy.data.objects.new(name=obj_name, object_data=data_block)
        self.obj = new_obj

    def copy(self) -&gt; bpy.types.Object:
        &#34;&#34;&#34;Return copy of object which is assigned to a collection&#34;&#34;&#34;
        obj = self.obj.copy()
        for collection in self.obj.users_collection:
            collection.objects.link(obj)
        return obj

    def remove_data(self):
        &#34;&#34;&#34;Should be called before removing item&#34;&#34;&#34;
        if self.obj:
            delete_data_block(self.obj)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.PropertyGroup</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.collection"><code class="name">var <span class="ident">collection</span> : <_PropertyDeferred, <built-in function PointerProperty>, {'type': <class 'bpy_types.Collection'>, 'attr': 'collection'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.obj"><code class="name">var <span class="ident">obj</span> : <_PropertyDeferred, <built-in function PointerProperty>, {'type': <class 'bpy_types.Object'>, 'attr': 'obj'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.check_object_name"><code class="name flex">
<span>def <span class="ident">check_object_name</span></span>(<span>self, name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>If base name of an object was changed names of all instances also should be changed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_object_name(self, name: str) -&gt; None:
    &#34;&#34;&#34;If base name of an object was changed names of all instances also should be changed&#34;&#34;&#34;
    real_name = self.obj.name.rsplit(&#39;.&#39;, 1)[0]
    if real_name != name:
        self.obj.name = name</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.check_object_show_state"><code class="name flex">
<span>def <span class="ident">check_object_show_state</span></span>(<span>self, to_show: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_object_show_state(self, to_show: bool):
    # hide_viewport is faster than hide_set and hide_viewport is stable
    # when objects are assigned to a collection
    hide = not to_show
    if self.obj.hide_viewport != hide:
        self.obj.hide_viewport = hide</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> bpy_types.Object</span>
</code></dt>
<dd>
<div class="desc"><p>Return copy of object which is assigned to a collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; bpy.types.Object:
    &#34;&#34;&#34;Return copy of object which is assigned to a collection&#34;&#34;&#34;
    obj = self.obj.copy()
    for collection in self.obj.users_collection:
        collection.objects.link(obj)
    return obj</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.ensure_link_to_collection"><code class="name flex">
<span>def <span class="ident">ensure_link_to_collection</span></span>(<span>self, collection: bpy_types.Collection = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links object to scene or given collection, unlink from previous collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_link_to_collection(self, collection: bpy.types.Collection = None):
    &#34;&#34;&#34;Links object to scene or given collection, unlink from previous collection&#34;&#34;&#34;
    try:
        if collection:
            collection.objects.link(self.obj)
        else:
            # default collection
            bpy.context.scene.collection.objects.link(self.obj)
    except RuntimeError:
        # then the object already added, it looks like more faster way to ensure object is in the scene
        pass

    if self.collection != collection:
        # new collection was given, object should be removed from previous one
        if self.collection is None:
            # it means that it is scene default collection
            # from other hand if item only was created it also will be None but object is not in any collection yet
            try:
                bpy.context.scene.collection.objects.unlink(self.obj)
            except RuntimeError:
                pass
        else:
            try:
                self.collection.objects.unlink(self.obj)
            except RuntimeError:
                # collection was already unliked by user or another node
                pass

        self.collection = collection</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.ensure_object"><code class="name flex">
<span>def <span class="ident">ensure_object</span></span>(<span>self, data_block, name: str, object_template: bpy_types.Object = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add object if it does not exist, if object_template is given new object will be copied from it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_object(self, data_block, name: str, object_template: bpy.types.Object = None):
    &#34;&#34;&#34;Add object if it does not exist, if object_template is given new object will be copied from it&#34;&#34;&#34;
    if not self.obj:
        # it looks like it means only that the property group item was created newly
        if object_template:
            self.obj = object_template.copy()
            self.obj.data = data_block
        else:
            self.obj = bpy.data.objects.new(name=name, object_data=data_block)
    else:
        # in case if data block was changed
        if self.obj.data != data_block:
            self.obj.data = data_block  # EXPENSIVE</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.recreate_object"><code class="name flex">
<span>def <span class="ident">recreate_object</span></span>(<span>self, object_template: bpy_types.Object = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object will be replaced by new object recreated from scratch or copied from given object_template if given
Previous object will be removed, data block remains unchanged</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recreate_object(self, object_template: bpy.types.Object = None):
    &#34;&#34;&#34;
    Object will be replaced by new object recreated from scratch or copied from given object_template if given
    Previous object will be removed, data block remains unchanged
    &#34;&#34;&#34;
    # in case recreated object should have a chance to get the same name of previous object
    # previous object should be deleted first
    data_block = self.obj.data
    obj_name = self.obj.name
    bpy.data.objects.remove(self.obj)
    if object_template:
        new_obj = object_template.copy()
        new_obj.data = data_block
    else:
        new_obj = bpy.data.objects.new(name=obj_name, object_data=data_block)
    self.obj = new_obj</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.remove_data"><code class="name flex">
<span>def <span class="ident">remove_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Should be called before removing item</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_data(self):
    &#34;&#34;&#34;Should be called before removing item&#34;&#34;&#34;
    if self.obj:
        delete_data_block(self.obj)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Just select the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self):
    &#34;&#34;&#34;Just select the object&#34;&#34;&#34;
    if self.obj:
        self.obj.select_set(True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames"><code class="flex name class">
<span>class <span class="ident">SvObjectNames</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvObjectNames(bpy.types.PropertyGroup):
    available_name_number: bpy.props.IntProperty(default=0, min=0, max=24)
    greek_alphabet = [
        &#39;Alpha&#39;, &#39;Beta&#39;, &#39;Gamma&#39;, &#39;Delta&#39;,
        &#39;Epsilon&#39;, &#39;Zeta&#39;, &#39;Eta&#39;, &#39;Theta&#39;,
        &#39;Iota&#39;, &#39;Kappa&#39;, &#39;Lamda&#39;, &#39;Mu&#39;,
        &#39;Nu&#39;, &#39;Xi&#39;, &#39;Omicron&#39;, &#39;Pi&#39;,
        &#39;Rho&#39;, &#39;Sigma&#39;, &#39;Tau&#39;, &#39;Upsilon&#39;,
        &#39;Phi&#39;, &#39;Chi&#39;, &#39;Psi&#39;, &#39;Omega&#39;]

    def get_available_name(self):
        &#34;&#34;&#34;It returns name from greek alphabet, if all names was used it returns random letters&#34;&#34;&#34;
        if self.available_name_number &lt;= 23:
            name = self.greek_alphabet[self.available_name_number]
            self.available_name_number += 1
        else:
            name = self.get_random_name()

        return name

    @staticmethod
    def get_random_name():
        &#34;&#34;&#34;Generate random name from random letters&#34;&#34;&#34;
        return &#39;&#39;.join(random.sample(set(string.ascii_uppercase), 6))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.PropertyGroup</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.available_name_number"><code class="name">var <span class="ident">available_name_number</span> : <_PropertyDeferred, <built-in function IntProperty>, {'default': 0, 'min': 0, 'max': 24, 'attr': 'available_name_number'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.greek_alphabet"><code class="name">var <span class="ident">greek_alphabet</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.get_random_name"><code class="name flex">
<span>def <span class="ident">get_random_name</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate random name from random letters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_random_name():
    &#34;&#34;&#34;Generate random name from random letters&#34;&#34;&#34;
    return &#39;&#39;.join(random.sample(set(string.ascii_uppercase), 6))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.get_available_name"><code class="name flex">
<span>def <span class="ident">get_available_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>It returns name from greek alphabet, if all names was used it returns random letters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_available_name(self):
    &#34;&#34;&#34;It returns name from greek alphabet, if all names was used it returns random letters&#34;&#34;&#34;
    if self.available_name_number &lt;= 23:
        name = self.greek_alphabet[self.available_name_number]
        self.available_name_number += 1
    else:
        name = self.get_random_name()

    return name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects"><code class="flex name class">
<span>class <span class="ident">SvSelectObjects</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>It calls <code>select</code> method of every item in <code>object_data</code> collection of node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvSelectObjects(SearchNode, bpy.types.Operator):
    &#34;&#34;&#34;It calls `select` method of every item in `object_data` collection of node&#34;&#34;&#34;
    bl_idname = &#39;node.sv_select_objects&#39;
    bl_label = &#34;Select objects&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    @classmethod
    def description(cls, context, properties):
        return &#34;Select generated objects&#34;

    def execute(self, context):
        prop: SvObjectData
        for prop in self.node.object_data:
            prop.select()
        return {&#39;FINISHED&#39;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode">SearchNode</a></li>
<li>bpy_types.Operator</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_idname"><code class="name">var <span class="ident">bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_label"><code class="name">var <span class="ident">bl_label</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_options"><code class="name">var <span class="ident">bl_options</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.node_name"><code class="name">var <span class="ident">node_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'node_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.tree_name"><code class="name">var <span class="ident">tree_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'attr': 'tree_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>context, properties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def description(cls, context, properties):
    return &#34;Select generated objects&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    prop: SvObjectData
    for prop in self.node.object_data:
        prop.select()
    return {&#39;FINISHED&#39;}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor"><code class="flex name class">
<span>class <span class="ident">SvShowFlyPanelOpeartor</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows extra node options</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvShowFlyPanelOpeartor(bpy.types.Operator):
    &#34;&#34;&#34;Shows extra node options&#34;&#34;&#34;
    bl_idname = &#39;node.sv_show_fly_panel&#39;
    bl_label = &#34;Node Options&#34;
    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;, &#39;INTERNAL&#39;}

    def execute(self, context):
        return {&#39;FINISHED&#39;}

    def invoke(self, context, event):
        self.node = context.node
        wm = context.window_manager
        return wm.invoke_popup(self, width=200)

    def draw(self, context):
        self.node.draw_buttons_fly(self.layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bpy_types.Operator</li>
<li>builtins.bpy_struct</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_idname"><code class="name">var <span class="ident">bl_idname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_label"><code class="name">var <span class="ident">bl_label</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_options"><code class="name">var <span class="ident">bl_options</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_rna"><code class="name">var <span class="ident">bl_rna</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, context):
    self.node.draw_buttons_fly(self.layout)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    return {&#39;FINISHED&#39;}</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.invoke"><code class="name flex">
<span>def <span class="ident">invoke</span></span>(<span>self, context, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invoke(self, context, event):
    self.node = context.node
    wm = context.window_manager
    return wm.invoke_popup(self, width=200)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode"><code class="flex name class">
<span>class <span class="ident">SvViewerLightNode</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for all nodes which displays any objects in viewport</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvViewerLightNode(BlenderObjects):
    &#34;&#34;&#34;
    Mixin for all nodes which displays any objects in viewport
    &#34;&#34;&#34;

    is_active: bpy.props.BoolProperty(
        name=&#39;Live&#39;,
        default=True,
        update=updateNode,
        description=&#34;When enabled this will process incoming data&#34;)

    base_data_name: bpy.props.StringProperty(
        default=&#39;Alpha&#39;,
        description=&#39;stores the mesh name found in the object, this mesh is instanced&#39;,
        update=updateNode)

    def draw_viewer_properties(self, layout):
        col = layout.column(align=True)
        row = col.row()

        row_show = row.row(align=True)
        row_show.prop(self, &#39;is_active&#39;, toggle=True)
        row_show.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                      icon=f&#39;HIDE_{&#34;OFF&#34; if self.show_objects else &#34;ON&#34;}&#39;)

        row.operator(SvShowFlyPanelOpeartor.bl_idname, text=&#34;Options&#34;)

    def draw_buttons_fly(self, layout):
        col = layout.column()
        row = col.row()

        row_show = row.row(align=True)

        row_show.prop(self, &#39;is_active&#39;, toggle=True)
        row_show.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                      icon=f&#39;HIDE_{&#34;OFF&#34; if self.show_objects else &#34;ON&#34;}&#39;)
        row = row.row(align=True)
        row.prop(self, &#39;selectable_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_SELECT_{&#39;OFF&#39; if self.selectable_objects else &#39;ON&#39;}&#34;)
        row.prop(self, &#39;render_objects&#39;, toggle=True, text=&#39;&#39;,
                    icon=f&#34;RESTRICT_RENDER_{&#39;OFF&#39; if self.render_objects else &#39;ON&#39;}&#34;)

        row = col.row(align=True)
        row.prop(self, &#34;base_data_name&#34;, text=&#34;&#34;, icon=&#39;OUTLINER_OB_MESH&#39;)
        op = row.operator(SvGenerateRandomObjectName.bl_idname, text=&#39;&#39;, icon=&#39;FILE_REFRESH&#39;)
        op.node_name = self.name
        op.tree_name = self.id_data.name
        row = col.row(align=True)
        row.scale_y = 2
        op = row.operator(&#39;node.sv_select_objects&#39;, text=&#34;Select&#34;)
        op.node_name = self.name
        op.tree_name = self.id_data.name
        op = row.operator(SvBakeObjectsOperator.bl_idname, text=&#34;Bake&#34;)
        op.node_name = self.name
        op.tree_name = self.id_data.name

    def init_viewer(self):
        &#34;&#34;&#34;Should be called from descendant class&#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        self.use_custom_color = True

        self.outputs.new(&#39;SvObjectSocket&#39;, &#34;Objects&#34;)

    def sv_copy(self, other):
        &#34;&#34;&#34;
        Regenerate object names, and clean data
        Use super().sv_copy(other) to override this method
        &#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        # object and mesh lists should be clear other wise two nodes would have links to the same objects
        self.object_data.clear()

    def sv_free(self):
        for data in self.object_data:
            data.remove_data()

    def bake(self):
        raise NotImplemented

    def show_viewport(self, is_show: bool):
        &#34;&#34;&#34;It should be called by node tree to show/hide objects&#34;&#34;&#34;
        if not self.show_objects:
            # just ignore request
            pass
        else:
            self.show_objects_update(None, is_show)

    def draw_label(self):
        if self.hide:
            return f&#34;{self.bl_label[:2]}V {self.base_data_name}&#34;
        else:
            return self.bl_label</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects">BlenderObjects</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>sverchok.nodes.viz.geo_nodes_viewer.SvGeoNodesViewerNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.base_data_name"><code class="name">var <span class="ident">base_data_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'default': 'Alpha', 'description': 'stores the mesh name found in the object, this mesh is instanced', 'update': <function updateNode at 0x7f2edd93a040>, 'attr': 'base_data_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.is_active"><code class="name">var <span class="ident">is_active</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'Live', 'default': True, 'update': <function updateNode at 0x7f2edd93a040>, 'description': 'When enabled this will process incoming data', 'attr': 'is_active'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.bake"><code class="name flex">
<span>def <span class="ident">bake</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bake(self):
    raise NotImplemented</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_buttons_fly"><code class="name flex">
<span>def <span class="ident">draw_buttons_fly</span></span>(<span>self, layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_buttons_fly(self, layout):
    col = layout.column()
    row = col.row()

    row_show = row.row(align=True)

    row_show.prop(self, &#39;is_active&#39;, toggle=True)
    row_show.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                  icon=f&#39;HIDE_{&#34;OFF&#34; if self.show_objects else &#34;ON&#34;}&#39;)
    row = row.row(align=True)
    row.prop(self, &#39;selectable_objects&#39;, toggle=True, text=&#39;&#39;,
                icon=f&#34;RESTRICT_SELECT_{&#39;OFF&#39; if self.selectable_objects else &#39;ON&#39;}&#34;)
    row.prop(self, &#39;render_objects&#39;, toggle=True, text=&#39;&#39;,
                icon=f&#34;RESTRICT_RENDER_{&#39;OFF&#39; if self.render_objects else &#39;ON&#39;}&#34;)

    row = col.row(align=True)
    row.prop(self, &#34;base_data_name&#34;, text=&#34;&#34;, icon=&#39;OUTLINER_OB_MESH&#39;)
    op = row.operator(SvGenerateRandomObjectName.bl_idname, text=&#39;&#39;, icon=&#39;FILE_REFRESH&#39;)
    op.node_name = self.name
    op.tree_name = self.id_data.name
    row = col.row(align=True)
    row.scale_y = 2
    op = row.operator(&#39;node.sv_select_objects&#39;, text=&#34;Select&#34;)
    op.node_name = self.name
    op.tree_name = self.id_data.name
    op = row.operator(SvBakeObjectsOperator.bl_idname, text=&#34;Bake&#34;)
    op.node_name = self.name
    op.tree_name = self.id_data.name</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_label"><code class="name flex">
<span>def <span class="ident">draw_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_label(self):
    if self.hide:
        return f&#34;{self.bl_label[:2]}V {self.base_data_name}&#34;
    else:
        return self.bl_label</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_viewer_properties"><code class="name flex">
<span>def <span class="ident">draw_viewer_properties</span></span>(<span>self, layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_viewer_properties(self, layout):
    col = layout.column(align=True)
    row = col.row()

    row_show = row.row(align=True)
    row_show.prop(self, &#39;is_active&#39;, toggle=True)
    row_show.prop(self, &#39;show_objects&#39;, toggle=True, text=&#39;&#39;,
                  icon=f&#39;HIDE_{&#34;OFF&#34; if self.show_objects else &#34;ON&#34;}&#39;)

    row.operator(SvShowFlyPanelOpeartor.bl_idname, text=&#34;Options&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.init_viewer"><code class="name flex">
<span>def <span class="ident">init_viewer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Should be called from descendant class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_viewer(self):
    &#34;&#34;&#34;Should be called from descendant class&#34;&#34;&#34;
    self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
    self.use_custom_color = True

    self.outputs.new(&#39;SvObjectSocket&#39;, &#34;Objects&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.show_viewport"><code class="name flex">
<span>def <span class="ident">show_viewport</span></span>(<span>self, is_show: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>It should be called by node tree to show/hide objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_viewport(self, is_show: bool):
    &#34;&#34;&#34;It should be called by node tree to show/hide objects&#34;&#34;&#34;
    if not self.show_objects:
        # just ignore request
        pass
    else:
        self.show_objects_update(None, is_show)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.sv_copy"><code class="name flex">
<span>def <span class="ident">sv_copy</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Regenerate object names, and clean data
Use super().sv_copy(other) to override this method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sv_copy(self, other):
    &#34;&#34;&#34;
    Regenerate object names, and clean data
    Use super().sv_copy(other) to override this method
    &#34;&#34;&#34;
    self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
    # object and mesh lists should be clear other wise two nodes would have links to the same objects
    self.object_data.clear()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.sv_free"><code class="name flex">
<span>def <span class="ident">sv_free</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sv_free(self):
    for data in self.object_data:
        data.remove_data()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects">BlenderObjects</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.draw_object_properties" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.draw_object_properties">draw_object_properties</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.regenerate_objects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.regenerate_objects">regenerate_objects</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update">show_objects_update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode"><code class="flex name class">
<span>class <span class="ident">SvViewerNode</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin for all nodes which displays any objects in viewport</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvViewerNode(BlenderObjects):
    &#34;&#34;&#34;
    Mixin for all nodes which displays any objects in viewport
    &#34;&#34;&#34;

    is_active: bpy.props.BoolProperty(name=&#39;Live&#39;, default=True, update=updateNode,
                                      description=&#34;When enabled this will process incoming data&#34;,)

    base_data_name: bpy.props.StringProperty(
        default=&#39;Alpha&#39;,
        description=&#39;stores the mesh name found in the object, this mesh is instanced&#39;,
        update=updateNode)

    collection: bpy.props.PointerProperty(type=bpy.types.Collection, update=updateNode,
                                          description=&#34;Collection where to put objects&#34;)

    def draw_viewer_properties(self, layout):
        col = layout.column(align=True)
        row = col.row(align=True)
        row.column().prop(self, &#39;is_active&#39;, toggle=True)

        self.draw_object_properties(row)  # hide, selectable, render

        col = layout.column(align=True)
        row = col.row(align=True)
        row.prop(self, &#34;base_data_name&#34;, text=&#34;&#34;, icon=&#39;OUTLINER_OB_MESH&#39;)
        row.operator(&#39;node.sv_generate_random_object_name&#39;, text=&#39;&#39;, icon=&#39;FILE_REFRESH&#39;)

        row = col.row(align=True)
        row.scale_y = 2
        row.operator(&#39;node.sv_select_objects&#39;, text=&#34;Select&#34;)

        col.prop_search(self, &#39;collection&#39;, bpy.data, &#39;collections&#39;, text=&#39;&#39;, icon=&#39;GROUP&#39;)

    def init_viewer(self):
        &#34;&#34;&#34;Should be called from descendant class&#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        self.use_custom_color = True

        self.outputs.new(&#39;SvObjectSocket&#39;, &#34;Objects&#34;)

    def sv_copy(self, other):
        &#34;&#34;&#34;
        Regenerate object names, and clean data
        Use super().sv_copy(other) to override this method
        &#34;&#34;&#34;
        self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
        # object and mesh lists should be clear other wise two nodes would have links to the same objects
        self.object_data.clear()

    def show_viewport(self, is_show: bool):
        &#34;&#34;&#34;It should be called by node tree to show/hide objects&#34;&#34;&#34;
        if not self.show_objects:
            # just ignore request
            pass
        else:
            self.show_objects_update(None, is_show)

    def load_from_json(self, node_data: dict, import_version: float):
        &#34;&#34;&#34;
        Manually serialization node properties
        Should be overridden in zis way: super().storage_get_data(storage); self.my_prop = storage[&#39;my_prop&#39;]
        &#34;&#34;&#34;
        if import_version &lt;= 0.08:
            collection_name = node_data[&#39;collection&#39;]
            if collection_name:
                collection = (bpy.data.collections.get(collection_name))
                if not collection:
                    collection = bpy.data.collections.new(collection_name)
                    bpy.context.collection.children.link(collection)
                self.collection = collection

    def draw_label(self):
        if self.hide:
            return f&#34;{self.bl_label[:2]}V {self.base_data_name}&#34;
        else:
            return self.bl_label</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects">BlenderObjects</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>sverchok.nodes.viz.dupli_instances_lite.SvDupliInstancesLite</li>
<li>sverchok.nodes.viz.dupli_instances_mk5.SvDupliInstancesMK5</li>
<li>sverchok.nodes.viz.instancer.SvInstancerNodeMK3</li>
<li>sverchok.nodes.viz.light_viewer.SvLightViewerNode</li>
<li>sverchok.nodes.viz.mesh_viewer.SvMeshViewer</li>
<li>sverchok.nodes.viz.polyline_viewer.SvPolylineViewerNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.base_data_name"><code class="name">var <span class="ident">base_data_name</span> : <_PropertyDeferred, <built-in function StringProperty>, {'default': 'Alpha', 'description': 'stores the mesh name found in the object, this mesh is instanced', 'update': <function updateNode at 0x7f2edd93a040>, 'attr': 'base_data_name'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.collection"><code class="name">var <span class="ident">collection</span> : <_PropertyDeferred, <built-in function PointerProperty>, {'type': <class 'bpy_types.Collection'>, 'update': <function updateNode at 0x7f2edd93a040>, 'description': 'Collection where to put objects', 'attr': 'collection'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.is_active"><code class="name">var <span class="ident">is_active</span> : <_PropertyDeferred, <built-in function BoolProperty>, {'name': 'Live', 'default': True, 'update': <function updateNode at 0x7f2edd93a040>, 'description': 'When enabled this will process incoming data', 'attr': 'is_active'}></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.draw_label"><code class="name flex">
<span>def <span class="ident">draw_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_label(self):
    if self.hide:
        return f&#34;{self.bl_label[:2]}V {self.base_data_name}&#34;
    else:
        return self.bl_label</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.draw_viewer_properties"><code class="name flex">
<span>def <span class="ident">draw_viewer_properties</span></span>(<span>self, layout)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_viewer_properties(self, layout):
    col = layout.column(align=True)
    row = col.row(align=True)
    row.column().prop(self, &#39;is_active&#39;, toggle=True)

    self.draw_object_properties(row)  # hide, selectable, render

    col = layout.column(align=True)
    row = col.row(align=True)
    row.prop(self, &#34;base_data_name&#34;, text=&#34;&#34;, icon=&#39;OUTLINER_OB_MESH&#39;)
    row.operator(&#39;node.sv_generate_random_object_name&#39;, text=&#39;&#39;, icon=&#39;FILE_REFRESH&#39;)

    row = col.row(align=True)
    row.scale_y = 2
    row.operator(&#39;node.sv_select_objects&#39;, text=&#34;Select&#34;)

    col.prop_search(self, &#39;collection&#39;, bpy.data, &#39;collections&#39;, text=&#39;&#39;, icon=&#39;GROUP&#39;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.init_viewer"><code class="name flex">
<span>def <span class="ident">init_viewer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Should be called from descendant class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_viewer(self):
    &#34;&#34;&#34;Should be called from descendant class&#34;&#34;&#34;
    self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
    self.use_custom_color = True

    self.outputs.new(&#39;SvObjectSocket&#39;, &#34;Objects&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.load_from_json"><code class="name flex">
<span>def <span class="ident">load_from_json</span></span>(<span>self, node_data: dict, import_version: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Manually serialization node properties
Should be overridden in zis way: super().storage_get_data(storage); self.my_prop = storage['my_prop']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_json(self, node_data: dict, import_version: float):
    &#34;&#34;&#34;
    Manually serialization node properties
    Should be overridden in zis way: super().storage_get_data(storage); self.my_prop = storage[&#39;my_prop&#39;]
    &#34;&#34;&#34;
    if import_version &lt;= 0.08:
        collection_name = node_data[&#39;collection&#39;]
        if collection_name:
            collection = (bpy.data.collections.get(collection_name))
            if not collection:
                collection = bpy.data.collections.new(collection_name)
                bpy.context.collection.children.link(collection)
            self.collection = collection</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.show_viewport"><code class="name flex">
<span>def <span class="ident">show_viewport</span></span>(<span>self, is_show: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>It should be called by node tree to show/hide objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_viewport(self, is_show: bool):
    &#34;&#34;&#34;It should be called by node tree to show/hide objects&#34;&#34;&#34;
    if not self.show_objects:
        # just ignore request
        pass
    else:
        self.show_objects_update(None, is_show)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.sv_copy"><code class="name flex">
<span>def <span class="ident">sv_copy</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Regenerate object names, and clean data
Use super().sv_copy(other) to override this method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sv_copy(self, other):
    &#34;&#34;&#34;
    Regenerate object names, and clean data
    Use super().sv_copy(other) to override this method
    &#34;&#34;&#34;
    self.base_data_name = bpy.context.scene.sv_object_names.get_available_name()
    # object and mesh lists should be clear other wise two nodes would have links to the same objects
    self.object_data.clear()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects">BlenderObjects</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.draw_object_properties" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.draw_object_properties">draw_object_properties</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.regenerate_objects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.regenerate_objects">regenerate_objects</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update">show_objects_update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.nodes_mixins" href="index.html">sverchok.utils.nodes_mixins</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.register" href="#sverchok.utils.nodes_mixins.generating_objects.register">register</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.unregister" href="#sverchok.utils.nodes_mixins.generating_objects.unregister">unregister</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects">BlenderObjects</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.draw_object_properties" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.draw_object_properties">draw_object_properties</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.object_data" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.object_data">object_data</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.regenerate_objects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.regenerate_objects">regenerate_objects</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects">render_objects</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.render_objects_update">render_objects_update</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects">selectable_objects</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.selectable_objects_update">selectable_objects_update</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects">show_objects</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update" href="#sverchok.utils.nodes_mixins.generating_objects.BlenderObjects.show_objects_update">show_objects_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode">SearchNode</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode.invoke" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode.invoke">invoke</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode.node" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode.node">node</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode.node_name" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode.node_name">node_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SearchNode.tree_name" href="#sverchok.utils.nodes_mixins.generating_objects.SearchNode.tree_name">tree_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator">SvBakeObjectsOperator</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_idname" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_idname">bl_idname</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_label" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_label">bl_label</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_options" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_options">bl_options</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.execute" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.execute">execute</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.node_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.node_name">node_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.tree_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvBakeObjectsOperator.tree_name">tree_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial">SvCreateMaterial</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_idname" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_idname">bl_idname</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_label" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_label">bl_label</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_options" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_options">bl_options</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.description" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.description">description</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.execute" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.execute">execute</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.poll" href="#sverchok.utils.nodes_mixins.generating_objects.SvCreateMaterial.poll">poll</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCurveData" href="#sverchok.utils.nodes_mixins.generating_objects.SvCurveData">SvCurveData</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvCurveData.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.curve" href="#sverchok.utils.nodes_mixins.generating_objects.SvCurveData.curve">curve</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.regenerate_curve" href="#sverchok.utils.nodes_mixins.generating_objects.SvCurveData.regenerate_curve">regenerate_curve</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvCurveData.remove_data" href="#sverchok.utils.nodes_mixins.generating_objects.SvCurveData.remove_data">remove_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName">SvGenerateRandomObjectName</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_idname" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_idname">bl_idname</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_label" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_label">bl_label</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_options" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_options">bl_options</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.description" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.description">description</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.execute" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.execute">execute</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.node_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.node_name">node_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.tree_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvGenerateRandomObjectName.tree_name">tree_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvLightData" href="#sverchok.utils.nodes_mixins.generating_objects.SvLightData">SvLightData</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvLightData.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvLightData.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvLightData.light" href="#sverchok.utils.nodes_mixins.generating_objects.SvLightData.light">light</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvLightData.regenerate_light" href="#sverchok.utils.nodes_mixins.generating_objects.SvLightData.regenerate_light">regenerate_light</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvLightData.remove_data" href="#sverchok.utils.nodes_mixins.generating_objects.SvLightData.remove_data">remove_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData">SvMeshData</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.copy" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.is_topology_changed" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.is_topology_changed">is_topology_changed</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.mesh" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.mesh">mesh</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.regenerate_mesh" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.regenerate_mesh">regenerate_mesh</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.remove_data" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.remove_data">remove_data</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.set_smooth" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.set_smooth">set_smooth</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvMeshData.update_vertices" href="#sverchok.utils.nodes_mixins.generating_objects.SvMeshData.update_vertices">update_vertices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData">SvObjectData</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.check_object_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.check_object_name">check_object_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.check_object_show_state" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.check_object_show_state">check_object_show_state</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.collection" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.collection">collection</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.copy" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.ensure_link_to_collection" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.ensure_link_to_collection">ensure_link_to_collection</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.ensure_object" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.ensure_object">ensure_object</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.obj" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.obj">obj</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.recreate_object" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.recreate_object">recreate_object</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.remove_data" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.remove_data">remove_data</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectData.select" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectData.select">select</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectNames">SvObjectNames</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.available_name_number" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.available_name_number">available_name_number</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.get_available_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.get_available_name">get_available_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.get_random_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.get_random_name">get_random_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.greek_alphabet" href="#sverchok.utils.nodes_mixins.generating_objects.SvObjectNames.greek_alphabet">greek_alphabet</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects">SvSelectObjects</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_idname" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_idname">bl_idname</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_label" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_label">bl_label</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_options" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_options">bl_options</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.description" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.description">description</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.execute" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.execute">execute</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.node_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.node_name">node_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.tree_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvSelectObjects.tree_name">tree_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor">SvShowFlyPanelOpeartor</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_idname" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_idname">bl_idname</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_label" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_label">bl_label</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_options" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_options">bl_options</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_rna" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.bl_rna">bl_rna</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.draw" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.draw">draw</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.execute" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.execute">execute</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.invoke" href="#sverchok.utils.nodes_mixins.generating_objects.SvShowFlyPanelOpeartor.invoke">invoke</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode">SvViewerLightNode</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.bake" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.bake">bake</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.base_data_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.base_data_name">base_data_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_buttons_fly" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_buttons_fly">draw_buttons_fly</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_label" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_label">draw_label</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_viewer_properties" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.draw_viewer_properties">draw_viewer_properties</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.init_viewer" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.init_viewer">init_viewer</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.is_active" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.is_active">is_active</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.show_viewport" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.show_viewport">show_viewport</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.sv_copy" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.sv_copy">sv_copy</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.sv_free" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerLightNode.sv_free">sv_free</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode">SvViewerNode</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.base_data_name" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.base_data_name">base_data_name</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.collection" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.collection">collection</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.draw_label" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.draw_label">draw_label</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.draw_viewer_properties" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.draw_viewer_properties">draw_viewer_properties</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.init_viewer" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.init_viewer">init_viewer</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.is_active" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.is_active">is_active</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.load_from_json" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.load_from_json">load_from_json</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.show_viewport" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.show_viewport">show_viewport</a></code></li>
<li><code><a title="sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.sv_copy" href="#sverchok.utils.nodes_mixins.generating_objects.SvViewerNode.sv_copy">sv_copy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>