<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.surface.nurbs API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.surface.nurbs</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from collections import defaultdict

from sverchok.utils.geom import Spline
from sverchok.utils.nurbs_common import (
        SvNurbsMaths, SvNurbsBasisFunctions,
        nurbs_divide, from_homogenous,
        CantRemoveKnotException, CantReduceDegreeException
    )
from sverchok.utils.curve import knotvector as sv_knotvector
from sverchok.utils.curve.nurbs_algorithms import unify_curves, nurbs_curve_to_xoy, nurbs_curve_matrix
from sverchok.utils.curve.algorithms import unify_curves_degree, SvCurveFrameCalculator
from sverchok.utils.curve.nurbs_solver_applications import interpolate_nurbs_curve_with_tangents
from sverchok.utils.surface.core import UnsupportedSurfaceTypeException
from sverchok.utils.surface import SvSurface, SurfaceCurvatureCalculator, SurfaceDerivativesData
from sverchok.utils.sv_logging import sv_logger, get_logger
from sverchok.data_structure import repeat_last_for_length
from sverchok.dependencies import geomdl

if geomdl is not None:
    from geomdl import operations
    from geomdl import NURBS, BSpline

##################
#                #
#  Surfaces      #
#                #
##################

class SvNurbsSurface(SvSurface):
    &#34;&#34;&#34;
    Base abstract class for all supported implementations of NURBS surfaces.
    &#34;&#34;&#34;
    NATIVE = SvNurbsMaths.NATIVE
    GEOMDL = SvNurbsMaths.GEOMDL

    U = &#39;U&#39;
    V = &#39;V&#39;

    @classmethod
    def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
        return SvNurbsMaths.build_surface(implementation,
                    degree_u, degree_v,
                    knotvector_u, knotvector_v,
                    control_points, weights,
                    normalize_knots)

    @classmethod
    def get(cls, surface, implementation = NATIVE):
        if isinstance(surface, SvNurbsSurface):
            return surface
        if hasattr(surface, &#39;to_nurbs&#39;):
            try:
                return surface.to_nurbs(implementation=implementation)
            except UnsupportedSurfaceTypeException as e:
                sv_logger.info(&#34;Can&#39;t convert %s to NURBS: %s&#34;, surface, e)
        return None

    @classmethod
    def get_nurbs_implementation(cls):
        raise Exception(&#34;NURBS implementation is not defined&#34;)

    def copy(self, implementation = None, degree_u=None, degree_v = None, knotvector_u = None, knotvector_v = None, control_points = None, weights = None):
        if implementation is None:
            implementation = self.get_nurbs_implementation()
        if degree_u is None:
            degree_u = self.get_degree_u()
        if degree_v is None:
            degree_v = self.get_degree_v()
        if knotvector_u is None:
            knotvector_u = self.get_knotvector_u()
        if knotvector_v is None:
            knotvector_v = self.get_knotvector_v()
        if control_points is None:
            control_points = self.get_control_points()
        if weights is None:
            weights = self.get_weights()

        return SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)

    def insert_knot(self, direction, parameter, count=1, if_possible=False):
        raise Exception(&#34;Not implemented!&#34;)

    def remove_knot(self, direction, parameter, count=1, tolerance=None, if_possible=False):
        raise Exception(&#34;Not implemented!&#34;)

    def get_degree_u(self):
        raise Exception(&#34;Not implemented!&#34;)

    def get_degree_v(self):
        raise Exception(&#34;Not implemented!&#34;)

    def get_knotvector_u(self):
        &#34;&#34;&#34;
        returns: np.array of shape (X,)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def get_knotvector_v(self):
        &#34;&#34;&#34;
        returns: np.array of shape (X,)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def get_control_points(self):
        &#34;&#34;&#34;
        returns: np.array of shape (n_u, n_v, 3)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def get_weights(self):
        &#34;&#34;&#34;
        returns: np.array of shape (n_u, n_v)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def iso_curve(self, fixed_direction, param):
        raise Exception(&#34;Not implemented&#34;)
    
    def is_rational(self, tolerance=1e-4):
        weights = self.get_weights()
        w, W = weights.min(), weights.max()
        return (W - w) &gt; tolerance

    def calc_greville_us(self):
        n = self.get_control_points().shape[0]
        p = self.get_degree_u()
        kv = self.get_knotvector_u()
        return sv_knotvector.calc_nodes(p, n, kv)

    def calc_greville_vs(self):
        n = self.get_control_points().shape[1]
        p = self.get_degree_v()
        kv = self.get_knotvector_v()
        return sv_knotvector.calc_nodes(p, n, kv)

    def get_homogenous_control_points(self):
        &#34;&#34;&#34;
        returns: np.array of shape (m, n, 4)
        &#34;&#34;&#34;
        points = self.get_control_points()
        weights = np.transpose(self.get_weights()[np.newaxis], axes=(1,2,0))
        weighted = weights * points
        return np.concatenate((weighted, weights), axis=2)

    def get_min_u_continuity(self):
        &#34;&#34;&#34;
        Return minimum continuity degree of the surface in the U direction (guaranteed by knotvector):
        0 - point-wise continuity only (C0),
        1 - tangent continuity (C1),
        2 - 2nd derivative continuity (C2), and so on.
        &#34;&#34;&#34;
        kv = self.get_knotvector_u()
        degree = self.get_degree_u()
        return sv_knotvector.get_min_continuity(kv, degree)

    def get_min_v_continuity(self):
        &#34;&#34;&#34;
        Return minimum continuity degree of the surface in the V direction (guaranteed by knotvector):
        0 - point-wise continuity only (C0),
        1 - tangent continuity (C1),
        2 - 2nd derivative continuity (C2), and so on.
        &#34;&#34;&#34;
        kv = self.get_knotvector_v()
        degree = self.get_degree_v()
        return sv_knotvector.get_min_continuity(kv, degree)
    
    def get_min_continuity(self):
        &#34;&#34;&#34;
        Return minimum continuity degree of the surface (guaranteed by knotvectors):
        0 - point-wise continuity only (C0),
        1 - tangent continuity (C1),
        2 - 2nd derivative continuity (C2), and so on.
        &#34;&#34;&#34;
        c_u = self.get_min_u_continuity()
        c_v = self.get_min_v_continuity()
        return min(c_u, c_v)

    def swap_uv(self):
        degree_u = self.get_degree_u()
        degree_v = self.get_degree_v()
        knotvector_u = self.get_knotvector_u()
        knotvector_v = self.get_knotvector_v()

        control_points = self.get_control_points()
        weights = self.get_weights()

        control_points = np.transpose(control_points, axes=(1,0,2))
        weights = weights.T

        return SvNurbsSurface.build(self.get_nurbs_implementation(),
                degree_v, degree_u,
                knotvector_v, knotvector_u,
                control_points, weights)

    def elevate_degree(self, direction, delta=None, target=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        if direction == SvNurbsSurface.U:
            degree = self.get_degree_u()
        else:
            degree = self.get_degree_v()
        if delta is None:
            delta = target - degree
            if delta &lt; 0:
                raise Exception(f&#34;Surface already has degree {degree}, which is greater than target {target}&#34;)
        if delta == 0:
            return self

        implementation = self.get_nurbs_implementation()

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_u(), self.get_knotvector_u(),
                                    fixed_v_points, fixed_v_weights)
                fixed_v_curve = fixed_v_curve.elevate_degree(delta)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            return SvNurbsSurface.build(self.get_nurbs_implementation(),
                    new_u_degree, self.get_degree_v(),
                    fixed_v_knotvector, self.get_knotvector_v(),
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_v(), self.get_knotvector_v(),
                                    fixed_u_points, fixed_u_weights)
                fixed_u_curve = fixed_u_curve.elevate_degree(delta)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            return SvNurbsSurface.build(implementation,
                    self.get_degree_u(), new_v_degree,
                    self.get_knotvector_u(), fixed_u_knotvector,
                    new_points, new_weights)

    def reduce_degree(self, direction, delta=None, target=None, tolerance=1e-6, logger=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        if direction == SvNurbsSurface.U:
            degree = self.get_degree_u()
        else:
            degree = self.get_degree_v()
        if delta is None:
            delta = degree - target
            if delta &lt; 0:
                raise Exception(f&#34;Surface already has degree {degree}, which is less than target {target}&#34;)
        if delta == 0:
            return self

        if logger is None:
            logger = get_logger()

        implementation = self.get_nurbs_implementation()

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            remaining_tolerance = tolerance
            max_error = 0.0
            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_u(), self.get_knotvector_u(),
                                    fixed_v_points, fixed_v_weights)
                try:
                    fixed_v_curve, error = fixed_v_curve.reduce_degree(delta=delta, tolerance=remaining_tolerance, return_error=True, logger=logger)
                except CantReduceDegreeException as e:
                    raise CantReduceDegreeException(f&#34;At parallel #{i}: {e}&#34;) from e
                max_error = max(max_error, error)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            logger.debug(f&#34;Surface degree reduction error: {max_error}&#34;)

            return SvNurbsSurface.build(self.get_nurbs_implementation(),
                    new_u_degree, self.get_degree_v(),
                    fixed_v_knotvector, self.get_knotvector_v(),
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            remaining_tolerance = tolerance
            max_error = 0.0
            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_v(), self.get_knotvector_v(),
                                    fixed_u_points, fixed_u_weights)
                try:
                    fixed_u_curve, error = fixed_u_curve.reduce_degree(delta=delta, tolerance=remaining_tolerance, return_error=True, logger=logger)
                except CantReduceDegreeException as e:
                    raise CantReduceDegreeException(f&#34;At parallel #{i}: {e}&#34;) from e
                max_error = max(max_error, error)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            logger.debug(f&#34;Surface degree reduction error: {max_error}&#34;)

            return SvNurbsSurface.build(implementation,
                    self.get_degree_u(), new_v_degree,
                    self.get_knotvector_u(), fixed_u_knotvector,
                    new_points, new_weights)

    def cut_u(self, u):
        u_min, u_max = self.get_u_min(), self.get_u_max()

        if u &lt;= u_min:
            return None, self
        if u &gt;= u_max:
            return self, None

        knotvector = self.get_knotvector_u()
        current_multiplicity = sv_knotvector.find_multiplicity(knotvector, u)
        to_add = self.get_degree_u() - current_multiplicity
        surface = self.insert_knot(&#39;U&#39;, u, count=to_add)
        knot_span = np.searchsorted(knotvector, u)

        us = np.full((self.get_degree_u()+1,), u)
        knotvector1 = np.concatenate((surface.get_knotvector_u()[:knot_span], us))
        knotvector2 = np.insert(surface.get_knotvector_u()[knot_span:], 0, u)

        control_points_1 = surface.get_control_points()[:knot_span, :]
        control_points_2 = surface.get_control_points()[knot_span-1:, :]
        weights_1 = surface.get_weights()[:knot_span, :]
        weights_2 = surface.get_weights()[knot_span-1:, :]

        surface1 = self.copy(knotvector_u=knotvector1, weights=weights_1, control_points=control_points_1)
        surface2 = self.copy(knotvector_u=knotvector2, weights=weights_2, control_points=control_points_2)

        return surface1, surface2

    def cut_v(self, v):
        v_min, v_max = self.get_v_min(), self.get_v_max()

        if v &lt;= v_min:
            return None, self
        if v &gt;= v_max:
            return self, None

        current_multiplicity = sv_knotvector.find_multiplicity(self.get_knotvector_v(), v)
        to_add = self.get_degree_v() - current_multiplicity
        surface = self.insert_knot(&#39;V&#39;, v, count=to_add)
        m,n,_ = surface.get_control_points().shape
        knot_span = sv_knotvector.find_span(surface.get_knotvector_v(), n, v) - 1
        #knot_span = np.searchsorted(surface.get_knotvector_v(), v)#, side=&#39;right&#39;)-1

        vs = np.full((self.get_degree_v()+1,), v)
        knotvector1 = np.concatenate((surface.get_knotvector_v()[:knot_span], vs))
        knotvector2 = np.insert(surface.get_knotvector_v()[knot_span:], 0, v)

        control_points_1 = surface.get_control_points()[:, :knot_span]
        control_points_2 = surface.get_control_points()[:, knot_span-1:]
        weights_1 = surface.get_weights()[:, :knot_span]
        weights_2 = surface.get_weights()[:, knot_span-1:]

        surface1 = self.copy(knotvector_v=knotvector1, weights=weights_1, control_points=control_points_1)
        surface2 = self.copy(knotvector_v=knotvector2, weights=weights_2, control_points=control_points_2)

        return surface1, surface2

    def split_at(self, direction, parameter):
        if direction == SvNurbsSurface.U:
            return self.cut_u(parameter)
        elif direction == SvNurbsSurface.V:
            return self.cut_v(parameter)
        else:
            raise Exception(&#34;Unsupported direction&#34;)

    def cut_slice(self, direction, p_min, p_max):
        _, rest = self.split_at(direction, p_min)
        if rest is None:
            return None
        result, _ = rest.split_at(direction, p_max)
        return result

    def _concat_u(self, surface2, tolerance=1e-6):
        surface1 = self
        surface2 = SvNurbsSurface.get(surface2)
        if surface2 is None:
            raise UnsupportedSurfaceTypeException(&#34;second surface is not NURBS&#34;)

        if surface1.get_control_points().shape[1] != surface2.get_control_points().shape[1]:
            # TODO: try to unify knots first?
            raise UnsupportedSurfaceTypeException(&#34;number of control points along V direction does not match&#34;)

        p1, p2 = surface1.get_degree_u(), surface2.get_degree_u()
        if p1 &gt; p2:
            surface2 = surface2.elevate_degree(&#39;U&#39;, delta = p1 - p2)
        elif p2 &gt; p1:
            surface1 = surface1.elevate_degree(&#39;U&#39;, delta = p2 - p1)

        cps1 = surface1.get_control_points()[-1,:]
        cps2 = surface2.get_control_points()[0,:]
        dpts = np.linalg.norm(cps1 - cps2, axis=0)
        if (dpts &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Boundary control points do not match&#34;)

        ws1 = surface1.get_weights()[-1,:]
        ws2 = surface2.get_weights()[0,:]
        if (np.abs(ws1 - ws2) &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Weights at bounds do not match&#34;)

        p = surface1.get_degree_u()

        kv1 = surface1.get_knotvector_u()
        kv2 = surface2.get_knotvector_u()
        kv1_end_multiplicity = sv_knotvector.to_multiplicity(kv1)[-1][1]
        kv2_start_multiplicity = sv_knotvector.to_multiplicity(kv2)[0][1]
        if kv1_end_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;End knot multiplicity of the first surface ({kv1_end_multiplicity}) is not equal to degree+1 ({p+1})&#34;)
        if kv2_start_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;Start knot multiplicity of the second surface ({kv2_start_multiplicity}) is not equal to degree+1 ({p+1})&#34;)

        knotvector = sv_knotvector.concatenate(kv1, kv2, join_multiplicity=p)

        weights = np.concatenate((surface1.get_weights(), surface2.get_weights()[1:]))
        control_points = np.concatenate((surface1.get_control_points(), surface2.get_control_points()[1:]))

        result = surface1.copy(knotvector_u = knotvector,
                    control_points = control_points,
                    weights = weights)
        return result

    def _concat_v(self, surface2, tolerance=1e-6):
        surface1 = self
        surface2 = SvNurbsSurface.get(surface2)
        if surface2 is None:
            raise UnsupportedSurfaceTypeException(&#34;second surface is not NURBS&#34;)

        if surface1.get_control_points().shape[0] != surface2.get_control_points().shape[0]:
            # TODO: try to unify knots first?
            raise UnsupportedSurfaceTypeException(&#34;number of control points along U direction does not match&#34;)

        p1, p2 = surface1.get_degree_v(), surface2.get_degree_v()
        if p1 &gt; p2:
            surface2 = surface2.elevate_degree(&#39;V&#39;, delta = p1 - p2)
        elif p2 &gt; p1:
            surface1 = surface1.elevate_degree(&#39;V&#39;, delta = p2 - p1)
        cps1 = surface1.get_control_points()[:,-1]
        cps2 = surface2.get_control_points()[:,0]
        dpts = np.linalg.norm(cps1 - cps2, axis=0)
        if (dpts &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Boundary control points do not match&#34;)

        ws1 = surface1.get_weights()[:,-1]
        ws2 = surface2.get_weights()[:,0]
        if (np.abs(ws1 - ws2) &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Weights at bounds do not match&#34;)

        p = surface1.get_degree_v()

        kv1 = surface1.get_knotvector_v()
        kv2 = surface2.get_knotvector_v()
        kv1_end_multiplicity = sv_knotvector.to_multiplicity(kv1)[-1][1]
        kv2_start_multiplicity = sv_knotvector.to_multiplicity(kv2)[0][1]
        if kv1_end_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;End knot multiplicity of the first surface ({kv1_end_multiplicity}) is not equal to degree+1 ({p+1})&#34;)
        if kv2_start_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;Start knot multiplicity of the second surface ({kv2_start_multiplicity}) is not equal to degree+1 ({p+1})&#34;)

        knotvector = sv_knotvector.concatenate(kv1, kv2, join_multiplicity=p)

        weights = np.concatenate((surface1.get_weights(), surface2.get_weights()[:,1:]), axis=1)
        control_points = np.concatenate((surface1.get_control_points(), surface2.get_control_points()[:,1:]), axis=1)

        result = surface1.copy(knotvector_v = knotvector,
                    control_points = control_points,
                    weights = weights)
        return result

    def concatenate(self, direction, surface2, tolerance=1e-6):
        if direction == SvNurbsSurface.U:
            return self._concat_u(surface2, tolerance)
        elif direction == SvNurbsSurface.V:
            return self._concat_v(surface2, tolerance)
        else:
            raise Exception(&#34;Unsupported direction&#34;)

class SvGeomdlSurface(SvNurbsSurface):
    def __init__(self, surface):
        self.surface = surface
        self.u_bounds = (0, 1)
        self.v_bounds = (0, 1)
        self.__description__ = f&#34;Geomdl NURBS (degree={surface.degree_u}x{surface.degree_v}, pts={len(surface.ctrlpts2d)}x{len(surface.ctrlpts2d[0])})&#34;

    @classmethod
    def get_nurbs_implementation(cls):
        return SvNurbsSurface.GEOMDL

    def insert_knot(self, direction, parameter, count=1, if_possible=False):
        if direction == SvNurbsSurface.U:
            uv = [parameter, None]
            counts = [count, 0]
        elif direction == SvNurbsSurface.V:
            uv = [None, parameter]
            counts = [0, count]
        surface = operations.insert_knot(self.surface, uv, counts)
        return SvGeomdlSurface(surface)

    def remove_knot(self, direction, parameter, count=1, if_possible=False, tolerance=None):
        if direction == SvNurbsSurface.U:
            orig_kv = self.get_knotvector_u()
            uv = [parameter, None]
            counts = [count, 0]
        elif direction == SvNurbsSurface.V:
            orig_kv = self.get_knotvector_v()
            uv = [None, parameter]
            counts = [0, count]
        orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)

        surface = operations.remove_knot(self.surface, uv, counts)

        if direction == SvNurbsSurface.U:
            new_kv = self.get_knotvector_u()
        elif direction == SvNurbsSurface.V:
            new_kv = self.get_knotvector_v()

        new_multiplicity = sv_knotvector.find_multiplicity(new_kv, parameter)

        if not if_possible and (orig_multiplicity - new_multiplicity &lt; count):
            raise CantRemoveKnotException(f&#34;Asked to remove knot {direction}={parameter} {count} times, but could remove it only {orig_multiplicity-new_multiplicity} times&#34;)

        return SvGeomdlSurface(surface)

    def get_degree_u(self):
        return self.surface.degree_u

    def get_degree_v(self):
        return self.surface.degree_v

    def get_knotvector_u(self):
        return np.array(self.surface.knotvector_u)

    def get_knotvector_v(self):
        return np.array(self.surface.knotvector_v)

    def get_control_points(self):
        pts = []
        for row in self.surface.ctrlpts2d:
            new_row = []
            for point in row:
                if len(point) == 4:
                    x,y,z,w = point
                    new_point = (x/w, y/w, z/w)
                else:
                    new_point = point
                new_row.append(new_point)
            pts.append(new_row)
        return np.array(pts)

    def get_weights(self):
        if isinstance(self.surface, NURBS.Surface):
            weights = [[pt[3] for pt in row] for row in self.surface.ctrlpts2d]
        else:
            weights = [[1.0 for pt in row] for row in self.surface.ctrlpts2d]
        return np.array(weights)

    @classmethod
    def build_geomdl(cls, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots=False):

        def convert_row(verts_row, weights_row):
            return [(x*w, y*w, z*w, w) for (x,y,z), w in zip(verts_row, weights_row)]

        if weights is None:
            surf = BSpline.Surface(normalize_kv = normalize_knots)
        else:
            surf = NURBS.Surface(normalize_kv = normalize_knots)
        surf.degree_u = degree_u
        surf.degree_v = degree_v
        if weights is None:
            ctrlpts = control_points
        else:
            ctrlpts = list(map(convert_row, control_points, weights))
        surf.ctrlpts2d = ctrlpts
        surf.knotvector_u = knotvector_u
        surf.knotvector_v = knotvector_v

        result = SvGeomdlSurface(surf)
        result.u_bounds = surf.knotvector_u[0], surf.knotvector_u[-1]
        result.v_bounds = surf.knotvector_v[0], surf.knotvector_v[-1]
        return result

    @classmethod
    def from_any_nurbs(cls, surface):
        if not isinstance(surface, SvNurbsSurface):
            raise TypeError(&#34;Invalid surface&#34;)
        if isinstance(surface, SvGeomdlSurface):
            return surface
        return SvGeomdlSurface.build_geomdl(surface.get_degree_u(), surface.get_degree_v(),
                    surface.get_knotvector_u(), surface.get_knotvector_v(),
                    surface.get_control_points(),
                    surface.get_weights())

    @classmethod
    def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
        return SvGeomdlSurface.build_geomdl(degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots)

    def get_input_orientation(self):
        return &#39;Z&#39;

    def get_coord_mode(self):
        return &#39;UV&#39;

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]

    @property
    def has_input_matrix(self):
        return False

    def evaluate(self, u, v):
        vert = self.surface.evaluate_single((u, v))
        return np.array(vert)

    def evaluate_array(self, us, vs):
        uv_coords = list(zip(list(us), list(vs)))
        verts = self.surface.evaluate_list(uv_coords)
        verts = np.array(verts)
        return verts

    def iso_curve(self, fixed_direction, param, flip=False):
        if self.surface.rational:
            raise UnsupportedSurfaceTypeException(&#34;iso_curve() is not supported for rational Geomdl surfaces yet&#34;)
        controls = self.get_control_points()
        weights = self.get_weights()
        k_u,k_v = weights.shape
        if fixed_direction == SvNurbsSurface.U:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_u(),
                            self.get_knotvector_u(),
                            controls[:,j], weights[:,j]) for j in range(k_v)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = np.ones((k_v,))
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_v(),
                    self.get_knotvector_v(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve
        elif fixed_direction == SvNurbsSurface.V:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_v(),
                            self.get_knotvector_v(),
                            controls[i,:], weights[i,:]) for i in range(k_u)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = np.ones((k_u,))
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_u(),
                    self.get_knotvector_u(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve
    def normal(self, u, v):
        return self.normal_array(np.array([u]), np.array([v]))[0]

    def normal_array(self, us, vs):
        if geomdl is not None:
            uv_coords = list(zip(list(us), list(vs)))
            spline_normals = np.array( operations.normal(self.surface, uv_coords) )[:,1,:]
            return spline_normals

    def derivatives_list(self, us, vs):
        result = []
        for u, v in zip(us, vs):
            ds = self.surface.derivatives(u, v, order=2)
            result.append(ds)
        return np.array(result)

    def curvature_calculator(self, us, vs, order=True):
        surf_vertices = self.evaluate_array(us, vs)

        derivatives = self.derivatives_list(us, vs)
        # derivatives[i][j][k] = derivative w.r.t U j times, w.r.t. V k times, at i&#39;th pair of (u, v)
        fu = derivatives[:,1,0]
        fv = derivatives[:,0,1]

        normal = np.cross(fu, fv)
        norm = np.linalg.norm(normal, axis=1, keepdims=True)
        normal = normal / norm

        fuu = derivatives[:,2,0]
        fvv = derivatives[:,0,2]
        fuv = derivatives[:,1,1]

        nuu = (fuu * normal).sum(axis=1)
        nvv = (fvv * normal).sum(axis=1)
        nuv = (fuv * normal).sum(axis=1)

        duu = np.linalg.norm(fu, axis=1) **2
        dvv = np.linalg.norm(fv, axis=1) **2
        duv = (fu * fv).sum(axis=1)

        calc = SurfaceCurvatureCalculator(us, vs, order=order)
        calc.set(surf_vertices, normal, fu, fv, duu, dvv, duv, nuu, nvv, nuv)
        return calc

    def derivatives_data_array(self, us, vs):
        surf_vertices = self.evaluate_array(us, vs)
        derivatives = self.derivatives_list(us, vs)
        # derivatives[i][j][k] = derivative w.r.t U j times, w.r.t. V k times, at i&#39;th pair of (u, v)
        du = derivatives[:,1,0]
        dv = derivatives[:,0,1]
        return SurfaceDerivativesData(surf_vertices, du, dv)

class SvNativeNurbsSurface(SvNurbsSurface):
    def __init__(self, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots=False):
        self.degree_u = degree_u
        self.degree_v = degree_v
        self.knotvector_u = np.array(knotvector_u)
        self.knotvector_v = np.array(knotvector_v)
        if normalize_knots:
            self.knotvector_u = sv_knotvector.normalize(self.knotvector_u)
            self.knotvector_v = sv_knotvector.normalize(self.knotvector_v)
        self.control_points = np.array(control_points)
        c_ku, c_kv, _ = self.control_points.shape
        if weights is None:
            self.weights = weights = np.ones((c_ku, c_kv))
        else:
            self.weights = np.array(weights)
            w_ku, w_kv = self.weights.shape
            if c_ku != w_ku or c_kv != w_kv:
                raise Exception(f&#34;Shape of control_points ({c_ku}, {c_kv}) does not match to shape of weights ({w_ku}, {w_kv})&#34;)
        self.basis_u = SvNurbsBasisFunctions(knotvector_u)
        self.basis_v = SvNurbsBasisFunctions(knotvector_v)
        self.u_bounds = (self.knotvector_u.min(), self.knotvector_u.max())
        self.v_bounds = (self.knotvector_v.min(), self.knotvector_v.max())
        self.normal_delta = 0.0001
        self.__description__ = f&#34;Native NURBS (degree={degree_u}x{degree_v}, pts={self.control_points.shape[0]}x{self.control_points.shape[1]})&#34;

    @classmethod
    def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
        return SvNativeNurbsSurface(degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots)

    @classmethod
    def get_nurbs_implementation(cls):
        return SvNurbsSurface.NATIVE

    def insert_knot(self, direction, parameter, count=1, if_possible=False):
        def get_common_count(curves):
            if not if_possible:
                # in this case the first curve.rinsert() call which can&#39;t insert the knot
                # requested number of times will raise an exception, so we do not have to bother
                return count
            else:
                # curve.insert_knot() calls will not raise exceptions, so we have to
                # select the minimum number of possible knot insertions among all curves
                min_count = count
                for curve in curves:
                    orig_kv = curve.get_knotvector()
                    orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)
                    if (parameter == orig_kv[0]) or (parameter == orig_kv[-1]):
                        max_multiplicity = curve.get_degree()+1
                    else:
                        max_multiplicity = curve.get_degree()
                    max_delta = max_multiplicity - orig_multiplicity
                    min_count = min(min_count, max_delta)
                return min_count

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            fixed_v_curves = []

            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_u, self.knotvector_u,
                                    fixed_v_points, fixed_v_weights)
                fixed_v_curves.append(fixed_v_curve)

            common_count = get_common_count(fixed_v_curves)

            for fixed_v_curve in fixed_v_curves:
                fixed_v_curve = fixed_v_curve.insert_knot(parameter, common_count, if_possible)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            return SvNativeNurbsSurface(new_u_degree, self.degree_v,
                    fixed_v_knotvector, self.knotvector_v,
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            fixed_u_curves = []

            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_v, self.knotvector_v,
                                    fixed_u_points, fixed_u_weights)
                fixed_u_curves.append(fixed_u_curve)

            common_count = get_common_count(fixed_u_curves)

            for fixed_u_curve in fixed_u_curves:
                fixed_u_curve = fixed_u_curve.insert_knot(parameter, common_count, if_possible)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            return SvNativeNurbsSurface(self.degree_u, new_v_degree,
                    self.knotvector_u, fixed_u_knotvector,
                    new_points, new_weights)
        else:
            raise Exception(&#34;Unsupported direction&#34;)

    def remove_knot(self, direction, parameter, count=1, if_possible=False, tolerance=1e-6):
        def get_common_count(curves):
            if not if_possible:
                # in this case the first curve.remove_knot() call which can&#39;t remove the knot
                # requested number of times will raise an exception, so we do not have to bother
                return count
            else:
                # curve.remove_knot() calls will not raise exceptions, so we have to
                # select the minimum number of possible knot removals among all curves
                min_count = curves[0].get_degree()+1
                for curve in curves:
                    orig_kv = curve.get_knotvector()
                    orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)
                    tmp = curve.remove_knot(parameter, count, if_possible=True, tolerance=tolerance)
                    new_kv = tmp.get_knotvector()
                    new_multiplicity = sv_knotvector.find_multiplicity(new_kv, parameter)
                    delta = orig_multiplicity - new_multiplicity
                    min_count = min(min_count, delta)
                return min_count

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            fixed_v_curves = []
            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_u, self.knotvector_u,
                                    fixed_v_points, fixed_v_weights)
                fixed_v_curves.append(fixed_v_curve)
            
            common_count = get_common_count(fixed_v_curves)

            for fixed_v_curve in fixed_v_curves:
                fixed_v_curve = fixed_v_curve.remove_knot(parameter, common_count, if_possible=if_possible, tolerance=tolerance)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            return SvNativeNurbsSurface(new_u_degree, self.degree_v,
                    fixed_v_knotvector, self.knotvector_v,
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            fixed_u_curves = []
            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_v, self.knotvector_v,
                                    fixed_u_points, fixed_u_weights)
                fixed_u_curves.append(fixed_u_curve)

            common_count = get_common_count(fixed_u_curves)

            for fixed_u_curve in fixed_u_curves:
                fixed_u_curve = fixed_u_curve.remove_knot(parameter, common_count, if_possible=if_possible, tolerance=tolerance)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            return SvNativeNurbsSurface(self.degree_u, new_v_degree,
                    self.knotvector_u, fixed_u_knotvector,
                    new_points, new_weights)
        else:
            raise Exception(&#34;Unsupported direction&#34;)

    def get_degree_u(self):
        return self.degree_u

    def get_degree_v(self):
        return self.degree_v

    def get_knotvector_u(self):
        return self.knotvector_u

    def get_knotvector_v(self):
        return self.knotvector_v

    def get_control_points(self):
        return self.control_points

    def get_weights(self):
        return self.weights

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def fraction(self, deriv_order_u, deriv_order_v, us, vs):
        pu = self.degree_u
        pv = self.degree_v
        ku, kv, _ = self.control_points.shape
        nsu = np.array([self.basis_u.derivative(i, pu, deriv_order_u)(us) for i in range(ku)]) # (ku, n)
        nsv = np.array([self.basis_v.derivative(i, pv, deriv_order_v)(vs) for i in range(kv)]) # (kv, n)
        nsu = np.transpose(nsu[np.newaxis], axes=(1,0,2)) # (ku, 1, n)
        nsv = nsv[np.newaxis] # (1, kv, n)
        ns = nsu * nsv # (ku, kv, n)
        weights = np.transpose(self.weights[np.newaxis], axes=(1,2,0)) # (ku, kv, 1)
        coeffs = ns * weights # (ku, kv, n)
        coeffs = np.transpose(coeffs[np.newaxis], axes=(3,1,2,0)) # (n,ku,kv,1)
        controls = self.control_points # (ku,kv,3)

        numerator = coeffs * controls # (n,ku,kv,3)
        numerator = numerator.sum(axis=1).sum(axis=1) # (n,3)
        denominator = coeffs.sum(axis=1).sum(axis=1)

        return numerator, denominator

    def evaluate_array(self, us, vs):
        numerator, denominator = self.fraction(0, 0, us, vs)
        return nurbs_divide(numerator, denominator)

    def normal(self, u, v):
        return self.normal_array(np.array([u]), np.array([v]))[0]

    def normal_array(self, us, vs):
        numerator, denominator = self.fraction(0, 0, us, vs)
        surface = nurbs_divide(numerator, denominator)
        numerator_u, denominator_u = self.fraction(1, 0, us, vs)
        numerator_v, denominator_v = self.fraction(0, 1, us, vs)
        surface_u = nurbs_divide(numerator_u - surface*denominator_u, denominator)
        surface_v = nurbs_divide(numerator_v - surface*denominator_v, denominator)
        normal = np.cross(surface_u, surface_v)
        n = np.linalg.norm(normal, axis=1, keepdims=True)
        normal = nurbs_divide(normal, n)
        return normal

    def iso_curve(self, fixed_direction, param, flip=False):
        controls = self.get_control_points()
        weights = self.get_weights()
        k_u,k_v = weights.shape
        if fixed_direction == SvNurbsSurface.U:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_u(),
                            self.get_knotvector_u(),
                            controls[:,j], weights[:,j]) for j in range(k_v)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = [q_curve.fraction_single(0, param)[1] for q_curve in q_curves]
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_v(),
                    self.get_knotvector_v(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve
        elif fixed_direction == SvNurbsSurface.V:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_v(),
                            self.get_knotvector_v(),
                            controls[i,:], weights[i,:]) for i in range(k_u)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = [q_curve.fraction_single(0, param)[1] for q_curve in q_curves]
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_u(),
                    self.get_knotvector_u(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve

    def derivatives_data_array(self, us, vs):
        numerator, denominator = self.fraction(0, 0, us, vs)
        surface = nurbs_divide(numerator, denominator)
        numerator_u, denominator_u = self.fraction(1, 0, us, vs)
        numerator_v, denominator_v = self.fraction(0, 1, us, vs)
        surface_u = (numerator_u - surface*denominator_u) / denominator
        surface_v = (numerator_v - surface*denominator_v) / denominator
        return SurfaceDerivativesData(surface, surface_u, surface_v)

    def curvature_calculator(self, us, vs, order=True):
    
        numerator, denominator = self.fraction(0, 0, us, vs)
        surface = nurbs_divide(numerator, denominator)
        numerator_u, denominator_u = self.fraction(1, 0, us, vs)
        numerator_v, denominator_v = self.fraction(0, 1, us, vs)
        surface_u = (numerator_u - surface*denominator_u) / denominator
        surface_v = (numerator_v - surface*denominator_v) / denominator

        normal = np.cross(surface_u, surface_v)
        n = np.linalg.norm(normal, axis=1, keepdims=True)
        normal = normal / n

        numerator_uu, denominator_uu = self.fraction(2, 0, us, vs)
        surface_uu = (numerator_uu - 2*surface_u*denominator_u - surface*denominator_uu) / denominator
        numerator_vv, denominator_vv = self.fraction(0, 2, us, vs)
        surface_vv = (numerator_vv - 2*surface_v*denominator_v - surface*denominator_vv) / denominator

        numerator_uv, denominator_uv = self.fraction(1, 1, us, vs)
        surface_uv = (numerator_uv - surface_v*denominator_u - surface_u*denominator_v - surface*denominator_uv) / denominator

        nuu = (surface_uu * normal).sum(axis=1)
        nvv = (surface_vv * normal).sum(axis=1)
        nuv = (surface_uv * normal).sum(axis=1)

        duu = np.linalg.norm(surface_u, axis=1) **2
        dvv = np.linalg.norm(surface_v, axis=1) **2
        duv = (surface_u * surface_v).sum(axis=1)

        calc = SurfaceCurvatureCalculator(us, vs, order=order)
        calc.set(surface, normal, surface_u, surface_v, duu, dvv, duv, nuu, nvv, nuv)
        return calc

def build_from_curves(curves, degree_u = None, implementation = SvNurbsSurface.NATIVE):
    curves = unify_curves(curves)
    degree_v = curves[0].get_degree()
    if degree_u is None:
        degree_u = degree_v
    control_points = [curve.get_control_points() for curve in curves]
    control_points = np.array(control_points)
    weights = np.array([curve.get_weights() for curve in curves])
    knotvector_u = sv_knotvector.generate(degree_u, len(curves))
    #knotvector_v = curves[0].get_knotvector()
    knotvector_v = sv_knotvector.average([curve.get_knotvector() for curve in curves])

    surface = SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)

    return curves, surface

def simple_loft(curves, degree_v = None, knots_u = &#39;UNIFY&#39;, knotvector_accuracy=6, metric=&#39;DISTANCE&#39;, tknots=None, implementation=SvNurbsSurface.NATIVE, logger = None):
    &#34;&#34;&#34;
    Loft between given NURBS curves (a.k.a skinning).

    inputs:
    * degree_v - degree of resulting surface along V parameter; by default - use the same degree as provided curves
    * knots_u - one of:
        - &#39;UNIFY&#39; - unify knotvectors of given curves by inserting additional knots
        - &#39;AVERAGE&#39; - average knotvectors of given curves; this will work only if all curves have the same number of control points
    * metric - metric for interpolation; most useful are &#39;DISTANCE&#39; and &#39;CENTRIPETAL&#39;
    * implementation - NURBS maths implementation

    output: tuple:
        * list of curves - input curves after unification
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;
    if knots_u not in {&#39;UNIFY&#39;, &#39;AVERAGE&#39;}:
        raise Exception(f&#34;Unsupported knots_u option: {knots_u}&#34;)
    if logger is None:
        logger = get_logger()
    curves = unify_curves_degree(curves)
    if knots_u == &#39;UNIFY&#39;:
        curves = unify_curves(curves, accuracy=knotvector_accuracy)
    else:
        kvs = [len(curve.get_control_points()) for curve in curves]
        max_kv, min_kv = max(kvs), min(kvs)
        if max_kv != min_kv:
            raise Exception(f&#34;U knotvector averaging is not applicable: Curves have different number of control points: {kvs}&#34;)

    degree_u = curves[0].get_degree()
    if degree_v is None:
        degree_v = degree_u

    if degree_v &gt; len(curves):
        raise Exception(f&#34;V degree ({degree_v}) must be not greater than number of curves ({len(curves)}) minus 1&#34;)

    src_points = [curve.get_homogenous_control_points() for curve in curves]
    #print(&#34;P&#34;, [p.shape for p in src_points])
#     lens = [len(pts) for pts in src_points]
#     max_len, min_len = max(lens), min(lens)
#     if max_len != min_len:
#         raise Exception(f&#34;Unify error: curves have different number of control points: {lens}&#34;)

    #print(&#34;Src:&#34;, src_points)
    src_points = np.array(src_points)
    src_points = np.transpose(src_points, axes=(1,0,2))

    if tknots is None:
        tknots_vs = [Spline.create_knots(src_points[i,:], metric=metric) for i in range(src_points.shape[0])]
        tknots_vs = np.array(tknots_vs)
        tknots_v = np.mean(tknots_vs, axis=0)
    else:
        tknots_v = tknots

    v_curves = [SvNurbsMaths.interpolate_curve(implementation, degree_v, points, metric=metric, tknots=tknots_v, logger=logger) for points in src_points]
    control_points = [curve.get_homogenous_control_points() for curve in v_curves]
    control_points = np.array(control_points)
    #weights = [curve.get_weights() for curve in v_curves]
    #weights = np.array([curve.get_weights() for curve in curves]).T
    n,m,ndim = control_points.shape
    control_points = control_points.reshape((n*m, ndim))
    control_points, weights = from_homogenous(control_points)
    control_points = control_points.reshape((n,m,3))
    weights = weights.reshape((n,m))

    mean_v_vector = control_points.mean(axis=0)
    #tknots_v = Spline.create_knots(mean_v_vector, metric=metric)
    knotvector_v = sv_knotvector.from_tknots(degree_v, tknots_v)
    if knots_u == &#39;UNIFY&#39;:
        knotvector_u = curves[0].get_knotvector()
    else:
        knotvectors = np.array([curve.get_knotvector() for curve in curves])
        knotvector_u = knotvectors.mean(axis=0)
    
    surface = SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)
    surface.u_bounds = curves[0].get_u_bounds()
    return curves, v_curves, surface

def loft_by_binormals(curves, degree_v = 3,
        binormals_scale = 1.0,
        metric = &#39;DISTANCE&#39;, tknots=None,
        knotvector_accuracy = 6,
        implementation = SvNurbsMaths.NATIVE,
        logger = None):

    if logger is None:
        logger = get_logger()

    n_curves = len(curves)
    curves = unify_curves_degree(curves)
    curves = unify_curves(curves, accuracy=knotvector_accuracy)
    degree_u = curves[0].get_degree()

    src_points = [curve.get_homogenous_control_points() for curve in curves]
    src_points = np.array(src_points)
    src_points = np.transpose(src_points, axes=(1,0,2))
    
    greville_ts = [curve.calc_greville_ts() for curve in curves]
    
    binormals = [curve.binormal_array(ts, normalize=True) for curve, ts in zip(curves, greville_ts)]
    binormals = np.array(binormals)
    binormals = np.transpose(binormals, axes=(1,0,2))

    greville_pts = [curve.evaluate_array(ts) for curve, ts in zip(curves, greville_ts)]
    greville_pts = np.array(greville_pts)
    greville_dpts = greville_pts[1:] - greville_pts[:-1]
    greville_dpts_mean = np.mean(greville_dpts, axis=0)
    greville_dpts = np.concatenate((greville_dpts, [greville_dpts_mean]))
    binormal_lengths = np.linalg.norm(greville_dpts, axis=2, keepdims = True)
    binormal_lengths = np.transpose(binormal_lengths, axes=(1,0,2))
    
    cpts_mean_by_curve = np.mean(src_points, axis=0)
    cpts_direction = np.mean(cpts_mean_by_curve[1:] - cpts_mean_by_curve[:-1], axis=0)
    
    binormals *= binormal_lengths * binormals_scale / 3.0
    n,m,ndim = binormals.shape
    
    binormals = np.concatenate((binormals, np.zeros((n,m,1))), axis=2)
    
    r = np.sum(binormals * cpts_direction, axis=2)
    bad = (r &lt; 0)
    binormals[bad] = - binormals[bad]

    tknots_vs = [Spline.create_knots(src_points[i,:], metric=metric) for i in range(n)]
    tknots_vs = np.array(tknots_vs)
    tknots_v = np.mean(tknots_vs, axis=0)
    
    v_curves = [interpolate_nurbs_curve_with_tangents(degree_v, points, tangents, tknots=tknots_v, implementation=implementation, logger=logger) for points, tangents in zip(src_points, binormals)]
    control_points = [curve.get_homogenous_control_points() for curve in v_curves]
    control_points = np.array(control_points)
    n,m,ndim = control_points.shape
    control_points = control_points.reshape((n*m, ndim))
    control_points, weights = from_homogenous(control_points)
    control_points = control_points.reshape((n,m,3))
    weights = weights.reshape((n,m))
    
    knotvector_u = curves[0].get_knotvector()
    knotvector_v = v_curves[0].get_knotvector()
    
    surface = SvNurbsSurface.build(SvNurbsSurface.NATIVE,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)
    return surface

def loft_with_tangents(curves, tangent_fields, degree_v = 3,
        metric = &#39;DISTANCE&#39;, tknots=None,
        knotvector_accuracy = 6,
        implementation = SvNurbsMaths.NATIVE,
        logger = None):

    if logger is None:
        logger = get_logger()

    n_curves = len(curves)
    curves = unify_curves_degree(curves)
    curves = unify_curves(curves, accuracy=knotvector_accuracy)
    degree_u = curves[0].get_degree()

    src_points = [curve.get_homogenous_control_points() for curve in curves]
    src_points = np.array(src_points)
    src_points = np.transpose(src_points, axes=(1,0,2))

    tangents = [field.evaluate_array(curve.get_control_points()) for curve, field in zip(curves, tangent_fields)]
    tangents = np.array(tangents)
    tangents = np.transpose(tangents, axes=(2,0,1))

    n,m,ndim = tangents.shape
    tangents = np.concatenate((tangents, np.zeros((n,m,1))), axis=2)

    tknots_vs = [Spline.create_knots(src_points[i,:], metric=metric) for i in range(n_curves)]
    tknots_vs = np.array(tknots_vs)
    tknots_v = np.mean(tknots_vs, axis=0)

    v_curves = [interpolate_nurbs_curve_with_tangents(degree_v, points, tangents, tknots=tknots_v, implementation=implementation, logger=logger) for points, tangents in zip(src_points, tangents)]
    control_points = [curve.get_homogenous_control_points() for curve in v_curves]
    control_points = np.array(control_points)
    n,m,ndim = control_points.shape
    control_points = control_points.reshape((n*m, ndim))
    control_points, weights = from_homogenous(control_points)
    control_points = control_points.reshape((n,m,3))
    weights = weights.reshape((n,m))
    
    knotvector_u = curves[0].get_knotvector()
    knotvector_v = v_curves[0].get_knotvector()
    
    surface = SvNurbsSurface.build(SvNurbsSurface.NATIVE,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)
    return surface

def interpolate_nurbs_curves(curves, base_vs, target_vs,
        degree_v = None, knots_u = &#39;UNIFY&#39;,
        implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    Interpolate many NURBS curves between a list of NURBS curves, by lofting.
    Inputs:
    * curves: list of SvNurbsCurve
    * base_vs: np.array of shape (M,) - T values corresponding to `curves&#39;
        input. M must be equal to len(curves).
    * target_vs: np.array of shape (N,) - T values at which to calculate interpolated curves.
    * rest: arguments for simple_loft.
    Returns: list of SvNurbsCurve of length N.
    &#34;&#34;&#34;
    min_v, max_v = min(base_vs), max(base_vs)
    # Place input curves along Z axis and loft between them
    vectors = np.array([(0,0,v) for v in base_vs])
    to_loft = [curve.transform(None, vector) for curve, vector in zip(curves, vectors)]
    #to_loft = curves
    tknots = (base_vs - min_v) / (max_v - min_v)
    _,_,lofted = simple_loft(to_loft,
                degree_v = degree_v, knots_u = knots_u,
                #metric = &#39;POINTS&#39;,
                tknots = tknots,
                implementation = implementation)

    rebased_vs = np.linspace(min_v, max_v, num=len(target_vs))
    iso_curves = [lofted.iso_curve(fixed_direction=&#39;V&#39;, param=v) for v in rebased_vs]
    # Calculate iso_curves of the lofted surface, and move them back along Z axis
    back_vectors = []
    for v in rebased_vs:
        back_vector = np.array([0, 0, -v])
        back_vectors.append(back_vector)

    return [curve.transform(None, back) for curve, back in zip(iso_curves, back_vectors)]

def interpolate_nurbs_surface(degree_u, degree_v, points, metric=&#39;DISTANCE&#39;, uknots=None, vknots=None, implementation = SvNurbsSurface.NATIVE, logger=None):
    points = np.asarray(points)
    n = len(points)
    m = len(points[0])

    if (uknots is None) != (vknots is None):
        raise Exception(&#34;uknots and vknots must be either both provided or both omitted&#34;)

    if logger is None:
        logger = get_logger()

    if uknots is None:
        knots = np.array([Spline.create_knots(points[i,:], metric=metric) for i in range(n)])
        uknots = knots.mean(axis=0)
    if vknots is None:
        knots = np.array([Spline.create_knots(points[:,j], metric=metric) for j in range(m)])
        vknots = knots.mean(axis=0)

    knotvector_u = sv_knotvector.from_tknots(degree_u, uknots)
    knotvector_v = sv_knotvector.from_tknots(degree_v, vknots)

    u_curves = [SvNurbsMaths.interpolate_curve(implementation, degree_u, points[i,:], tknots=uknots, logger=logger) for i in range(n)]
    u_curves_cpts = np.array([curve.get_control_points() for curve in u_curves])
    v_curves = [SvNurbsMaths.interpolate_curve(implementation, degree_v, u_curves_cpts[:,j], tknots=vknots, logger=logger) for j in range(m)]

    control_points = np.array([curve.get_control_points() for curve in v_curves])

    surface = SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights=None)

    return surface

def nurbs_sweep_impl(path, profiles, ts, frame_calculator, knots_u = &#39;UNIFY&#39;, metric = &#39;DISTANCE&#39;, implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    NURBS Sweep implementation.
    Interface of this function is not flexible, so you usually want to call `nurbs_sweep&#39; instead.

    Inputs:
    * path: SvNurbsCurve
    * profiles: list of SvNurbsCurve
    * ts: T values along path which correspond to profiles. Number of ts must
        be equal to number of profiles.
    * frame_calculator: a function, which takes np.array((n,)) of T values and
        returns np.array((n, 3, 3)) of curve frames.
    * rest: arguments for simple_loft function.

    output: tuple:
        * list of curves - initial profile curves placed / rotated along the path curve
        * list of curves - interpolated profile curves
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;
    if len(profiles) != len(ts):
        raise Exception(f&#34;Number of profiles ({len(profiles)}) is not equal to number of T values ({len(ts)})&#34;)
    if len(ts) &lt; 2:
        raise Exception(&#34;At least 2 profiles are required&#34;)

    path_points = path.evaluate_array(ts)
    frames = frame_calculator(ts)
    to_loft = []
    for profile, path_point, frame in zip(profiles, path_points, frames):
        profile = profile.transform(frame, path_point)
        #cpt = profile.evaluate(profile.get_u_bounds()[0])
        #profile = profile.transform(None, -cpt + path_point)
        to_loft.append(profile)

    unified_curves, v_curves, surface = simple_loft(to_loft, degree_v = path.get_degree(),
            knots_u = knots_u, metric = metric,
            implementation = implementation)
    return to_loft, unified_curves, v_curves, surface

def nurbs_sweep(path, profiles, ts, min_profiles, algorithm, knots_u = &#39;UNIFY&#39;, metric = &#39;DISTANCE&#39;, implementation = SvNurbsSurface.NATIVE, **kwargs):
    &#34;&#34;&#34;
    NURBS Sweep surface.
    
    Inputs:
    * path: SvNurbsCurve
    * profiles: list of SvNurbsCurve
    * ts: T values along path which correspond to profiles. Number of ts must
        be equal to number of profiles. If None, the function will calculate
        appropriate values automatically.
    * min_profiles: minimal number of (copies of) profile curves to be placed
        along the path: bigger number correspond to better precision, within
        certain limits. If min_profiles &gt; len(profiles), additional profiles
        will be generated by interpolation (by lofting).
    * algorithm: rotation calculation algorithm: one of NONE, ZERO, FRENET,
        HOUSEHOLDER, TRACK, DIFF, TRACK_NORMAL, NORMAL_DIR.
    * knots_u: &#39;UNIFY&#39; or &#39;AVERAGE&#39;
    * metric: interpolation metric
    * implementation: surface implementation
    * kwargs: arguments for rotation calculation algorithm

    output: tuple:
        * list of curves - initial profile curves placed / rotated along the path curve
        * list of curves - interpolated profile curves
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;
    n_profiles = len(profiles)
    have_ts = ts is not None and len(ts) &gt; 0
    if have_ts and n_profiles != len(ts):
        raise Exception(f&#34;Number of profiles ({n_profiles}) is not equal to number of T values ({len(ts)})&#34;)

    t_min, t_max = path.get_u_bounds()
    if not have_ts:
        ts = np.linspace(t_min, t_max, num=n_profiles)

    if n_profiles == 1:
        p = profiles[0]
        ts = np.linspace(t_min, t_max, num=min_profiles)
        profiles = [p] * min_profiles
    elif n_profiles == 2 and n_profiles &lt; min_profiles:
        coeffs = np.linspace(0.0, 1.0, num=min_profiles)
        p0, p1 = profiles
        profiles = [p0.lerp_to(p1, coeff) for coeff in coeffs]
        ts = np.linspace(t_min, t_max, num=min_profiles)
    elif n_profiles &lt; min_profiles:
        target_vs = np.linspace(0.0, 1.0, num=min_profiles)
        max_degree = n_profiles - 1
        profiles = interpolate_nurbs_curves(profiles, ts, target_vs,
                    degree_v = min(max_degree, path.get_degree()),
                    knots_u = knots_u,
                    implementation = implementation)
        ts = np.linspace(t_min, t_max, num=min_profiles)
    else:
        profiles = repeat_last_for_length(profiles, min_profiles)

    frame_calculator = SvCurveFrameCalculator(path, algorithm, **kwargs).get_matrices

#     for i, p in enumerate(profiles):
#         print(f&#34;P#{i}: {p.get_control_points()}&#34;)

    return nurbs_sweep_impl(path, profiles, ts, frame_calculator,
                knots_u=knots_u, metric=metric,
                implementation=implementation)

def nurbs_birail(path1, path2, profiles,
        ts1 = None, ts2 = None,
        min_profiles = 10,
        knots_u = &#39;UNIFY&#39;,
        degree_v = None, metric = &#39;DISTANCE&#39;,
        scale_uniform = True,
        auto_rotate = False,
        use_tangents = &#39;PATHS_AVG&#39;,
        implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    NURBS BiRail.

    Inputs:
    * path1, path2: SvNurbsCurve.
    * profiles: list of SvNurbsCurve.
    * ts: T values along path which correspond to profiles. Number of ts must
        be equal to number of profiles. If None, the function will calculate
        appropriate values automatically.
    * min_profiles: minimal number of (copies of) profile curves to be placed
        along the path: bigger number correspond to better precision, within
        certain limits. If min_profiles &gt; len(profiles), additional profiles
        will be generated by interpolation (by lofting).
    * knots_u: &#39;UNIFY&#39; or &#39;AVERAGE&#39;
    * degree_v: degree of the surface along V direction; if not specified,
        degree of the first path will be used.
    * metric: interpolation metric
    * scale_uniform: If True, profile curves will be scaled along all axes
        uniformly; if False, they will be scaled only along one axis, in order to
        fill space between two path curves.
    * auto_rotate: if False, the profile curves are supposed to lie in XOY plane.
        Otherwise, try to figure out their rotation automatically.
    * implementation: surface implementation

    output: tuple:
        * list of curves - initial profile curves placed / rotated along the path curve
        * list of curves - interpolated profile curves
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;

    n_profiles = len(profiles)
    have_ts1 = ts1 is not None and len(ts1) &gt; 0
    have_ts2 = ts2 is not None and len(ts2) &gt; 0
    if have_ts1 and n_profiles != len(ts1):
        raise Exception(f&#34;Number of profiles ({n_profiles}) is not equal to number of T values ({len(ts1)})&#34;)
    if have_ts2 and n_profiles != len(ts2):
        raise Exception(f&#34;Number of profiles ({n_profiles}) is not equal to number of T values ({len(ts2)})&#34;)

    if degree_v is None:
        degree_v = path1.get_degree()

    t_min_1, t_max_1 = path1.get_u_bounds()
    t_min_2, t_max_2 = path2.get_u_bounds()
    if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=n_profiles)
    if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=n_profiles)

    if n_profiles == 1:
        p = profiles[0]
        profiles = [p] * min_profiles
        #if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=min_profiles)
        #if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=min_profiles)
    elif n_profiles == 2 and n_profiles &lt; min_profiles:
        coeffs = np.linspace(0.0, 1.0, num=min_profiles)
        p0, p1 = profiles
        profiles = [p0.lerp_to(p1, coeff) for coeff in coeffs]
        #if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=min_profiles)
        #if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=min_profiles)
    elif n_profiles &lt; min_profiles:
        target_vs = np.linspace(0.0, 1.0, num=min_profiles)
        max_degree = n_profiles - 1
        if not have_ts1:
            ts1 = np.linspace(t_min_1, t_max_1, num=n_profiles)
        profiles = interpolate_nurbs_curves(profiles, ts1, target_vs,
                    degree_v = min(max_degree, degree_v),
                    knots_u = knots_u,
                    implementation = implementation)
        #if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=min_profiles)
        #if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=min_profiles)
    else:
        profiles = repeat_last_for_length(profiles, min_profiles)

    points1 = path1.evaluate_array(ts1)
    points2 = path2.evaluate_array(ts2)

    orig_profiles = profiles[:]

    if use_tangents == &#39;PATHS_AVG&#39;:
        tangents1 = path1.tangent_array(ts1)
        tangents2 = path2.tangent_array(ts2)
        tangents = 0.5 * (tangents1 + tangents2)
        tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)
    elif use_tangents == &#39;FROM_PATH1&#39;:
        tangents = path1.tangent_array(ts1)
        tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)
    elif use_tangents == &#39;FROM_PATH2&#39;:
        tangents = path2.tangent_array(ts2)
        tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)
    elif use_tangents == &#39;FROM_PROFILE&#39;:
        tangents = []
        for profile in orig_profiles:
            matrix = nurbs_curve_matrix(profile)
            yy = matrix @ np.array([0, 0, -1])
            yy /= np.linalg.norm(yy)
            tangents.append(yy)
        tangents = np.array(tangents)

    binormals = points2 - points1
    scales = np.linalg.norm(binormals, axis=1, keepdims=True)
    if scales.min() &lt; 1e-6:
        raise Exception(&#34;Paths go too close&#34;)
    binormals /= scales

    normals = np.cross(tangents, binormals)
    normals /= np.linalg.norm(normals, axis=1, keepdims=True)

    tangents = np.cross(binormals, normals)
    tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)

    matrices = np.dstack((normals, binormals, tangents))
    matrices = np.transpose(matrices, axes=(0,2,1))
    matrices = np.linalg.inv(matrices)

    scales = scales.flatten()
    placed_profiles = []
    prev_normal = None
    for pt1, pt2, profile, tangent, scale, matrix in zip(points1, points2, profiles, tangents, scales, matrices):

        if auto_rotate:
            profile = nurbs_curve_to_xoy(profile, tangent)

        t_min, t_max = profile.get_u_bounds()
        pr_start = profile.evaluate(t_min)
        pr_end = profile.evaluate(t_max)
        pr_vector = pr_end - pr_start
        pr_length = np.linalg.norm(pr_vector)
        if pr_length &lt; 1e-6:
            raise Exception(&#34;One of profiles is closed&#34;)
        pr_dir = pr_vector / pr_length
        pr_x, pr_y, _ = tuple(pr_dir)

        rotation = np.array([
                (pr_y, -pr_x, 0),
                (pr_x, pr_y, 0),
                (0, 0, 1)
            ])

        src_scale = scale
        scale /= pr_length
        if scale_uniform:
            scale_m = np.array([
                    (scale, 0, 0),
                    (0, scale, 0),
                    (0, 0, scale)
                ])
        else:
            scale_m = np.array([
                    (1, 0, 0),
                    (0, scale, 0),
                    (0, 0, 1)
                ])
        cpts = [matrix @ scale_m @ rotation @ (pt - pr_start) + pt1 for pt in profile.get_control_points()]
        cpts = np.array(cpts)

        profile = profile.copy(control_points = cpts)
        placed_profiles.append(profile)

    unified_curves, v_curves, surface = simple_loft(placed_profiles, degree_v = degree_v,
            knots_u = knots_u, metric = metric,
            implementation = implementation)

    return placed_profiles, unified_curves, v_curves, surface

SvNurbsMaths.surface_classes[SvNurbsMaths.NATIVE] = SvNativeNurbsSurface
if geomdl is not None:
    SvNurbsMaths.surface_classes[SvNurbsMaths.GEOMDL] = SvGeomdlSurface</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.surface.nurbs.build_from_curves"><code class="name flex">
<span>def <span class="ident">build_from_curves</span></span>(<span>curves, degree_u=None, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_from_curves(curves, degree_u = None, implementation = SvNurbsSurface.NATIVE):
    curves = unify_curves(curves)
    degree_v = curves[0].get_degree()
    if degree_u is None:
        degree_u = degree_v
    control_points = [curve.get_control_points() for curve in curves]
    control_points = np.array(control_points)
    weights = np.array([curve.get_weights() for curve in curves])
    knotvector_u = sv_knotvector.generate(degree_u, len(curves))
    #knotvector_v = curves[0].get_knotvector()
    knotvector_v = sv_knotvector.average([curve.get_knotvector() for curve in curves])

    surface = SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)

    return curves, surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.interpolate_nurbs_curves"><code class="name flex">
<span>def <span class="ident">interpolate_nurbs_curves</span></span>(<span>curves, base_vs, target_vs, degree_v=None, knots_u='UNIFY', implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate many NURBS curves between a list of NURBS curves, by lofting.
Inputs:
* curves: list of SvNurbsCurve
* base_vs: np.array of shape (M,) - T values corresponding to `curves'
input. M must be equal to len(curves).
* target_vs: np.array of shape (N,) - T values at which to calculate interpolated curves.
* rest: arguments for simple_loft.
Returns: list of SvNurbsCurve of length N.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_nurbs_curves(curves, base_vs, target_vs,
        degree_v = None, knots_u = &#39;UNIFY&#39;,
        implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    Interpolate many NURBS curves between a list of NURBS curves, by lofting.
    Inputs:
    * curves: list of SvNurbsCurve
    * base_vs: np.array of shape (M,) - T values corresponding to `curves&#39;
        input. M must be equal to len(curves).
    * target_vs: np.array of shape (N,) - T values at which to calculate interpolated curves.
    * rest: arguments for simple_loft.
    Returns: list of SvNurbsCurve of length N.
    &#34;&#34;&#34;
    min_v, max_v = min(base_vs), max(base_vs)
    # Place input curves along Z axis and loft between them
    vectors = np.array([(0,0,v) for v in base_vs])
    to_loft = [curve.transform(None, vector) for curve, vector in zip(curves, vectors)]
    #to_loft = curves
    tknots = (base_vs - min_v) / (max_v - min_v)
    _,_,lofted = simple_loft(to_loft,
                degree_v = degree_v, knots_u = knots_u,
                #metric = &#39;POINTS&#39;,
                tknots = tknots,
                implementation = implementation)

    rebased_vs = np.linspace(min_v, max_v, num=len(target_vs))
    iso_curves = [lofted.iso_curve(fixed_direction=&#39;V&#39;, param=v) for v in rebased_vs]
    # Calculate iso_curves of the lofted surface, and move them back along Z axis
    back_vectors = []
    for v in rebased_vs:
        back_vector = np.array([0, 0, -v])
        back_vectors.append(back_vector)

    return [curve.transform(None, back) for curve, back in zip(iso_curves, back_vectors)]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.interpolate_nurbs_surface"><code class="name flex">
<span>def <span class="ident">interpolate_nurbs_surface</span></span>(<span>degree_u, degree_v, points, metric='DISTANCE', uknots=None, vknots=None, implementation='NATIVE', logger=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_nurbs_surface(degree_u, degree_v, points, metric=&#39;DISTANCE&#39;, uknots=None, vknots=None, implementation = SvNurbsSurface.NATIVE, logger=None):
    points = np.asarray(points)
    n = len(points)
    m = len(points[0])

    if (uknots is None) != (vknots is None):
        raise Exception(&#34;uknots and vknots must be either both provided or both omitted&#34;)

    if logger is None:
        logger = get_logger()

    if uknots is None:
        knots = np.array([Spline.create_knots(points[i,:], metric=metric) for i in range(n)])
        uknots = knots.mean(axis=0)
    if vknots is None:
        knots = np.array([Spline.create_knots(points[:,j], metric=metric) for j in range(m)])
        vknots = knots.mean(axis=0)

    knotvector_u = sv_knotvector.from_tknots(degree_u, uknots)
    knotvector_v = sv_knotvector.from_tknots(degree_v, vknots)

    u_curves = [SvNurbsMaths.interpolate_curve(implementation, degree_u, points[i,:], tknots=uknots, logger=logger) for i in range(n)]
    u_curves_cpts = np.array([curve.get_control_points() for curve in u_curves])
    v_curves = [SvNurbsMaths.interpolate_curve(implementation, degree_v, u_curves_cpts[:,j], tknots=vknots, logger=logger) for j in range(m)]

    control_points = np.array([curve.get_control_points() for curve in v_curves])

    surface = SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights=None)

    return surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.loft_by_binormals"><code class="name flex">
<span>def <span class="ident">loft_by_binormals</span></span>(<span>curves, degree_v=3, binormals_scale=1.0, metric='DISTANCE', tknots=None, knotvector_accuracy=6, implementation='NATIVE', logger=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loft_by_binormals(curves, degree_v = 3,
        binormals_scale = 1.0,
        metric = &#39;DISTANCE&#39;, tknots=None,
        knotvector_accuracy = 6,
        implementation = SvNurbsMaths.NATIVE,
        logger = None):

    if logger is None:
        logger = get_logger()

    n_curves = len(curves)
    curves = unify_curves_degree(curves)
    curves = unify_curves(curves, accuracy=knotvector_accuracy)
    degree_u = curves[0].get_degree()

    src_points = [curve.get_homogenous_control_points() for curve in curves]
    src_points = np.array(src_points)
    src_points = np.transpose(src_points, axes=(1,0,2))
    
    greville_ts = [curve.calc_greville_ts() for curve in curves]
    
    binormals = [curve.binormal_array(ts, normalize=True) for curve, ts in zip(curves, greville_ts)]
    binormals = np.array(binormals)
    binormals = np.transpose(binormals, axes=(1,0,2))

    greville_pts = [curve.evaluate_array(ts) for curve, ts in zip(curves, greville_ts)]
    greville_pts = np.array(greville_pts)
    greville_dpts = greville_pts[1:] - greville_pts[:-1]
    greville_dpts_mean = np.mean(greville_dpts, axis=0)
    greville_dpts = np.concatenate((greville_dpts, [greville_dpts_mean]))
    binormal_lengths = np.linalg.norm(greville_dpts, axis=2, keepdims = True)
    binormal_lengths = np.transpose(binormal_lengths, axes=(1,0,2))
    
    cpts_mean_by_curve = np.mean(src_points, axis=0)
    cpts_direction = np.mean(cpts_mean_by_curve[1:] - cpts_mean_by_curve[:-1], axis=0)
    
    binormals *= binormal_lengths * binormals_scale / 3.0
    n,m,ndim = binormals.shape
    
    binormals = np.concatenate((binormals, np.zeros((n,m,1))), axis=2)
    
    r = np.sum(binormals * cpts_direction, axis=2)
    bad = (r &lt; 0)
    binormals[bad] = - binormals[bad]

    tknots_vs = [Spline.create_knots(src_points[i,:], metric=metric) for i in range(n)]
    tknots_vs = np.array(tknots_vs)
    tknots_v = np.mean(tknots_vs, axis=0)
    
    v_curves = [interpolate_nurbs_curve_with_tangents(degree_v, points, tangents, tknots=tknots_v, implementation=implementation, logger=logger) for points, tangents in zip(src_points, binormals)]
    control_points = [curve.get_homogenous_control_points() for curve in v_curves]
    control_points = np.array(control_points)
    n,m,ndim = control_points.shape
    control_points = control_points.reshape((n*m, ndim))
    control_points, weights = from_homogenous(control_points)
    control_points = control_points.reshape((n,m,3))
    weights = weights.reshape((n,m))
    
    knotvector_u = curves[0].get_knotvector()
    knotvector_v = v_curves[0].get_knotvector()
    
    surface = SvNurbsSurface.build(SvNurbsSurface.NATIVE,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)
    return surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.loft_with_tangents"><code class="name flex">
<span>def <span class="ident">loft_with_tangents</span></span>(<span>curves, tangent_fields, degree_v=3, metric='DISTANCE', tknots=None, knotvector_accuracy=6, implementation='NATIVE', logger=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loft_with_tangents(curves, tangent_fields, degree_v = 3,
        metric = &#39;DISTANCE&#39;, tknots=None,
        knotvector_accuracy = 6,
        implementation = SvNurbsMaths.NATIVE,
        logger = None):

    if logger is None:
        logger = get_logger()

    n_curves = len(curves)
    curves = unify_curves_degree(curves)
    curves = unify_curves(curves, accuracy=knotvector_accuracy)
    degree_u = curves[0].get_degree()

    src_points = [curve.get_homogenous_control_points() for curve in curves]
    src_points = np.array(src_points)
    src_points = np.transpose(src_points, axes=(1,0,2))

    tangents = [field.evaluate_array(curve.get_control_points()) for curve, field in zip(curves, tangent_fields)]
    tangents = np.array(tangents)
    tangents = np.transpose(tangents, axes=(2,0,1))

    n,m,ndim = tangents.shape
    tangents = np.concatenate((tangents, np.zeros((n,m,1))), axis=2)

    tknots_vs = [Spline.create_knots(src_points[i,:], metric=metric) for i in range(n_curves)]
    tknots_vs = np.array(tknots_vs)
    tknots_v = np.mean(tknots_vs, axis=0)

    v_curves = [interpolate_nurbs_curve_with_tangents(degree_v, points, tangents, tknots=tknots_v, implementation=implementation, logger=logger) for points, tangents in zip(src_points, tangents)]
    control_points = [curve.get_homogenous_control_points() for curve in v_curves]
    control_points = np.array(control_points)
    n,m,ndim = control_points.shape
    control_points = control_points.reshape((n*m, ndim))
    control_points, weights = from_homogenous(control_points)
    control_points = control_points.reshape((n,m,3))
    weights = weights.reshape((n,m))
    
    knotvector_u = curves[0].get_knotvector()
    knotvector_v = v_curves[0].get_knotvector()
    
    surface = SvNurbsSurface.build(SvNurbsSurface.NATIVE,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)
    return surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.nurbs_birail"><code class="name flex">
<span>def <span class="ident">nurbs_birail</span></span>(<span>path1, path2, profiles, ts1=None, ts2=None, min_profiles=10, knots_u='UNIFY', degree_v=None, metric='DISTANCE', scale_uniform=True, auto_rotate=False, use_tangents='PATHS_AVG', implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"><p>NURBS BiRail.</p>
<p>Inputs:
* path1, path2: SvNurbsCurve.
* profiles: list of SvNurbsCurve.
* ts: T values along path which correspond to profiles. Number of ts must
be equal to number of profiles. If None, the function will calculate
appropriate values automatically.
* min_profiles: minimal number of (copies of) profile curves to be placed
along the path: bigger number correspond to better precision, within
certain limits. If min_profiles &gt; len(profiles), additional profiles
will be generated by interpolation (by lofting).
* knots_u: 'UNIFY' or 'AVERAGE'
* degree_v: degree of the surface along V direction; if not specified,
degree of the first path will be used.
* metric: interpolation metric
* scale_uniform: If True, profile curves will be scaled along all axes
uniformly; if False, they will be scaled only along one axis, in order to
fill space between two path curves.
* auto_rotate: if False, the profile curves are supposed to lie in XOY plane.
Otherwise, try to figure out their rotation automatically.
* implementation: surface implementation</p>
<p>output: tuple:
* list of curves - initial profile curves placed / rotated along the path curve
* list of curves - interpolated profile curves
* list of NURBS curves along V direction
* generated NURBS surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nurbs_birail(path1, path2, profiles,
        ts1 = None, ts2 = None,
        min_profiles = 10,
        knots_u = &#39;UNIFY&#39;,
        degree_v = None, metric = &#39;DISTANCE&#39;,
        scale_uniform = True,
        auto_rotate = False,
        use_tangents = &#39;PATHS_AVG&#39;,
        implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    NURBS BiRail.

    Inputs:
    * path1, path2: SvNurbsCurve.
    * profiles: list of SvNurbsCurve.
    * ts: T values along path which correspond to profiles. Number of ts must
        be equal to number of profiles. If None, the function will calculate
        appropriate values automatically.
    * min_profiles: minimal number of (copies of) profile curves to be placed
        along the path: bigger number correspond to better precision, within
        certain limits. If min_profiles &gt; len(profiles), additional profiles
        will be generated by interpolation (by lofting).
    * knots_u: &#39;UNIFY&#39; or &#39;AVERAGE&#39;
    * degree_v: degree of the surface along V direction; if not specified,
        degree of the first path will be used.
    * metric: interpolation metric
    * scale_uniform: If True, profile curves will be scaled along all axes
        uniformly; if False, they will be scaled only along one axis, in order to
        fill space between two path curves.
    * auto_rotate: if False, the profile curves are supposed to lie in XOY plane.
        Otherwise, try to figure out their rotation automatically.
    * implementation: surface implementation

    output: tuple:
        * list of curves - initial profile curves placed / rotated along the path curve
        * list of curves - interpolated profile curves
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;

    n_profiles = len(profiles)
    have_ts1 = ts1 is not None and len(ts1) &gt; 0
    have_ts2 = ts2 is not None and len(ts2) &gt; 0
    if have_ts1 and n_profiles != len(ts1):
        raise Exception(f&#34;Number of profiles ({n_profiles}) is not equal to number of T values ({len(ts1)})&#34;)
    if have_ts2 and n_profiles != len(ts2):
        raise Exception(f&#34;Number of profiles ({n_profiles}) is not equal to number of T values ({len(ts2)})&#34;)

    if degree_v is None:
        degree_v = path1.get_degree()

    t_min_1, t_max_1 = path1.get_u_bounds()
    t_min_2, t_max_2 = path2.get_u_bounds()
    if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=n_profiles)
    if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=n_profiles)

    if n_profiles == 1:
        p = profiles[0]
        profiles = [p] * min_profiles
        #if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=min_profiles)
        #if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=min_profiles)
    elif n_profiles == 2 and n_profiles &lt; min_profiles:
        coeffs = np.linspace(0.0, 1.0, num=min_profiles)
        p0, p1 = profiles
        profiles = [p0.lerp_to(p1, coeff) for coeff in coeffs]
        #if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=min_profiles)
        #if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=min_profiles)
    elif n_profiles &lt; min_profiles:
        target_vs = np.linspace(0.0, 1.0, num=min_profiles)
        max_degree = n_profiles - 1
        if not have_ts1:
            ts1 = np.linspace(t_min_1, t_max_1, num=n_profiles)
        profiles = interpolate_nurbs_curves(profiles, ts1, target_vs,
                    degree_v = min(max_degree, degree_v),
                    knots_u = knots_u,
                    implementation = implementation)
        #if not have_ts1:
        ts1 = np.linspace(t_min_1, t_max_1, num=min_profiles)
        #if not have_ts2:
        ts2 = np.linspace(t_min_2, t_max_2, num=min_profiles)
    else:
        profiles = repeat_last_for_length(profiles, min_profiles)

    points1 = path1.evaluate_array(ts1)
    points2 = path2.evaluate_array(ts2)

    orig_profiles = profiles[:]

    if use_tangents == &#39;PATHS_AVG&#39;:
        tangents1 = path1.tangent_array(ts1)
        tangents2 = path2.tangent_array(ts2)
        tangents = 0.5 * (tangents1 + tangents2)
        tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)
    elif use_tangents == &#39;FROM_PATH1&#39;:
        tangents = path1.tangent_array(ts1)
        tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)
    elif use_tangents == &#39;FROM_PATH2&#39;:
        tangents = path2.tangent_array(ts2)
        tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)
    elif use_tangents == &#39;FROM_PROFILE&#39;:
        tangents = []
        for profile in orig_profiles:
            matrix = nurbs_curve_matrix(profile)
            yy = matrix @ np.array([0, 0, -1])
            yy /= np.linalg.norm(yy)
            tangents.append(yy)
        tangents = np.array(tangents)

    binormals = points2 - points1
    scales = np.linalg.norm(binormals, axis=1, keepdims=True)
    if scales.min() &lt; 1e-6:
        raise Exception(&#34;Paths go too close&#34;)
    binormals /= scales

    normals = np.cross(tangents, binormals)
    normals /= np.linalg.norm(normals, axis=1, keepdims=True)

    tangents = np.cross(binormals, normals)
    tangents /= np.linalg.norm(tangents, axis=1, keepdims=True)

    matrices = np.dstack((normals, binormals, tangents))
    matrices = np.transpose(matrices, axes=(0,2,1))
    matrices = np.linalg.inv(matrices)

    scales = scales.flatten()
    placed_profiles = []
    prev_normal = None
    for pt1, pt2, profile, tangent, scale, matrix in zip(points1, points2, profiles, tangents, scales, matrices):

        if auto_rotate:
            profile = nurbs_curve_to_xoy(profile, tangent)

        t_min, t_max = profile.get_u_bounds()
        pr_start = profile.evaluate(t_min)
        pr_end = profile.evaluate(t_max)
        pr_vector = pr_end - pr_start
        pr_length = np.linalg.norm(pr_vector)
        if pr_length &lt; 1e-6:
            raise Exception(&#34;One of profiles is closed&#34;)
        pr_dir = pr_vector / pr_length
        pr_x, pr_y, _ = tuple(pr_dir)

        rotation = np.array([
                (pr_y, -pr_x, 0),
                (pr_x, pr_y, 0),
                (0, 0, 1)
            ])

        src_scale = scale
        scale /= pr_length
        if scale_uniform:
            scale_m = np.array([
                    (scale, 0, 0),
                    (0, scale, 0),
                    (0, 0, scale)
                ])
        else:
            scale_m = np.array([
                    (1, 0, 0),
                    (0, scale, 0),
                    (0, 0, 1)
                ])
        cpts = [matrix @ scale_m @ rotation @ (pt - pr_start) + pt1 for pt in profile.get_control_points()]
        cpts = np.array(cpts)

        profile = profile.copy(control_points = cpts)
        placed_profiles.append(profile)

    unified_curves, v_curves, surface = simple_loft(placed_profiles, degree_v = degree_v,
            knots_u = knots_u, metric = metric,
            implementation = implementation)

    return placed_profiles, unified_curves, v_curves, surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.nurbs_sweep"><code class="name flex">
<span>def <span class="ident">nurbs_sweep</span></span>(<span>path, profiles, ts, min_profiles, algorithm, knots_u='UNIFY', metric='DISTANCE', implementation='NATIVE', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>NURBS Sweep surface.</p>
<p>Inputs:
* path: SvNurbsCurve
* profiles: list of SvNurbsCurve
* ts: T values along path which correspond to profiles. Number of ts must
be equal to number of profiles. If None, the function will calculate
appropriate values automatically.
* min_profiles: minimal number of (copies of) profile curves to be placed
along the path: bigger number correspond to better precision, within
certain limits. If min_profiles &gt; len(profiles), additional profiles
will be generated by interpolation (by lofting).
* algorithm: rotation calculation algorithm: one of NONE, ZERO, FRENET,
HOUSEHOLDER, TRACK, DIFF, TRACK_NORMAL, NORMAL_DIR.
* knots_u: 'UNIFY' or 'AVERAGE'
* metric: interpolation metric
* implementation: surface implementation
* kwargs: arguments for rotation calculation algorithm</p>
<p>output: tuple:
* list of curves - initial profile curves placed / rotated along the path curve
* list of curves - interpolated profile curves
* list of NURBS curves along V direction
* generated NURBS surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nurbs_sweep(path, profiles, ts, min_profiles, algorithm, knots_u = &#39;UNIFY&#39;, metric = &#39;DISTANCE&#39;, implementation = SvNurbsSurface.NATIVE, **kwargs):
    &#34;&#34;&#34;
    NURBS Sweep surface.
    
    Inputs:
    * path: SvNurbsCurve
    * profiles: list of SvNurbsCurve
    * ts: T values along path which correspond to profiles. Number of ts must
        be equal to number of profiles. If None, the function will calculate
        appropriate values automatically.
    * min_profiles: minimal number of (copies of) profile curves to be placed
        along the path: bigger number correspond to better precision, within
        certain limits. If min_profiles &gt; len(profiles), additional profiles
        will be generated by interpolation (by lofting).
    * algorithm: rotation calculation algorithm: one of NONE, ZERO, FRENET,
        HOUSEHOLDER, TRACK, DIFF, TRACK_NORMAL, NORMAL_DIR.
    * knots_u: &#39;UNIFY&#39; or &#39;AVERAGE&#39;
    * metric: interpolation metric
    * implementation: surface implementation
    * kwargs: arguments for rotation calculation algorithm

    output: tuple:
        * list of curves - initial profile curves placed / rotated along the path curve
        * list of curves - interpolated profile curves
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;
    n_profiles = len(profiles)
    have_ts = ts is not None and len(ts) &gt; 0
    if have_ts and n_profiles != len(ts):
        raise Exception(f&#34;Number of profiles ({n_profiles}) is not equal to number of T values ({len(ts)})&#34;)

    t_min, t_max = path.get_u_bounds()
    if not have_ts:
        ts = np.linspace(t_min, t_max, num=n_profiles)

    if n_profiles == 1:
        p = profiles[0]
        ts = np.linspace(t_min, t_max, num=min_profiles)
        profiles = [p] * min_profiles
    elif n_profiles == 2 and n_profiles &lt; min_profiles:
        coeffs = np.linspace(0.0, 1.0, num=min_profiles)
        p0, p1 = profiles
        profiles = [p0.lerp_to(p1, coeff) for coeff in coeffs]
        ts = np.linspace(t_min, t_max, num=min_profiles)
    elif n_profiles &lt; min_profiles:
        target_vs = np.linspace(0.0, 1.0, num=min_profiles)
        max_degree = n_profiles - 1
        profiles = interpolate_nurbs_curves(profiles, ts, target_vs,
                    degree_v = min(max_degree, path.get_degree()),
                    knots_u = knots_u,
                    implementation = implementation)
        ts = np.linspace(t_min, t_max, num=min_profiles)
    else:
        profiles = repeat_last_for_length(profiles, min_profiles)

    frame_calculator = SvCurveFrameCalculator(path, algorithm, **kwargs).get_matrices

#     for i, p in enumerate(profiles):
#         print(f&#34;P#{i}: {p.get_control_points()}&#34;)

    return nurbs_sweep_impl(path, profiles, ts, frame_calculator,
                knots_u=knots_u, metric=metric,
                implementation=implementation)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.nurbs_sweep_impl"><code class="name flex">
<span>def <span class="ident">nurbs_sweep_impl</span></span>(<span>path, profiles, ts, frame_calculator, knots_u='UNIFY', metric='DISTANCE', implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"><p>NURBS Sweep implementation.
Interface of this function is not flexible, so you usually want to call `nurbs_sweep' instead.</p>
<p>Inputs:
* path: SvNurbsCurve
* profiles: list of SvNurbsCurve
* ts: T values along path which correspond to profiles. Number of ts must
be equal to number of profiles.
* frame_calculator: a function, which takes np.array((n,)) of T values and
returns np.array((n, 3, 3)) of curve frames.
* rest: arguments for simple_loft function.</p>
<p>output: tuple:
* list of curves - initial profile curves placed / rotated along the path curve
* list of curves - interpolated profile curves
* list of NURBS curves along V direction
* generated NURBS surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nurbs_sweep_impl(path, profiles, ts, frame_calculator, knots_u = &#39;UNIFY&#39;, metric = &#39;DISTANCE&#39;, implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    NURBS Sweep implementation.
    Interface of this function is not flexible, so you usually want to call `nurbs_sweep&#39; instead.

    Inputs:
    * path: SvNurbsCurve
    * profiles: list of SvNurbsCurve
    * ts: T values along path which correspond to profiles. Number of ts must
        be equal to number of profiles.
    * frame_calculator: a function, which takes np.array((n,)) of T values and
        returns np.array((n, 3, 3)) of curve frames.
    * rest: arguments for simple_loft function.

    output: tuple:
        * list of curves - initial profile curves placed / rotated along the path curve
        * list of curves - interpolated profile curves
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;
    if len(profiles) != len(ts):
        raise Exception(f&#34;Number of profiles ({len(profiles)}) is not equal to number of T values ({len(ts)})&#34;)
    if len(ts) &lt; 2:
        raise Exception(&#34;At least 2 profiles are required&#34;)

    path_points = path.evaluate_array(ts)
    frames = frame_calculator(ts)
    to_loft = []
    for profile, path_point, frame in zip(profiles, path_points, frames):
        profile = profile.transform(frame, path_point)
        #cpt = profile.evaluate(profile.get_u_bounds()[0])
        #profile = profile.transform(None, -cpt + path_point)
        to_loft.append(profile)

    unified_curves, v_curves, surface = simple_loft(to_loft, degree_v = path.get_degree(),
            knots_u = knots_u, metric = metric,
            implementation = implementation)
    return to_loft, unified_curves, v_curves, surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.simple_loft"><code class="name flex">
<span>def <span class="ident">simple_loft</span></span>(<span>curves, degree_v=None, knots_u='UNIFY', knotvector_accuracy=6, metric='DISTANCE', tknots=None, implementation='NATIVE', logger=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loft between given NURBS curves (a.k.a skinning).</p>
<p>inputs:
* degree_v - degree of resulting surface along V parameter; by default - use the same degree as provided curves
* knots_u - one of:
- 'UNIFY' - unify knotvectors of given curves by inserting additional knots
- 'AVERAGE' - average knotvectors of given curves; this will work only if all curves have the same number of control points
* metric - metric for interpolation; most useful are 'DISTANCE' and 'CENTRIPETAL'
* implementation - NURBS maths implementation</p>
<p>output: tuple:
* list of curves - input curves after unification
* list of NURBS curves along V direction
* generated NURBS surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_loft(curves, degree_v = None, knots_u = &#39;UNIFY&#39;, knotvector_accuracy=6, metric=&#39;DISTANCE&#39;, tknots=None, implementation=SvNurbsSurface.NATIVE, logger = None):
    &#34;&#34;&#34;
    Loft between given NURBS curves (a.k.a skinning).

    inputs:
    * degree_v - degree of resulting surface along V parameter; by default - use the same degree as provided curves
    * knots_u - one of:
        - &#39;UNIFY&#39; - unify knotvectors of given curves by inserting additional knots
        - &#39;AVERAGE&#39; - average knotvectors of given curves; this will work only if all curves have the same number of control points
    * metric - metric for interpolation; most useful are &#39;DISTANCE&#39; and &#39;CENTRIPETAL&#39;
    * implementation - NURBS maths implementation

    output: tuple:
        * list of curves - input curves after unification
        * list of NURBS curves along V direction
        * generated NURBS surface.
    &#34;&#34;&#34;
    if knots_u not in {&#39;UNIFY&#39;, &#39;AVERAGE&#39;}:
        raise Exception(f&#34;Unsupported knots_u option: {knots_u}&#34;)
    if logger is None:
        logger = get_logger()
    curves = unify_curves_degree(curves)
    if knots_u == &#39;UNIFY&#39;:
        curves = unify_curves(curves, accuracy=knotvector_accuracy)
    else:
        kvs = [len(curve.get_control_points()) for curve in curves]
        max_kv, min_kv = max(kvs), min(kvs)
        if max_kv != min_kv:
            raise Exception(f&#34;U knotvector averaging is not applicable: Curves have different number of control points: {kvs}&#34;)

    degree_u = curves[0].get_degree()
    if degree_v is None:
        degree_v = degree_u

    if degree_v &gt; len(curves):
        raise Exception(f&#34;V degree ({degree_v}) must be not greater than number of curves ({len(curves)}) minus 1&#34;)

    src_points = [curve.get_homogenous_control_points() for curve in curves]
    #print(&#34;P&#34;, [p.shape for p in src_points])
#     lens = [len(pts) for pts in src_points]
#     max_len, min_len = max(lens), min(lens)
#     if max_len != min_len:
#         raise Exception(f&#34;Unify error: curves have different number of control points: {lens}&#34;)

    #print(&#34;Src:&#34;, src_points)
    src_points = np.array(src_points)
    src_points = np.transpose(src_points, axes=(1,0,2))

    if tknots is None:
        tknots_vs = [Spline.create_knots(src_points[i,:], metric=metric) for i in range(src_points.shape[0])]
        tknots_vs = np.array(tknots_vs)
        tknots_v = np.mean(tknots_vs, axis=0)
    else:
        tknots_v = tknots

    v_curves = [SvNurbsMaths.interpolate_curve(implementation, degree_v, points, metric=metric, tknots=tknots_v, logger=logger) for points in src_points]
    control_points = [curve.get_homogenous_control_points() for curve in v_curves]
    control_points = np.array(control_points)
    #weights = [curve.get_weights() for curve in v_curves]
    #weights = np.array([curve.get_weights() for curve in curves]).T
    n,m,ndim = control_points.shape
    control_points = control_points.reshape((n*m, ndim))
    control_points, weights = from_homogenous(control_points)
    control_points = control_points.reshape((n,m,3))
    weights = weights.reshape((n,m))

    mean_v_vector = control_points.mean(axis=0)
    #tknots_v = Spline.create_knots(mean_v_vector, metric=metric)
    knotvector_v = sv_knotvector.from_tknots(degree_v, tknots_v)
    if knots_u == &#39;UNIFY&#39;:
        knotvector_u = curves[0].get_knotvector()
    else:
        knotvectors = np.array([curve.get_knotvector() for curve in curves])
        knotvector_u = knotvectors.mean(axis=0)
    
    surface = SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)
    surface.u_bounds = curves[0].get_u_bounds()
    return curves, v_curves, surface</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface"><code class="flex name class">
<span>class <span class="ident">SvGeomdlSurface</span></span>
<span>(</span><span>surface)</span>
</code></dt>
<dd>
<div class="desc"><p>Base abstract class for all supported implementations of NURBS surfaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvGeomdlSurface(SvNurbsSurface):
    def __init__(self, surface):
        self.surface = surface
        self.u_bounds = (0, 1)
        self.v_bounds = (0, 1)
        self.__description__ = f&#34;Geomdl NURBS (degree={surface.degree_u}x{surface.degree_v}, pts={len(surface.ctrlpts2d)}x{len(surface.ctrlpts2d[0])})&#34;

    @classmethod
    def get_nurbs_implementation(cls):
        return SvNurbsSurface.GEOMDL

    def insert_knot(self, direction, parameter, count=1, if_possible=False):
        if direction == SvNurbsSurface.U:
            uv = [parameter, None]
            counts = [count, 0]
        elif direction == SvNurbsSurface.V:
            uv = [None, parameter]
            counts = [0, count]
        surface = operations.insert_knot(self.surface, uv, counts)
        return SvGeomdlSurface(surface)

    def remove_knot(self, direction, parameter, count=1, if_possible=False, tolerance=None):
        if direction == SvNurbsSurface.U:
            orig_kv = self.get_knotvector_u()
            uv = [parameter, None]
            counts = [count, 0]
        elif direction == SvNurbsSurface.V:
            orig_kv = self.get_knotvector_v()
            uv = [None, parameter]
            counts = [0, count]
        orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)

        surface = operations.remove_knot(self.surface, uv, counts)

        if direction == SvNurbsSurface.U:
            new_kv = self.get_knotvector_u()
        elif direction == SvNurbsSurface.V:
            new_kv = self.get_knotvector_v()

        new_multiplicity = sv_knotvector.find_multiplicity(new_kv, parameter)

        if not if_possible and (orig_multiplicity - new_multiplicity &lt; count):
            raise CantRemoveKnotException(f&#34;Asked to remove knot {direction}={parameter} {count} times, but could remove it only {orig_multiplicity-new_multiplicity} times&#34;)

        return SvGeomdlSurface(surface)

    def get_degree_u(self):
        return self.surface.degree_u

    def get_degree_v(self):
        return self.surface.degree_v

    def get_knotvector_u(self):
        return np.array(self.surface.knotvector_u)

    def get_knotvector_v(self):
        return np.array(self.surface.knotvector_v)

    def get_control_points(self):
        pts = []
        for row in self.surface.ctrlpts2d:
            new_row = []
            for point in row:
                if len(point) == 4:
                    x,y,z,w = point
                    new_point = (x/w, y/w, z/w)
                else:
                    new_point = point
                new_row.append(new_point)
            pts.append(new_row)
        return np.array(pts)

    def get_weights(self):
        if isinstance(self.surface, NURBS.Surface):
            weights = [[pt[3] for pt in row] for row in self.surface.ctrlpts2d]
        else:
            weights = [[1.0 for pt in row] for row in self.surface.ctrlpts2d]
        return np.array(weights)

    @classmethod
    def build_geomdl(cls, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots=False):

        def convert_row(verts_row, weights_row):
            return [(x*w, y*w, z*w, w) for (x,y,z), w in zip(verts_row, weights_row)]

        if weights is None:
            surf = BSpline.Surface(normalize_kv = normalize_knots)
        else:
            surf = NURBS.Surface(normalize_kv = normalize_knots)
        surf.degree_u = degree_u
        surf.degree_v = degree_v
        if weights is None:
            ctrlpts = control_points
        else:
            ctrlpts = list(map(convert_row, control_points, weights))
        surf.ctrlpts2d = ctrlpts
        surf.knotvector_u = knotvector_u
        surf.knotvector_v = knotvector_v

        result = SvGeomdlSurface(surf)
        result.u_bounds = surf.knotvector_u[0], surf.knotvector_u[-1]
        result.v_bounds = surf.knotvector_v[0], surf.knotvector_v[-1]
        return result

    @classmethod
    def from_any_nurbs(cls, surface):
        if not isinstance(surface, SvNurbsSurface):
            raise TypeError(&#34;Invalid surface&#34;)
        if isinstance(surface, SvGeomdlSurface):
            return surface
        return SvGeomdlSurface.build_geomdl(surface.get_degree_u(), surface.get_degree_v(),
                    surface.get_knotvector_u(), surface.get_knotvector_v(),
                    surface.get_control_points(),
                    surface.get_weights())

    @classmethod
    def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
        return SvGeomdlSurface.build_geomdl(degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots)

    def get_input_orientation(self):
        return &#39;Z&#39;

    def get_coord_mode(self):
        return &#39;UV&#39;

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]

    @property
    def has_input_matrix(self):
        return False

    def evaluate(self, u, v):
        vert = self.surface.evaluate_single((u, v))
        return np.array(vert)

    def evaluate_array(self, us, vs):
        uv_coords = list(zip(list(us), list(vs)))
        verts = self.surface.evaluate_list(uv_coords)
        verts = np.array(verts)
        return verts

    def iso_curve(self, fixed_direction, param, flip=False):
        if self.surface.rational:
            raise UnsupportedSurfaceTypeException(&#34;iso_curve() is not supported for rational Geomdl surfaces yet&#34;)
        controls = self.get_control_points()
        weights = self.get_weights()
        k_u,k_v = weights.shape
        if fixed_direction == SvNurbsSurface.U:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_u(),
                            self.get_knotvector_u(),
                            controls[:,j], weights[:,j]) for j in range(k_v)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = np.ones((k_v,))
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_v(),
                    self.get_knotvector_v(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve
        elif fixed_direction == SvNurbsSurface.V:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_v(),
                            self.get_knotvector_v(),
                            controls[i,:], weights[i,:]) for i in range(k_u)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = np.ones((k_u,))
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_u(),
                    self.get_knotvector_u(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve
    def normal(self, u, v):
        return self.normal_array(np.array([u]), np.array([v]))[0]

    def normal_array(self, us, vs):
        if geomdl is not None:
            uv_coords = list(zip(list(us), list(vs)))
            spline_normals = np.array( operations.normal(self.surface, uv_coords) )[:,1,:]
            return spline_normals

    def derivatives_list(self, us, vs):
        result = []
        for u, v in zip(us, vs):
            ds = self.surface.derivatives(u, v, order=2)
            result.append(ds)
        return np.array(result)

    def curvature_calculator(self, us, vs, order=True):
        surf_vertices = self.evaluate_array(us, vs)

        derivatives = self.derivatives_list(us, vs)
        # derivatives[i][j][k] = derivative w.r.t U j times, w.r.t. V k times, at i&#39;th pair of (u, v)
        fu = derivatives[:,1,0]
        fv = derivatives[:,0,1]

        normal = np.cross(fu, fv)
        norm = np.linalg.norm(normal, axis=1, keepdims=True)
        normal = normal / norm

        fuu = derivatives[:,2,0]
        fvv = derivatives[:,0,2]
        fuv = derivatives[:,1,1]

        nuu = (fuu * normal).sum(axis=1)
        nvv = (fvv * normal).sum(axis=1)
        nuv = (fuv * normal).sum(axis=1)

        duu = np.linalg.norm(fu, axis=1) **2
        dvv = np.linalg.norm(fv, axis=1) **2
        duv = (fu * fv).sum(axis=1)

        calc = SurfaceCurvatureCalculator(us, vs, order=order)
        calc.set(surf_vertices, normal, fu, fv, duu, dvv, duv, nuu, nvv, nuv)
        return calc

    def derivatives_data_array(self, us, vs):
        surf_vertices = self.evaluate_array(us, vs)
        derivatives = self.derivatives_list(us, vs)
        # derivatives[i][j][k] = derivative w.r.t U j times, w.r.t. V k times, at i&#39;th pair of (u, v)
        du = derivatives[:,1,0]
        dv = derivatives[:,0,1]
        return SurfaceDerivativesData(surf_vertices, du, dv)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.nurbs.SvNurbsSurface" href="#sverchok.utils.surface.nurbs.SvNurbsSurface">SvNurbsSurface</a></li>
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
    return SvGeomdlSurface.build_geomdl(degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.build_geomdl"><code class="name flex">
<span>def <span class="ident">build_geomdl</span></span>(<span>degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_geomdl(cls, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots=False):

    def convert_row(verts_row, weights_row):
        return [(x*w, y*w, z*w, w) for (x,y,z), w in zip(verts_row, weights_row)]

    if weights is None:
        surf = BSpline.Surface(normalize_kv = normalize_knots)
    else:
        surf = NURBS.Surface(normalize_kv = normalize_knots)
    surf.degree_u = degree_u
    surf.degree_v = degree_v
    if weights is None:
        ctrlpts = control_points
    else:
        ctrlpts = list(map(convert_row, control_points, weights))
    surf.ctrlpts2d = ctrlpts
    surf.knotvector_u = knotvector_u
    surf.knotvector_v = knotvector_v

    result = SvGeomdlSurface(surf)
    result.u_bounds = surf.knotvector_u[0], surf.knotvector_u[-1]
    result.v_bounds = surf.knotvector_v[0], surf.knotvector_v[-1]
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.from_any_nurbs"><code class="name flex">
<span>def <span class="ident">from_any_nurbs</span></span>(<span>surface)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_any_nurbs(cls, surface):
    if not isinstance(surface, SvNurbsSurface):
        raise TypeError(&#34;Invalid surface&#34;)
    if isinstance(surface, SvGeomdlSurface):
        return surface
    return SvGeomdlSurface.build_geomdl(surface.get_degree_u(), surface.get_degree_v(),
                surface.get_knotvector_u(), surface.get_knotvector_v(),
                surface.get_control_points(),
                surface.get_weights())</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_nurbs_implementation"><code class="name flex">
<span>def <span class="ident">get_nurbs_implementation</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_nurbs_implementation(cls):
    return SvNurbsSurface.GEOMDL</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.has_input_matrix"><code class="name">var <span class="ident">has_input_matrix</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_input_matrix(self):
    return False</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    return self.u_bounds[1] - self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    return self.v_bounds[1] - self.v_bounds[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.curvature_calculator"><code class="name flex">
<span>def <span class="ident">curvature_calculator</span></span>(<span>self, us, vs, order=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curvature_calculator(self, us, vs, order=True):
    surf_vertices = self.evaluate_array(us, vs)

    derivatives = self.derivatives_list(us, vs)
    # derivatives[i][j][k] = derivative w.r.t U j times, w.r.t. V k times, at i&#39;th pair of (u, v)
    fu = derivatives[:,1,0]
    fv = derivatives[:,0,1]

    normal = np.cross(fu, fv)
    norm = np.linalg.norm(normal, axis=1, keepdims=True)
    normal = normal / norm

    fuu = derivatives[:,2,0]
    fvv = derivatives[:,0,2]
    fuv = derivatives[:,1,1]

    nuu = (fuu * normal).sum(axis=1)
    nvv = (fvv * normal).sum(axis=1)
    nuv = (fuv * normal).sum(axis=1)

    duu = np.linalg.norm(fu, axis=1) **2
    dvv = np.linalg.norm(fv, axis=1) **2
    duv = (fu * fv).sum(axis=1)

    calc = SurfaceCurvatureCalculator(us, vs, order=order)
    calc.set(surf_vertices, normal, fu, fv, duu, dvv, duv, nuu, nvv, nuv)
    return calc</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.derivatives_data_array"><code class="name flex">
<span>def <span class="ident">derivatives_data_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivatives_data_array(self, us, vs):
    surf_vertices = self.evaluate_array(us, vs)
    derivatives = self.derivatives_list(us, vs)
    # derivatives[i][j][k] = derivative w.r.t U j times, w.r.t. V k times, at i&#39;th pair of (u, v)
    du = derivatives[:,1,0]
    dv = derivatives[:,0,1]
    return SurfaceDerivativesData(surf_vertices, du, dv)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.derivatives_list"><code class="name flex">
<span>def <span class="ident">derivatives_list</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivatives_list(self, us, vs):
    result = []
    for u, v in zip(us, vs):
        ds = self.surface.derivatives(u, v, order=2)
        result.append(ds)
    return np.array(result)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    vert = self.surface.evaluate_single((u, v))
    return np.array(vert)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    uv_coords = list(zip(list(us), list(vs)))
    verts = self.surface.evaluate_list(uv_coords)
    verts = np.array(verts)
    return verts</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_coord_mode"><code class="name flex">
<span>def <span class="ident">get_coord_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord_mode(self):
    return &#39;UV&#39;</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_degree_u"><code class="name flex">
<span>def <span class="ident">get_degree_u</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degree_u(self):
    return self.surface.degree_u</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_degree_v"><code class="name flex">
<span>def <span class="ident">get_degree_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degree_v(self):
    return self.surface.degree_v</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_input_orientation"><code class="name flex">
<span>def <span class="ident">get_input_orientation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_orientation(self):
    return &#39;Z&#39;</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.u_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.v_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.v_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.insert_knot"><code class="name flex">
<span>def <span class="ident">insert_knot</span></span>(<span>self, direction, parameter, count=1, if_possible=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_knot(self, direction, parameter, count=1, if_possible=False):
    if direction == SvNurbsSurface.U:
        uv = [parameter, None]
        counts = [count, 0]
    elif direction == SvNurbsSurface.V:
        uv = [None, parameter]
        counts = [0, count]
    surface = operations.insert_knot(self.surface, uv, counts)
    return SvGeomdlSurface(surface)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.iso_curve"><code class="name flex">
<span>def <span class="ident">iso_curve</span></span>(<span>self, fixed_direction, param, flip=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iso_curve(self, fixed_direction, param, flip=False):
    if self.surface.rational:
        raise UnsupportedSurfaceTypeException(&#34;iso_curve() is not supported for rational Geomdl surfaces yet&#34;)
    controls = self.get_control_points()
    weights = self.get_weights()
    k_u,k_v = weights.shape
    if fixed_direction == SvNurbsSurface.U:
        q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                        self.get_degree_u(),
                        self.get_knotvector_u(),
                        controls[:,j], weights[:,j]) for j in range(k_v)]
        q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
        q_weights = np.ones((k_v,))
        curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                self.get_degree_v(),
                self.get_knotvector_v(),
                q_controls, q_weights)
        if flip:
            return curve.reverse()
        else:
            return curve
    elif fixed_direction == SvNurbsSurface.V:
        q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                        self.get_degree_v(),
                        self.get_knotvector_v(),
                        controls[i,:], weights[i,:]) for i in range(k_u)]
        q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
        q_weights = np.ones((k_u,))
        curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                self.get_degree_u(),
                self.get_knotvector_u(),
                q_controls, q_weights)
        if flip:
            return curve.reverse()
        else:
            return curve</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal(self, u, v):
    return self.normal_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.normal_array"><code class="name flex">
<span>def <span class="ident">normal_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_array(self, us, vs):
    if geomdl is not None:
        uv_coords = list(zip(list(us), list(vs)))
        spline_normals = np.array( operations.normal(self.surface, uv_coords) )[:,1,:]
        return spline_normals</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvGeomdlSurface.remove_knot"><code class="name flex">
<span>def <span class="ident">remove_knot</span></span>(<span>self, direction, parameter, count=1, if_possible=False, tolerance=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_knot(self, direction, parameter, count=1, if_possible=False, tolerance=None):
    if direction == SvNurbsSurface.U:
        orig_kv = self.get_knotvector_u()
        uv = [parameter, None]
        counts = [count, 0]
    elif direction == SvNurbsSurface.V:
        orig_kv = self.get_knotvector_v()
        uv = [None, parameter]
        counts = [0, count]
    orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)

    surface = operations.remove_knot(self.surface, uv, counts)

    if direction == SvNurbsSurface.U:
        new_kv = self.get_knotvector_u()
    elif direction == SvNurbsSurface.V:
        new_kv = self.get_knotvector_v()

    new_multiplicity = sv_knotvector.find_multiplicity(new_kv, parameter)

    if not if_possible and (orig_multiplicity - new_multiplicity &lt; count):
        raise CantRemoveKnotException(f&#34;Asked to remove knot {direction}={parameter} {count} times, but could remove it only {orig_multiplicity-new_multiplicity} times&#34;)

    return SvGeomdlSurface(surface)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.surface.nurbs.SvNurbsSurface" href="#sverchok.utils.surface.nurbs.SvNurbsSurface">SvNurbsSurface</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_control_points" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_homogenous_control_points" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_homogenous_control_points">get_homogenous_control_points</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_u" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_u">get_knotvector_u</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_v" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_v">get_knotvector_v</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_continuity">get_min_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_u_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_u_continuity">get_min_u_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_v_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_v_continuity">get_min_v_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_weights" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_weights">get_weights</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface"><code class="flex name class">
<span>class <span class="ident">SvNativeNurbsSurface</span></span>
<span>(</span><span>degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Base abstract class for all supported implementations of NURBS surfaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNativeNurbsSurface(SvNurbsSurface):
    def __init__(self, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots=False):
        self.degree_u = degree_u
        self.degree_v = degree_v
        self.knotvector_u = np.array(knotvector_u)
        self.knotvector_v = np.array(knotvector_v)
        if normalize_knots:
            self.knotvector_u = sv_knotvector.normalize(self.knotvector_u)
            self.knotvector_v = sv_knotvector.normalize(self.knotvector_v)
        self.control_points = np.array(control_points)
        c_ku, c_kv, _ = self.control_points.shape
        if weights is None:
            self.weights = weights = np.ones((c_ku, c_kv))
        else:
            self.weights = np.array(weights)
            w_ku, w_kv = self.weights.shape
            if c_ku != w_ku or c_kv != w_kv:
                raise Exception(f&#34;Shape of control_points ({c_ku}, {c_kv}) does not match to shape of weights ({w_ku}, {w_kv})&#34;)
        self.basis_u = SvNurbsBasisFunctions(knotvector_u)
        self.basis_v = SvNurbsBasisFunctions(knotvector_v)
        self.u_bounds = (self.knotvector_u.min(), self.knotvector_u.max())
        self.v_bounds = (self.knotvector_v.min(), self.knotvector_v.max())
        self.normal_delta = 0.0001
        self.__description__ = f&#34;Native NURBS (degree={degree_u}x{degree_v}, pts={self.control_points.shape[0]}x{self.control_points.shape[1]})&#34;

    @classmethod
    def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
        return SvNativeNurbsSurface(degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots)

    @classmethod
    def get_nurbs_implementation(cls):
        return SvNurbsSurface.NATIVE

    def insert_knot(self, direction, parameter, count=1, if_possible=False):
        def get_common_count(curves):
            if not if_possible:
                # in this case the first curve.rinsert() call which can&#39;t insert the knot
                # requested number of times will raise an exception, so we do not have to bother
                return count
            else:
                # curve.insert_knot() calls will not raise exceptions, so we have to
                # select the minimum number of possible knot insertions among all curves
                min_count = count
                for curve in curves:
                    orig_kv = curve.get_knotvector()
                    orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)
                    if (parameter == orig_kv[0]) or (parameter == orig_kv[-1]):
                        max_multiplicity = curve.get_degree()+1
                    else:
                        max_multiplicity = curve.get_degree()
                    max_delta = max_multiplicity - orig_multiplicity
                    min_count = min(min_count, max_delta)
                return min_count

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            fixed_v_curves = []

            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_u, self.knotvector_u,
                                    fixed_v_points, fixed_v_weights)
                fixed_v_curves.append(fixed_v_curve)

            common_count = get_common_count(fixed_v_curves)

            for fixed_v_curve in fixed_v_curves:
                fixed_v_curve = fixed_v_curve.insert_knot(parameter, common_count, if_possible)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            return SvNativeNurbsSurface(new_u_degree, self.degree_v,
                    fixed_v_knotvector, self.knotvector_v,
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            fixed_u_curves = []

            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_v, self.knotvector_v,
                                    fixed_u_points, fixed_u_weights)
                fixed_u_curves.append(fixed_u_curve)

            common_count = get_common_count(fixed_u_curves)

            for fixed_u_curve in fixed_u_curves:
                fixed_u_curve = fixed_u_curve.insert_knot(parameter, common_count, if_possible)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            return SvNativeNurbsSurface(self.degree_u, new_v_degree,
                    self.knotvector_u, fixed_u_knotvector,
                    new_points, new_weights)
        else:
            raise Exception(&#34;Unsupported direction&#34;)

    def remove_knot(self, direction, parameter, count=1, if_possible=False, tolerance=1e-6):
        def get_common_count(curves):
            if not if_possible:
                # in this case the first curve.remove_knot() call which can&#39;t remove the knot
                # requested number of times will raise an exception, so we do not have to bother
                return count
            else:
                # curve.remove_knot() calls will not raise exceptions, so we have to
                # select the minimum number of possible knot removals among all curves
                min_count = curves[0].get_degree()+1
                for curve in curves:
                    orig_kv = curve.get_knotvector()
                    orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)
                    tmp = curve.remove_knot(parameter, count, if_possible=True, tolerance=tolerance)
                    new_kv = tmp.get_knotvector()
                    new_multiplicity = sv_knotvector.find_multiplicity(new_kv, parameter)
                    delta = orig_multiplicity - new_multiplicity
                    min_count = min(min_count, delta)
                return min_count

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            fixed_v_curves = []
            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_u, self.knotvector_u,
                                    fixed_v_points, fixed_v_weights)
                fixed_v_curves.append(fixed_v_curve)
            
            common_count = get_common_count(fixed_v_curves)

            for fixed_v_curve in fixed_v_curves:
                fixed_v_curve = fixed_v_curve.remove_knot(parameter, common_count, if_possible=if_possible, tolerance=tolerance)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            return SvNativeNurbsSurface(new_u_degree, self.degree_v,
                    fixed_v_knotvector, self.knotvector_v,
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            fixed_u_curves = []
            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                    self.degree_v, self.knotvector_v,
                                    fixed_u_points, fixed_u_weights)
                fixed_u_curves.append(fixed_u_curve)

            common_count = get_common_count(fixed_u_curves)

            for fixed_u_curve in fixed_u_curves:
                fixed_u_curve = fixed_u_curve.remove_knot(parameter, common_count, if_possible=if_possible, tolerance=tolerance)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            return SvNativeNurbsSurface(self.degree_u, new_v_degree,
                    self.knotvector_u, fixed_u_knotvector,
                    new_points, new_weights)
        else:
            raise Exception(&#34;Unsupported direction&#34;)

    def get_degree_u(self):
        return self.degree_u

    def get_degree_v(self):
        return self.degree_v

    def get_knotvector_u(self):
        return self.knotvector_u

    def get_knotvector_v(self):
        return self.knotvector_v

    def get_control_points(self):
        return self.control_points

    def get_weights(self):
        return self.weights

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def fraction(self, deriv_order_u, deriv_order_v, us, vs):
        pu = self.degree_u
        pv = self.degree_v
        ku, kv, _ = self.control_points.shape
        nsu = np.array([self.basis_u.derivative(i, pu, deriv_order_u)(us) for i in range(ku)]) # (ku, n)
        nsv = np.array([self.basis_v.derivative(i, pv, deriv_order_v)(vs) for i in range(kv)]) # (kv, n)
        nsu = np.transpose(nsu[np.newaxis], axes=(1,0,2)) # (ku, 1, n)
        nsv = nsv[np.newaxis] # (1, kv, n)
        ns = nsu * nsv # (ku, kv, n)
        weights = np.transpose(self.weights[np.newaxis], axes=(1,2,0)) # (ku, kv, 1)
        coeffs = ns * weights # (ku, kv, n)
        coeffs = np.transpose(coeffs[np.newaxis], axes=(3,1,2,0)) # (n,ku,kv,1)
        controls = self.control_points # (ku,kv,3)

        numerator = coeffs * controls # (n,ku,kv,3)
        numerator = numerator.sum(axis=1).sum(axis=1) # (n,3)
        denominator = coeffs.sum(axis=1).sum(axis=1)

        return numerator, denominator

    def evaluate_array(self, us, vs):
        numerator, denominator = self.fraction(0, 0, us, vs)
        return nurbs_divide(numerator, denominator)

    def normal(self, u, v):
        return self.normal_array(np.array([u]), np.array([v]))[0]

    def normal_array(self, us, vs):
        numerator, denominator = self.fraction(0, 0, us, vs)
        surface = nurbs_divide(numerator, denominator)
        numerator_u, denominator_u = self.fraction(1, 0, us, vs)
        numerator_v, denominator_v = self.fraction(0, 1, us, vs)
        surface_u = nurbs_divide(numerator_u - surface*denominator_u, denominator)
        surface_v = nurbs_divide(numerator_v - surface*denominator_v, denominator)
        normal = np.cross(surface_u, surface_v)
        n = np.linalg.norm(normal, axis=1, keepdims=True)
        normal = nurbs_divide(normal, n)
        return normal

    def iso_curve(self, fixed_direction, param, flip=False):
        controls = self.get_control_points()
        weights = self.get_weights()
        k_u,k_v = weights.shape
        if fixed_direction == SvNurbsSurface.U:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_u(),
                            self.get_knotvector_u(),
                            controls[:,j], weights[:,j]) for j in range(k_v)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = [q_curve.fraction_single(0, param)[1] for q_curve in q_curves]
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_v(),
                    self.get_knotvector_v(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve
        elif fixed_direction == SvNurbsSurface.V:
            q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                            self.get_degree_v(),
                            self.get_knotvector_v(),
                            controls[i,:], weights[i,:]) for i in range(k_u)]
            q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
            q_weights = [q_curve.fraction_single(0, param)[1] for q_curve in q_curves]
            curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                    self.get_degree_u(),
                    self.get_knotvector_u(),
                    q_controls, q_weights)
            if flip:
                return curve.reverse()
            else:
                return curve

    def derivatives_data_array(self, us, vs):
        numerator, denominator = self.fraction(0, 0, us, vs)
        surface = nurbs_divide(numerator, denominator)
        numerator_u, denominator_u = self.fraction(1, 0, us, vs)
        numerator_v, denominator_v = self.fraction(0, 1, us, vs)
        surface_u = (numerator_u - surface*denominator_u) / denominator
        surface_v = (numerator_v - surface*denominator_v) / denominator
        return SurfaceDerivativesData(surface, surface_u, surface_v)

    def curvature_calculator(self, us, vs, order=True):
    
        numerator, denominator = self.fraction(0, 0, us, vs)
        surface = nurbs_divide(numerator, denominator)
        numerator_u, denominator_u = self.fraction(1, 0, us, vs)
        numerator_v, denominator_v = self.fraction(0, 1, us, vs)
        surface_u = (numerator_u - surface*denominator_u) / denominator
        surface_v = (numerator_v - surface*denominator_v) / denominator

        normal = np.cross(surface_u, surface_v)
        n = np.linalg.norm(normal, axis=1, keepdims=True)
        normal = normal / n

        numerator_uu, denominator_uu = self.fraction(2, 0, us, vs)
        surface_uu = (numerator_uu - 2*surface_u*denominator_u - surface*denominator_uu) / denominator
        numerator_vv, denominator_vv = self.fraction(0, 2, us, vs)
        surface_vv = (numerator_vv - 2*surface_v*denominator_v - surface*denominator_vv) / denominator

        numerator_uv, denominator_uv = self.fraction(1, 1, us, vs)
        surface_uv = (numerator_uv - surface_v*denominator_u - surface_u*denominator_v - surface*denominator_uv) / denominator

        nuu = (surface_uu * normal).sum(axis=1)
        nvv = (surface_vv * normal).sum(axis=1)
        nuv = (surface_uv * normal).sum(axis=1)

        duu = np.linalg.norm(surface_u, axis=1) **2
        dvv = np.linalg.norm(surface_v, axis=1) **2
        duv = (surface_u * surface_v).sum(axis=1)

        calc = SurfaceCurvatureCalculator(us, vs, order=order)
        calc.set(surface, normal, surface_u, surface_v, duu, dvv, duv, nuu, nvv, nuv)
        return calc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.nurbs.SvNurbsSurface" href="#sverchok.utils.surface.nurbs.SvNurbsSurface">SvNurbsSurface</a></li>
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
    return SvNativeNurbsSurface(degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights, normalize_knots)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_nurbs_implementation"><code class="name flex">
<span>def <span class="ident">get_nurbs_implementation</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_nurbs_implementation(cls):
    return SvNurbsSurface.NATIVE</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.curvature_calculator"><code class="name flex">
<span>def <span class="ident">curvature_calculator</span></span>(<span>self, us, vs, order=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curvature_calculator(self, us, vs, order=True):

    numerator, denominator = self.fraction(0, 0, us, vs)
    surface = nurbs_divide(numerator, denominator)
    numerator_u, denominator_u = self.fraction(1, 0, us, vs)
    numerator_v, denominator_v = self.fraction(0, 1, us, vs)
    surface_u = (numerator_u - surface*denominator_u) / denominator
    surface_v = (numerator_v - surface*denominator_v) / denominator

    normal = np.cross(surface_u, surface_v)
    n = np.linalg.norm(normal, axis=1, keepdims=True)
    normal = normal / n

    numerator_uu, denominator_uu = self.fraction(2, 0, us, vs)
    surface_uu = (numerator_uu - 2*surface_u*denominator_u - surface*denominator_uu) / denominator
    numerator_vv, denominator_vv = self.fraction(0, 2, us, vs)
    surface_vv = (numerator_vv - 2*surface_v*denominator_v - surface*denominator_vv) / denominator

    numerator_uv, denominator_uv = self.fraction(1, 1, us, vs)
    surface_uv = (numerator_uv - surface_v*denominator_u - surface_u*denominator_v - surface*denominator_uv) / denominator

    nuu = (surface_uu * normal).sum(axis=1)
    nvv = (surface_vv * normal).sum(axis=1)
    nuv = (surface_uv * normal).sum(axis=1)

    duu = np.linalg.norm(surface_u, axis=1) **2
    dvv = np.linalg.norm(surface_v, axis=1) **2
    duv = (surface_u * surface_v).sum(axis=1)

    calc = SurfaceCurvatureCalculator(us, vs, order=order)
    calc.set(surface, normal, surface_u, surface_v, duu, dvv, duv, nuu, nvv, nuv)
    return calc</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.derivatives_data_array"><code class="name flex">
<span>def <span class="ident">derivatives_data_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivatives_data_array(self, us, vs):
    numerator, denominator = self.fraction(0, 0, us, vs)
    surface = nurbs_divide(numerator, denominator)
    numerator_u, denominator_u = self.fraction(1, 0, us, vs)
    numerator_v, denominator_v = self.fraction(0, 1, us, vs)
    surface_u = (numerator_u - surface*denominator_u) / denominator
    surface_v = (numerator_v - surface*denominator_v) / denominator
    return SurfaceDerivativesData(surface, surface_u, surface_v)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    numerator, denominator = self.fraction(0, 0, us, vs)
    return nurbs_divide(numerator, denominator)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.fraction"><code class="name flex">
<span>def <span class="ident">fraction</span></span>(<span>self, deriv_order_u, deriv_order_v, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fraction(self, deriv_order_u, deriv_order_v, us, vs):
    pu = self.degree_u
    pv = self.degree_v
    ku, kv, _ = self.control_points.shape
    nsu = np.array([self.basis_u.derivative(i, pu, deriv_order_u)(us) for i in range(ku)]) # (ku, n)
    nsv = np.array([self.basis_v.derivative(i, pv, deriv_order_v)(vs) for i in range(kv)]) # (kv, n)
    nsu = np.transpose(nsu[np.newaxis], axes=(1,0,2)) # (ku, 1, n)
    nsv = nsv[np.newaxis] # (1, kv, n)
    ns = nsu * nsv # (ku, kv, n)
    weights = np.transpose(self.weights[np.newaxis], axes=(1,2,0)) # (ku, kv, 1)
    coeffs = ns * weights # (ku, kv, n)
    coeffs = np.transpose(coeffs[np.newaxis], axes=(3,1,2,0)) # (n,ku,kv,1)
    controls = self.control_points # (ku,kv,3)

    numerator = coeffs * controls # (n,ku,kv,3)
    numerator = numerator.sum(axis=1).sum(axis=1) # (n,3)
    denominator = coeffs.sum(axis=1).sum(axis=1)

    return numerator, denominator</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_degree_u"><code class="name flex">
<span>def <span class="ident">get_degree_u</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degree_u(self):
    return self.degree_u</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_degree_v"><code class="name flex">
<span>def <span class="ident">get_degree_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degree_v(self):
    return self.degree_v</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.u_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.v_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.v_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.insert_knot"><code class="name flex">
<span>def <span class="ident">insert_knot</span></span>(<span>self, direction, parameter, count=1, if_possible=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_knot(self, direction, parameter, count=1, if_possible=False):
    def get_common_count(curves):
        if not if_possible:
            # in this case the first curve.rinsert() call which can&#39;t insert the knot
            # requested number of times will raise an exception, so we do not have to bother
            return count
        else:
            # curve.insert_knot() calls will not raise exceptions, so we have to
            # select the minimum number of possible knot insertions among all curves
            min_count = count
            for curve in curves:
                orig_kv = curve.get_knotvector()
                orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)
                if (parameter == orig_kv[0]) or (parameter == orig_kv[-1]):
                    max_multiplicity = curve.get_degree()+1
                else:
                    max_multiplicity = curve.get_degree()
                max_delta = max_multiplicity - orig_multiplicity
                min_count = min(min_count, max_delta)
            return min_count

    if direction == SvNurbsSurface.U:
        new_points = []
        new_weights = []
        new_u_degree = None
        fixed_v_curves = []

        for i in range(self.get_control_points().shape[1]):
            fixed_v_points = self.get_control_points()[:,i]
            fixed_v_weights = self.get_weights()[:,i]
            fixed_v_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                self.degree_u, self.knotvector_u,
                                fixed_v_points, fixed_v_weights)
            fixed_v_curves.append(fixed_v_curve)

        common_count = get_common_count(fixed_v_curves)

        for fixed_v_curve in fixed_v_curves:
            fixed_v_curve = fixed_v_curve.insert_knot(parameter, common_count, if_possible)
            fixed_v_knotvector = fixed_v_curve.get_knotvector()
            new_u_degree = fixed_v_curve.get_degree()
            fixed_v_points = fixed_v_curve.get_control_points()
            fixed_v_weights = fixed_v_curve.get_weights()
            new_points.append(fixed_v_points)
            new_weights.append(fixed_v_weights)

        new_points = np.transpose(np.array(new_points), axes=(1,0,2))
        new_weights = np.array(new_weights).T

        return SvNativeNurbsSurface(new_u_degree, self.degree_v,
                fixed_v_knotvector, self.knotvector_v,
                new_points, new_weights)

    elif direction == SvNurbsSurface.V:
        new_points = []
        new_weights = []
        new_v_degree = None
        fixed_u_curves = []

        for i in range(self.get_control_points().shape[0]):
            fixed_u_points = self.get_control_points()[i,:]
            fixed_u_weights = self.get_weights()[i,:]
            fixed_u_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                self.degree_v, self.knotvector_v,
                                fixed_u_points, fixed_u_weights)
            fixed_u_curves.append(fixed_u_curve)

        common_count = get_common_count(fixed_u_curves)

        for fixed_u_curve in fixed_u_curves:
            fixed_u_curve = fixed_u_curve.insert_knot(parameter, common_count, if_possible)
            fixed_u_knotvector = fixed_u_curve.get_knotvector()
            new_v_degree = fixed_u_curve.get_degree()
            fixed_u_points = fixed_u_curve.get_control_points()
            fixed_u_weights = fixed_u_curve.get_weights()
            new_points.append(fixed_u_points)
            new_weights.append(fixed_u_weights)

        new_points = np.array(new_points)
        new_weights = np.array(new_weights)

        return SvNativeNurbsSurface(self.degree_u, new_v_degree,
                self.knotvector_u, fixed_u_knotvector,
                new_points, new_weights)
    else:
        raise Exception(&#34;Unsupported direction&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.iso_curve"><code class="name flex">
<span>def <span class="ident">iso_curve</span></span>(<span>self, fixed_direction, param, flip=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iso_curve(self, fixed_direction, param, flip=False):
    controls = self.get_control_points()
    weights = self.get_weights()
    k_u,k_v = weights.shape
    if fixed_direction == SvNurbsSurface.U:
        q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                        self.get_degree_u(),
                        self.get_knotvector_u(),
                        controls[:,j], weights[:,j]) for j in range(k_v)]
        q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
        q_weights = [q_curve.fraction_single(0, param)[1] for q_curve in q_curves]
        curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                self.get_degree_v(),
                self.get_knotvector_v(),
                q_controls, q_weights)
        if flip:
            return curve.reverse()
        else:
            return curve
    elif fixed_direction == SvNurbsSurface.V:
        q_curves = [SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                        self.get_degree_v(),
                        self.get_knotvector_v(),
                        controls[i,:], weights[i,:]) for i in range(k_u)]
        q_controls = [q_curve.evaluate(param) for q_curve in q_curves]
        q_weights = [q_curve.fraction_single(0, param)[1] for q_curve in q_curves]
        curve = SvNurbsMaths.build_curve(self.get_nurbs_implementation(),
                self.get_degree_u(),
                self.get_knotvector_u(),
                q_controls, q_weights)
        if flip:
            return curve.reverse()
        else:
            return curve</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal(self, u, v):
    return self.normal_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.normal_array"><code class="name flex">
<span>def <span class="ident">normal_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_array(self, us, vs):
    numerator, denominator = self.fraction(0, 0, us, vs)
    surface = nurbs_divide(numerator, denominator)
    numerator_u, denominator_u = self.fraction(1, 0, us, vs)
    numerator_v, denominator_v = self.fraction(0, 1, us, vs)
    surface_u = nurbs_divide(numerator_u - surface*denominator_u, denominator)
    surface_v = nurbs_divide(numerator_v - surface*denominator_v, denominator)
    normal = np.cross(surface_u, surface_v)
    n = np.linalg.norm(normal, axis=1, keepdims=True)
    normal = nurbs_divide(normal, n)
    return normal</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.remove_knot"><code class="name flex">
<span>def <span class="ident">remove_knot</span></span>(<span>self, direction, parameter, count=1, if_possible=False, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_knot(self, direction, parameter, count=1, if_possible=False, tolerance=1e-6):
    def get_common_count(curves):
        if not if_possible:
            # in this case the first curve.remove_knot() call which can&#39;t remove the knot
            # requested number of times will raise an exception, so we do not have to bother
            return count
        else:
            # curve.remove_knot() calls will not raise exceptions, so we have to
            # select the minimum number of possible knot removals among all curves
            min_count = curves[0].get_degree()+1
            for curve in curves:
                orig_kv = curve.get_knotvector()
                orig_multiplicity = sv_knotvector.find_multiplicity(orig_kv, parameter)
                tmp = curve.remove_knot(parameter, count, if_possible=True, tolerance=tolerance)
                new_kv = tmp.get_knotvector()
                new_multiplicity = sv_knotvector.find_multiplicity(new_kv, parameter)
                delta = orig_multiplicity - new_multiplicity
                min_count = min(min_count, delta)
            return min_count

    if direction == SvNurbsSurface.U:
        new_points = []
        new_weights = []
        new_u_degree = None
        fixed_v_curves = []
        for i in range(self.get_control_points().shape[1]):
            fixed_v_points = self.get_control_points()[:,i]
            fixed_v_weights = self.get_weights()[:,i]
            fixed_v_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                self.degree_u, self.knotvector_u,
                                fixed_v_points, fixed_v_weights)
            fixed_v_curves.append(fixed_v_curve)
        
        common_count = get_common_count(fixed_v_curves)

        for fixed_v_curve in fixed_v_curves:
            fixed_v_curve = fixed_v_curve.remove_knot(parameter, common_count, if_possible=if_possible, tolerance=tolerance)
            fixed_v_knotvector = fixed_v_curve.get_knotvector()
            new_u_degree = fixed_v_curve.get_degree()
            fixed_v_points = fixed_v_curve.get_control_points()
            fixed_v_weights = fixed_v_curve.get_weights()
            new_points.append(fixed_v_points)
            new_weights.append(fixed_v_weights)

        new_points = np.transpose(np.array(new_points), axes=(1,0,2))
        new_weights = np.array(new_weights).T

        return SvNativeNurbsSurface(new_u_degree, self.degree_v,
                fixed_v_knotvector, self.knotvector_v,
                new_points, new_weights)

    elif direction == SvNurbsSurface.V:
        new_points = []
        new_weights = []
        new_v_degree = None
        fixed_u_curves = []
        for i in range(self.get_control_points().shape[0]):
            fixed_u_points = self.get_control_points()[i,:]
            fixed_u_weights = self.get_weights()[i,:]
            fixed_u_curve = SvNurbsMaths.build_curve(SvNurbsMaths.NATIVE,
                                self.degree_v, self.knotvector_v,
                                fixed_u_points, fixed_u_weights)
            fixed_u_curves.append(fixed_u_curve)

        common_count = get_common_count(fixed_u_curves)

        for fixed_u_curve in fixed_u_curves:
            fixed_u_curve = fixed_u_curve.remove_knot(parameter, common_count, if_possible=if_possible, tolerance=tolerance)
            fixed_u_knotvector = fixed_u_curve.get_knotvector()
            new_v_degree = fixed_u_curve.get_degree()
            fixed_u_points = fixed_u_curve.get_control_points()
            fixed_u_weights = fixed_u_curve.get_weights()
            new_points.append(fixed_u_points)
            new_weights.append(fixed_u_weights)

        new_points = np.array(new_points)
        new_weights = np.array(new_weights)

        return SvNativeNurbsSurface(self.degree_u, new_v_degree,
                self.knotvector_u, fixed_u_knotvector,
                new_points, new_weights)
    else:
        raise Exception(&#34;Unsupported direction&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.surface.nurbs.SvNurbsSurface" href="#sverchok.utils.surface.nurbs.SvNurbsSurface">SvNurbsSurface</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_control_points" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_homogenous_control_points" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_homogenous_control_points">get_homogenous_control_points</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_u" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_u">get_knotvector_u</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_v" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_v">get_knotvector_v</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_continuity">get_min_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_u_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_u_continuity">get_min_u_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_v_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_v_continuity">get_min_v_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_weights" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_weights">get_weights</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface"><code class="flex name class">
<span>class <span class="ident">SvNurbsSurface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base abstract class for all supported implementations of NURBS surfaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvNurbsSurface(SvSurface):
    &#34;&#34;&#34;
    Base abstract class for all supported implementations of NURBS surfaces.
    &#34;&#34;&#34;
    NATIVE = SvNurbsMaths.NATIVE
    GEOMDL = SvNurbsMaths.GEOMDL

    U = &#39;U&#39;
    V = &#39;V&#39;

    @classmethod
    def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
        return SvNurbsMaths.build_surface(implementation,
                    degree_u, degree_v,
                    knotvector_u, knotvector_v,
                    control_points, weights,
                    normalize_knots)

    @classmethod
    def get(cls, surface, implementation = NATIVE):
        if isinstance(surface, SvNurbsSurface):
            return surface
        if hasattr(surface, &#39;to_nurbs&#39;):
            try:
                return surface.to_nurbs(implementation=implementation)
            except UnsupportedSurfaceTypeException as e:
                sv_logger.info(&#34;Can&#39;t convert %s to NURBS: %s&#34;, surface, e)
        return None

    @classmethod
    def get_nurbs_implementation(cls):
        raise Exception(&#34;NURBS implementation is not defined&#34;)

    def copy(self, implementation = None, degree_u=None, degree_v = None, knotvector_u = None, knotvector_v = None, control_points = None, weights = None):
        if implementation is None:
            implementation = self.get_nurbs_implementation()
        if degree_u is None:
            degree_u = self.get_degree_u()
        if degree_v is None:
            degree_v = self.get_degree_v()
        if knotvector_u is None:
            knotvector_u = self.get_knotvector_u()
        if knotvector_v is None:
            knotvector_v = self.get_knotvector_v()
        if control_points is None:
            control_points = self.get_control_points()
        if weights is None:
            weights = self.get_weights()

        return SvNurbsSurface.build(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights)

    def insert_knot(self, direction, parameter, count=1, if_possible=False):
        raise Exception(&#34;Not implemented!&#34;)

    def remove_knot(self, direction, parameter, count=1, tolerance=None, if_possible=False):
        raise Exception(&#34;Not implemented!&#34;)

    def get_degree_u(self):
        raise Exception(&#34;Not implemented!&#34;)

    def get_degree_v(self):
        raise Exception(&#34;Not implemented!&#34;)

    def get_knotvector_u(self):
        &#34;&#34;&#34;
        returns: np.array of shape (X,)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def get_knotvector_v(self):
        &#34;&#34;&#34;
        returns: np.array of shape (X,)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def get_control_points(self):
        &#34;&#34;&#34;
        returns: np.array of shape (n_u, n_v, 3)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def get_weights(self):
        &#34;&#34;&#34;
        returns: np.array of shape (n_u, n_v)
        &#34;&#34;&#34;
        raise Exception(&#34;Not implemented!&#34;)

    def iso_curve(self, fixed_direction, param):
        raise Exception(&#34;Not implemented&#34;)
    
    def is_rational(self, tolerance=1e-4):
        weights = self.get_weights()
        w, W = weights.min(), weights.max()
        return (W - w) &gt; tolerance

    def calc_greville_us(self):
        n = self.get_control_points().shape[0]
        p = self.get_degree_u()
        kv = self.get_knotvector_u()
        return sv_knotvector.calc_nodes(p, n, kv)

    def calc_greville_vs(self):
        n = self.get_control_points().shape[1]
        p = self.get_degree_v()
        kv = self.get_knotvector_v()
        return sv_knotvector.calc_nodes(p, n, kv)

    def get_homogenous_control_points(self):
        &#34;&#34;&#34;
        returns: np.array of shape (m, n, 4)
        &#34;&#34;&#34;
        points = self.get_control_points()
        weights = np.transpose(self.get_weights()[np.newaxis], axes=(1,2,0))
        weighted = weights * points
        return np.concatenate((weighted, weights), axis=2)

    def get_min_u_continuity(self):
        &#34;&#34;&#34;
        Return minimum continuity degree of the surface in the U direction (guaranteed by knotvector):
        0 - point-wise continuity only (C0),
        1 - tangent continuity (C1),
        2 - 2nd derivative continuity (C2), and so on.
        &#34;&#34;&#34;
        kv = self.get_knotvector_u()
        degree = self.get_degree_u()
        return sv_knotvector.get_min_continuity(kv, degree)

    def get_min_v_continuity(self):
        &#34;&#34;&#34;
        Return minimum continuity degree of the surface in the V direction (guaranteed by knotvector):
        0 - point-wise continuity only (C0),
        1 - tangent continuity (C1),
        2 - 2nd derivative continuity (C2), and so on.
        &#34;&#34;&#34;
        kv = self.get_knotvector_v()
        degree = self.get_degree_v()
        return sv_knotvector.get_min_continuity(kv, degree)
    
    def get_min_continuity(self):
        &#34;&#34;&#34;
        Return minimum continuity degree of the surface (guaranteed by knotvectors):
        0 - point-wise continuity only (C0),
        1 - tangent continuity (C1),
        2 - 2nd derivative continuity (C2), and so on.
        &#34;&#34;&#34;
        c_u = self.get_min_u_continuity()
        c_v = self.get_min_v_continuity()
        return min(c_u, c_v)

    def swap_uv(self):
        degree_u = self.get_degree_u()
        degree_v = self.get_degree_v()
        knotvector_u = self.get_knotvector_u()
        knotvector_v = self.get_knotvector_v()

        control_points = self.get_control_points()
        weights = self.get_weights()

        control_points = np.transpose(control_points, axes=(1,0,2))
        weights = weights.T

        return SvNurbsSurface.build(self.get_nurbs_implementation(),
                degree_v, degree_u,
                knotvector_v, knotvector_u,
                control_points, weights)

    def elevate_degree(self, direction, delta=None, target=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        if direction == SvNurbsSurface.U:
            degree = self.get_degree_u()
        else:
            degree = self.get_degree_v()
        if delta is None:
            delta = target - degree
            if delta &lt; 0:
                raise Exception(f&#34;Surface already has degree {degree}, which is greater than target {target}&#34;)
        if delta == 0:
            return self

        implementation = self.get_nurbs_implementation()

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_u(), self.get_knotvector_u(),
                                    fixed_v_points, fixed_v_weights)
                fixed_v_curve = fixed_v_curve.elevate_degree(delta)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            return SvNurbsSurface.build(self.get_nurbs_implementation(),
                    new_u_degree, self.get_degree_v(),
                    fixed_v_knotvector, self.get_knotvector_v(),
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_v(), self.get_knotvector_v(),
                                    fixed_u_points, fixed_u_weights)
                fixed_u_curve = fixed_u_curve.elevate_degree(delta)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            return SvNurbsSurface.build(implementation,
                    self.get_degree_u(), new_v_degree,
                    self.get_knotvector_u(), fixed_u_knotvector,
                    new_points, new_weights)

    def reduce_degree(self, direction, delta=None, target=None, tolerance=1e-6, logger=None):
        if delta is None and target is None:
            delta = 1
        if delta is not None and target is not None:
            raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
        if direction == SvNurbsSurface.U:
            degree = self.get_degree_u()
        else:
            degree = self.get_degree_v()
        if delta is None:
            delta = degree - target
            if delta &lt; 0:
                raise Exception(f&#34;Surface already has degree {degree}, which is less than target {target}&#34;)
        if delta == 0:
            return self

        if logger is None:
            logger = get_logger()

        implementation = self.get_nurbs_implementation()

        if direction == SvNurbsSurface.U:
            new_points = []
            new_weights = []
            new_u_degree = None
            remaining_tolerance = tolerance
            max_error = 0.0
            for i in range(self.get_control_points().shape[1]):
                fixed_v_points = self.get_control_points()[:,i]
                fixed_v_weights = self.get_weights()[:,i]
                fixed_v_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_u(), self.get_knotvector_u(),
                                    fixed_v_points, fixed_v_weights)
                try:
                    fixed_v_curve, error = fixed_v_curve.reduce_degree(delta=delta, tolerance=remaining_tolerance, return_error=True, logger=logger)
                except CantReduceDegreeException as e:
                    raise CantReduceDegreeException(f&#34;At parallel #{i}: {e}&#34;) from e
                max_error = max(max_error, error)
                fixed_v_knotvector = fixed_v_curve.get_knotvector()
                new_u_degree = fixed_v_curve.get_degree()
                fixed_v_points = fixed_v_curve.get_control_points()
                fixed_v_weights = fixed_v_curve.get_weights()
                new_points.append(fixed_v_points)
                new_weights.append(fixed_v_weights)

            new_points = np.transpose(np.array(new_points), axes=(1,0,2))
            new_weights = np.array(new_weights).T

            logger.debug(f&#34;Surface degree reduction error: {max_error}&#34;)

            return SvNurbsSurface.build(self.get_nurbs_implementation(),
                    new_u_degree, self.get_degree_v(),
                    fixed_v_knotvector, self.get_knotvector_v(),
                    new_points, new_weights)

        elif direction == SvNurbsSurface.V:
            new_points = []
            new_weights = []
            new_v_degree = None
            remaining_tolerance = tolerance
            max_error = 0.0
            for i in range(self.get_control_points().shape[0]):
                fixed_u_points = self.get_control_points()[i,:]
                fixed_u_weights = self.get_weights()[i,:]
                fixed_u_curve = SvNurbsMaths.build_curve(implementation,
                                    self.get_degree_v(), self.get_knotvector_v(),
                                    fixed_u_points, fixed_u_weights)
                try:
                    fixed_u_curve, error = fixed_u_curve.reduce_degree(delta=delta, tolerance=remaining_tolerance, return_error=True, logger=logger)
                except CantReduceDegreeException as e:
                    raise CantReduceDegreeException(f&#34;At parallel #{i}: {e}&#34;) from e
                max_error = max(max_error, error)
                fixed_u_knotvector = fixed_u_curve.get_knotvector()
                new_v_degree = fixed_u_curve.get_degree()
                fixed_u_points = fixed_u_curve.get_control_points()
                fixed_u_weights = fixed_u_curve.get_weights()
                new_points.append(fixed_u_points)
                new_weights.append(fixed_u_weights)

            new_points = np.array(new_points)
            new_weights = np.array(new_weights)

            logger.debug(f&#34;Surface degree reduction error: {max_error}&#34;)

            return SvNurbsSurface.build(implementation,
                    self.get_degree_u(), new_v_degree,
                    self.get_knotvector_u(), fixed_u_knotvector,
                    new_points, new_weights)

    def cut_u(self, u):
        u_min, u_max = self.get_u_min(), self.get_u_max()

        if u &lt;= u_min:
            return None, self
        if u &gt;= u_max:
            return self, None

        knotvector = self.get_knotvector_u()
        current_multiplicity = sv_knotvector.find_multiplicity(knotvector, u)
        to_add = self.get_degree_u() - current_multiplicity
        surface = self.insert_knot(&#39;U&#39;, u, count=to_add)
        knot_span = np.searchsorted(knotvector, u)

        us = np.full((self.get_degree_u()+1,), u)
        knotvector1 = np.concatenate((surface.get_knotvector_u()[:knot_span], us))
        knotvector2 = np.insert(surface.get_knotvector_u()[knot_span:], 0, u)

        control_points_1 = surface.get_control_points()[:knot_span, :]
        control_points_2 = surface.get_control_points()[knot_span-1:, :]
        weights_1 = surface.get_weights()[:knot_span, :]
        weights_2 = surface.get_weights()[knot_span-1:, :]

        surface1 = self.copy(knotvector_u=knotvector1, weights=weights_1, control_points=control_points_1)
        surface2 = self.copy(knotvector_u=knotvector2, weights=weights_2, control_points=control_points_2)

        return surface1, surface2

    def cut_v(self, v):
        v_min, v_max = self.get_v_min(), self.get_v_max()

        if v &lt;= v_min:
            return None, self
        if v &gt;= v_max:
            return self, None

        current_multiplicity = sv_knotvector.find_multiplicity(self.get_knotvector_v(), v)
        to_add = self.get_degree_v() - current_multiplicity
        surface = self.insert_knot(&#39;V&#39;, v, count=to_add)
        m,n,_ = surface.get_control_points().shape
        knot_span = sv_knotvector.find_span(surface.get_knotvector_v(), n, v) - 1
        #knot_span = np.searchsorted(surface.get_knotvector_v(), v)#, side=&#39;right&#39;)-1

        vs = np.full((self.get_degree_v()+1,), v)
        knotvector1 = np.concatenate((surface.get_knotvector_v()[:knot_span], vs))
        knotvector2 = np.insert(surface.get_knotvector_v()[knot_span:], 0, v)

        control_points_1 = surface.get_control_points()[:, :knot_span]
        control_points_2 = surface.get_control_points()[:, knot_span-1:]
        weights_1 = surface.get_weights()[:, :knot_span]
        weights_2 = surface.get_weights()[:, knot_span-1:]

        surface1 = self.copy(knotvector_v=knotvector1, weights=weights_1, control_points=control_points_1)
        surface2 = self.copy(knotvector_v=knotvector2, weights=weights_2, control_points=control_points_2)

        return surface1, surface2

    def split_at(self, direction, parameter):
        if direction == SvNurbsSurface.U:
            return self.cut_u(parameter)
        elif direction == SvNurbsSurface.V:
            return self.cut_v(parameter)
        else:
            raise Exception(&#34;Unsupported direction&#34;)

    def cut_slice(self, direction, p_min, p_max):
        _, rest = self.split_at(direction, p_min)
        if rest is None:
            return None
        result, _ = rest.split_at(direction, p_max)
        return result

    def _concat_u(self, surface2, tolerance=1e-6):
        surface1 = self
        surface2 = SvNurbsSurface.get(surface2)
        if surface2 is None:
            raise UnsupportedSurfaceTypeException(&#34;second surface is not NURBS&#34;)

        if surface1.get_control_points().shape[1] != surface2.get_control_points().shape[1]:
            # TODO: try to unify knots first?
            raise UnsupportedSurfaceTypeException(&#34;number of control points along V direction does not match&#34;)

        p1, p2 = surface1.get_degree_u(), surface2.get_degree_u()
        if p1 &gt; p2:
            surface2 = surface2.elevate_degree(&#39;U&#39;, delta = p1 - p2)
        elif p2 &gt; p1:
            surface1 = surface1.elevate_degree(&#39;U&#39;, delta = p2 - p1)

        cps1 = surface1.get_control_points()[-1,:]
        cps2 = surface2.get_control_points()[0,:]
        dpts = np.linalg.norm(cps1 - cps2, axis=0)
        if (dpts &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Boundary control points do not match&#34;)

        ws1 = surface1.get_weights()[-1,:]
        ws2 = surface2.get_weights()[0,:]
        if (np.abs(ws1 - ws2) &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Weights at bounds do not match&#34;)

        p = surface1.get_degree_u()

        kv1 = surface1.get_knotvector_u()
        kv2 = surface2.get_knotvector_u()
        kv1_end_multiplicity = sv_knotvector.to_multiplicity(kv1)[-1][1]
        kv2_start_multiplicity = sv_knotvector.to_multiplicity(kv2)[0][1]
        if kv1_end_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;End knot multiplicity of the first surface ({kv1_end_multiplicity}) is not equal to degree+1 ({p+1})&#34;)
        if kv2_start_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;Start knot multiplicity of the second surface ({kv2_start_multiplicity}) is not equal to degree+1 ({p+1})&#34;)

        knotvector = sv_knotvector.concatenate(kv1, kv2, join_multiplicity=p)

        weights = np.concatenate((surface1.get_weights(), surface2.get_weights()[1:]))
        control_points = np.concatenate((surface1.get_control_points(), surface2.get_control_points()[1:]))

        result = surface1.copy(knotvector_u = knotvector,
                    control_points = control_points,
                    weights = weights)
        return result

    def _concat_v(self, surface2, tolerance=1e-6):
        surface1 = self
        surface2 = SvNurbsSurface.get(surface2)
        if surface2 is None:
            raise UnsupportedSurfaceTypeException(&#34;second surface is not NURBS&#34;)

        if surface1.get_control_points().shape[0] != surface2.get_control_points().shape[0]:
            # TODO: try to unify knots first?
            raise UnsupportedSurfaceTypeException(&#34;number of control points along U direction does not match&#34;)

        p1, p2 = surface1.get_degree_v(), surface2.get_degree_v()
        if p1 &gt; p2:
            surface2 = surface2.elevate_degree(&#39;V&#39;, delta = p1 - p2)
        elif p2 &gt; p1:
            surface1 = surface1.elevate_degree(&#39;V&#39;, delta = p2 - p1)
        cps1 = surface1.get_control_points()[:,-1]
        cps2 = surface2.get_control_points()[:,0]
        dpts = np.linalg.norm(cps1 - cps2, axis=0)
        if (dpts &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Boundary control points do not match&#34;)

        ws1 = surface1.get_weights()[:,-1]
        ws2 = surface2.get_weights()[:,0]
        if (np.abs(ws1 - ws2) &gt; tolerance).any():
            raise UnsupportedSurfaceTypeException(&#34;Weights at bounds do not match&#34;)

        p = surface1.get_degree_v()

        kv1 = surface1.get_knotvector_v()
        kv2 = surface2.get_knotvector_v()
        kv1_end_multiplicity = sv_knotvector.to_multiplicity(kv1)[-1][1]
        kv2_start_multiplicity = sv_knotvector.to_multiplicity(kv2)[0][1]
        if kv1_end_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;End knot multiplicity of the first surface ({kv1_end_multiplicity}) is not equal to degree+1 ({p+1})&#34;)
        if kv2_start_multiplicity != p+1:
            raise UnsupportedSurfaceTypeException(f&#34;Start knot multiplicity of the second surface ({kv2_start_multiplicity}) is not equal to degree+1 ({p+1})&#34;)

        knotvector = sv_knotvector.concatenate(kv1, kv2, join_multiplicity=p)

        weights = np.concatenate((surface1.get_weights(), surface2.get_weights()[:,1:]), axis=1)
        control_points = np.concatenate((surface1.get_control_points(), surface2.get_control_points()[:,1:]), axis=1)

        result = surface1.copy(knotvector_v = knotvector,
                    control_points = control_points,
                    weights = weights)
        return result

    def concatenate(self, direction, surface2, tolerance=1e-6):
        if direction == SvNurbsSurface.U:
            return self._concat_u(surface2, tolerance)
        elif direction == SvNurbsSurface.V:
            return self._concat_v(surface2, tolerance)
        else:
            raise Exception(&#34;Unsupported direction&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.freecad.SvFreeCadNurbsSurface" href="freecad.html#sverchok.utils.surface.freecad.SvFreeCadNurbsSurface">SvFreeCadNurbsSurface</a></li>
<li><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface">SvGeomdlSurface</a></li>
<li><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface">SvNativeNurbsSurface</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.GEOMDL"><code class="name">var <span class="ident">GEOMDL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.NATIVE"><code class="name">var <span class="ident">NATIVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.U"><code class="name">var <span class="ident">U</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.V"><code class="name">var <span class="ident">V</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, implementation, degree_u, degree_v, knotvector_u, knotvector_v, control_points, weights=None, normalize_knots=False):
    return SvNurbsMaths.build_surface(implementation,
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                control_points, weights,
                normalize_knots)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>surface, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get(cls, surface, implementation = NATIVE):
    if isinstance(surface, SvNurbsSurface):
        return surface
    if hasattr(surface, &#39;to_nurbs&#39;):
        try:
            return surface.to_nurbs(implementation=implementation)
        except UnsupportedSurfaceTypeException as e:
            sv_logger.info(&#34;Can&#39;t convert %s to NURBS: %s&#34;, surface, e)
    return None</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_nurbs_implementation"><code class="name flex">
<span>def <span class="ident">get_nurbs_implementation</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_nurbs_implementation(cls):
    raise Exception(&#34;NURBS implementation is not defined&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.calc_greville_us"><code class="name flex">
<span>def <span class="ident">calc_greville_us</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_greville_us(self):
    n = self.get_control_points().shape[0]
    p = self.get_degree_u()
    kv = self.get_knotvector_u()
    return sv_knotvector.calc_nodes(p, n, kv)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.calc_greville_vs"><code class="name flex">
<span>def <span class="ident">calc_greville_vs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_greville_vs(self):
    n = self.get_control_points().shape[1]
    p = self.get_degree_v()
    kv = self.get_knotvector_v()
    return sv_knotvector.calc_nodes(p, n, kv)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.concatenate"><code class="name flex">
<span>def <span class="ident">concatenate</span></span>(<span>self, direction, surface2, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate(self, direction, surface2, tolerance=1e-6):
    if direction == SvNurbsSurface.U:
        return self._concat_u(surface2, tolerance)
    elif direction == SvNurbsSurface.V:
        return self._concat_v(surface2, tolerance)
    else:
        raise Exception(&#34;Unsupported direction&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, implementation=None, degree_u=None, degree_v=None, knotvector_u=None, knotvector_v=None, control_points=None, weights=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, implementation = None, degree_u=None, degree_v = None, knotvector_u = None, knotvector_v = None, control_points = None, weights = None):
    if implementation is None:
        implementation = self.get_nurbs_implementation()
    if degree_u is None:
        degree_u = self.get_degree_u()
    if degree_v is None:
        degree_v = self.get_degree_v()
    if knotvector_u is None:
        knotvector_u = self.get_knotvector_u()
    if knotvector_v is None:
        knotvector_v = self.get_knotvector_v()
    if control_points is None:
        control_points = self.get_control_points()
    if weights is None:
        weights = self.get_weights()

    return SvNurbsSurface.build(implementation,
            degree_u, degree_v,
            knotvector_u, knotvector_v,
            control_points, weights)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.cut_slice"><code class="name flex">
<span>def <span class="ident">cut_slice</span></span>(<span>self, direction, p_min, p_max)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_slice(self, direction, p_min, p_max):
    _, rest = self.split_at(direction, p_min)
    if rest is None:
        return None
    result, _ = rest.split_at(direction, p_max)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.cut_u"><code class="name flex">
<span>def <span class="ident">cut_u</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_u(self, u):
    u_min, u_max = self.get_u_min(), self.get_u_max()

    if u &lt;= u_min:
        return None, self
    if u &gt;= u_max:
        return self, None

    knotvector = self.get_knotvector_u()
    current_multiplicity = sv_knotvector.find_multiplicity(knotvector, u)
    to_add = self.get_degree_u() - current_multiplicity
    surface = self.insert_knot(&#39;U&#39;, u, count=to_add)
    knot_span = np.searchsorted(knotvector, u)

    us = np.full((self.get_degree_u()+1,), u)
    knotvector1 = np.concatenate((surface.get_knotvector_u()[:knot_span], us))
    knotvector2 = np.insert(surface.get_knotvector_u()[knot_span:], 0, u)

    control_points_1 = surface.get_control_points()[:knot_span, :]
    control_points_2 = surface.get_control_points()[knot_span-1:, :]
    weights_1 = surface.get_weights()[:knot_span, :]
    weights_2 = surface.get_weights()[knot_span-1:, :]

    surface1 = self.copy(knotvector_u=knotvector1, weights=weights_1, control_points=control_points_1)
    surface2 = self.copy(knotvector_u=knotvector2, weights=weights_2, control_points=control_points_2)

    return surface1, surface2</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.cut_v"><code class="name flex">
<span>def <span class="ident">cut_v</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_v(self, v):
    v_min, v_max = self.get_v_min(), self.get_v_max()

    if v &lt;= v_min:
        return None, self
    if v &gt;= v_max:
        return self, None

    current_multiplicity = sv_knotvector.find_multiplicity(self.get_knotvector_v(), v)
    to_add = self.get_degree_v() - current_multiplicity
    surface = self.insert_knot(&#39;V&#39;, v, count=to_add)
    m,n,_ = surface.get_control_points().shape
    knot_span = sv_knotvector.find_span(surface.get_knotvector_v(), n, v) - 1
    #knot_span = np.searchsorted(surface.get_knotvector_v(), v)#, side=&#39;right&#39;)-1

    vs = np.full((self.get_degree_v()+1,), v)
    knotvector1 = np.concatenate((surface.get_knotvector_v()[:knot_span], vs))
    knotvector2 = np.insert(surface.get_knotvector_v()[knot_span:], 0, v)

    control_points_1 = surface.get_control_points()[:, :knot_span]
    control_points_2 = surface.get_control_points()[:, knot_span-1:]
    weights_1 = surface.get_weights()[:, :knot_span]
    weights_2 = surface.get_weights()[:, knot_span-1:]

    surface1 = self.copy(knotvector_v=knotvector1, weights=weights_1, control_points=control_points_1)
    surface2 = self.copy(knotvector_v=knotvector2, weights=weights_2, control_points=control_points_2)

    return surface1, surface2</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.elevate_degree"><code class="name flex">
<span>def <span class="ident">elevate_degree</span></span>(<span>self, direction, delta=None, target=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elevate_degree(self, direction, delta=None, target=None):
    if delta is None and target is None:
        delta = 1
    if delta is not None and target is not None:
        raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
    if direction == SvNurbsSurface.U:
        degree = self.get_degree_u()
    else:
        degree = self.get_degree_v()
    if delta is None:
        delta = target - degree
        if delta &lt; 0:
            raise Exception(f&#34;Surface already has degree {degree}, which is greater than target {target}&#34;)
    if delta == 0:
        return self

    implementation = self.get_nurbs_implementation()

    if direction == SvNurbsSurface.U:
        new_points = []
        new_weights = []
        new_u_degree = None
        for i in range(self.get_control_points().shape[1]):
            fixed_v_points = self.get_control_points()[:,i]
            fixed_v_weights = self.get_weights()[:,i]
            fixed_v_curve = SvNurbsMaths.build_curve(implementation,
                                self.get_degree_u(), self.get_knotvector_u(),
                                fixed_v_points, fixed_v_weights)
            fixed_v_curve = fixed_v_curve.elevate_degree(delta)
            fixed_v_knotvector = fixed_v_curve.get_knotvector()
            new_u_degree = fixed_v_curve.get_degree()
            fixed_v_points = fixed_v_curve.get_control_points()
            fixed_v_weights = fixed_v_curve.get_weights()
            new_points.append(fixed_v_points)
            new_weights.append(fixed_v_weights)

        new_points = np.transpose(np.array(new_points), axes=(1,0,2))
        new_weights = np.array(new_weights).T

        return SvNurbsSurface.build(self.get_nurbs_implementation(),
                new_u_degree, self.get_degree_v(),
                fixed_v_knotvector, self.get_knotvector_v(),
                new_points, new_weights)

    elif direction == SvNurbsSurface.V:
        new_points = []
        new_weights = []
        new_v_degree = None
        for i in range(self.get_control_points().shape[0]):
            fixed_u_points = self.get_control_points()[i,:]
            fixed_u_weights = self.get_weights()[i,:]
            fixed_u_curve = SvNurbsMaths.build_curve(implementation,
                                self.get_degree_v(), self.get_knotvector_v(),
                                fixed_u_points, fixed_u_weights)
            fixed_u_curve = fixed_u_curve.elevate_degree(delta)
            fixed_u_knotvector = fixed_u_curve.get_knotvector()
            new_v_degree = fixed_u_curve.get_degree()
            fixed_u_points = fixed_u_curve.get_control_points()
            fixed_u_weights = fixed_u_curve.get_weights()
            new_points.append(fixed_u_points)
            new_weights.append(fixed_u_weights)

        new_points = np.array(new_points)
        new_weights = np.array(new_weights)

        return SvNurbsSurface.build(implementation,
                self.get_degree_u(), new_v_degree,
                self.get_knotvector_u(), fixed_u_knotvector,
                new_points, new_weights)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_control_points"><code class="name flex">
<span>def <span class="ident">get_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns: np.array of shape (n_u, n_v, 3)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_control_points(self):
    &#34;&#34;&#34;
    returns: np.array of shape (n_u, n_v, 3)
    &#34;&#34;&#34;
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_degree_u"><code class="name flex">
<span>def <span class="ident">get_degree_u</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degree_u(self):
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_degree_v"><code class="name flex">
<span>def <span class="ident">get_degree_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degree_v(self):
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_homogenous_control_points"><code class="name flex">
<span>def <span class="ident">get_homogenous_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns: np.array of shape (m, n, 4)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_homogenous_control_points(self):
    &#34;&#34;&#34;
    returns: np.array of shape (m, n, 4)
    &#34;&#34;&#34;
    points = self.get_control_points()
    weights = np.transpose(self.get_weights()[np.newaxis], axes=(1,2,0))
    weighted = weights * points
    return np.concatenate((weighted, weights), axis=2)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_u"><code class="name flex">
<span>def <span class="ident">get_knotvector_u</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns: np.array of shape (X,)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_knotvector_u(self):
    &#34;&#34;&#34;
    returns: np.array of shape (X,)
    &#34;&#34;&#34;
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_v"><code class="name flex">
<span>def <span class="ident">get_knotvector_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns: np.array of shape (X,)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_knotvector_v(self):
    &#34;&#34;&#34;
    returns: np.array of shape (X,)
    &#34;&#34;&#34;
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_continuity"><code class="name flex">
<span>def <span class="ident">get_min_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return minimum continuity degree of the surface (guaranteed by knotvectors):
0 - point-wise continuity only (C0),
1 - tangent continuity (C1),
2 - 2nd derivative continuity (C2), and so on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_continuity(self):
    &#34;&#34;&#34;
    Return minimum continuity degree of the surface (guaranteed by knotvectors):
    0 - point-wise continuity only (C0),
    1 - tangent continuity (C1),
    2 - 2nd derivative continuity (C2), and so on.
    &#34;&#34;&#34;
    c_u = self.get_min_u_continuity()
    c_v = self.get_min_v_continuity()
    return min(c_u, c_v)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_u_continuity"><code class="name flex">
<span>def <span class="ident">get_min_u_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return minimum continuity degree of the surface in the U direction (guaranteed by knotvector):
0 - point-wise continuity only (C0),
1 - tangent continuity (C1),
2 - 2nd derivative continuity (C2), and so on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_u_continuity(self):
    &#34;&#34;&#34;
    Return minimum continuity degree of the surface in the U direction (guaranteed by knotvector):
    0 - point-wise continuity only (C0),
    1 - tangent continuity (C1),
    2 - 2nd derivative continuity (C2), and so on.
    &#34;&#34;&#34;
    kv = self.get_knotvector_u()
    degree = self.get_degree_u()
    return sv_knotvector.get_min_continuity(kv, degree)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_v_continuity"><code class="name flex">
<span>def <span class="ident">get_min_v_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return minimum continuity degree of the surface in the V direction (guaranteed by knotvector):
0 - point-wise continuity only (C0),
1 - tangent continuity (C1),
2 - 2nd derivative continuity (C2), and so on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_v_continuity(self):
    &#34;&#34;&#34;
    Return minimum continuity degree of the surface in the V direction (guaranteed by knotvector):
    0 - point-wise continuity only (C0),
    1 - tangent continuity (C1),
    2 - 2nd derivative continuity (C2), and so on.
    &#34;&#34;&#34;
    kv = self.get_knotvector_v()
    degree = self.get_degree_v()
    return sv_knotvector.get_min_continuity(kv, degree)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns: np.array of shape (n_u, n_v)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    &#34;&#34;&#34;
    returns: np.array of shape (n_u, n_v)
    &#34;&#34;&#34;
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.insert_knot"><code class="name flex">
<span>def <span class="ident">insert_knot</span></span>(<span>self, direction, parameter, count=1, if_possible=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_knot(self, direction, parameter, count=1, if_possible=False):
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.is_rational"><code class="name flex">
<span>def <span class="ident">is_rational</span></span>(<span>self, tolerance=0.0001)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_rational(self, tolerance=1e-4):
    weights = self.get_weights()
    w, W = weights.min(), weights.max()
    return (W - w) &gt; tolerance</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.iso_curve"><code class="name flex">
<span>def <span class="ident">iso_curve</span></span>(<span>self, fixed_direction, param)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iso_curve(self, fixed_direction, param):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.reduce_degree"><code class="name flex">
<span>def <span class="ident">reduce_degree</span></span>(<span>self, direction, delta=None, target=None, tolerance=1e-06, logger=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_degree(self, direction, delta=None, target=None, tolerance=1e-6, logger=None):
    if delta is None and target is None:
        delta = 1
    if delta is not None and target is not None:
        raise Exception(&#34;Of delta and target, only one parameter can be specified&#34;)
    if direction == SvNurbsSurface.U:
        degree = self.get_degree_u()
    else:
        degree = self.get_degree_v()
    if delta is None:
        delta = degree - target
        if delta &lt; 0:
            raise Exception(f&#34;Surface already has degree {degree}, which is less than target {target}&#34;)
    if delta == 0:
        return self

    if logger is None:
        logger = get_logger()

    implementation = self.get_nurbs_implementation()

    if direction == SvNurbsSurface.U:
        new_points = []
        new_weights = []
        new_u_degree = None
        remaining_tolerance = tolerance
        max_error = 0.0
        for i in range(self.get_control_points().shape[1]):
            fixed_v_points = self.get_control_points()[:,i]
            fixed_v_weights = self.get_weights()[:,i]
            fixed_v_curve = SvNurbsMaths.build_curve(implementation,
                                self.get_degree_u(), self.get_knotvector_u(),
                                fixed_v_points, fixed_v_weights)
            try:
                fixed_v_curve, error = fixed_v_curve.reduce_degree(delta=delta, tolerance=remaining_tolerance, return_error=True, logger=logger)
            except CantReduceDegreeException as e:
                raise CantReduceDegreeException(f&#34;At parallel #{i}: {e}&#34;) from e
            max_error = max(max_error, error)
            fixed_v_knotvector = fixed_v_curve.get_knotvector()
            new_u_degree = fixed_v_curve.get_degree()
            fixed_v_points = fixed_v_curve.get_control_points()
            fixed_v_weights = fixed_v_curve.get_weights()
            new_points.append(fixed_v_points)
            new_weights.append(fixed_v_weights)

        new_points = np.transpose(np.array(new_points), axes=(1,0,2))
        new_weights = np.array(new_weights).T

        logger.debug(f&#34;Surface degree reduction error: {max_error}&#34;)

        return SvNurbsSurface.build(self.get_nurbs_implementation(),
                new_u_degree, self.get_degree_v(),
                fixed_v_knotvector, self.get_knotvector_v(),
                new_points, new_weights)

    elif direction == SvNurbsSurface.V:
        new_points = []
        new_weights = []
        new_v_degree = None
        remaining_tolerance = tolerance
        max_error = 0.0
        for i in range(self.get_control_points().shape[0]):
            fixed_u_points = self.get_control_points()[i,:]
            fixed_u_weights = self.get_weights()[i,:]
            fixed_u_curve = SvNurbsMaths.build_curve(implementation,
                                self.get_degree_v(), self.get_knotvector_v(),
                                fixed_u_points, fixed_u_weights)
            try:
                fixed_u_curve, error = fixed_u_curve.reduce_degree(delta=delta, tolerance=remaining_tolerance, return_error=True, logger=logger)
            except CantReduceDegreeException as e:
                raise CantReduceDegreeException(f&#34;At parallel #{i}: {e}&#34;) from e
            max_error = max(max_error, error)
            fixed_u_knotvector = fixed_u_curve.get_knotvector()
            new_v_degree = fixed_u_curve.get_degree()
            fixed_u_points = fixed_u_curve.get_control_points()
            fixed_u_weights = fixed_u_curve.get_weights()
            new_points.append(fixed_u_points)
            new_weights.append(fixed_u_weights)

        new_points = np.array(new_points)
        new_weights = np.array(new_weights)

        logger.debug(f&#34;Surface degree reduction error: {max_error}&#34;)

        return SvNurbsSurface.build(implementation,
                self.get_degree_u(), new_v_degree,
                self.get_knotvector_u(), fixed_u_knotvector,
                new_points, new_weights)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.remove_knot"><code class="name flex">
<span>def <span class="ident">remove_knot</span></span>(<span>self, direction, parameter, count=1, tolerance=None, if_possible=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_knot(self, direction, parameter, count=1, tolerance=None, if_possible=False):
    raise Exception(&#34;Not implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.split_at"><code class="name flex">
<span>def <span class="ident">split_at</span></span>(<span>self, direction, parameter)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_at(self, direction, parameter):
    if direction == SvNurbsSurface.U:
        return self.cut_u(parameter)
    elif direction == SvNurbsSurface.V:
        return self.cut_v(parameter)
    else:
        raise Exception(&#34;Unsupported direction&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.nurbs.SvNurbsSurface.swap_uv"><code class="name flex">
<span>def <span class="ident">swap_uv</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_uv(self):
    degree_u = self.get_degree_u()
    degree_v = self.get_degree_v()
    knotvector_u = self.get_knotvector_u()
    knotvector_v = self.get_knotvector_v()

    control_points = self.get_control_points()
    weights = self.get_weights()

    control_points = np.transpose(control_points, axes=(1,0,2))
    weights = weights.T

    return SvNurbsSurface.build(self.get_nurbs_implementation(),
            degree_v, degree_u,
            knotvector_v, knotvector_u,
            control_points, weights)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.surface" href="index.html">sverchok.utils.surface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.surface.nurbs.build_from_curves" href="#sverchok.utils.surface.nurbs.build_from_curves">build_from_curves</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.interpolate_nurbs_curves" href="#sverchok.utils.surface.nurbs.interpolate_nurbs_curves">interpolate_nurbs_curves</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.interpolate_nurbs_surface" href="#sverchok.utils.surface.nurbs.interpolate_nurbs_surface">interpolate_nurbs_surface</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.loft_by_binormals" href="#sverchok.utils.surface.nurbs.loft_by_binormals">loft_by_binormals</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.loft_with_tangents" href="#sverchok.utils.surface.nurbs.loft_with_tangents">loft_with_tangents</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.nurbs_birail" href="#sverchok.utils.surface.nurbs.nurbs_birail">nurbs_birail</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.nurbs_sweep" href="#sverchok.utils.surface.nurbs.nurbs_sweep">nurbs_sweep</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.nurbs_sweep_impl" href="#sverchok.utils.surface.nurbs.nurbs_sweep_impl">nurbs_sweep_impl</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.simple_loft" href="#sverchok.utils.surface.nurbs.simple_loft">simple_loft</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface">SvGeomdlSurface</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.build" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.build">build</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.build_geomdl" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.build_geomdl">build_geomdl</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.curvature_calculator" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.curvature_calculator">curvature_calculator</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.derivatives_data_array" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.derivatives_data_array">derivatives_data_array</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.derivatives_list" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.derivatives_list">derivatives_list</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.evaluate" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.evaluate_array" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.from_any_nurbs" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.from_any_nurbs">from_any_nurbs</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_coord_mode" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_coord_mode">get_coord_mode</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_degree_u" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_degree_u">get_degree_u</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_degree_v" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_degree_v">get_degree_v</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_input_orientation" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_input_orientation">get_input_orientation</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_nurbs_implementation" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_nurbs_implementation">get_nurbs_implementation</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_u_max" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_u_min" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_v_max" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.get_v_min" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.has_input_matrix" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.has_input_matrix">has_input_matrix</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.insert_knot" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.insert_knot">insert_knot</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.iso_curve" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.iso_curve">iso_curve</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.normal" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.normal">normal</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.normal_array" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.normal_array">normal_array</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.remove_knot" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.remove_knot">remove_knot</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.u_size" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvGeomdlSurface.v_size" href="#sverchok.utils.surface.nurbs.SvGeomdlSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface">SvNativeNurbsSurface</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.build" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.build">build</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.curvature_calculator" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.curvature_calculator">curvature_calculator</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.derivatives_data_array" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.derivatives_data_array">derivatives_data_array</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.evaluate" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.evaluate_array" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.fraction" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.fraction">fraction</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_degree_u" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_degree_u">get_degree_u</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_degree_v" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_degree_v">get_degree_v</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_nurbs_implementation" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_nurbs_implementation">get_nurbs_implementation</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_u_max" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_u_min" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_v_max" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_v_min" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.insert_knot" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.insert_knot">insert_knot</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.iso_curve" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.iso_curve">iso_curve</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.normal" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.normal">normal</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.normal_array" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.normal_array">normal_array</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNativeNurbsSurface.remove_knot" href="#sverchok.utils.surface.nurbs.SvNativeNurbsSurface.remove_knot">remove_knot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface" href="#sverchok.utils.surface.nurbs.SvNurbsSurface">SvNurbsSurface</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.GEOMDL" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.GEOMDL">GEOMDL</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.NATIVE" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.NATIVE">NATIVE</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.U" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.U">U</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.V" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.V">V</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.build" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.build">build</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.calc_greville_us" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.calc_greville_us">calc_greville_us</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.calc_greville_vs" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.calc_greville_vs">calc_greville_vs</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.concatenate" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.concatenate">concatenate</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.copy" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.copy">copy</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.cut_slice" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.cut_slice">cut_slice</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.cut_u" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.cut_u">cut_u</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.cut_v" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.cut_v">cut_v</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.elevate_degree" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.elevate_degree">elevate_degree</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get">get</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_control_points" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_control_points">get_control_points</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_degree_u" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_degree_u">get_degree_u</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_degree_v" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_degree_v">get_degree_v</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_homogenous_control_points" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_homogenous_control_points">get_homogenous_control_points</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_u" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_u">get_knotvector_u</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_v" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_knotvector_v">get_knotvector_v</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_continuity">get_min_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_u_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_u_continuity">get_min_u_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_v_continuity" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_min_v_continuity">get_min_v_continuity</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_nurbs_implementation" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_nurbs_implementation">get_nurbs_implementation</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.get_weights" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.get_weights">get_weights</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.insert_knot" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.insert_knot">insert_knot</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.is_rational" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.is_rational">is_rational</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.iso_curve" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.iso_curve">iso_curve</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.reduce_degree" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.reduce_degree">reduce_degree</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.remove_knot" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.remove_knot">remove_knot</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.split_at" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.split_at">split_at</a></code></li>
<li><code><a title="sverchok.utils.surface.nurbs.SvNurbsSurface.swap_uv" href="#sverchok.utils.surface.nurbs.SvNurbsSurface.swap_uv">swap_uv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>