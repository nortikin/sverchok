<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.surface.populate API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.surface.populate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#  
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

import numpy as np
import random

from mathutils.kdtree import KDTree

from sverchok.utils.sv_logging import sv_logger


def random_point(min_x, max_x, min_y, max_y):
    x = random.uniform(min_x, max_x)
    y = random.uniform(min_y, max_y)
    return x,y

def _check_min_distance(v_new, vs_old, min_r):
    kdt = KDTree(len(vs_old))
    for i, v in enumerate(vs_old):
        kdt.insert(v, i)
    kdt.balance()
    nearest, idx, dist = kdt.find(v_new)
    if dist is None:
        return True
    return (dist &gt;= min_r)

#     for v_old in vs_old:
#         distance = np.linalg.norm(v_new - v_old)
#         if distance &lt; min_r:
#             return False
#    return True

def _check_min_radius(point, old_points, old_radiuses, min_r):
    if not old_points:
        return True
    old_points = np.array(old_points)
    old_radiuses = np.array(old_radiuses)
    point = np.array(point)
    distances = np.linalg.norm(old_points - point, axis=1)
    ok = (old_radiuses + min_r &lt; distances).all()
    return ok

BATCH_SIZE = 100
MAX_ITERATIONS = 1000

def populate_surface(surface, field, count, threshold,
        proportional=False, field_min=None, field_max=None,
        min_r=0, min_r_field = None,
        random_radius = False,
        avoid_spheres = None,
        seed=0, predicate=None):
    &#34;&#34;&#34;
    Generate random points on the surface, with distribution controlled (optionally) by scalar field.

    inputs:
    * surface : SvSurface
    * field : SvScalarField. Pass None to use even (uniform) distribution.
    * count: number of points to generate.
    * threshold: do not generate points where value of scalar field is less than this value.
    * proportional: if True, then density of points will be proportional to
      scalar field value. Otherwise, values of the field will be used only to not
      generate points in places where scalar field is less than threshold.
    * field_min: (expected) minimum value of scalar field in the area of the
      surface. Mandatory if `proportional` is set to True.
    * field_max: (expected) maximum value of scalar field in the area of the
      surface. Mandatory if `proportional` is set to True.
    * min_r: minimum distance between generated points. Set to zero to disable this check.
    * seed: random generator seed value.
    * predicate: additional predicate to check if generated point is valid.
      Takes two arguments: point in UV space and the same point in 3D space.
      Optional.

    outputs: tuple:
    * Coordinates of points in surface&#39;s UV space
    * Coordinates of points in 3D space.
    &#34;&#34;&#34;
    if min_r != 0 and min_r_field is not None:
        raise Exception(&#34;min_r and min_r_field can not be specified simultaneously&#34;)

    u_min, u_max = surface.get_u_min(), surface.get_u_max()
    v_min, v_max = surface.get_v_min(), surface.get_v_max()

    if avoid_spheres is not None:
        old_points = [s[0] for s in avoid_spheres]
        old_radiuses = [s[1] for s in avoid_spheres]
    else:
        old_points = []
        old_radiuses = []

    if seed == 0:
        seed = 12345
    if seed is not None:
        random.seed(seed)
    done = 0
    generated_verts = []
    generated_uv = []
    generated_radiuses = []
    iterations = 0

    if field is None and avoid_spheres is None and min_r == 0 and min_r_field is None and predicate is None:
        batch_size = count
    else:
        batch_size = BATCH_SIZE

    while done &lt; count:
        iterations += 1
        if iterations &gt; MAX_ITERATIONS:
            sv_logger.error(&#34;Maximum number of iterations (%s) reached, stop.&#34;, MAX_ITERATIONS)
            break
        batch_us = []
        batch_vs = []
        left = count - done
        max_size = min(batch_size, left)
        for i in range(max_size):
            u = random.uniform(u_min, u_max)
            v = random.uniform(v_min, v_max)
            batch_us.append(u)
            batch_vs.append(v)
        batch_us = np.array(batch_us)
        batch_vs = np.array(batch_vs)
        batch_ws = np.zeros_like(batch_us)
        batch_uvs = np.stack((batch_us, batch_vs, batch_ws)).T

        batch_verts = surface.evaluate_array(batch_us, batch_vs)
        batch_xs = batch_verts[:,0]
        batch_ys = batch_verts[:,1]
        batch_zs = batch_verts[:,2]

        if field is not None:
            values = field.evaluate_grid(batch_xs, batch_ys, batch_zs)

            good_idxs = values &gt;= threshold
            if not proportional:
                candidates = batch_verts[good_idxs]
                candidate_uvs = batch_uvs[good_idxs]
            else:
                candidates = []
                candidate_uvs = []
                for uv, vert, value in zip(batch_uvs[good_idxs].tolist(), batch_verts[good_idxs].tolist(), values[good_idxs].tolist()):
                    probe = random.uniform(field_min, field_max)
                    if probe &lt;= value:
                        candidates.append(vert)
                        candidate_uvs.append(uv)
                candidates = np.array(candidates)
                candidate_uvs = np.array(candidate_uvs)
        else:
            candidates = batch_verts
            candidate_uvs = batch_uvs

        good_radiuses = []
        if len(candidates) &gt; 0:
            if min_r == 0 and min_r_field is None:
                good_verts = candidates.tolist()
                good_uvs = candidate_uvs.tolist()
                good_radiuses = [0 for i in range(len(good_verts))]
            elif min_r_field is not None:
                xs = np.array([p[0] for p in candidates])
                ys = np.array([p[1] for p in candidates])
                zs = np.array([p[2] for p in candidates])
                min_rs = min_r_field.evaluate_grid(xs, ys, zs).tolist()
                good_verts = []
                good_uvs = []
                for candidate_uv, candidate, min_r in zip(candidate_uvs, candidates, min_rs):
                    if random_radius:
                        min_r = random.uniform(0, min_r)
                    if _check_min_radius(candidate, old_points + generated_verts + good_verts, old_radiuses + generated_radiuses + good_radiuses, min_r):
                        good_verts.append(tuple(candidate))
                        good_uvs.append(tuple(candidate_uv))
                        good_radiuses.append(min_r)
            else: # min_r != 0
                good_verts = []
                good_uvs = []
                for candidate_uv, candidate in zip(candidate_uvs, candidates):
                    distance_ok = _check_min_distance(candidate, old_points + generated_verts + good_verts, min_r)
                    if distance_ok:
                        good_verts.append(tuple(candidate))
                        good_uvs.append(tuple(candidate_uv))
                        good_radiuses.append(0)

            if predicate is not None:
                results = [(uv, vert, radius) for uv, vert, radius in zip(good_uvs, good_verts, good_radiuses) if predicate(uv, vert)]
                good_uvs = [r[0] for r in results]
                good_verts = [r[1] for r in results]
                good_radiuses = [r[2] for r in results]

            generated_verts.extend(good_verts)
            generated_uv.extend(good_uvs)
            generated_radiuses.extend(good_radiuses)
            done += len(good_verts)

    return generated_uv, generated_verts, generated_radiuses</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.surface.populate.populate_surface"><code class="name flex">
<span>def <span class="ident">populate_surface</span></span>(<span>surface, field, count, threshold, proportional=False, field_min=None, field_max=None, min_r=0, min_r_field=None, random_radius=False, avoid_spheres=None, seed=0, predicate=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate random points on the surface, with distribution controlled (optionally) by scalar field.</p>
<p>inputs:
* surface : SvSurface
* field : SvScalarField. Pass None to use even (uniform) distribution.
* count: number of points to generate.
* threshold: do not generate points where value of scalar field is less than this value.
* proportional: if True, then density of points will be proportional to
scalar field value. Otherwise, values of the field will be used only to not
generate points in places where scalar field is less than threshold.
* field_min: (expected) minimum value of scalar field in the area of the
surface. Mandatory if <code>proportional</code> is set to True.
* field_max: (expected) maximum value of scalar field in the area of the
surface. Mandatory if <code>proportional</code> is set to True.
* min_r: minimum distance between generated points. Set to zero to disable this check.
* seed: random generator seed value.
* predicate: additional predicate to check if generated point is valid.
Takes two arguments: point in UV space and the same point in 3D space.
Optional.</p>
<p>outputs: tuple:
* Coordinates of points in surface's UV space
* Coordinates of points in 3D space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_surface(surface, field, count, threshold,
        proportional=False, field_min=None, field_max=None,
        min_r=0, min_r_field = None,
        random_radius = False,
        avoid_spheres = None,
        seed=0, predicate=None):
    &#34;&#34;&#34;
    Generate random points on the surface, with distribution controlled (optionally) by scalar field.

    inputs:
    * surface : SvSurface
    * field : SvScalarField. Pass None to use even (uniform) distribution.
    * count: number of points to generate.
    * threshold: do not generate points where value of scalar field is less than this value.
    * proportional: if True, then density of points will be proportional to
      scalar field value. Otherwise, values of the field will be used only to not
      generate points in places where scalar field is less than threshold.
    * field_min: (expected) minimum value of scalar field in the area of the
      surface. Mandatory if `proportional` is set to True.
    * field_max: (expected) maximum value of scalar field in the area of the
      surface. Mandatory if `proportional` is set to True.
    * min_r: minimum distance between generated points. Set to zero to disable this check.
    * seed: random generator seed value.
    * predicate: additional predicate to check if generated point is valid.
      Takes two arguments: point in UV space and the same point in 3D space.
      Optional.

    outputs: tuple:
    * Coordinates of points in surface&#39;s UV space
    * Coordinates of points in 3D space.
    &#34;&#34;&#34;
    if min_r != 0 and min_r_field is not None:
        raise Exception(&#34;min_r and min_r_field can not be specified simultaneously&#34;)

    u_min, u_max = surface.get_u_min(), surface.get_u_max()
    v_min, v_max = surface.get_v_min(), surface.get_v_max()

    if avoid_spheres is not None:
        old_points = [s[0] for s in avoid_spheres]
        old_radiuses = [s[1] for s in avoid_spheres]
    else:
        old_points = []
        old_radiuses = []

    if seed == 0:
        seed = 12345
    if seed is not None:
        random.seed(seed)
    done = 0
    generated_verts = []
    generated_uv = []
    generated_radiuses = []
    iterations = 0

    if field is None and avoid_spheres is None and min_r == 0 and min_r_field is None and predicate is None:
        batch_size = count
    else:
        batch_size = BATCH_SIZE

    while done &lt; count:
        iterations += 1
        if iterations &gt; MAX_ITERATIONS:
            sv_logger.error(&#34;Maximum number of iterations (%s) reached, stop.&#34;, MAX_ITERATIONS)
            break
        batch_us = []
        batch_vs = []
        left = count - done
        max_size = min(batch_size, left)
        for i in range(max_size):
            u = random.uniform(u_min, u_max)
            v = random.uniform(v_min, v_max)
            batch_us.append(u)
            batch_vs.append(v)
        batch_us = np.array(batch_us)
        batch_vs = np.array(batch_vs)
        batch_ws = np.zeros_like(batch_us)
        batch_uvs = np.stack((batch_us, batch_vs, batch_ws)).T

        batch_verts = surface.evaluate_array(batch_us, batch_vs)
        batch_xs = batch_verts[:,0]
        batch_ys = batch_verts[:,1]
        batch_zs = batch_verts[:,2]

        if field is not None:
            values = field.evaluate_grid(batch_xs, batch_ys, batch_zs)

            good_idxs = values &gt;= threshold
            if not proportional:
                candidates = batch_verts[good_idxs]
                candidate_uvs = batch_uvs[good_idxs]
            else:
                candidates = []
                candidate_uvs = []
                for uv, vert, value in zip(batch_uvs[good_idxs].tolist(), batch_verts[good_idxs].tolist(), values[good_idxs].tolist()):
                    probe = random.uniform(field_min, field_max)
                    if probe &lt;= value:
                        candidates.append(vert)
                        candidate_uvs.append(uv)
                candidates = np.array(candidates)
                candidate_uvs = np.array(candidate_uvs)
        else:
            candidates = batch_verts
            candidate_uvs = batch_uvs

        good_radiuses = []
        if len(candidates) &gt; 0:
            if min_r == 0 and min_r_field is None:
                good_verts = candidates.tolist()
                good_uvs = candidate_uvs.tolist()
                good_radiuses = [0 for i in range(len(good_verts))]
            elif min_r_field is not None:
                xs = np.array([p[0] for p in candidates])
                ys = np.array([p[1] for p in candidates])
                zs = np.array([p[2] for p in candidates])
                min_rs = min_r_field.evaluate_grid(xs, ys, zs).tolist()
                good_verts = []
                good_uvs = []
                for candidate_uv, candidate, min_r in zip(candidate_uvs, candidates, min_rs):
                    if random_radius:
                        min_r = random.uniform(0, min_r)
                    if _check_min_radius(candidate, old_points + generated_verts + good_verts, old_radiuses + generated_radiuses + good_radiuses, min_r):
                        good_verts.append(tuple(candidate))
                        good_uvs.append(tuple(candidate_uv))
                        good_radiuses.append(min_r)
            else: # min_r != 0
                good_verts = []
                good_uvs = []
                for candidate_uv, candidate in zip(candidate_uvs, candidates):
                    distance_ok = _check_min_distance(candidate, old_points + generated_verts + good_verts, min_r)
                    if distance_ok:
                        good_verts.append(tuple(candidate))
                        good_uvs.append(tuple(candidate_uv))
                        good_radiuses.append(0)

            if predicate is not None:
                results = [(uv, vert, radius) for uv, vert, radius in zip(good_uvs, good_verts, good_radiuses) if predicate(uv, vert)]
                good_uvs = [r[0] for r in results]
                good_verts = [r[1] for r in results]
                good_radiuses = [r[2] for r in results]

            generated_verts.extend(good_verts)
            generated_uv.extend(good_uvs)
            generated_radiuses.extend(good_radiuses)
            done += len(good_verts)

    return generated_uv, generated_verts, generated_radiuses</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.populate.random_point"><code class="name flex">
<span>def <span class="ident">random_point</span></span>(<span>min_x, max_x, min_y, max_y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_point(min_x, max_x, min_y, max_y):
    x = random.uniform(min_x, max_x)
    y = random.uniform(min_y, max_y)
    return x,y</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.surface" href="index.html">sverchok.utils.surface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.surface.populate.populate_surface" href="#sverchok.utils.surface.populate.populate_surface">populate_surface</a></code></li>
<li><code><a title="sverchok.utils.surface.populate.random_point" href="#sverchok.utils.surface.populate.random_point">random_point</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>