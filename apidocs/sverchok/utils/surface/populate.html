<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sverchok.utils.surface.populate API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.surface.populate</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.surface.populate.populate_surface"><code class="name flex">
<span>def <span class="ident">populate_surface</span></span>(<span>surface,<br>field,<br>count,<br>threshold,<br>proportional=False,<br>field_min=None,<br>field_max=None,<br>min_r=0,<br>min_r_field=None,<br>random_radius=False,<br>avoid_spheres=None,<br>seed=0,<br>predicate=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_surface(surface, field, count, threshold,
        proportional=False, field_min=None, field_max=None,
        min_r=0, min_r_field = None,
        random_radius = False,
        avoid_spheres = None,
        seed=0, predicate=None):
    &#34;&#34;&#34;
    Generate random points on the surface, with distribution controlled (optionally) by scalar field.

    inputs:
    * surface : SvSurface
    * field : SvScalarField. Pass None to use even (uniform) distribution.
    * count: number of points to generate.
    * threshold: do not generate points where value of scalar field is less than this value.
    * proportional: if True, then density of points will be proportional to
      scalar field value. Otherwise, values of the field will be used only to not
      generate points in places where scalar field is less than threshold.
    * field_min: (expected) minimum value of scalar field in the area of the
      surface. Mandatory if `proportional` is set to True.
    * field_max: (expected) maximum value of scalar field in the area of the
      surface. Mandatory if `proportional` is set to True.
    * min_r: minimum distance between generated points. Set to zero to disable this check.
    * seed: random generator seed value.
    * predicate: additional predicate to check if generated point is valid.
      Takes two arguments: point in UV space and the same point in 3D space.
      Optional.

    outputs: tuple:
    * Coordinates of points in surface&#39;s UV space
    * Coordinates of points in 3D space.
    &#34;&#34;&#34;
    if min_r != 0 and min_r_field is not None:
        raise ArgumentError(&#34;min_r and min_r_field can not be specified simultaneously&#34;)

    u_min, u_max = surface.get_u_min(), surface.get_u_max()
    v_min, v_max = surface.get_v_min(), surface.get_v_max()

    if avoid_spheres is not None:
        old_points = [s[0] for s in avoid_spheres]
        old_radiuses = [s[1] for s in avoid_spheres]
    else:
        old_points = []
        old_radiuses = []

    if seed == 0:
        seed = 12345
    if seed is not None:
        np.random.seed(seed)
    done = 0
    generated_verts = []
    generated_uv = []
    generated_radiuses = []
    iterations = 0

    if field is None and avoid_spheres is None and min_r == 0 and min_r_field is None and predicate is None:
        batch_size = count
    else:
        batch_size = BATCH_SIZE

    while done &lt; count:
        iterations += 1
        if iterations &gt; MAX_ITERATIONS:
            sv_logger.error(&#34;Maximum number of iterations (%s) reached, generated only %s points of %s, stop.&#34;, MAX_ITERATIONS, done, count)
            break
        batch_us = []
        batch_vs = []
        left = count - done
        max_size = min(batch_size, left)
        batch_uvs = np.random.uniform((u_min,v_min), (u_max,v_max), (max_size,2))
        batch_us = batch_uvs[:,0]
        batch_vs = batch_uvs[:,1]
        batch_ws = np.zeros_like(batch_us)
        batch_uvs = np.stack((batch_us, batch_vs, batch_ws)).T

        batch_verts = surface.evaluate_array(batch_us, batch_vs)
        batch_xs = batch_verts[:,0]
        batch_ys = batch_verts[:,1]
        batch_zs = batch_verts[:,2]

        if field is not None:
            values = field.evaluate_grid(batch_xs, batch_ys, batch_zs)

            good_idxs = values &gt;= threshold
            if not proportional:
                candidates = batch_verts[good_idxs]
                candidate_uvs = batch_uvs[good_idxs]
            else:
                probes = np.random.uniform(field_min, field_max, len(batch_verts))
                probe_idxs = probes &lt;= values
                good_idxs = np.logical_and(good_idxs, probe_idxs)
                candidates = batch_verts[good_idxs]
                candidate_uvs = batch_uvs[good_idxs]
        else:
            candidates = batch_verts
            candidate_uvs = batch_uvs

        good_radiuses = []
        if len(candidates) &gt; 0:
            if min_r == 0 and min_r_field is None:
                good_verts = candidates.tolist()
                good_uvs = candidate_uvs.tolist()
                good_radiuses = [0 for i in range(len(good_verts))]
            elif min_r_field is not None:
                xs = np.array([p[0] for p in candidates])
                ys = np.array([p[1] for p in candidates])
                zs = np.array([p[2] for p in candidates])
                min_rs = min_r_field.evaluate_grid(xs, ys, zs).tolist()
                good_verts = []
                good_uvs = []
                for candidate_uv, candidate, min_r in zip(candidate_uvs, candidates, min_rs):
                    if random_radius:
                        min_r = random.uniform(0, min_r)
                    if _check_min_radius(candidate, old_points + generated_verts + good_verts, old_radiuses + generated_radiuses + good_radiuses, min_r):
                        good_verts.append(tuple(candidate))
                        good_uvs.append(tuple(candidate_uv))
                        good_radiuses.append(min_r)
            else: # min_r != 0
                good_verts = []
                good_uvs = []
                for candidate_uv, candidate in zip(candidate_uvs, candidates):
                    distance_ok = _check_min_distance(candidate, old_points + generated_verts + good_verts, min_r)
                    if distance_ok:
                        good_verts.append(tuple(candidate))
                        good_uvs.append(tuple(candidate_uv))
                        good_radiuses.append(0)

            if predicate is not None:
                results = [(uv, vert, radius) for uv, vert, radius in zip(good_uvs, good_verts, good_radiuses) if predicate(uv, vert)]
                good_uvs = [r[0] for r in results]
                good_verts = [r[1] for r in results]
                good_radiuses = [r[2] for r in results]

            generated_verts.extend(good_verts)
            generated_uv.extend(good_uvs)
            generated_radiuses.extend(good_radiuses)
            done += len(good_verts)

    return generated_uv, generated_verts, generated_radiuses</code></pre>
</details>
<div class="desc"><p>Generate random points on the surface, with distribution controlled (optionally) by scalar field.</p>
<p>inputs:
* surface : SvSurface
* field : SvScalarField. Pass None to use even (uniform) distribution.
* count: number of points to generate.
* threshold: do not generate points where value of scalar field is less than this value.
* proportional: if True, then density of points will be proportional to
scalar field value. Otherwise, values of the field will be used only to not
generate points in places where scalar field is less than threshold.
* field_min: (expected) minimum value of scalar field in the area of the
surface. Mandatory if <code>proportional</code> is set to True.
* field_max: (expected) maximum value of scalar field in the area of the
surface. Mandatory if <code>proportional</code> is set to True.
* min_r: minimum distance between generated points. Set to zero to disable this check.
* seed: random generator seed value.
* predicate: additional predicate to check if generated point is valid.
Takes two arguments: point in UV space and the same point in 3D space.
Optional.</p>
<p>outputs: tuple:
* Coordinates of points in surface's UV space
* Coordinates of points in 3D space.</p></div>
</dd>
<dt id="sverchok.utils.surface.populate.random_point"><code class="name flex">
<span>def <span class="ident">random_point</span></span>(<span>min_x, max_x, min_y, max_y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_point(min_x, max_x, min_y, max_y):
    x = random.uniform(min_x, max_x)
    y = random.uniform(min_y, max_y)
    return x,y</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.surface" href="index.html">sverchok.utils.surface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.surface.populate.populate_surface" href="#sverchok.utils.surface.populate.populate_surface">populate_surface</a></code></li>
<li><code><a title="sverchok.utils.surface.populate.random_point" href="#sverchok.utils.surface.populate.random_point">random_point</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
