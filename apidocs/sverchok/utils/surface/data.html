<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sverchok.utils.surface.data API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.surface.data</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator"><code class="flex name class">
<span>class <span class="ident">SurfaceCurvatureCalculator</span></span>
<span>(</span><span>us, vs, order=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SurfaceCurvatureCalculator(object):
    &#34;&#34;&#34;
    This class contains pre-calculated first and second surface derivatives,
    and calculates any curvature information from them.
    &#34;&#34;&#34;
    def __init__(self, us, vs, order=True):
        self.us = us
        self.vs = vs
        self.order = order
        self.fu = self.fv = None
        self.duu = self.dvv = self.duv = None
        self.nuu = self.nvv = self.nuv = None
        self.points = None
        self.normals = None
        self._derivatives_data = None

    def set(self, points, normals, fu, fv, duu, dvv, duv, nuu, nvv, nuv):
        &#34;&#34;&#34;Set derivatives information&#34;&#34;&#34;
        self.points = points
        self.normals = normals
        self.fu = fu   # df/du
        self.fv = fv   # df/dv
        self.duu = duu # (fu, fv), a.k.a. E
        self.dvv = dvv # (fv, fv), a.k.a. G
        self.duv = duv # (fu, fv), a.k.a F
        self.nuu = nuu # (fuu, normal), a.k.a l
        self.nvv = nvv # (fvv, normal), a.k.a n
        self.nuv = nuv # (fuv, normal), a.k.a m

    @property
    def derivatives_data(self):
        if self._derivatives_data is None:
            if self.points is None or self.fu is None or self.fv is None:
                raise Exception(&#34;SurfaceCurvatureCalculator.set() was not called before call to SurfaceCurvatureCalculator.derivatives_data&#34;)
            self._derivatives_data = SurfaceDerivativesData(self.points, self.fu, self.fv)
        return self._derivatives_data

    def christoffel(self):
        U, V, W = 0,1,2
        fu = self.fu # / np.linalg.norm(self.fu, axis=1, keepdims=True)
        fv = self.fv # / np.linalg.norm(self.fv, axis=1, keepdims=True)
        normal = self.normals
        n = len(self.us)

        def solve(vec):
            A = np.zeros((n,3,3))
            A[:,:,0] = fu
            A[:,:,1] = fv
            A[:,:,2] = normal
            B = np.zeros((n,3))
            B[:] = vec
            res = np.linalg.solve(A, B) # (n, 3)
            return res.T # (3, n)

        gamma = np.zeros((2,3,3,n))
        gamma[U,U,:,:] = solve(self.fuu)
        gamma[U,V,:,:] = solve(self.fuv)
        gamma[V,U,:,:] = gamma[U,V,:,:]
        gamma[V,V,:,:] = solve(self.fvv)
        gamma[U, W, W] = gamma[U,U,U] + gamma[U,V,V]
        gamma[V, W, W] = gamma[V,U,U] + gamma[V,V,V]
        return gamma

    def mean(self):
        &#34;&#34;&#34;
        Calculate mean curvature.

        Note: although mean curvature is defined as (k1 + k2)/2, where k1 and k2 are
        principal curvature values, it is possible to calculate mean curvature without
        calculating k1 and k2 first.
        &#34;&#34;&#34;
        duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
        numerator = duu*nvv - 2*duv*nuv + dvv*nuu
        denominator = 2*(duu*dvv - duv*duv)

        curvature = np.zeros_like(numerator)
        good = (denominator != 0)
        curvature[good] = numerator[good] / denominator[good]
        return curvature

    def gauss(self):
        &#34;&#34;&#34;
        Calculate Gaussian curvature.

        Note: although Gaussian curvature is defined as k1*k2, where k1 and k2
        are principal curvature values, it is possible to calculate Gaussian
        curvature without calculating k1 and k2 first.
        &#34;&#34;&#34;
        duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
        numerator = nuu * nvv - nuv*nuv
        denominator = duu * dvv - duv*duv
        curvature = np.zeros_like(numerator)
        good = (denominator != 0)
        curvature[good] = numerator[good] / denominator[good]
        return curvature

    def curvature_along_direction(self, v1, v2):
        &#34;&#34;&#34;
        Calculate curvature value along specified direction.

        Args:
            v1, v2: coefficients in the equation v = v1*du + v2*dv, where v is
                direction in which you want to find the curvature, du is unit
                vector along df / du derivative, and dv is unit vector along df /
                dv derivative.

        Note: to calculate curvature along the direction perpendicular to (v1,v2),
        one can use formula: 2 * calc.mean() - calc.curvature_along_direction(v1, v2).
        &#34;&#34;&#34;
        v1s, v2s = v1*v1, v2*v2
        v12 = v1*v2
        l, m, n = self.nuu, self.nuv, self.nvv
        E, F, G = self.duu, self.duv, self.dvv
        numerator = l*v1s + 2*m*v12 + n*v2s
        denominator = E*v1s + 2*F*v12 + G*v2s
        return numerator / denominator

    def values(self):
        &#34;&#34;&#34;
        Calculate two principal curvature values.
        If &#34;order&#34; parameter is set to True, then it will be guaranteed,
        that k1 value is always less than k2.
        
        Note: by definition, principal curvature values are curvatures along
        principal curvature directions. But, it is possible to calculate
        principal curvature values as solutions of quadratic equation, without
        calculating corresponding principal curvature directions.
        &#34;&#34;&#34;

        # lambda^2 (E G - F^2) - lambda (E N - 2 F M + G L) + (L N - M^2) = 0

        duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
        A = duu*dvv - duv*duv
        B = duu*nvv - 2*duv*nuv + dvv*nuu
        C = nuu*nvv - nuv*nuv
        D = B*B - 4*A*C
        c1 = (-B - np.sqrt(D))/(2*A)
        c2 = (-B + np.sqrt(D))/(2*A)

        c1[np.isnan(c1)] = 0
        c2[np.isnan(c2)] = 0

        if self.order:
            c1mask = (c1 &lt; c2)
            c2mask = np.logical_not(c1mask)
            c1_r = np.where(c1mask, c1, c2)
            c2_r = np.where(c2mask, c1, c2)
            return c1_r, c2_r
        else:
            return c1, c2

    def first_fundamental_form(self):
        n = len(self.us)
        G = np.empty((n,2,2))
        G[:,0,0] = self.duu
        G[:,0,1] = self.duv
        G[:,1,0] = self.duv
        G[:,1,1] = self.dvv
        return G

    def values_and_directions(self):
        &#34;&#34;&#34;
        Calculate principal curvature values together with principal curvature directions.
        If &#34;order&#34; parameter is set to True, then it will be guaranteed, that C1 value
        is always less than C2. Curvature directions are always output correspondingly,
        i.e. principal_direction_1 corresponds to principal_value_1 and principal_direction_2
        corresponds to principal_value_2.
        &#34;&#34;&#34;
        # If we need not only curvature values, but principal curvature directions as well,
        # we have to solve an eigenvalue problem to find values and directions at once.

        # L p = lambda G p

        fu, fv = self.fu, self.fv
        duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
        n = len(self.us)

        L = np.empty((n,2,2))
        L[:,0,0] = nuu
        L[:,0,1] = nuv
        L[:,1,0] = nuv
        L[:,1,1] = nvv

        G = np.empty((n,2,2))
        G[:,0,0] = duu
        G[:,0,1] = duv
        G[:,1,0] = duv
        G[:,1,1] = dvv

        M = np.matmul(np.linalg.inv(G), L)
        eigvals, eigvecs = np.linalg.eig(M)
        # Values of first and second principal curvatures
        c1 = eigvals[:,0]
        c2 = eigvals[:,1]

        if self.order:
            c1mask = (c1 &lt; c2)
            c2mask = np.logical_not(c1mask)
            c1_r = np.where(c1mask, c1, c2)
            c2_r = np.where(c2mask, c1, c2)
        else:
            c1_r = c1
            c2_r = c2

        # dir_1 corresponds to c1, dir_2 corresponds to c2
        dir_1_x = eigvecs[:,0,0][np.newaxis].T
        dir_2_x = eigvecs[:,0,1][np.newaxis].T
        dir_1_y = eigvecs[:,1,0][np.newaxis].T
        dir_2_y = eigvecs[:,1,1][np.newaxis].T

        # another possible approach
#         A = duv * nvv - dvv*nuv 
#         B = duu * nvv - dvv*nuu
#         C = duu*nuv - duv*nuu
#         D = B*B - 4*A*C
#         t1 = (-B - np.sqrt(D)) / (2*A)
#         t2 = (-B + np.sqrt(D)) / (2*A)

        dir_1 = dir_1_x * fu + dir_1_y * fv
        dir_2 = dir_2_x * fu + dir_2_y * fv

        dir_1 = dir_1 / np.linalg.norm(dir_1, axis=1, keepdims=True)
        dir_2 = dir_2 / np.linalg.norm(dir_2, axis=1, keepdims=True)

        if self.order:
            c1maskT = c1mask[np.newaxis].T
            c2maskT = c2mask[np.newaxis].T
            dir_1_r = np.where(c1maskT, dir_1, -dir_2)
            dir_2_r = np.where(c2maskT, dir_1, dir_2)
        else:
            dir_1_r = dir_1
            dir_2_r = dir_2
        #r = (np.cross(dir_1_r, dir_2_r) * self.normals).sum(axis=1)
        #print(r)

        dir1_uv = eigvecs[:,:,0]
        dir2_uv = eigvecs[:,:,1]
        if self.order:
            c1maskT = c1mask[np.newaxis].T
            c2maskT = c2mask[np.newaxis].T
            dir1_uv_r = np.where(c1maskT, dir1_uv, -dir2_uv)
            dir2_uv_r = np.where(c2maskT, dir1_uv, dir2_uv)
        else:
            dir1_uv_r = dir1_uv
            dir2_uv_r = dir2_uv
            
        return c1_r, c2_r, dir1_uv_r, dir2_uv_r, dir_1_r, dir_2_r

    def calc(self, need_values=True, need_directions=True, need_uv_directions = False, need_gauss=True, need_mean=True, need_matrix = True):
        &#34;&#34;&#34;
        Calculate curvature information.
        Return value: SurfaceCurvatureData instance.
        &#34;&#34;&#34;
        # We try to do as less calculations as possible,
        # by not doing complex computations if not required
        # and reusing results of other computations if possible.
        data = SurfaceCurvatureData()
        if need_matrix:
            need_directions = True
        if need_uv_directions:
            need_directions = True
        if need_directions:
            # If we need principal curvature directions, then the method
            # being used will calculate us curvature values for free.
            c1, c2, dir1_uv, dir2_uv, dir1, dir2 = self.values_and_directions()
            data.principal_value_1, data.principal_value_2 = c1, c2
            data.principal_direction_1, data.principal_direction_2 = dir1, dir2
            data.principal_direction_1_uv = dir1_uv
            data.principal_direction_2_uv = dir2_uv
            if need_gauss:
                data.gauss = c1 * c2
            if need_mean:
                data.mean = (c1 + c2)/2.0
        if need_matrix:
            matrices_np = np.dstack((data.principal_direction_2, data.principal_direction_1, self.normals))
            matrices_np = np.transpose(matrices_np, axes=(0,2,1))
            matrices_np = np.linalg.inv(matrices_np)
            matrices = [Matrix(m.tolist()).to_4x4() for m in matrices_np]
            for matrix, point in zip(matrices, self.points):
                matrix.translation = Vector(point)
            data.matrix = matrices
        if need_values and not need_directions:
            c1, c2 = self.values()
            data.principal_value_1, data.principal_value_2 = c1, c2
            if need_gauss:
                data.gauss = c1 * c2
            if need_mean:
                data.mean = (c1 + c2)/2.0
        if need_gauss and not need_directions and not need_values:
            data.gauss = self.gauss()
        if need_mean and not need_directions and not need_values:
            data.mean = self.mean()
        return data</code></pre>
</details>
<div class="desc"><p>This class contains pre-calculated first and second surface derivatives,
and calculates any curvature information from them.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.derivatives_data"><code class="name">prop <span class="ident">derivatives_data</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def derivatives_data(self):
    if self._derivatives_data is None:
        if self.points is None or self.fu is None or self.fv is None:
            raise Exception(&#34;SurfaceCurvatureCalculator.set() was not called before call to SurfaceCurvatureCalculator.derivatives_data&#34;)
        self._derivatives_data = SurfaceDerivativesData(self.points, self.fu, self.fv)
    return self._derivatives_data</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.calc"><code class="name flex">
<span>def <span class="ident">calc</span></span>(<span>self,<br>need_values=True,<br>need_directions=True,<br>need_uv_directions=False,<br>need_gauss=True,<br>need_mean=True,<br>need_matrix=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc(self, need_values=True, need_directions=True, need_uv_directions = False, need_gauss=True, need_mean=True, need_matrix = True):
    &#34;&#34;&#34;
    Calculate curvature information.
    Return value: SurfaceCurvatureData instance.
    &#34;&#34;&#34;
    # We try to do as less calculations as possible,
    # by not doing complex computations if not required
    # and reusing results of other computations if possible.
    data = SurfaceCurvatureData()
    if need_matrix:
        need_directions = True
    if need_uv_directions:
        need_directions = True
    if need_directions:
        # If we need principal curvature directions, then the method
        # being used will calculate us curvature values for free.
        c1, c2, dir1_uv, dir2_uv, dir1, dir2 = self.values_and_directions()
        data.principal_value_1, data.principal_value_2 = c1, c2
        data.principal_direction_1, data.principal_direction_2 = dir1, dir2
        data.principal_direction_1_uv = dir1_uv
        data.principal_direction_2_uv = dir2_uv
        if need_gauss:
            data.gauss = c1 * c2
        if need_mean:
            data.mean = (c1 + c2)/2.0
    if need_matrix:
        matrices_np = np.dstack((data.principal_direction_2, data.principal_direction_1, self.normals))
        matrices_np = np.transpose(matrices_np, axes=(0,2,1))
        matrices_np = np.linalg.inv(matrices_np)
        matrices = [Matrix(m.tolist()).to_4x4() for m in matrices_np]
        for matrix, point in zip(matrices, self.points):
            matrix.translation = Vector(point)
        data.matrix = matrices
    if need_values and not need_directions:
        c1, c2 = self.values()
        data.principal_value_1, data.principal_value_2 = c1, c2
        if need_gauss:
            data.gauss = c1 * c2
        if need_mean:
            data.mean = (c1 + c2)/2.0
    if need_gauss and not need_directions and not need_values:
        data.gauss = self.gauss()
    if need_mean and not need_directions and not need_values:
        data.mean = self.mean()
    return data</code></pre>
</details>
<div class="desc"><p>Calculate curvature information.
Return value: SurfaceCurvatureData instance.</p></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.christoffel"><code class="name flex">
<span>def <span class="ident">christoffel</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def christoffel(self):
    U, V, W = 0,1,2
    fu = self.fu # / np.linalg.norm(self.fu, axis=1, keepdims=True)
    fv = self.fv # / np.linalg.norm(self.fv, axis=1, keepdims=True)
    normal = self.normals
    n = len(self.us)

    def solve(vec):
        A = np.zeros((n,3,3))
        A[:,:,0] = fu
        A[:,:,1] = fv
        A[:,:,2] = normal
        B = np.zeros((n,3))
        B[:] = vec
        res = np.linalg.solve(A, B) # (n, 3)
        return res.T # (3, n)

    gamma = np.zeros((2,3,3,n))
    gamma[U,U,:,:] = solve(self.fuu)
    gamma[U,V,:,:] = solve(self.fuv)
    gamma[V,U,:,:] = gamma[U,V,:,:]
    gamma[V,V,:,:] = solve(self.fvv)
    gamma[U, W, W] = gamma[U,U,U] + gamma[U,V,V]
    gamma[V, W, W] = gamma[V,U,U] + gamma[V,V,V]
    return gamma</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.curvature_along_direction"><code class="name flex">
<span>def <span class="ident">curvature_along_direction</span></span>(<span>self, v1, v2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curvature_along_direction(self, v1, v2):
    &#34;&#34;&#34;
    Calculate curvature value along specified direction.

    Args:
        v1, v2: coefficients in the equation v = v1*du + v2*dv, where v is
            direction in which you want to find the curvature, du is unit
            vector along df / du derivative, and dv is unit vector along df /
            dv derivative.

    Note: to calculate curvature along the direction perpendicular to (v1,v2),
    one can use formula: 2 * calc.mean() - calc.curvature_along_direction(v1, v2).
    &#34;&#34;&#34;
    v1s, v2s = v1*v1, v2*v2
    v12 = v1*v2
    l, m, n = self.nuu, self.nuv, self.nvv
    E, F, G = self.duu, self.duv, self.dvv
    numerator = l*v1s + 2*m*v12 + n*v2s
    denominator = E*v1s + 2*F*v12 + G*v2s
    return numerator / denominator</code></pre>
</details>
<div class="desc"><p>Calculate curvature value along specified direction.</p>
<h2 id="args">Args</h2>
<p>v1, v2: coefficients in the equation v = v1<em>du + v2</em>dv, where v is
direction in which you want to find the curvature, du is unit
vector along df / du derivative, and dv is unit vector along df /
dv derivative.
Note: to calculate curvature along the direction perpendicular to (v1,v2),
one can use formula: 2 * calc.mean() - calc.curvature_along_direction(v1, v2).</p></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.first_fundamental_form"><code class="name flex">
<span>def <span class="ident">first_fundamental_form</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_fundamental_form(self):
    n = len(self.us)
    G = np.empty((n,2,2))
    G[:,0,0] = self.duu
    G[:,0,1] = self.duv
    G[:,1,0] = self.duv
    G[:,1,1] = self.dvv
    return G</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.gauss"><code class="name flex">
<span>def <span class="ident">gauss</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gauss(self):
    &#34;&#34;&#34;
    Calculate Gaussian curvature.

    Note: although Gaussian curvature is defined as k1*k2, where k1 and k2
    are principal curvature values, it is possible to calculate Gaussian
    curvature without calculating k1 and k2 first.
    &#34;&#34;&#34;
    duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
    numerator = nuu * nvv - nuv*nuv
    denominator = duu * dvv - duv*duv
    curvature = np.zeros_like(numerator)
    good = (denominator != 0)
    curvature[good] = numerator[good] / denominator[good]
    return curvature</code></pre>
</details>
<div class="desc"><p>Calculate Gaussian curvature.</p>
<p>Note: although Gaussian curvature is defined as k1*k2, where k1 and k2
are principal curvature values, it is possible to calculate Gaussian
curvature without calculating k1 and k2 first.</p></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    &#34;&#34;&#34;
    Calculate mean curvature.

    Note: although mean curvature is defined as (k1 + k2)/2, where k1 and k2 are
    principal curvature values, it is possible to calculate mean curvature without
    calculating k1 and k2 first.
    &#34;&#34;&#34;
    duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
    numerator = duu*nvv - 2*duv*nuv + dvv*nuu
    denominator = 2*(duu*dvv - duv*duv)

    curvature = np.zeros_like(numerator)
    good = (denominator != 0)
    curvature[good] = numerator[good] / denominator[good]
    return curvature</code></pre>
</details>
<div class="desc"><p>Calculate mean curvature.</p>
<p>Note: although mean curvature is defined as (k1 + k2)/2, where k1 and k2 are
principal curvature values, it is possible to calculate mean curvature without
calculating k1 and k2 first.</p></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, points, normals, fu, fv, duu, dvv, duv, nuu, nvv, nuv)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, points, normals, fu, fv, duu, dvv, duv, nuu, nvv, nuv):
    &#34;&#34;&#34;Set derivatives information&#34;&#34;&#34;
    self.points = points
    self.normals = normals
    self.fu = fu   # df/du
    self.fv = fv   # df/dv
    self.duu = duu # (fu, fv), a.k.a. E
    self.dvv = dvv # (fv, fv), a.k.a. G
    self.duv = duv # (fu, fv), a.k.a F
    self.nuu = nuu # (fuu, normal), a.k.a l
    self.nvv = nvv # (fvv, normal), a.k.a n
    self.nuv = nuv # (fuv, normal), a.k.a m</code></pre>
</details>
<div class="desc"><p>Set derivatives information</p></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34;
    Calculate two principal curvature values.
    If &#34;order&#34; parameter is set to True, then it will be guaranteed,
    that k1 value is always less than k2.
    
    Note: by definition, principal curvature values are curvatures along
    principal curvature directions. But, it is possible to calculate
    principal curvature values as solutions of quadratic equation, without
    calculating corresponding principal curvature directions.
    &#34;&#34;&#34;

    # lambda^2 (E G - F^2) - lambda (E N - 2 F M + G L) + (L N - M^2) = 0

    duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
    A = duu*dvv - duv*duv
    B = duu*nvv - 2*duv*nuv + dvv*nuu
    C = nuu*nvv - nuv*nuv
    D = B*B - 4*A*C
    c1 = (-B - np.sqrt(D))/(2*A)
    c2 = (-B + np.sqrt(D))/(2*A)

    c1[np.isnan(c1)] = 0
    c2[np.isnan(c2)] = 0

    if self.order:
        c1mask = (c1 &lt; c2)
        c2mask = np.logical_not(c1mask)
        c1_r = np.where(c1mask, c1, c2)
        c2_r = np.where(c2mask, c1, c2)
        return c1_r, c2_r
    else:
        return c1, c2</code></pre>
</details>
<div class="desc"><p>Calculate two principal curvature values.
If "order" parameter is set to True, then it will be guaranteed,
that k1 value is always less than k2.</p>
<p>Note: by definition, principal curvature values are curvatures along
principal curvature directions. But, it is possible to calculate
principal curvature values as solutions of quadratic equation, without
calculating corresponding principal curvature directions.</p></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureCalculator.values_and_directions"><code class="name flex">
<span>def <span class="ident">values_and_directions</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def values_and_directions(self):
        &#34;&#34;&#34;
        Calculate principal curvature values together with principal curvature directions.
        If &#34;order&#34; parameter is set to True, then it will be guaranteed, that C1 value
        is always less than C2. Curvature directions are always output correspondingly,
        i.e. principal_direction_1 corresponds to principal_value_1 and principal_direction_2
        corresponds to principal_value_2.
        &#34;&#34;&#34;
        # If we need not only curvature values, but principal curvature directions as well,
        # we have to solve an eigenvalue problem to find values and directions at once.

        # L p = lambda G p

        fu, fv = self.fu, self.fv
        duu, dvv, duv, nuu, nvv, nuv = self.duu, self.dvv, self.duv, self.nuu, self.nvv, self.nuv
        n = len(self.us)

        L = np.empty((n,2,2))
        L[:,0,0] = nuu
        L[:,0,1] = nuv
        L[:,1,0] = nuv
        L[:,1,1] = nvv

        G = np.empty((n,2,2))
        G[:,0,0] = duu
        G[:,0,1] = duv
        G[:,1,0] = duv
        G[:,1,1] = dvv

        M = np.matmul(np.linalg.inv(G), L)
        eigvals, eigvecs = np.linalg.eig(M)
        # Values of first and second principal curvatures
        c1 = eigvals[:,0]
        c2 = eigvals[:,1]

        if self.order:
            c1mask = (c1 &lt; c2)
            c2mask = np.logical_not(c1mask)
            c1_r = np.where(c1mask, c1, c2)
            c2_r = np.where(c2mask, c1, c2)
        else:
            c1_r = c1
            c2_r = c2

        # dir_1 corresponds to c1, dir_2 corresponds to c2
        dir_1_x = eigvecs[:,0,0][np.newaxis].T
        dir_2_x = eigvecs[:,0,1][np.newaxis].T
        dir_1_y = eigvecs[:,1,0][np.newaxis].T
        dir_2_y = eigvecs[:,1,1][np.newaxis].T

        # another possible approach
#         A = duv * nvv - dvv*nuv 
#         B = duu * nvv - dvv*nuu
#         C = duu*nuv - duv*nuu
#         D = B*B - 4*A*C
#         t1 = (-B - np.sqrt(D)) / (2*A)
#         t2 = (-B + np.sqrt(D)) / (2*A)

        dir_1 = dir_1_x * fu + dir_1_y * fv
        dir_2 = dir_2_x * fu + dir_2_y * fv

        dir_1 = dir_1 / np.linalg.norm(dir_1, axis=1, keepdims=True)
        dir_2 = dir_2 / np.linalg.norm(dir_2, axis=1, keepdims=True)

        if self.order:
            c1maskT = c1mask[np.newaxis].T
            c2maskT = c2mask[np.newaxis].T
            dir_1_r = np.where(c1maskT, dir_1, -dir_2)
            dir_2_r = np.where(c2maskT, dir_1, dir_2)
        else:
            dir_1_r = dir_1
            dir_2_r = dir_2
        #r = (np.cross(dir_1_r, dir_2_r) * self.normals).sum(axis=1)
        #print(r)

        dir1_uv = eigvecs[:,:,0]
        dir2_uv = eigvecs[:,:,1]
        if self.order:
            c1maskT = c1mask[np.newaxis].T
            c2maskT = c2mask[np.newaxis].T
            dir1_uv_r = np.where(c1maskT, dir1_uv, -dir2_uv)
            dir2_uv_r = np.where(c2maskT, dir1_uv, dir2_uv)
        else:
            dir1_uv_r = dir1_uv
            dir2_uv_r = dir2_uv
            
        return c1_r, c2_r, dir1_uv_r, dir2_uv_r, dir_1_r, dir_2_r</code></pre>
</details>
<div class="desc"><p>Calculate principal curvature values together with principal curvature directions.
If "order" parameter is set to True, then it will be guaranteed, that C1 value
is always less than C2. Curvature directions are always output correspondingly,
i.e. principal_direction_1 corresponds to principal_value_1 and principal_direction_2
corresponds to principal_value_2.</p></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceCurvatureData"><code class="flex name class">
<span>class <span class="ident">SurfaceCurvatureData</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SurfaceCurvatureData(object):
    &#34;&#34;&#34;Container class for calculated curvature values&#34;&#34;&#34;
    def __init__(self):
        self.principal_value_1 = self.principal_value_2 = None
        self.principal_direction_1 = self.principal_direction_2 = None
        self.principal_direction_1_uv = self.principal_direction_2_uv = None
        self.mean = self.gauss = None
        self.matrix = None</code></pre>
</details>
<div class="desc"><p>Container class for calculated curvature values</p></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData"><code class="flex name class">
<span>class <span class="ident">SurfaceDerivativesData</span></span>
<span>(</span><span>points, du, dv)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SurfaceDerivativesData(object):
    def __init__(self, points, du, dv):
        self.points = points
        self.du = du
        self.dv = dv
        self._normals = None
        self._normals_len = None
        self._unit_normals = None
        self._unit_du = None
        self._unit_dv = None
        self._du_len = self._dv_len = None

    def normals(self):
        if self._normals is None:
            self._normals = np.cross(self.du, self.dv)
        return self._normals

    def normals_len(self):
        if self._normals_len is None:
            normals = self.normals()
            self._normals_len = np.linalg.norm(normals, axis=1)[np.newaxis].T
        return self._normals_len

    def unit_normals(self):
        if self._unit_normals is None:
            normals = self.normals()
            norm = self.normals_len()
            self._unit_normals = normals / norm
        return self._unit_normals

    def tangent_lens(self, keepdims=True):
        if self._du_len is None:
            self._du_len = np.linalg.norm(self.du, axis=1, keepdims=True)
            self._dv_len = np.linalg.norm(self.dv, axis=1, keepdims=True)
        return self._du_len, self._dv_len

    def unit_tangents(self):
        if self._unit_du is None:
            du_norm, dv_norm = self.tangent_lens()
            self._unit_du = self.du / du_norm
            self._unit_dv = self.dv / dv_norm
        return self._unit_du, self._unit_dv

    def matrices(self, as_mathutils = False):
        normals = self.unit_normals()
        du, dv = self.unit_tangents()
        matrices_np = np.dstack((du, dv, normals))
        if as_mathutils:
            matrices = [Matrix(m.tolist()).to_4x4() for m in matrices_np]
            for m, p in zip(matrices, self.points):
                m.translation = Vector(p)
            return matrices
        else:
            return matrices_np

    def tangents_in_direction(self, uv_directions, w_axis=2):
        if w_axis == 2:
            U, V = 0, 1
        elif w_axis == 1:
            U, V = 0, 2
        else:
            U, V = 1, 2
        d_u = uv_directions[:,U][np.newaxis].T
        d_v = uv_directions[:,V][np.newaxis].T
        return self.du * d_u + self.dv * d_v</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData.matrices"><code class="name flex">
<span>def <span class="ident">matrices</span></span>(<span>self, as_mathutils=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrices(self, as_mathutils = False):
    normals = self.unit_normals()
    du, dv = self.unit_tangents()
    matrices_np = np.dstack((du, dv, normals))
    if as_mathutils:
        matrices = [Matrix(m.tolist()).to_4x4() for m in matrices_np]
        for m, p in zip(matrices, self.points):
            m.translation = Vector(p)
        return matrices
    else:
        return matrices_np</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData.normals"><code class="name flex">
<span>def <span class="ident">normals</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normals(self):
    if self._normals is None:
        self._normals = np.cross(self.du, self.dv)
    return self._normals</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData.normals_len"><code class="name flex">
<span>def <span class="ident">normals_len</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normals_len(self):
    if self._normals_len is None:
        normals = self.normals()
        self._normals_len = np.linalg.norm(normals, axis=1)[np.newaxis].T
    return self._normals_len</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData.tangent_lens"><code class="name flex">
<span>def <span class="ident">tangent_lens</span></span>(<span>self, keepdims=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tangent_lens(self, keepdims=True):
    if self._du_len is None:
        self._du_len = np.linalg.norm(self.du, axis=1, keepdims=True)
        self._dv_len = np.linalg.norm(self.dv, axis=1, keepdims=True)
    return self._du_len, self._dv_len</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData.tangents_in_direction"><code class="name flex">
<span>def <span class="ident">tangents_in_direction</span></span>(<span>self, uv_directions, w_axis=2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tangents_in_direction(self, uv_directions, w_axis=2):
    if w_axis == 2:
        U, V = 0, 1
    elif w_axis == 1:
        U, V = 0, 2
    else:
        U, V = 1, 2
    d_u = uv_directions[:,U][np.newaxis].T
    d_v = uv_directions[:,V][np.newaxis].T
    return self.du * d_u + self.dv * d_v</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData.unit_normals"><code class="name flex">
<span>def <span class="ident">unit_normals</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_normals(self):
    if self._unit_normals is None:
        normals = self.normals()
        norm = self.normals_len()
        self._unit_normals = normals / norm
    return self._unit_normals</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.data.SurfaceDerivativesData.unit_tangents"><code class="name flex">
<span>def <span class="ident">unit_tangents</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_tangents(self):
    if self._unit_du is None:
        du_norm, dv_norm = self.tangent_lens()
        self._unit_du = self.du / du_norm
        self._unit_dv = self.dv / dv_norm
    return self._unit_du, self._unit_dv</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.surface" href="index.html">sverchok.utils.surface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator">SurfaceCurvatureCalculator</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.calc" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.calc">calc</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.christoffel" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.christoffel">christoffel</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.curvature_along_direction" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.curvature_along_direction">curvature_along_direction</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.derivatives_data" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.derivatives_data">derivatives_data</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.first_fundamental_form" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.first_fundamental_form">first_fundamental_form</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.gauss" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.gauss">gauss</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.mean" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.mean">mean</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.set" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.set">set</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.values" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.values">values</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceCurvatureCalculator.values_and_directions" href="#sverchok.utils.surface.data.SurfaceCurvatureCalculator.values_and_directions">values_and_directions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.data.SurfaceCurvatureData" href="#sverchok.utils.surface.data.SurfaceCurvatureData">SurfaceCurvatureData</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData" href="#sverchok.utils.surface.data.SurfaceDerivativesData">SurfaceDerivativesData</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData.matrices" href="#sverchok.utils.surface.data.SurfaceDerivativesData.matrices">matrices</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData.normals" href="#sverchok.utils.surface.data.SurfaceDerivativesData.normals">normals</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData.normals_len" href="#sverchok.utils.surface.data.SurfaceDerivativesData.normals_len">normals_len</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData.tangent_lens" href="#sverchok.utils.surface.data.SurfaceDerivativesData.tangent_lens">tangent_lens</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData.tangents_in_direction" href="#sverchok.utils.surface.data.SurfaceDerivativesData.tangents_in_direction">tangents_in_direction</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData.unit_normals" href="#sverchok.utils.surface.data.SurfaceDerivativesData.unit_normals">unit_normals</a></code></li>
<li><code><a title="sverchok.utils.surface.data.SurfaceDerivativesData.unit_tangents" href="#sverchok.utils.surface.data.SurfaceDerivativesData.unit_tangents">unit_tangents</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
