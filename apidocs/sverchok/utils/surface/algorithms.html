<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sverchok.utils.surface.algorithms API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.surface.algorithms</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of project Sverchok. It&#39;s copyrighted by the contributors
# recorded in the version control history of the file, available from
# its original location https://github.com/nortikin/sverchok/commit/master
#  
# SPDX-License-Identifier: GPL3
# License-Filename: LICENSE

from math import pi, cos, sin
from collections import defaultdict

from mathutils import Matrix, Vector


from sverchok.utils.math import (
        ZERO, FRENET, HOUSEHOLDER, TRACK, DIFF, TRACK_NORMAL,
        np_dot
    )
from sverchok.utils.geom import (
        LineEquation, CircleEquation3D, PlaneEquation,
        rotate_vector_around_vector, rotate_vector_around_vector_np,
        autorotate_householder, autorotate_track, autorotate_diff,
        center, linear_approximation
    )
from sverchok.utils.curve.core import UnsupportedCurveTypeException
from sverchok.utils.curve.primitives import SvCircle
from sverchok.utils.curve import knotvector as sv_knotvector
from sverchok.utils.curve.algorithms import (
            SvNormalTrack, curve_frame_on_surface_array,
            MathutilsRotationCalculator, DifferentialRotationCalculator,
            reparametrize_curve
        )
from sverchok.utils.surface.core import SvSurface, UnsupportedSurfaceTypeException
from sverchok.utils.surface.nurbs import SvNurbsSurface
from sverchok.utils.surface.data import *
from sverchok.utils.nurbs_common import SvNurbsBasisFunctions, SvNurbsMaths
from sverchok.utils.sv_logging import sv_logger


class SvInterpolatingSurface(SvSurface):
    __description__ = &#34;Interpolating&#34;

    def __init__(self, u_bounds, v_bounds, u_spline_constructor, v_splines, reparametrize_v_splines=True):
        if reparametrize_v_splines:
            self.v_splines = [reparametrize_curve(spline) for spline in v_splines]
        else:
            for spline in v_splines:
                m,M = spline.get_u_bounds()
                if m != 0.0 or M != 1.0:
                    raise Exception(&#34;one of splines has to be reparametrized&#34;)
            self.v_splines = v_splines
        self.u_spline_constructor = u_spline_constructor
        self.u_bounds = u_bounds
        self.v_bounds = v_bounds

        # Caches
        # v -&gt; Spline
        self._u_splines = {}
        # (u,v) -&gt; vertex
        self._eval_cache = {}
        # (u,v) -&gt; normal
        self._normal_cache = {}

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]
        #v = 0.0
        #verts = [spline.evaluate(v) for spline in self.v_splines]
        #return self.get_u_spline(v, verts).u_size

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]
        #return self.v_splines[0].v_size

    def get_u_spline(self, v, vertices):
        &#34;&#34;&#34;Get a spline along U direction for specified value of V coordinate&#34;&#34;&#34;
        spline = self._u_splines.get(v, None)
        if spline is not None:
            return spline
        else:
            spline = self.u_spline_constructor(vertices)
            self._u_splines[v] = spline
            return spline

    def _evaluate(self, u, v):
        spline_vertices = []
        for spline in self.v_splines:
            point = spline.evaluate(v)
            spline_vertices.append(point)
        #spline_vertices = [spline.evaluate(v) for spline in self.v_splines]
        u_spline = self.get_u_spline(v, spline_vertices)
        result = u_spline.evaluate(u)
        return result

    def evaluate(self, u, v):
        result = self._eval_cache.get((u,v), None)
        if result is not None:
            return result
        else:
            result = self._evaluate(u, v)
            self._eval_cache[(u,v)] = result
            return result

#     def evaluate_array(self, us, vs):
#         # FIXME: To be optimized!
#         normals = [self._evaluate(u, v) for u,v in zip(us, vs)]
#         return np.array(normals)

    def evaluate_array(self, us, vs):
        result = np.empty((len(us), 3))
        v_to_u = defaultdict(list)
        v_to_i = defaultdict(list)
        for i, (u, v) in enumerate(zip(us, vs)):
            v_to_u[v].append(u)
            v_to_i[v].append(i)

        # here we rely on fact that in Python 3.7+ dicts are ordered.
        all_vs = np.array(list(v_to_u.keys()))
        v_spline_points = np.array([spline.evaluate_array(all_vs) for spline in self.v_splines])

        for v_idx, (v, us_by_v) in enumerate(v_to_u.items()):
            is_by_v = v_to_i[v]
            spline_vertices = []
            for spline_idx, spline in enumerate(self.v_splines):
                point = v_spline_points[spline_idx,v_idx]
                #point = spline.evaluate(v)
                spline_vertices.append(point)
            u_spline = self.get_u_spline(v, spline_vertices)
            points = u_spline.evaluate_array(np.array(us_by_v))
            idxs = np.array(is_by_v)[np.newaxis].T
            np.put_along_axis(result, idxs, points, axis=0)
        return result

    def _normal(self, u, v):
        h = 0.001
        point = self.evaluate(u, v)
        # we know this exists because it was filled in evaluate()
        u_spline = self._u_splines[v]
        u_tangent = u_spline.tangent(u)
        point_v = self.evaluate(u, v+h)
        dv = (point_v - point)/h
        n = np.cross(u_tangent, dv)
        norm = np.linalg.norm(n)
        if norm != 0:
            n = n / norm
        return n

    def normal(self, u, v):
        result = self._normal_cache.get((u,v), None)
        if result is not None:
            return result
        else:
            result = self._normal(u, v)
            self._normal_cache[(u,v)] = result
            return result

#     def normal_array(self, us, vs):
#         # FIXME: To be optimized!
#         normals = [self._normal(u, v) for u,v in zip(us, vs)]
#         return np.array(normals)

    def normal_vertices_array(self, us, vs):
        h = 1e-4 # (np.array([1], dtype=np.float64)/100000000)[0] # 0.0001 One can use float64 of numpy. Blender float relax now. ))) 1e-8 is a diameter of hydrogen atom.
        _points         = np.empty( (0, 3), dtype=np.float64)
        _points_u_h     = np.empty( (0, 3), dtype=np.float64)
        _points_v_h     = np.empty( (0, 3), dtype=np.float64)
        v_to_u = defaultdict(list)
        v_to_i = defaultdict(list)
        for i, (u, v) in enumerate(zip(us, vs)):
            v_to_u[v].append(u)
            v_to_i[v].append(i)
        v_to_i_flatten = np.hstack(np.array( list(v_to_i.values())).flatten())

        list_spline_v = []
        list_spline_h = []
        _v = np.array( list(v_to_u.keys()), dtype=np.float64 )
        # A remark about a reverse. Algorithm cannot calc vectors out of a surface.
        # So calc that vectors in a reverse direction into the surface then reverse that vectors.
        # TODO: need attention for case - may be do %uv_bounds if uv coords are circled?
        # Here is no params about this for a while. So use reverse.
        for i_spline, v_spline in enumerate(self.v_splines):
            v_min, v_max = v_spline.get_u_bounds()
            _vx = (v_max-v_min)*_v+v_min
            _list_v_i = _vx
            _list_h_i = np.where( _vx+h&lt;=v_max, _vx+h, _vx-h ) # if need point out of surface then do step in reverse direction
            list_spline_v.append( _list_v_i )
            list_spline_h.append( _list_h_i )

        r_v = []
        r_h = []
        for i, v_spline in enumerate(self.v_splines):
            _r_v, _r_h = v_spline.evaluate_array( np.concatenate( (list_spline_v[i], list_spline_h[i]) )).reshape(2,-1,3) # to increase performance for one call
            r_v.append( _r_v )
            r_h.append( _r_h )

        u_min, u_max = 0.0, 1.0
        
        for i_on_spline, (v, _us_by_v) in enumerate(v_to_u.items()):
            us_by_v = np.array(_us_by_v)
            spline_vertices = []
            spline_vertices_h = []

            for i_spline, v_spline in enumerate(self.v_splines):
                point_v = r_v[i_spline][i_on_spline]
                point_h = r_h[i_spline][i_on_spline]
                spline_vertices.append(point_v)
                spline_vertices_h.append(point_h)

            u_spline   = self.get_u_spline(v  , spline_vertices  )
            if v+h &lt;= v_max:
                u_spline_h = self.get_u_spline(v+h, spline_vertices_h)
            else:
                # curve for reversed vertices
                u_spline_h = self.get_u_spline(v-h, spline_vertices_h)

            us_v = us_by_v
            not_reversed_us = us_by_v + h &lt;= u_max
            us_h_gb = np.where( not_reversed_us, us_by_v+h, us_by_v-h )

            points, points_u_h = u_spline.evaluate_array( np.concatenate( (us_v, us_h_gb) ) ).reshape(2,-1,3) # to increase performance for one call
            points_u_h = np.where( not_reversed_us.T[:,np.newaxis], points_u_h, -(points_u_h-points)+points) # reverse some vectors in u direction
            points_v_h = u_spline_h.evaluate_array(us_by_v)
            _points     = np.concatenate( (_points, points) )
            _points_u_h = np.concatenate( (_points_u_h, points_u_h) )
            if v+h &lt;= v_max:
                _points_v_h = np.concatenate( (_points_v_h, points_v_h) )
            else:
                # reverse points if curve is reversed
                _points_v_h = np.concatenate( (_points_v_h, -(points_v_h-points)+points) ) # reverse some vectors in v direction

        _dvs = (_points_v_h - _points)/h
        _dus = (_points_u_h - _points)/h
        _normals = np.cross(_dus, _dvs)
        _norms = np.linalg.norm(_normals, axis=1, keepdims=True)
        _normals = _normals / _norms
        _result_normals = _normals[np.argsort(v_to_i_flatten)]
        _result_point = _points[np.argsort(v_to_i_flatten)]
        return _result_normals, _result_point

PROJECT = &#39;project&#39;
COPROJECT = &#39;coproject&#39;

def _dot(vs1, vs2):
    return (vs1 * vs2).sum(axis=1)[np.newaxis].T

class SvDeformedByFieldSurface(SvSurface):
    def __init__(self, surface, field, coefficient=1.0, by_normal=None):
        self.surface = surface
        self.field = field
        self.coefficient = coefficient
        self.by_normal = by_normal
        self.normal_delta = 0.0001
        self.__description__ = &#34;{}({})&#34;.format(field, surface)

    def get_coord_mode(self):
        return self.surface.get_coord_mode()

    def get_u_min(self):
        return self.surface.get_u_min()

    def get_u_max(self):
        return self.surface.get_u_max()

    def get_v_min(self):
        return self.surface.get_v_min()

    def get_v_max(self):
        return self.surface.get_v_max()

    @property
    def u_size(self):
        return self.surface.u_size

    @property
    def v_size(self):
        return self.surface.v_size

    @property
    def has_input_matrix(self):
        return self.surface.has_input_matrix

    def get_input_matrix(self):
        return self.surface.get_input_matrix()

    def evaluate(self, u, v):
        p = self.surface.evaluate(u, v)
        vec = self.field.evaluate(p[0], p[1], p[2])
        if self.by_normal == PROJECT:
            normal = self.surface.normal(u, v)
            vec = np.dot(vec, normal) * normal / np.dot(normal, normal)
        elif self.by_normal == COPROJECT:
            normal = self.surface.normal(u, v)
            projection = np.dot(vec, normal) * normal / np.dot(normal, normal)
            vec = vec - projection
        return p + self.coefficient * vec

    def evaluate_array(self, us, vs):
        ps = self.surface.evaluate_array(us, vs)
        xs, ys, zs = ps[:,0], ps[:,1], ps[:,2]
        vxs, vys, vzs = self.field.evaluate_grid(xs, ys, zs)
        vecs = np.stack((vxs, vys, vzs)).T
        if self.by_normal == PROJECT:
            normals = self.surface.normal_array(us, vs)
            vecs = _dot(vecs, normals) * normals / _dot(normals, normals)
        elif self.by_normal == COPROJECT:
            normals = self.surface.normal_array(us, vs)
            projections = _dot(vecs, normals) * normals / _dot(normals, normals)
            vecs = vecs - projections
        return ps + self.coefficient * vecs

    def normal(self, u, v):
        h = self.normal_delta
        p = self.evaluate(u, v)
        p_u = self.evaluate(u+h, v)
        p_v = self.evaluate(u, v+h)
        du = (p_u - p) / h
        dv = (p_v - p) / h
        normal = np.cross(du, dv)
        n = np.linalg.norm(normal)
        normal = normal / n
        return normal

    # def normal_vertices_array(self, us, vs):
    #     surf_vertices = self.evaluate_array(us, vs)
    #     u_plus = self.evaluate_array(us + self.normal_delta, vs)
    #     v_plus = self.evaluate_array(us, vs + self.normal_delta)
    #     du = u_plus - surf_vertices
    #     dv = v_plus - surf_vertices
    #     #self.info(&#34;Du: %s&#34;, du)
    #     #self.info(&#34;Dv: %s&#34;, dv)
    #     normal = np.cross(du, dv)
    #     norm = np.linalg.norm(normal, axis=1)[np.newaxis].T
    #     #if norm != 0:
    #     normal = normal / norm
    #     #self.info(&#34;Normals: %s&#34;, normal)
    #     return normal, surf_vertices

class SvRevolutionSurface(SvSurface):
    __description__ = &#34;Revolution&#34;

    def __init__(self, curve, point, direction, global_origin=True):
        self.curve = curve
        self.point = point
        self.direction = direction
        self.global_origin = global_origin
        self.normal_delta = 0.0001
        self.v_bounds = (0.0, 2*pi)

    @classmethod
    def build(cls, curve, point, direction, v_min=0, v_max=2*pi, global_origin=True):
        if hasattr(curve, &#39;make_revolution_surface&#39;):
            try:
                return curve.make_revolution_surface(point, direction, v_min, v_max, global_origin)
            except UnsupportedCurveTypeException:
                pass
        surface = SvRevolutionSurface(curve, point, direction, global_origin)
        surface.v_bounds = (v_min, v_max)
        return surface

    def evaluate(self, u, v):
        point_on_curve = self.curve.evaluate(u)
        dv = point_on_curve - self.point
        result = np.array(rotate_vector_around_vector(dv, self.direction, v))
        if not self.global_origin:
            result = result + self.point
        return result

    def evaluate_array(self, us, vs):
        points_on_curve = self.curve.evaluate_array(us)
        dvs = points_on_curve - self.point
        result = rotate_vector_around_vector_np(dvs, self.direction, vs)
        if not self.global_origin:
            result = result + self.point
        return result

    def get_u_min(self):
        return self.curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.curve.get_u_bounds()[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

class SvExtrudeCurveVectorSurface(SvSurface):
    def __init__(self, curve, vector):
        self.curve = curve
        self.vector = np.array(vector)
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(curve)

    @classmethod
    def build(cls, curve, vector):
        if hasattr(curve, &#39;extrude_along_vector&#39;):
            try:
                return curve.extrude_along_vector(vector)
            except UnsupportedCurveTypeException:
                pass
        return SvExtrudeCurveVectorSurface(curve, vector)

    def evaluate(self, u, v):
        point_on_curve = self.curve.evaluate(u)
        return point_on_curve + v * self.vector

    def evaluate_array(self, us, vs):
        points_on_curve = self.curve.evaluate_array(us)
        return points_on_curve + vs[np.newaxis].T * self.vector

    def get_u_min(self):
        return self.curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.curve.get_u_bounds()[1]

    def get_v_min(self):
        return 0.0

    def get_v_max(self):
        return 1.0

    @property
    def u_size(self):
        m,M = self.curve.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        return 1.0

class SvExtrudeCurvePointSurface(SvSurface):
    def __init__(self, curve, point):
        self.curve = curve
        self.point = point
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(curve)

    @staticmethod
    def build(curve, point):
        if hasattr(curve, &#39;extrude_to_point&#39;):
            try:
                return curve.extrude_to_point(point)
            except UnsupportedCurveTypeException:
                pass
        return SvExtrudeCurvePointSurface(curve, point)

    def evaluate(self, u, v):
        point_on_curve = self.curve.evaluate(u)
        return (1.0 - v) * point_on_curve + v * self.point

    def evaluate_array(self, us, vs):
        points_on_curve = self.curve.evaluate_array(us)
        vs = vs[np.newaxis].T
        return (1.0 - vs) * points_on_curve + vs * self.point

    def get_u_min(self):
        return self.curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.curve.get_u_bounds()[1]

    def get_v_min(self):
        return 0.0

    def get_v_max(self):
        return 1.0

    @property
    def u_size(self):
        m,M = self.curve.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        return 1.0

PROFILE = &#39;profile&#39;
EXTRUSION = &#39;extrusion&#39;

class SvExtrudeCurveCurveSurface(SvSurface):
    def __init__(self, u_curve, v_curve, origin = PROFILE):
        self.u_curve = u_curve
        self.v_curve = v_curve
        self.origin = origin
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(u_curve)

    def evaluate(self, u, v):
        u_point = self.u_curve.evaluate(u)
        u_min, u_max = self.u_curve.get_u_bounds()
        v_min, v_max = self.v_curve.get_u_bounds()
        v0 = self.v_curve.evaluate(v_min)
        v_point = self.v_curve.evaluate(v)
        if self.origin == EXTRUSION:
            result = u_point + v_point
        else:
            result = u_point + (v_point - v0)
        return result

    def evaluate_array(self, us, vs):
        u_points = self.u_curve.evaluate_array(us)
        u_min, u_max = self.u_curve.get_u_bounds()
        v_min, v_max = self.v_curve.get_u_bounds()
        v0 = self.v_curve.evaluate(v_min)
        v_points = self.v_curve.evaluate_array(vs)
        if self.origin == EXTRUSION:
            result = u_points + v_points
        else:
            result = u_points + (v_points - v0)
        return result

    def get_u_min(self):
        return self.u_curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.u_curve.get_u_bounds()[1]

    def get_v_min(self):
        return self.v_curve.get_u_bounds()[0]

    def get_v_max(self):
        return self.v_curve.get_u_bounds()[1]

    @property
    def u_size(self):
        m,M = self.u_curve.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        m,M = self.v_curve.get_u_bounds()
        return M - m

class SvExtrudeCurveFrenetSurface(SvSurface):
    def __init__(self, profile, extrusion, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start
        frenet, _ , _ = self.extrusion.frame_array(vs)
        profile_vectors = (frenet @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

    @property
    def u_size(self):
        m,M = self.profile.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        m,M = self.extrusion.get_u_bounds()
        return M - m

class SvExtrudeCurveZeroTwistSurface(SvSurface):
    def __init__(self, profile, extrusion, resolution, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.normal_delta = 0.0001
        self.extrusion.pre_calc_torsion_integral(resolution)
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        frenet, _ , _ = self.extrusion.frame_array(vs)

        angles = - self.extrusion.torsion_integral(vs)
        n = len(us)
        zeros = np.zeros((n,))
        ones = np.ones((n,))
        row1 = np.stack((np.cos(angles), np.sin(angles), zeros)).T # (n, 3)
        row2 = np.stack((-np.sin(angles), np.cos(angles), zeros)).T # (n, 3)
        row3 = np.stack((zeros, zeros, ones)).T # (n, 3)
        rotation_matrices = np.dstack((row1, row2, row3))

        profile_vectors = (frenet @ rotation_matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

class SvExtrudeCurveTrackNormalSurface(SvSurface):
    def __init__(self, profile, extrusion, resolution, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.normal_delta = 0.0001
        self.tracker = SvNormalTrack(extrusion, resolution)
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_vectors = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        matrices = self.tracker.evaluate_array(vs)
        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + extrusion_start
        return result

class SvExtrudeCurveMathutilsSurface(SvSurface):
    def __init__(self, profile, extrusion, algorithm, orient_axis=&#39;Z&#39;, up_axis=&#39;X&#39;, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.algorithm = algorithm
        self.orient_axis = orient_axis
        self.up_axis = up_axis
        self.origin = origin
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def get_matrix(self, tangent):
        x = Vector((1.0, 0.0, 0.0))
        y = Vector((0.0, 1.0, 0.0))
        z = Vector((0.0, 0.0, 1.0))

        if self.orient_axis == &#39;X&#39;:
            ax1, ax2, ax3 = x, y, z
        elif self.orient_axis == &#39;Y&#39;:
            ax1, ax2, ax3 = y, x, z
        else:
            ax1, ax2, ax3 = z, x, y

        if self.algorithm == &#39;householder&#39;:
            rot = autorotate_householder(ax1, tangent).inverted()
        elif self.algorithm == &#39;track&#39;:
            rot = autorotate_track(self.orient_axis, tangent, self.up_axis)
        elif self.algorithm == &#39;diff&#39;:
            rot = autorotate_diff(tangent, ax1)
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)

        return rot

    def get_matrices(self, vs):
        tangents = self.extrusion.tangent_array(vs)
        matrices = []
        for tangent in tangents:
            matrix = self.get_matrix(Vector(tangent)).to_3x3()
            matrices.append(matrix)
        return np.array(matrices)

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        matrices = self.get_matrices(vs)

        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

class SvExtrudeCurveNormalDirSurface(SvSurface):
    def __init__(self, profile, extrusion, plane_normal, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.plane_normal = np.array(plane_normal)
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start
        matrices, _ , _ = self.extrusion.frame_by_plane_array(vs, self.plane_normal)
        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

    @property
    def u_size(self):
        m,M = self.profile.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        m,M = self.extrusion.get_u_bounds()
        return M - m

class SvConstPipeSurface(SvSurface):
    __description__ = &#34;Pipe&#34;

    def __init__(self, curve, radius, algorithm = FRENET, resolution=50):
        self.curve = curve
        self.radius = radius
        self.circle = SvCircle(Matrix(), radius)
        self.algorithm = algorithm
        self.normal_delta = 0.00001
        self.u_bounds = self.circle.get_u_bounds()
        if algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            self.calculator = DifferentialRotationCalculator(curve, algorithm, resolution)

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.curve.get_u_bounds()[0]

    def get_v_max(self):
        return self.curve.get_u_bounds()[1]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def get_matrix(self, tangent):
        return MathutilsRotationCalculator.get_matrix(tangent, scale=1.0,
                axis=2,
                algorithm = self.algorithm,
                scale_all=False)

    def get_matrices(self, ts):
        if self.algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            return self.calculator.get_matrices(ts)
        elif self.algorithm in {HOUSEHOLDER, TRACK, DIFF}:
            tangents = self.curve.tangent_array(ts)
            matrices = np.vectorize(lambda t : self.get_matrix(t), signature=&#39;(3)-&gt;(3,3)&#39;)(tangents)
            return matrices
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)

    def evaluate_array(self, us, vs):
        profile_vectors = self.circle.evaluate_array(us)
        u_min, u_max = self.circle.get_u_bounds()
        v_min, v_max = self.curve.get_u_bounds()
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.curve.evaluate(v_min)
        extrusion_points = self.curve.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        matrices = self.get_matrices(vs)

        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        result = result + extrusion_start
        return result

class SvCurveLerpSurface(SvSurface):
    __description__ = &#34;Ruled&#34;

    def __init__(self, curve1, curve2):
        self.curve1 = curve1
        self.curve2 = curve2
        self.normal_delta = 0.0001
        self.v_bounds = (0.0, 1.0)
        self.u_bounds = (0.0, 1.0)
        self.c1_min, self.c1_max = curve1.get_u_bounds()
        self.c2_min, self.c2_max = curve2.get_u_bounds()

    @classmethod
    def build(cls, curve1, curve2, vmin=0.0, vmax=1.0):
        if hasattr(curve1, &#39;make_ruled_surface&#39;):
            try:
                return curve1.make_ruled_surface(curve2, vmin, vmax)
            except TypeError as e:
                # make_ruled_surface method can raise TypeError in case
                # it can&#39;t work with given curve2.
                # In this case we must use generic method.
                sv_logger.debug(&#34;Can&#39;t make a native ruled surface: %s&#34;, e)
                pass

        # generic method
        surface = SvCurveLerpSurface(curve1, curve2)
        surface.v_bounds = (vmin, vmax)
        return surface

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        us1 = (self.c1_max - self.c1_min) * us + self.c1_min
        us2 = (self.c2_max - self.c2_min) * us + self.c2_min
        c1_points = self.curve1.evaluate_array(us1)
        c2_points = self.curve2.evaluate_array(us2)
        vs = vs[np.newaxis].T
        points = (1.0 - vs)*c1_points + vs*c2_points
        return points

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]

class SvSurfaceLerpSurface(SvSurface):
    __description__ = &#34;Lerp&#34;

    def __init__(self, surface1, surface2, coefficient):
        self.surface1 = surface1
        self.surface2 = surface2
        self.coefficient = coefficient
        self.normal_delta = 0.0001
        self.v_bounds = (0.0, 1.0)
        self.u_bounds = (0.0, 1.0)
        self.s1_u_min, self.s1_u_max = surface1.get_u_min(), surface1.get_u_max()
        self.s1_v_min, self.s1_v_max = surface1.get_v_min(), surface1.get_v_max()
        self.s2_u_min, self.s2_u_max = surface2.get_u_min(), surface2.get_u_max()
        self.s2_v_min, self.s2_v_max = surface2.get_v_min(), surface2.get_v_max()

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]
    
    def evaluate_array(self, us, vs):
        us1 = (self.s1_u_max - self.s1_u_min) * us + self.s1_u_min
        us2 = (self.s2_u_max - self.s2_u_min) * us + self.s2_u_min
        vs1 = (self.s1_v_max - self.s1_v_min) * vs + self.s1_v_min
        vs2 = (self.s2_v_max - self.s2_v_min) * vs + self.s2_v_min
        s1_points = self.surface1.evaluate_array(us1, vs1)
        s2_points = self.surface2.evaluate_array(us2, vs2)
        k = self.coefficient
        points = (1.0 - k) * s1_points + k * s2_points
        return points

class SvTaperSweepSurface(SvSurface):
    __description__ = &#34;Taper &amp; Sweep&#34;

    UNIT = &#39;UNIT&#39;
    PROFILE = &#39;PROFILE&#39;
    TAPER = &#39;TAPER&#39;

    def __init__(self, profile, taper, point, direction, scale_base=UNIT):
        self.profile = profile
        self.taper = taper
        self.direction = direction
        self.point = point
        self.line = LineEquation.from_direction_and_point(direction, point)
        self.scale_base = scale_base
        self.normal_delta = 0.0001

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.taper.get_u_bounds()[0]

    def get_v_max(self):
        return self.taper.get_u_bounds()[1]

    def _get_profile_scale(self):
        profile_u_min = self.profile.get_u_bounds()[0]
        profile_start = self.profile.evaluate(profile_u_min)
        profile_start_projection = self.line.projection_of_point(profile_start)
        dp = np.linalg.norm(profile_start - profile_start_projection)
        return dp

    def evaluate(self, u, v):
        taper_point = self.taper.evaluate(v)
        taper_projection = np.array( self.line.projection_of_point(taper_point) )
        scale = np.linalg.norm(taper_projection - taper_point)
        if self.scale_base == SvTaperSweepSurface.TAPER:
            dp = self._get_profile_scale()
            scale /= dp
        elif self.scale_base == SvTaperSweepSurface.PROFILE:
            taper_t_min = self.taper.get_u_bounds()[0]
            taper_start = self.taper.evaluate(taper_t_min)
            taper_start_projection = np.array(self.line.projection_of_point(taper_start))
            scale0 = np.linalg.norm(taper_start - taper_start_projection)
            scale /= scale0

        profile_point = self.profile.evaluate(u)
        return profile_point * scale + taper_projection

    def evaluate_array(self, us, vs):
        taper_points = self.taper.evaluate_array(vs)
        taper_projections = self.line.projection_of_points(taper_points)
        scale = np.linalg.norm(taper_projections - taper_points, axis=1, keepdims=True)

        if self.scale_base == SvTaperSweepSurface.TAPER:
            dp = self._get_profile_scale()
            scale /= dp
        elif self.scale_base == SvTaperSweepSurface.PROFILE:
            scale0 = scale[0]
            scale /= scale0

        profile_points = self.profile.evaluate_array(us)
        return profile_points * scale + taper_projections

class SvBlendSurface(SvSurface):
    def __init__(self, surface1, surface2, curve1, curve2, bulge1, bulge2):
        self.surface1 = surface1
        self.surface2 = surface2
        self.curve1 = curve1
        self.curve2 = curve2
        self.bulge1 = bulge1
        self.bulge2 = bulge2
        self.u_bounds = (0.0, 1.0)
        self.v_bounds = (0.0, 1.0)

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    def evaluate_array(self, us, vs):
        c1_min, c1_max = self.curve1.get_u_bounds()
        c2_min, c2_max = self.curve2.get_u_bounds()
        c1_us = (c1_max - c1_min) * us + c1_min
        c2_us = (c2_max - c2_min) * us + c2_min

        _, c1_points, _, _, c1_binormals = curve_frame_on_surface_array(self.surface1, self.curve1, c1_us)
        _, c2_points, _, _, c2_binormals = curve_frame_on_surface_array(self.surface2, self.curve2, c2_us)
        c1_binormals = self.bulge1 * c1_binormals
        c2_binormals = self.bulge2 * c2_binormals

        # See also sverchok.utils.curve.bezier.SvCubicBezierCurve.
        # Here we have re-implementation of the same algorithm
        # which works with arrays of control points
        p0s = c1_points                 # (n, 3)
        p1s = c1_points + c1_binormals
        p2s = c2_points + c2_binormals
        p3s = c2_points

        c0 = (1 - vs)**3      # (n,)
        c1 = 3*vs*(1-vs)**2
        c2 = 3*vs**2*(1-vs)
        c3 = vs**3

        # (n,1)
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]

        return c0*p0s + c1*p1s + c2*p2s + c3*p3s

class SvConcatSurface(SvSurface):
    def __init__(self, direction, surfaces):
        self.direction = direction
        self.surfaces = self._unify(surfaces)

        p1 = self._get_p_min(surfaces[0])
        boundaries = [p1]
        boundaries.extend([self._get_p_delta(s) for s in surfaces])
        self.boundaries = np.array(boundaries).cumsum()

    def _unify(self, surfaces):
        if self.direction == &#39;U&#39;:
            min_vs = [s.get_v_min() for s in surfaces]
            max_vs = [s.get_v_max() for s in surfaces]

            if min(min_vs) != max(min_vs) or min(max_vs) != max(max_vs):
                surfaces = [SvReparametrizedSurface.build(s, s.get_u_min(), s.get_u_max(), 0.0, 1.0) for s in surfaces]
            return surfaces
        
        else:
            min_us = [s.get_u_min() for s in surfaces]
            max_us = [s.get_u_max() for s in surfaces]

            if min(min_us) != max(min_us) or min(max_us) != max(max_us):
                surfaces = [SvReparametrizedSurface.build(s, 0.0, 1.0, s.get_v_min(), s.get_v_max()) for s in surfaces]
            return surfaces

    def _get_p_max(self, surface):
        if self.direction == &#39;U&#39;:
            return surface.get_u_max()
        else:
            return surface.get_v_max()

    def _get_p_delta(self, surface):
        if self.direction == &#39;U&#39;:
            return surface.get_u_max() - surface.get_u_min()
        else:
            return surface.get_v_max() - surface.get_v_min()

    def _get_p_min(self, surface):
        if self.direction == &#39;U&#39;:
            return surface.get_u_min()
        else:
            return surface.get_v_min()

    def get_u_min(self):
        if self.direction == &#39;U&#39;:
            return self.boundaries[0]
        else:
            return self.surfaces[0].get_u_min()

    def get_u_max(self):
        if self.direction == &#39;U&#39;:
            return self.boundaries[-1]
        else:
            return self.surfaces[0].get_u_max()

    def get_v_min(self):
        if self.direction == &#39;U&#39;:
            return self.surfaces[0].get_v_min()
        else:
            return self.boundaries[0]

    def get_v_max(self):
        if self.direction == &#39;U&#39;:
            return self.surfaces[0].get_v_max()
        else:
            return self.boundaries[-1]

    def evaluate(self, u, v):
        if self.direction == &#39;U&#39;:
            u_idx = self.boundaries.searchsorted(u, side=&#39;right&#39;)-1
            if u_idx &gt;= len(self.surfaces):
                v_idx = len(self.surfaces)-1
                du = self._get_p_delta(self.surfaces[-1])
            else:
                du = u - self.boundaries[u_idx]
            subsurf = self.surfaces[u_idx]
            return subsurf.evaluate(subsurf.get_u_min()+du, v)
        else:
            v_idx = self.boundaries.searchsorted(v, side=&#39;right&#39;)-1
            if v_idx &gt;= len(self.surfaces):
                v_idx = len(self.surfaces)-1
                dv = self._get_p_delta(self.surfaces[-1])
            else:
                dv = v - self.boundaries[v_idx]
            subsurf = self.surfaces[v_idx]
            return subsurf.evaluate(u, subsurf.get_v_min()+dv)

    def evaluate_array(self, us, vs):
        # TODO: numpy implementation
        return np.vectorize(self.evaluate, signature=&#39;(),()-&gt;(3)&#39;)(us, vs)

def concatenate_surfaces(direction, surfaces):
    if all(hasattr(s, &#39;concatenate&#39;) for s in surfaces):
        try:
            result = surfaces[0]
            for s in surfaces[1:]:
                result = result.concatenate(direction, s)
            return result
        except UnsupportedSurfaceTypeException as e:
            sv_logger.debug(&#34;Can&#39;t concatenate surfaces natively: %s&#34;, e)
    
    return SvConcatSurface(direction, surfaces)

def nurbs_revolution_surface(curve, origin, axis, v_min=0, v_max=2*pi, global_origin=True):
    my_control_points = curve.get_control_points()
    my_weights = curve.get_weights()
    control_points = []
    weights = []

    any_circle = SvCircle(Matrix(), 1)
    any_circle.u_bounds = (v_min, v_max)
    any_circle = any_circle.to_nurbs()
    # all circles with given (v_min, v_max)
    # actually always have the same knotvector
    # and the same number of control points
    n = len(any_circle.get_control_points())
    circle_knotvector = any_circle.get_knotvector()
    circle_weights = any_circle.get_weights()

    # TODO: vectorize with numpy? Or better let it so for better readability?
    for my_control_point, my_weight in zip(my_control_points, my_weights):
        eq = CircleEquation3D.from_axis_point(origin, axis, my_control_point)
        if abs(eq.radius) &lt; 1e-8:
            parallel_points = np.empty((n, 3))
            parallel_points[:] = np.array(eq.center) #[np.newaxis].T
        else:
            circle = SvCircle.from_equation(eq)
            circle.u_bounds = (v_min, v_max)
            nurbs_circle = circle.to_nurbs()
            parallel_points = nurbs_circle.get_control_points()
        parallel_weights = circle_weights * my_weight
        control_points.append(parallel_points)
        weights.append(parallel_weights)
    control_points = np.array(control_points)
    if global_origin:
        control_points = control_points - origin

    weights = np.array(weights)
    degree_u = curve.get_degree()
    degree_v = 2 # circle

    return SvNurbsSurface.build(curve.get_nurbs_implementation(),
            degree_u, degree_v,
            curve.get_knotvector(), circle_knotvector,
            control_points, weights)

def round_knotvectors(surface, accuracy):
    knotvector_u = surface.get_knotvector_u()
    knotvector_v = surface.get_knotvector_v()

    knotvector_u = np.round(knotvector_u, accuracy)
    knotvector_v = np.round(knotvector_v, accuracy)

    result = surface.copy(knotvector_u = knotvector_u, knotvector_v = knotvector_v)

    tolerance = 10**(-accuracy)

#     print(f&#34;KV_U: {knotvector_u}&#34;)
#     print(f&#34;KV_V: {knotvector_v}&#34;)
#     degree = surface.get_degree_u()
#     ms = sv_knotvector.to_multiplicity(knotvector_u, tolerance)
#     n = len(ms)
#     for idx, (u, count) in enumerate(ms):
#         if idx == 0 or idx == n-1:
#             max_allowed = degree+1
#         else:
#             max_allowed = degree
#         print(f&#34;U={u}: max.allowed {max_allowed}, actual {count}&#34;)
#         diff = count - max_allowed
# 
#         if diff &gt; 0:
#             print(f&#34;Remove U={u} x {diff}&#34;)
#             result = result.remove_knot(SvNurbsSurface.U, u, diff)
# 
#     degree = surface.get_degree_v()
#     ms = sv_knotvector.to_multiplicity(knotvector_v, tolerance)
#     n = len(ms)
#     for idx, (v, count) in enumerate(ms):
#         if idx == 0 or idx == n-1:
#             max_allowed = degree+1
#         else:
#             max_allowed = degree
#         print(f&#34;V={v}: max.allowed {max_allowed}, actual {count}&#34;)
#         diff = count - max_allowed
# 
#         if diff &gt; 0:
#             print(f&#34;Remove V={v} x {diff}&#34;)
#             result = result.remove_knot(SvNurbsSurface.V, v, diff)

    return result

def unify_nurbs_surfaces(surfaces, knots_method = &#39;UNIFY&#39;, knotvector_accuracy=6):
    # Unify surface degrees

    degrees_u = [surface.get_degree_u() for surface in surfaces]
    degrees_v = [surface.get_degree_v() for surface in surfaces]

    degree_u = max(degrees_u)
    degree_v = max(degrees_v)
    #print(f&#34;Elevate everything to {degree_u}x{degree_v}&#34;)

    surfaces = [surface.elevate_degree(SvNurbsSurface.U, target=degree_u) for surface in surfaces]
    surfaces = [surface.elevate_degree(SvNurbsSurface.V, target=degree_v) for surface in surfaces]

    # Unify surface knotvectors

    knotvector_tolerance = 10**(-knotvector_accuracy)

    if knots_method == &#39;UNIFY&#39;:

        surfaces = [round_knotvectors(s, knotvector_accuracy) for s in surfaces]
        for i, surface in enumerate(surfaces):
            #print(f&#34;S #{i} KV_U: {surface.get_knotvector_u()}&#34;)
            #print(f&#34;S #{i} KV_V: {surface.get_knotvector_v()}&#34;)
            kv_err = sv_knotvector.check_multiplicity(surface.get_degree_u(), surface.get_knotvector_u(), tolerance=knotvector_tolerance)
            if kv_err is not None:
                raise Exception(f&#34;Surface #{i}: invalid U knotvector: {kv_err}&#34;)

            kv_err = sv_knotvector.check_multiplicity(surface.get_degree_v(), surface.get_knotvector_v(), tolerance=knotvector_tolerance)
            if kv_err is not None:
                raise Exception(f&#34;Surface #{i}: invalid V knotvector: {kv_err}&#34;)

        dst_knots_u = defaultdict(int)
        dst_knots_v = defaultdict(int)
        for surface in surfaces:
            m_u = sv_knotvector.to_multiplicity(surface.get_knotvector_u(), tolerance=knotvector_tolerance)
            m_v = sv_knotvector.to_multiplicity(surface.get_knotvector_v(), tolerance=knotvector_tolerance)

            for u, count in m_u:
                u = round(u, knotvector_accuracy)
                dst_knots_u[u] = max(dst_knots_u[u], count)

            for v, count in m_v:
                v = round(v, knotvector_accuracy)
                dst_knots_v[v] = max(dst_knots_v[v], count)

        result = []
        for surface in surfaces:
            diffs_u = []
            kv_u = np.round(surface.get_knotvector_u(), knotvector_accuracy)
            ms_u = dict(sv_knotvector.to_multiplicity(kv_u, tolerance=knotvector_tolerance))
            for dst_u, dst_multiplicity in dst_knots_u.items():
                src_multiplicity = ms_u.get(dst_u, 0)
                diff = dst_multiplicity - src_multiplicity
                diffs_u.append((dst_u, diff))

            for u, diff in diffs_u:
                if diff &gt; 0:
                    #print(f&#34;S: Insert U = {u} x {diff}&#34;)
                    surface = surface.insert_knot(SvNurbsSurface.U, u, diff)

            diffs_v = []
            kv_v = np.round(surface.get_knotvector_v(), knotvector_accuracy)
            ms_v = dict(sv_knotvector.to_multiplicity(kv_v, tolerance=knotvector_tolerance))
            for dst_v, dst_multiplicity in dst_knots_v.items():
                src_multiplicity = ms_v.get(dst_v, 0)
                diff = dst_multiplicity - src_multiplicity
                diffs_v.append((dst_v, diff))

            for v, diff in diffs_v:
                if diff &gt; 0:
                    #print(f&#34;S: Insert V = {v} x {diff}&#34;)
                    surface = surface.insert_knot(SvNurbsSurface.V, v, diff)

            result.append(surface)

        return result

    elif knots_method == &#39;AVERAGE&#39;:
        kvs = [len(surface.get_control_points()) for surface in surfaces]
        max_kv, min_kv = max(kvs), min(kvs)
        if max_kv != min_kv:
            raise Exception(f&#34;U knotvector averaging is not applicable: Surfaces have different number of control points: {kvs}&#34;)

        kvs = [len(surface.get_control_points()[0]) for surface in surfaces]
        max_kv, min_kv = max(kvs), min(kvs)
        if max_kv != min_kv:
            raise Exception(f&#34;V knotvector averaging is not applicable: Surfaces have different number of control points: {kvs}&#34;)


        knotvectors = np.array([surface.get_knotvector_u() for surface in surfaces])
        knotvector_u = knotvectors.mean(axis=0)

        knotvectors = np.array([surface.get_knotvector_v() for surface in surfaces])
        knotvector_u = knotvectors.mean(axis=0)

        result = []
        for surface in surfaces:
            surface = SvNurbsSurface.build(surface.get_nurbs_implementation(),
                    surface.get_degree_u(), surface.get_degree_v(),
                    knotvector_u, knotvector_v,
                    surface.get_control_points(),
                    surface.get_weights())
            result.append(surface)
        return result
    else:
        raise Exception(&#39;Unsupported knotvector unification method&#39;)

def remove_excessive_knots(surface, direction, tolerance=1e-6):
    if direction not in {&#39;U&#39;, &#39;V&#39;, &#39;UV&#39;}:
        raise Exception(&#34;Unsupported direction&#34;)

    if direction in {&#39;U&#39;, &#39;UV&#39;}:
        kv = surface.get_knotvector_u()
        for u in sv_knotvector.get_internal_knots(kv):
            surface = surface.remove_knot(&#39;U&#39;, u, count=&#39;ALL&#39;, tolerance=tolerance, if_possible=True)

    if direction in {&#39;V&#39;, &#39;UV&#39;}:
        kv = surface.get_knotvector_v()
        for v in sv_knotvector.get_internal_knots(kv):
            surface = surface.remove_knot(&#39;V&#39;, v, count=&#39;ALL&#39;, tolerance=tolerance, if_possible=True)

    return surface

def build_nurbs_sphere(center, radius):
    &#34;&#34;&#34;
    Generate NURBS Surface representing a sphere.
    Sphere is defined here as a surface of revolution of
    half a circle.
    &#34;&#34;&#34;
    vectorx = np.array([0.0, 0.0, radius])
    axis = np.array([0.0, 0.0, 1.0])
    normal = np.array([1.0, 0.0, 0.0])
    matrix = SvCircle.calc_matrix(normal, vectorx)
    matrix = Matrix.Translation(center) @ Matrix(matrix).to_4x4()
    arc = SvCircle(matrix=matrix, radius=radius, normal=normal, vectorx=vectorx)
    arc.u_bounds = (0.0, pi)
    return nurbs_revolution_surface(arc.to_nurbs(), center, axis, 0, 2*pi, global_origin=True)

def deform_nurbs_surface(src_surface, uknots, vknots, points):
    &#34;&#34;&#34;
    Move some control points of a NURBS surface so that at
    given parameter values it passes through the given points.
    NB: rational surfaces are not supported yet.
    Parameters:
    * src_surface - SvNurbsSurface instance
    * uknots, vknots - np.array of shape (n,): U and V coordinates
        of points to be moved
    * points: np.array of shape (n,3): desired locations of surface points.
    Output:
    * SvNurbsSurface instance.
    &#34;&#34;&#34;
    n = len(points)
    if len(uknots) != n or len(vknots) != n:
        raise Exception(&#34;Number of points, uknots and vknots must be equal&#34;)
    if src_surface.is_rational():
        raise UnsupportedSurfaceTypeException(&#34;Rational surfaces are not supported yet&#34;)

    ndim = 3
    knotvector_u = src_surface.get_knotvector_u()
    knotvector_v = src_surface.get_knotvector_v()
    basis_u = SvNurbsBasisFunctions(knotvector_u)
    basis_v = SvNurbsBasisFunctions(knotvector_v)
    degree_u = src_surface.get_degree_u()
    degree_v = src_surface.get_degree_v()
    ncpts_u, ncpts_v,_ = src_surface.get_control_points().shape
    nsu = np.array([basis_u.derivative(i, degree_u, 0)(uknots) for i in range(ncpts_u)])
    nsv = np.array([basis_v.derivative(i, degree_v, 0)(vknots) for i in range(ncpts_v)])
    
    nsu_t = np.transpose(nsu[np.newaxis], axes=(1,0,2)) # (ncpts_u, 1, n)
    nsv_t = nsv[np.newaxis] # (1, ncpts_v, n)
    ns_t = nsu_t * nsv_t # (ncpts_u, ncpts_v, n)
    denominator = ns_t.sum(axis=0).sum(axis=0)
    
    n_equations = n*ndim
    n_unknowns = ncpts_u * ncpts_v * ndim
    #print(f&#34;Eqs: {n_equations}, Unk: {n_unknowns}&#34;)
    
    A = np.zeros((n_equations, n_unknowns))
    for u_idx in range(ncpts_u):
        for v_idx in range(ncpts_v):
            cpt_idx = ncpts_v * u_idx + v_idx
            for pt_idx in range(n):
                alpha = nsu[u_idx][pt_idx] * nsv[v_idx][pt_idx] / denominator[pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = alpha
                    
    src_points = src_surface.evaluate_array(uknots, vknots)
    
    B = np.zeros((n_equations,1))
    for pt_idx, point in enumerate(points):
        B[pt_idx*3:pt_idx*3+3,0] = point[np.newaxis] - src_points[pt_idx][np.newaxis]

    if n_equations == n_unknowns:
        print(&#34;Well-determined&#34;, n_equations)
        A1 = np.linalg.inv(A)
        X = (A1 @ B).T
    elif n_equations &lt; n_unknowns:
        print(&#34;Underdetermined&#34;, n_equations, n_unknowns)
        A1 = np.linalg.pinv(A)
        X = (A1 @ B).T
    else: # n_equations &gt; n_unknowns
        print(&#34;Overdetermined&#34;, n_equations, n_unknowns)
        X, residues, rank, singval = np.linalg.lstsq(A, B)
    d_cpts = X.reshape((ncpts_u, ncpts_v, ndim))
    cpts = src_surface.get_control_points()
    
    surface = SvNurbsSurface.build(src_surface.get_nurbs_implementation(),
                degree_u, degree_v, knotvector_u, knotvector_v,
                cpts + d_cpts)
    return surface

def make_planar_surface(origin, u_axis, v_axis, degree_u, degree_v, ncpts_u, ncpts_v, size_u, size_v, implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    Generate squa planar NURBS surface.
    Parameters:
    * origin - point at the plane, which will have UV coordinates (0.5, 0.5). np.array of shape (3,).
    * u_axis, v_axis - vectors which will define directions of U and V parameter axes. np.array of shape (3,).
    * degree_u, degree_v - degrees of the surface along U and V parameters.
    * ncpts_u, ncpts_v - number of control points of the surface along U and V.
    * size_u, size_v - size of the surface along U and V, measured in lengths of u_axis and v_axis.
    Return value: an instance of SvNurbsSurface.
    &#34;&#34;&#34;
    us = np.linspace(-size_u/2.0, size_u/2.0, num=ncpts_u)
    vs = np.linspace(-size_v/2.0, size_v/2.0, num=ncpts_v)
    cpts = [[origin + u*u_axis + v*v_axis for u in list(vs)] for v in list(us)]
    cpts = np.array(cpts)
    knotvector_u = sv_knotvector.generate(degree_u, ncpts_u)
    knotvector_v = sv_knotvector.generate(degree_v, ncpts_v)
    return SvNurbsSurface.build(implementation, 
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                cpts)

def nurbs_surface_from_points(points, degree_u, degree_v, num_cpts_u, num_cpts_v, normal = None, implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    Generate a NURBS surface which passes either through or near the specified points.
    Parameters:
    * points - points to draw a surface through. np.array of shape (n,3).
    * degree_u, degree_v - degrees of the surface along U and V directions.
    * num_cpts_u, num_cpts_v - number of surface&#39;s control points along U and V.

    If total number of control points (num_cpts_u * num_cpts_v) is equal to the
    number of points specified, then the system will be well-determined, so
    this will do interpolation (although depending on location of points, it
    may fail).
    If total number of control points is less than the number of points
    specified, then the system will be overdetermined, so this will do
    approximation.
    If total number of control points is more than the number of points
    specified, then the system will be underdetermined, i.e. there are many
    surfaces passing through these points. In this case, the method will select
    the surface which has all it&#39;s control points as close to origin (0.0, 0.0,
    0.0) as possible.

    Return values:
    * SvNurbsSurface instance
    * uv_points - coordinates of points provided in UV space of the surface.
        np.array of shape (n, 3).
    &#34;&#34;&#34;

    def calc_y_axis(plane, x_axis):
        normal = np.array(plane.normal)
        y_axis = np.cross(x_axis, normal)
        y_axis /= np.linalg.norm(y_axis)
        return y_axis

    if normal is None:
        linear = linear_approximation(points)
        origin = linear.center
        plane = linear.most_similar_plane()
    else:
        origin = center(points)
        plane = PlaneEquation.from_normal_and_point(normal, origin)

    start = points[0]
    start_projection = np.asarray(plane.projection_of_point(start))
    x_axis = start_projection - origin
    x_axis /= np.linalg.norm(x_axis)
    y_axis = calc_y_axis(plane, x_axis)
    distances = np.linalg.norm(points - origin, axis=1)
    max_distance = distances.max()
    
    planar_surface = make_planar_surface(origin,
                    x_axis, y_axis,
                    degree_u, degree_v,
                    num_cpts_u, num_cpts_v,
                    max_distance*2, max_distance*2,
                    implementation = implementation)
    
    us = np_dot(points, x_axis)
    vs = np_dot(points, y_axis)
    us_min, us_max = us.min(), us.max()
    vs_min, vs_max = vs.min(), vs.max()
    us = (us - us_min) / (us_max - us_min)
    vs = (vs - vs_min) / (vs_max - vs_min)
    surface = deform_nurbs_surface(planar_surface, us, vs, points)
    uv_points = np.array([[u,v, 0.0] for u,v in zip(us,vs)])
    return surface, uv_points

def nurbs_surface_from_curve(curve, samples, degree_u, degree_v, num_cpts_u, num_cpts_v, implementation = None):
    &#34;&#34;&#34;
    Generate a NURBS surface which passes through the points of specified curve.
    See also documentation of nurbs_surface_from_points method.
    Parameters:
    * curve - SvNurbsCurve instance.
    * samples - the number of points on the curve, through which the surface should be build.
    * degree_u, degree_v - degrees of the surface along U and V directions.
    * num_cpts_u, num_cpts_v - number of surface&#39;s control points along U and V.
    Return value:
    * SvNurbsSurface instance
    * SvNurbsCurve instance: a curve in surface&#39;s UV space, which passes
        through projections of specified points to the surface.
    &#34;&#34;&#34;

    if implementation is None:
        implementation = curve.get_nurbs_implementation()

    t_min, t_max = curve.get_u_bounds()
    ts = np.linspace(t_min, t_max, num=samples)
    points = curve.evaluate_array(ts)
    surface = nurbs_surface_from_points(points, degree_u, degere_v, num_cpts_u, num_cpts_v, implementation = implementation)
    trim_curve = SvNurbsMaths.interpolate_curve(implementation, curve.get_degree(), uv_points)
    return surface, trim_curve</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.surface.algorithms.build_nurbs_sphere"><code class="name flex">
<span>def <span class="ident">build_nurbs_sphere</span></span>(<span>center, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate NURBS Surface representing a sphere.
Sphere is defined here as a surface of revolution of
half a circle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_nurbs_sphere(center, radius):
    &#34;&#34;&#34;
    Generate NURBS Surface representing a sphere.
    Sphere is defined here as a surface of revolution of
    half a circle.
    &#34;&#34;&#34;
    vectorx = np.array([0.0, 0.0, radius])
    axis = np.array([0.0, 0.0, 1.0])
    normal = np.array([1.0, 0.0, 0.0])
    matrix = SvCircle.calc_matrix(normal, vectorx)
    matrix = Matrix.Translation(center) @ Matrix(matrix).to_4x4()
    arc = SvCircle(matrix=matrix, radius=radius, normal=normal, vectorx=vectorx)
    arc.u_bounds = (0.0, pi)
    return nurbs_revolution_surface(arc.to_nurbs(), center, axis, 0, 2*pi, global_origin=True)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.concatenate_surfaces"><code class="name flex">
<span>def <span class="ident">concatenate_surfaces</span></span>(<span>direction, surfaces)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concatenate_surfaces(direction, surfaces):
    if all(hasattr(s, &#39;concatenate&#39;) for s in surfaces):
        try:
            result = surfaces[0]
            for s in surfaces[1:]:
                result = result.concatenate(direction, s)
            return result
        except UnsupportedSurfaceTypeException as e:
            sv_logger.debug(&#34;Can&#39;t concatenate surfaces natively: %s&#34;, e)
    
    return SvConcatSurface(direction, surfaces)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.deform_nurbs_surface"><code class="name flex">
<span>def <span class="ident">deform_nurbs_surface</span></span>(<span>src_surface, uknots, vknots, points)</span>
</code></dt>
<dd>
<div class="desc"><p>Move some control points of a NURBS surface so that at
given parameter values it passes through the given points.
NB: rational surfaces are not supported yet.
Parameters:
* src_surface - SvNurbsSurface instance
* uknots, vknots - np.array of shape (n,): U and V coordinates
of points to be moved
* points: np.array of shape (n,3): desired locations of surface points.
Output:
* SvNurbsSurface instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deform_nurbs_surface(src_surface, uknots, vknots, points):
    &#34;&#34;&#34;
    Move some control points of a NURBS surface so that at
    given parameter values it passes through the given points.
    NB: rational surfaces are not supported yet.
    Parameters:
    * src_surface - SvNurbsSurface instance
    * uknots, vknots - np.array of shape (n,): U and V coordinates
        of points to be moved
    * points: np.array of shape (n,3): desired locations of surface points.
    Output:
    * SvNurbsSurface instance.
    &#34;&#34;&#34;
    n = len(points)
    if len(uknots) != n or len(vknots) != n:
        raise Exception(&#34;Number of points, uknots and vknots must be equal&#34;)
    if src_surface.is_rational():
        raise UnsupportedSurfaceTypeException(&#34;Rational surfaces are not supported yet&#34;)

    ndim = 3
    knotvector_u = src_surface.get_knotvector_u()
    knotvector_v = src_surface.get_knotvector_v()
    basis_u = SvNurbsBasisFunctions(knotvector_u)
    basis_v = SvNurbsBasisFunctions(knotvector_v)
    degree_u = src_surface.get_degree_u()
    degree_v = src_surface.get_degree_v()
    ncpts_u, ncpts_v,_ = src_surface.get_control_points().shape
    nsu = np.array([basis_u.derivative(i, degree_u, 0)(uknots) for i in range(ncpts_u)])
    nsv = np.array([basis_v.derivative(i, degree_v, 0)(vknots) for i in range(ncpts_v)])
    
    nsu_t = np.transpose(nsu[np.newaxis], axes=(1,0,2)) # (ncpts_u, 1, n)
    nsv_t = nsv[np.newaxis] # (1, ncpts_v, n)
    ns_t = nsu_t * nsv_t # (ncpts_u, ncpts_v, n)
    denominator = ns_t.sum(axis=0).sum(axis=0)
    
    n_equations = n*ndim
    n_unknowns = ncpts_u * ncpts_v * ndim
    #print(f&#34;Eqs: {n_equations}, Unk: {n_unknowns}&#34;)
    
    A = np.zeros((n_equations, n_unknowns))
    for u_idx in range(ncpts_u):
        for v_idx in range(ncpts_v):
            cpt_idx = ncpts_v * u_idx + v_idx
            for pt_idx in range(n):
                alpha = nsu[u_idx][pt_idx] * nsv[v_idx][pt_idx] / denominator[pt_idx]
                for dim_idx in range(ndim):
                    A[ndim*pt_idx + dim_idx, ndim*cpt_idx + dim_idx] = alpha
                    
    src_points = src_surface.evaluate_array(uknots, vknots)
    
    B = np.zeros((n_equations,1))
    for pt_idx, point in enumerate(points):
        B[pt_idx*3:pt_idx*3+3,0] = point[np.newaxis] - src_points[pt_idx][np.newaxis]

    if n_equations == n_unknowns:
        print(&#34;Well-determined&#34;, n_equations)
        A1 = np.linalg.inv(A)
        X = (A1 @ B).T
    elif n_equations &lt; n_unknowns:
        print(&#34;Underdetermined&#34;, n_equations, n_unknowns)
        A1 = np.linalg.pinv(A)
        X = (A1 @ B).T
    else: # n_equations &gt; n_unknowns
        print(&#34;Overdetermined&#34;, n_equations, n_unknowns)
        X, residues, rank, singval = np.linalg.lstsq(A, B)
    d_cpts = X.reshape((ncpts_u, ncpts_v, ndim))
    cpts = src_surface.get_control_points()
    
    surface = SvNurbsSurface.build(src_surface.get_nurbs_implementation(),
                degree_u, degree_v, knotvector_u, knotvector_v,
                cpts + d_cpts)
    return surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.make_planar_surface"><code class="name flex">
<span>def <span class="ident">make_planar_surface</span></span>(<span>origin, u_axis, v_axis, degree_u, degree_v, ncpts_u, ncpts_v, size_u, size_v, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate squa planar NURBS surface.
Parameters:
* origin - point at the plane, which will have UV coordinates (0.5, 0.5). np.array of shape (3,).
* u_axis, v_axis - vectors which will define directions of U and V parameter axes. np.array of shape (3,).
* degree_u, degree_v - degrees of the surface along U and V parameters.
* ncpts_u, ncpts_v - number of control points of the surface along U and V.
* size_u, size_v - size of the surface along U and V, measured in lengths of u_axis and v_axis.
Return value: an instance of SvNurbsSurface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_planar_surface(origin, u_axis, v_axis, degree_u, degree_v, ncpts_u, ncpts_v, size_u, size_v, implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    Generate squa planar NURBS surface.
    Parameters:
    * origin - point at the plane, which will have UV coordinates (0.5, 0.5). np.array of shape (3,).
    * u_axis, v_axis - vectors which will define directions of U and V parameter axes. np.array of shape (3,).
    * degree_u, degree_v - degrees of the surface along U and V parameters.
    * ncpts_u, ncpts_v - number of control points of the surface along U and V.
    * size_u, size_v - size of the surface along U and V, measured in lengths of u_axis and v_axis.
    Return value: an instance of SvNurbsSurface.
    &#34;&#34;&#34;
    us = np.linspace(-size_u/2.0, size_u/2.0, num=ncpts_u)
    vs = np.linspace(-size_v/2.0, size_v/2.0, num=ncpts_v)
    cpts = [[origin + u*u_axis + v*v_axis for u in list(vs)] for v in list(us)]
    cpts = np.array(cpts)
    knotvector_u = sv_knotvector.generate(degree_u, ncpts_u)
    knotvector_v = sv_knotvector.generate(degree_v, ncpts_v)
    return SvNurbsSurface.build(implementation, 
                degree_u, degree_v,
                knotvector_u, knotvector_v,
                cpts)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.nurbs_revolution_surface"><code class="name flex">
<span>def <span class="ident">nurbs_revolution_surface</span></span>(<span>curve, origin, axis, v_min=0, v_max=6.283185307179586, global_origin=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nurbs_revolution_surface(curve, origin, axis, v_min=0, v_max=2*pi, global_origin=True):
    my_control_points = curve.get_control_points()
    my_weights = curve.get_weights()
    control_points = []
    weights = []

    any_circle = SvCircle(Matrix(), 1)
    any_circle.u_bounds = (v_min, v_max)
    any_circle = any_circle.to_nurbs()
    # all circles with given (v_min, v_max)
    # actually always have the same knotvector
    # and the same number of control points
    n = len(any_circle.get_control_points())
    circle_knotvector = any_circle.get_knotvector()
    circle_weights = any_circle.get_weights()

    # TODO: vectorize with numpy? Or better let it so for better readability?
    for my_control_point, my_weight in zip(my_control_points, my_weights):
        eq = CircleEquation3D.from_axis_point(origin, axis, my_control_point)
        if abs(eq.radius) &lt; 1e-8:
            parallel_points = np.empty((n, 3))
            parallel_points[:] = np.array(eq.center) #[np.newaxis].T
        else:
            circle = SvCircle.from_equation(eq)
            circle.u_bounds = (v_min, v_max)
            nurbs_circle = circle.to_nurbs()
            parallel_points = nurbs_circle.get_control_points()
        parallel_weights = circle_weights * my_weight
        control_points.append(parallel_points)
        weights.append(parallel_weights)
    control_points = np.array(control_points)
    if global_origin:
        control_points = control_points - origin

    weights = np.array(weights)
    degree_u = curve.get_degree()
    degree_v = 2 # circle

    return SvNurbsSurface.build(curve.get_nurbs_implementation(),
            degree_u, degree_v,
            curve.get_knotvector(), circle_knotvector,
            control_points, weights)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.nurbs_surface_from_curve"><code class="name flex">
<span>def <span class="ident">nurbs_surface_from_curve</span></span>(<span>curve, samples, degree_u, degree_v, num_cpts_u, num_cpts_v, implementation=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a NURBS surface which passes through the points of specified curve.
See also documentation of nurbs_surface_from_points method.
Parameters:
* curve - SvNurbsCurve instance.
* samples - the number of points on the curve, through which the surface should be build.
* degree_u, degree_v - degrees of the surface along U and V directions.
* num_cpts_u, num_cpts_v - number of surface's control points along U and V.
Return value:
* SvNurbsSurface instance
* SvNurbsCurve instance: a curve in surface's UV space, which passes
through projections of specified points to the surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nurbs_surface_from_curve(curve, samples, degree_u, degree_v, num_cpts_u, num_cpts_v, implementation = None):
    &#34;&#34;&#34;
    Generate a NURBS surface which passes through the points of specified curve.
    See also documentation of nurbs_surface_from_points method.
    Parameters:
    * curve - SvNurbsCurve instance.
    * samples - the number of points on the curve, through which the surface should be build.
    * degree_u, degree_v - degrees of the surface along U and V directions.
    * num_cpts_u, num_cpts_v - number of surface&#39;s control points along U and V.
    Return value:
    * SvNurbsSurface instance
    * SvNurbsCurve instance: a curve in surface&#39;s UV space, which passes
        through projections of specified points to the surface.
    &#34;&#34;&#34;

    if implementation is None:
        implementation = curve.get_nurbs_implementation()

    t_min, t_max = curve.get_u_bounds()
    ts = np.linspace(t_min, t_max, num=samples)
    points = curve.evaluate_array(ts)
    surface = nurbs_surface_from_points(points, degree_u, degere_v, num_cpts_u, num_cpts_v, implementation = implementation)
    trim_curve = SvNurbsMaths.interpolate_curve(implementation, curve.get_degree(), uv_points)
    return surface, trim_curve</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.nurbs_surface_from_points"><code class="name flex">
<span>def <span class="ident">nurbs_surface_from_points</span></span>(<span>points, degree_u, degree_v, num_cpts_u, num_cpts_v, normal=None, implementation='NATIVE')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a NURBS surface which passes either through or near the specified points.
Parameters:
* points - points to draw a surface through. np.array of shape (n,3).
* degree_u, degree_v - degrees of the surface along U and V directions.
* num_cpts_u, num_cpts_v - number of surface's control points along U and V.</p>
<p>If total number of control points (num_cpts_u * num_cpts_v) is equal to the
number of points specified, then the system will be well-determined, so
this will do interpolation (although depending on location of points, it
may fail).
If total number of control points is less than the number of points
specified, then the system will be overdetermined, so this will do
approximation.
If total number of control points is more than the number of points
specified, then the system will be underdetermined, i.e. there are many
surfaces passing through these points. In this case, the method will select
the surface which has all it's control points as close to origin (0.0, 0.0,
0.0) as possible.</p>
<p>Return values:
* SvNurbsSurface instance
* uv_points - coordinates of points provided in UV space of the surface.
np.array of shape (n, 3).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nurbs_surface_from_points(points, degree_u, degree_v, num_cpts_u, num_cpts_v, normal = None, implementation = SvNurbsSurface.NATIVE):
    &#34;&#34;&#34;
    Generate a NURBS surface which passes either through or near the specified points.
    Parameters:
    * points - points to draw a surface through. np.array of shape (n,3).
    * degree_u, degree_v - degrees of the surface along U and V directions.
    * num_cpts_u, num_cpts_v - number of surface&#39;s control points along U and V.

    If total number of control points (num_cpts_u * num_cpts_v) is equal to the
    number of points specified, then the system will be well-determined, so
    this will do interpolation (although depending on location of points, it
    may fail).
    If total number of control points is less than the number of points
    specified, then the system will be overdetermined, so this will do
    approximation.
    If total number of control points is more than the number of points
    specified, then the system will be underdetermined, i.e. there are many
    surfaces passing through these points. In this case, the method will select
    the surface which has all it&#39;s control points as close to origin (0.0, 0.0,
    0.0) as possible.

    Return values:
    * SvNurbsSurface instance
    * uv_points - coordinates of points provided in UV space of the surface.
        np.array of shape (n, 3).
    &#34;&#34;&#34;

    def calc_y_axis(plane, x_axis):
        normal = np.array(plane.normal)
        y_axis = np.cross(x_axis, normal)
        y_axis /= np.linalg.norm(y_axis)
        return y_axis

    if normal is None:
        linear = linear_approximation(points)
        origin = linear.center
        plane = linear.most_similar_plane()
    else:
        origin = center(points)
        plane = PlaneEquation.from_normal_and_point(normal, origin)

    start = points[0]
    start_projection = np.asarray(plane.projection_of_point(start))
    x_axis = start_projection - origin
    x_axis /= np.linalg.norm(x_axis)
    y_axis = calc_y_axis(plane, x_axis)
    distances = np.linalg.norm(points - origin, axis=1)
    max_distance = distances.max()
    
    planar_surface = make_planar_surface(origin,
                    x_axis, y_axis,
                    degree_u, degree_v,
                    num_cpts_u, num_cpts_v,
                    max_distance*2, max_distance*2,
                    implementation = implementation)
    
    us = np_dot(points, x_axis)
    vs = np_dot(points, y_axis)
    us_min, us_max = us.min(), us.max()
    vs_min, vs_max = vs.min(), vs.max()
    us = (us - us_min) / (us_max - us_min)
    vs = (vs - vs_min) / (vs_max - vs_min)
    surface = deform_nurbs_surface(planar_surface, us, vs, points)
    uv_points = np.array([[u,v, 0.0] for u,v in zip(us,vs)])
    return surface, uv_points</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.remove_excessive_knots"><code class="name flex">
<span>def <span class="ident">remove_excessive_knots</span></span>(<span>surface, direction, tolerance=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_excessive_knots(surface, direction, tolerance=1e-6):
    if direction not in {&#39;U&#39;, &#39;V&#39;, &#39;UV&#39;}:
        raise Exception(&#34;Unsupported direction&#34;)

    if direction in {&#39;U&#39;, &#39;UV&#39;}:
        kv = surface.get_knotvector_u()
        for u in sv_knotvector.get_internal_knots(kv):
            surface = surface.remove_knot(&#39;U&#39;, u, count=&#39;ALL&#39;, tolerance=tolerance, if_possible=True)

    if direction in {&#39;V&#39;, &#39;UV&#39;}:
        kv = surface.get_knotvector_v()
        for v in sv_knotvector.get_internal_knots(kv):
            surface = surface.remove_knot(&#39;V&#39;, v, count=&#39;ALL&#39;, tolerance=tolerance, if_possible=True)

    return surface</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.round_knotvectors"><code class="name flex">
<span>def <span class="ident">round_knotvectors</span></span>(<span>surface, accuracy)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_knotvectors(surface, accuracy):
    knotvector_u = surface.get_knotvector_u()
    knotvector_v = surface.get_knotvector_v()

    knotvector_u = np.round(knotvector_u, accuracy)
    knotvector_v = np.round(knotvector_v, accuracy)

    result = surface.copy(knotvector_u = knotvector_u, knotvector_v = knotvector_v)

    tolerance = 10**(-accuracy)

#     print(f&#34;KV_U: {knotvector_u}&#34;)
#     print(f&#34;KV_V: {knotvector_v}&#34;)
#     degree = surface.get_degree_u()
#     ms = sv_knotvector.to_multiplicity(knotvector_u, tolerance)
#     n = len(ms)
#     for idx, (u, count) in enumerate(ms):
#         if idx == 0 or idx == n-1:
#             max_allowed = degree+1
#         else:
#             max_allowed = degree
#         print(f&#34;U={u}: max.allowed {max_allowed}, actual {count}&#34;)
#         diff = count - max_allowed
# 
#         if diff &gt; 0:
#             print(f&#34;Remove U={u} x {diff}&#34;)
#             result = result.remove_knot(SvNurbsSurface.U, u, diff)
# 
#     degree = surface.get_degree_v()
#     ms = sv_knotvector.to_multiplicity(knotvector_v, tolerance)
#     n = len(ms)
#     for idx, (v, count) in enumerate(ms):
#         if idx == 0 or idx == n-1:
#             max_allowed = degree+1
#         else:
#             max_allowed = degree
#         print(f&#34;V={v}: max.allowed {max_allowed}, actual {count}&#34;)
#         diff = count - max_allowed
# 
#         if diff &gt; 0:
#             print(f&#34;Remove V={v} x {diff}&#34;)
#             result = result.remove_knot(SvNurbsSurface.V, v, diff)

    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.unify_nurbs_surfaces"><code class="name flex">
<span>def <span class="ident">unify_nurbs_surfaces</span></span>(<span>surfaces, knots_method='UNIFY', knotvector_accuracy=6)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unify_nurbs_surfaces(surfaces, knots_method = &#39;UNIFY&#39;, knotvector_accuracy=6):
    # Unify surface degrees

    degrees_u = [surface.get_degree_u() for surface in surfaces]
    degrees_v = [surface.get_degree_v() for surface in surfaces]

    degree_u = max(degrees_u)
    degree_v = max(degrees_v)
    #print(f&#34;Elevate everything to {degree_u}x{degree_v}&#34;)

    surfaces = [surface.elevate_degree(SvNurbsSurface.U, target=degree_u) for surface in surfaces]
    surfaces = [surface.elevate_degree(SvNurbsSurface.V, target=degree_v) for surface in surfaces]

    # Unify surface knotvectors

    knotvector_tolerance = 10**(-knotvector_accuracy)

    if knots_method == &#39;UNIFY&#39;:

        surfaces = [round_knotvectors(s, knotvector_accuracy) for s in surfaces]
        for i, surface in enumerate(surfaces):
            #print(f&#34;S #{i} KV_U: {surface.get_knotvector_u()}&#34;)
            #print(f&#34;S #{i} KV_V: {surface.get_knotvector_v()}&#34;)
            kv_err = sv_knotvector.check_multiplicity(surface.get_degree_u(), surface.get_knotvector_u(), tolerance=knotvector_tolerance)
            if kv_err is not None:
                raise Exception(f&#34;Surface #{i}: invalid U knotvector: {kv_err}&#34;)

            kv_err = sv_knotvector.check_multiplicity(surface.get_degree_v(), surface.get_knotvector_v(), tolerance=knotvector_tolerance)
            if kv_err is not None:
                raise Exception(f&#34;Surface #{i}: invalid V knotvector: {kv_err}&#34;)

        dst_knots_u = defaultdict(int)
        dst_knots_v = defaultdict(int)
        for surface in surfaces:
            m_u = sv_knotvector.to_multiplicity(surface.get_knotvector_u(), tolerance=knotvector_tolerance)
            m_v = sv_knotvector.to_multiplicity(surface.get_knotvector_v(), tolerance=knotvector_tolerance)

            for u, count in m_u:
                u = round(u, knotvector_accuracy)
                dst_knots_u[u] = max(dst_knots_u[u], count)

            for v, count in m_v:
                v = round(v, knotvector_accuracy)
                dst_knots_v[v] = max(dst_knots_v[v], count)

        result = []
        for surface in surfaces:
            diffs_u = []
            kv_u = np.round(surface.get_knotvector_u(), knotvector_accuracy)
            ms_u = dict(sv_knotvector.to_multiplicity(kv_u, tolerance=knotvector_tolerance))
            for dst_u, dst_multiplicity in dst_knots_u.items():
                src_multiplicity = ms_u.get(dst_u, 0)
                diff = dst_multiplicity - src_multiplicity
                diffs_u.append((dst_u, diff))

            for u, diff in diffs_u:
                if diff &gt; 0:
                    #print(f&#34;S: Insert U = {u} x {diff}&#34;)
                    surface = surface.insert_knot(SvNurbsSurface.U, u, diff)

            diffs_v = []
            kv_v = np.round(surface.get_knotvector_v(), knotvector_accuracy)
            ms_v = dict(sv_knotvector.to_multiplicity(kv_v, tolerance=knotvector_tolerance))
            for dst_v, dst_multiplicity in dst_knots_v.items():
                src_multiplicity = ms_v.get(dst_v, 0)
                diff = dst_multiplicity - src_multiplicity
                diffs_v.append((dst_v, diff))

            for v, diff in diffs_v:
                if diff &gt; 0:
                    #print(f&#34;S: Insert V = {v} x {diff}&#34;)
                    surface = surface.insert_knot(SvNurbsSurface.V, v, diff)

            result.append(surface)

        return result

    elif knots_method == &#39;AVERAGE&#39;:
        kvs = [len(surface.get_control_points()) for surface in surfaces]
        max_kv, min_kv = max(kvs), min(kvs)
        if max_kv != min_kv:
            raise Exception(f&#34;U knotvector averaging is not applicable: Surfaces have different number of control points: {kvs}&#34;)

        kvs = [len(surface.get_control_points()[0]) for surface in surfaces]
        max_kv, min_kv = max(kvs), min(kvs)
        if max_kv != min_kv:
            raise Exception(f&#34;V knotvector averaging is not applicable: Surfaces have different number of control points: {kvs}&#34;)


        knotvectors = np.array([surface.get_knotvector_u() for surface in surfaces])
        knotvector_u = knotvectors.mean(axis=0)

        knotvectors = np.array([surface.get_knotvector_v() for surface in surfaces])
        knotvector_u = knotvectors.mean(axis=0)

        result = []
        for surface in surfaces:
            surface = SvNurbsSurface.build(surface.get_nurbs_implementation(),
                    surface.get_degree_u(), surface.get_degree_v(),
                    knotvector_u, knotvector_v,
                    surface.get_control_points(),
                    surface.get_weights())
            result.append(surface)
        return result
    else:
        raise Exception(&#39;Unsupported knotvector unification method&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvBlendSurface"><code class="flex name class">
<span>class <span class="ident">SvBlendSurface</span></span>
<span>(</span><span>surface1, surface2, curve1, curve2, bulge1, bulge2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvBlendSurface(SvSurface):
    def __init__(self, surface1, surface2, curve1, curve2, bulge1, bulge2):
        self.surface1 = surface1
        self.surface2 = surface2
        self.curve1 = curve1
        self.curve2 = curve2
        self.bulge1 = bulge1
        self.bulge2 = bulge2
        self.u_bounds = (0.0, 1.0)
        self.v_bounds = (0.0, 1.0)

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    def evaluate_array(self, us, vs):
        c1_min, c1_max = self.curve1.get_u_bounds()
        c2_min, c2_max = self.curve2.get_u_bounds()
        c1_us = (c1_max - c1_min) * us + c1_min
        c2_us = (c2_max - c2_min) * us + c2_min

        _, c1_points, _, _, c1_binormals = curve_frame_on_surface_array(self.surface1, self.curve1, c1_us)
        _, c2_points, _, _, c2_binormals = curve_frame_on_surface_array(self.surface2, self.curve2, c2_us)
        c1_binormals = self.bulge1 * c1_binormals
        c2_binormals = self.bulge2 * c2_binormals

        # See also sverchok.utils.curve.bezier.SvCubicBezierCurve.
        # Here we have re-implementation of the same algorithm
        # which works with arrays of control points
        p0s = c1_points                 # (n, 3)
        p1s = c1_points + c1_binormals
        p2s = c2_points + c2_binormals
        p3s = c2_points

        c0 = (1 - vs)**3      # (n,)
        c1 = 3*vs*(1-vs)**2
        c2 = 3*vs**2*(1-vs)
        c3 = vs**3

        # (n,1)
        c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]

        return c0*p0s + c1*p1s + c2*p2s + c3*p3s</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvBlendSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    c1_min, c1_max = self.curve1.get_u_bounds()
    c2_min, c2_max = self.curve2.get_u_bounds()
    c1_us = (c1_max - c1_min) * us + c1_min
    c2_us = (c2_max - c2_min) * us + c2_min

    _, c1_points, _, _, c1_binormals = curve_frame_on_surface_array(self.surface1, self.curve1, c1_us)
    _, c2_points, _, _, c2_binormals = curve_frame_on_surface_array(self.surface2, self.curve2, c2_us)
    c1_binormals = self.bulge1 * c1_binormals
    c2_binormals = self.bulge2 * c2_binormals

    # See also sverchok.utils.curve.bezier.SvCubicBezierCurve.
    # Here we have re-implementation of the same algorithm
    # which works with arrays of control points
    p0s = c1_points                 # (n, 3)
    p1s = c1_points + c1_binormals
    p2s = c2_points + c2_binormals
    p3s = c2_points

    c0 = (1 - vs)**3      # (n,)
    c1 = 3*vs*(1-vs)**2
    c2 = 3*vs**2*(1-vs)
    c3 = vs**3

    # (n,1)
    c0, c1, c2, c3 = c0[:,np.newaxis], c1[:,np.newaxis], c2[:,np.newaxis], c3[:,np.newaxis]

    return c0*p0s + c1*p1s + c2*p2s + c3*p3s</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvBlendSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.u_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvBlendSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvBlendSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.v_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvBlendSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.v_bounds[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConcatSurface"><code class="flex name class">
<span>class <span class="ident">SvConcatSurface</span></span>
<span>(</span><span>direction, surfaces)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvConcatSurface(SvSurface):
    def __init__(self, direction, surfaces):
        self.direction = direction
        self.surfaces = self._unify(surfaces)

        p1 = self._get_p_min(surfaces[0])
        boundaries = [p1]
        boundaries.extend([self._get_p_delta(s) for s in surfaces])
        self.boundaries = np.array(boundaries).cumsum()

    def _unify(self, surfaces):
        if self.direction == &#39;U&#39;:
            min_vs = [s.get_v_min() for s in surfaces]
            max_vs = [s.get_v_max() for s in surfaces]

            if min(min_vs) != max(min_vs) or min(max_vs) != max(max_vs):
                surfaces = [SvReparametrizedSurface.build(s, s.get_u_min(), s.get_u_max(), 0.0, 1.0) for s in surfaces]
            return surfaces
        
        else:
            min_us = [s.get_u_min() for s in surfaces]
            max_us = [s.get_u_max() for s in surfaces]

            if min(min_us) != max(min_us) or min(max_us) != max(max_us):
                surfaces = [SvReparametrizedSurface.build(s, 0.0, 1.0, s.get_v_min(), s.get_v_max()) for s in surfaces]
            return surfaces

    def _get_p_max(self, surface):
        if self.direction == &#39;U&#39;:
            return surface.get_u_max()
        else:
            return surface.get_v_max()

    def _get_p_delta(self, surface):
        if self.direction == &#39;U&#39;:
            return surface.get_u_max() - surface.get_u_min()
        else:
            return surface.get_v_max() - surface.get_v_min()

    def _get_p_min(self, surface):
        if self.direction == &#39;U&#39;:
            return surface.get_u_min()
        else:
            return surface.get_v_min()

    def get_u_min(self):
        if self.direction == &#39;U&#39;:
            return self.boundaries[0]
        else:
            return self.surfaces[0].get_u_min()

    def get_u_max(self):
        if self.direction == &#39;U&#39;:
            return self.boundaries[-1]
        else:
            return self.surfaces[0].get_u_max()

    def get_v_min(self):
        if self.direction == &#39;U&#39;:
            return self.surfaces[0].get_v_min()
        else:
            return self.boundaries[0]

    def get_v_max(self):
        if self.direction == &#39;U&#39;:
            return self.surfaces[0].get_v_max()
        else:
            return self.boundaries[-1]

    def evaluate(self, u, v):
        if self.direction == &#39;U&#39;:
            u_idx = self.boundaries.searchsorted(u, side=&#39;right&#39;)-1
            if u_idx &gt;= len(self.surfaces):
                v_idx = len(self.surfaces)-1
                du = self._get_p_delta(self.surfaces[-1])
            else:
                du = u - self.boundaries[u_idx]
            subsurf = self.surfaces[u_idx]
            return subsurf.evaluate(subsurf.get_u_min()+du, v)
        else:
            v_idx = self.boundaries.searchsorted(v, side=&#39;right&#39;)-1
            if v_idx &gt;= len(self.surfaces):
                v_idx = len(self.surfaces)-1
                dv = self._get_p_delta(self.surfaces[-1])
            else:
                dv = v - self.boundaries[v_idx]
            subsurf = self.surfaces[v_idx]
            return subsurf.evaluate(u, subsurf.get_v_min()+dv)

    def evaluate_array(self, us, vs):
        # TODO: numpy implementation
        return np.vectorize(self.evaluate, signature=&#39;(),()-&gt;(3)&#39;)(us, vs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvConcatSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    if self.direction == &#39;U&#39;:
        u_idx = self.boundaries.searchsorted(u, side=&#39;right&#39;)-1
        if u_idx &gt;= len(self.surfaces):
            v_idx = len(self.surfaces)-1
            du = self._get_p_delta(self.surfaces[-1])
        else:
            du = u - self.boundaries[u_idx]
        subsurf = self.surfaces[u_idx]
        return subsurf.evaluate(subsurf.get_u_min()+du, v)
    else:
        v_idx = self.boundaries.searchsorted(v, side=&#39;right&#39;)-1
        if v_idx &gt;= len(self.surfaces):
            v_idx = len(self.surfaces)-1
            dv = self._get_p_delta(self.surfaces[-1])
        else:
            dv = v - self.boundaries[v_idx]
        subsurf = self.surfaces[v_idx]
        return subsurf.evaluate(u, subsurf.get_v_min()+dv)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConcatSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    # TODO: numpy implementation
    return np.vectorize(self.evaluate, signature=&#39;(),()-&gt;(3)&#39;)(us, vs)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConcatSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    if self.direction == &#39;U&#39;:
        return self.boundaries[-1]
    else:
        return self.surfaces[0].get_u_max()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConcatSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    if self.direction == &#39;U&#39;:
        return self.boundaries[0]
    else:
        return self.surfaces[0].get_u_min()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConcatSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    if self.direction == &#39;U&#39;:
        return self.surfaces[0].get_v_max()
    else:
        return self.boundaries[-1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConcatSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    if self.direction == &#39;U&#39;:
        return self.surfaces[0].get_v_min()
    else:
        return self.boundaries[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface"><code class="flex name class">
<span>class <span class="ident">SvConstPipeSurface</span></span>
<span>(</span><span>curve, radius, algorithm='FRENET', resolution=50)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvConstPipeSurface(SvSurface):
    __description__ = &#34;Pipe&#34;

    def __init__(self, curve, radius, algorithm = FRENET, resolution=50):
        self.curve = curve
        self.radius = radius
        self.circle = SvCircle(Matrix(), radius)
        self.algorithm = algorithm
        self.normal_delta = 0.00001
        self.u_bounds = self.circle.get_u_bounds()
        if algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            self.calculator = DifferentialRotationCalculator(curve, algorithm, resolution)

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.curve.get_u_bounds()[0]

    def get_v_max(self):
        return self.curve.get_u_bounds()[1]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def get_matrix(self, tangent):
        return MathutilsRotationCalculator.get_matrix(tangent, scale=1.0,
                axis=2,
                algorithm = self.algorithm,
                scale_all=False)

    def get_matrices(self, ts):
        if self.algorithm in {FRENET, ZERO, TRACK_NORMAL}:
            return self.calculator.get_matrices(ts)
        elif self.algorithm in {HOUSEHOLDER, TRACK, DIFF}:
            tangents = self.curve.tangent_array(ts)
            matrices = np.vectorize(lambda t : self.get_matrix(t), signature=&#39;(3)-&gt;(3,3)&#39;)(tangents)
            return matrices
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)

    def evaluate_array(self, us, vs):
        profile_vectors = self.circle.evaluate_array(us)
        u_min, u_max = self.circle.get_u_bounds()
        v_min, v_max = self.curve.get_u_bounds()
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.curve.evaluate(v_min)
        extrusion_points = self.curve.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        matrices = self.get_matrices(vs)

        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        result = result + extrusion_start
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    profile_vectors = self.circle.evaluate_array(us)
    u_min, u_max = self.circle.get_u_bounds()
    v_min, v_max = self.curve.get_u_bounds()
    profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
    extrusion_start = self.curve.evaluate(v_min)
    extrusion_points = self.curve.evaluate_array(vs)
    extrusion_vectors = extrusion_points - extrusion_start

    matrices = self.get_matrices(vs)

    profile_vectors = (matrices @ profile_vectors)[:,:,0]
    result = extrusion_vectors + profile_vectors
    result = result + extrusion_start
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_matrices"><code class="name flex">
<span>def <span class="ident">get_matrices</span></span>(<span>self, ts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrices(self, ts):
    if self.algorithm in {FRENET, ZERO, TRACK_NORMAL}:
        return self.calculator.get_matrices(ts)
    elif self.algorithm in {HOUSEHOLDER, TRACK, DIFF}:
        tangents = self.curve.tangent_array(ts)
        matrices = np.vectorize(lambda t : self.get_matrix(t), signature=&#39;(3)-&gt;(3,3)&#39;)(tangents)
        return matrices
    else:
        raise Exception(&#34;Unsupported algorithm&#34;)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_matrix"><code class="name flex">
<span>def <span class="ident">get_matrix</span></span>(<span>self, tangent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrix(self, tangent):
    return MathutilsRotationCalculator.get_matrix(tangent, scale=1.0,
            axis=2,
            algorithm = self.algorithm,
            scale_all=False)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.u_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.curve.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.curve.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface"><code class="flex name class">
<span>class <span class="ident">SvCurveLerpSurface</span></span>
<span>(</span><span>curve1, curve2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvCurveLerpSurface(SvSurface):
    __description__ = &#34;Ruled&#34;

    def __init__(self, curve1, curve2):
        self.curve1 = curve1
        self.curve2 = curve2
        self.normal_delta = 0.0001
        self.v_bounds = (0.0, 1.0)
        self.u_bounds = (0.0, 1.0)
        self.c1_min, self.c1_max = curve1.get_u_bounds()
        self.c2_min, self.c2_max = curve2.get_u_bounds()

    @classmethod
    def build(cls, curve1, curve2, vmin=0.0, vmax=1.0):
        if hasattr(curve1, &#39;make_ruled_surface&#39;):
            try:
                return curve1.make_ruled_surface(curve2, vmin, vmax)
            except TypeError as e:
                # make_ruled_surface method can raise TypeError in case
                # it can&#39;t work with given curve2.
                # In this case we must use generic method.
                sv_logger.debug(&#34;Can&#39;t make a native ruled surface: %s&#34;, e)
                pass

        # generic method
        surface = SvCurveLerpSurface(curve1, curve2)
        surface.v_bounds = (vmin, vmax)
        return surface

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        us1 = (self.c1_max - self.c1_min) * us + self.c1_min
        us2 = (self.c2_max - self.c2_min) * us + self.c2_min
        c1_points = self.curve1.evaluate_array(us1)
        c2_points = self.curve2.evaluate_array(us2)
        vs = vs[np.newaxis].T
        points = (1.0 - vs)*c1_points + vs*c2_points
        return points

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>curve1, curve2, vmin=0.0, vmax=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, curve1, curve2, vmin=0.0, vmax=1.0):
    if hasattr(curve1, &#39;make_ruled_surface&#39;):
        try:
            return curve1.make_ruled_surface(curve2, vmin, vmax)
        except TypeError as e:
            # make_ruled_surface method can raise TypeError in case
            # it can&#39;t work with given curve2.
            # In this case we must use generic method.
            sv_logger.debug(&#34;Can&#39;t make a native ruled surface: %s&#34;, e)
            pass

    # generic method
    surface = SvCurveLerpSurface(curve1, curve2)
    surface.v_bounds = (vmin, vmax)
    return surface</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    return self.u_bounds[1] - self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    return self.v_bounds[1] - self.v_bounds[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    us1 = (self.c1_max - self.c1_min) * us + self.c1_min
    us2 = (self.c2_max - self.c2_min) * us + self.c2_min
    c1_points = self.curve1.evaluate_array(us1)
    c2_points = self.curve2.evaluate_array(us2)
    vs = vs[np.newaxis].T
    points = (1.0 - vs)*c1_points + vs*c2_points
    return points</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.u_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.v_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.v_bounds[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface"><code class="flex name class">
<span>class <span class="ident">SvDeformedByFieldSurface</span></span>
<span>(</span><span>surface, field, coefficient=1.0, by_normal=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvDeformedByFieldSurface(SvSurface):
    def __init__(self, surface, field, coefficient=1.0, by_normal=None):
        self.surface = surface
        self.field = field
        self.coefficient = coefficient
        self.by_normal = by_normal
        self.normal_delta = 0.0001
        self.__description__ = &#34;{}({})&#34;.format(field, surface)

    def get_coord_mode(self):
        return self.surface.get_coord_mode()

    def get_u_min(self):
        return self.surface.get_u_min()

    def get_u_max(self):
        return self.surface.get_u_max()

    def get_v_min(self):
        return self.surface.get_v_min()

    def get_v_max(self):
        return self.surface.get_v_max()

    @property
    def u_size(self):
        return self.surface.u_size

    @property
    def v_size(self):
        return self.surface.v_size

    @property
    def has_input_matrix(self):
        return self.surface.has_input_matrix

    def get_input_matrix(self):
        return self.surface.get_input_matrix()

    def evaluate(self, u, v):
        p = self.surface.evaluate(u, v)
        vec = self.field.evaluate(p[0], p[1], p[2])
        if self.by_normal == PROJECT:
            normal = self.surface.normal(u, v)
            vec = np.dot(vec, normal) * normal / np.dot(normal, normal)
        elif self.by_normal == COPROJECT:
            normal = self.surface.normal(u, v)
            projection = np.dot(vec, normal) * normal / np.dot(normal, normal)
            vec = vec - projection
        return p + self.coefficient * vec

    def evaluate_array(self, us, vs):
        ps = self.surface.evaluate_array(us, vs)
        xs, ys, zs = ps[:,0], ps[:,1], ps[:,2]
        vxs, vys, vzs = self.field.evaluate_grid(xs, ys, zs)
        vecs = np.stack((vxs, vys, vzs)).T
        if self.by_normal == PROJECT:
            normals = self.surface.normal_array(us, vs)
            vecs = _dot(vecs, normals) * normals / _dot(normals, normals)
        elif self.by_normal == COPROJECT:
            normals = self.surface.normal_array(us, vs)
            projections = _dot(vecs, normals) * normals / _dot(normals, normals)
            vecs = vecs - projections
        return ps + self.coefficient * vecs

    def normal(self, u, v):
        h = self.normal_delta
        p = self.evaluate(u, v)
        p_u = self.evaluate(u+h, v)
        p_v = self.evaluate(u, v+h)
        du = (p_u - p) / h
        dv = (p_v - p) / h
        normal = np.cross(du, dv)
        n = np.linalg.norm(normal)
        normal = normal / n
        return normal

    # def normal_vertices_array(self, us, vs):
    #     surf_vertices = self.evaluate_array(us, vs)
    #     u_plus = self.evaluate_array(us + self.normal_delta, vs)
    #     v_plus = self.evaluate_array(us, vs + self.normal_delta)
    #     du = u_plus - surf_vertices
    #     dv = v_plus - surf_vertices
    #     #self.info(&#34;Du: %s&#34;, du)
    #     #self.info(&#34;Dv: %s&#34;, dv)
    #     normal = np.cross(du, dv)
    #     norm = np.linalg.norm(normal, axis=1)[np.newaxis].T
    #     #if norm != 0:
    #     normal = normal / norm
    #     #self.info(&#34;Normals: %s&#34;, normal)
    #     return normal, surf_vertices</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.has_input_matrix"><code class="name">var <span class="ident">has_input_matrix</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_input_matrix(self):
    return self.surface.has_input_matrix</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    return self.surface.u_size</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    return self.surface.v_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    p = self.surface.evaluate(u, v)
    vec = self.field.evaluate(p[0], p[1], p[2])
    if self.by_normal == PROJECT:
        normal = self.surface.normal(u, v)
        vec = np.dot(vec, normal) * normal / np.dot(normal, normal)
    elif self.by_normal == COPROJECT:
        normal = self.surface.normal(u, v)
        projection = np.dot(vec, normal) * normal / np.dot(normal, normal)
        vec = vec - projection
    return p + self.coefficient * vec</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    ps = self.surface.evaluate_array(us, vs)
    xs, ys, zs = ps[:,0], ps[:,1], ps[:,2]
    vxs, vys, vzs = self.field.evaluate_grid(xs, ys, zs)
    vecs = np.stack((vxs, vys, vzs)).T
    if self.by_normal == PROJECT:
        normals = self.surface.normal_array(us, vs)
        vecs = _dot(vecs, normals) * normals / _dot(normals, normals)
    elif self.by_normal == COPROJECT:
        normals = self.surface.normal_array(us, vs)
        projections = _dot(vecs, normals) * normals / _dot(normals, normals)
        vecs = vecs - projections
    return ps + self.coefficient * vecs</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_coord_mode"><code class="name flex">
<span>def <span class="ident">get_coord_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coord_mode(self):
    return self.surface.get_coord_mode()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_input_matrix"><code class="name flex">
<span>def <span class="ident">get_input_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_matrix(self):
    return self.surface.get_input_matrix()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.surface.get_u_max()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.surface.get_u_min()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.surface.get_v_max()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.surface.get_v_min()</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal(self, u, v):
    h = self.normal_delta
    p = self.evaluate(u, v)
    p_u = self.evaluate(u+h, v)
    p_v = self.evaluate(u, v+h)
    du = (p_u - p) / h
    dv = (p_v - p) / h
    normal = np.cross(du, dv)
    n = np.linalg.norm(normal)
    normal = normal / n
    return normal</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurveCurveSurface</span></span>
<span>(</span><span>u_curve, v_curve, origin='profile')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurveCurveSurface(SvSurface):
    def __init__(self, u_curve, v_curve, origin = PROFILE):
        self.u_curve = u_curve
        self.v_curve = v_curve
        self.origin = origin
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(u_curve)

    def evaluate(self, u, v):
        u_point = self.u_curve.evaluate(u)
        u_min, u_max = self.u_curve.get_u_bounds()
        v_min, v_max = self.v_curve.get_u_bounds()
        v0 = self.v_curve.evaluate(v_min)
        v_point = self.v_curve.evaluate(v)
        if self.origin == EXTRUSION:
            result = u_point + v_point
        else:
            result = u_point + (v_point - v0)
        return result

    def evaluate_array(self, us, vs):
        u_points = self.u_curve.evaluate_array(us)
        u_min, u_max = self.u_curve.get_u_bounds()
        v_min, v_max = self.v_curve.get_u_bounds()
        v0 = self.v_curve.evaluate(v_min)
        v_points = self.v_curve.evaluate_array(vs)
        if self.origin == EXTRUSION:
            result = u_points + v_points
        else:
            result = u_points + (v_points - v0)
        return result

    def get_u_min(self):
        return self.u_curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.u_curve.get_u_bounds()[1]

    def get_v_min(self):
        return self.v_curve.get_u_bounds()[0]

    def get_v_max(self):
        return self.v_curve.get_u_bounds()[1]

    @property
    def u_size(self):
        m,M = self.u_curve.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        m,M = self.v_curve.get_u_bounds()
        return M - m</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    m,M = self.u_curve.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    m,M = self.v_curve.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    u_point = self.u_curve.evaluate(u)
    u_min, u_max = self.u_curve.get_u_bounds()
    v_min, v_max = self.v_curve.get_u_bounds()
    v0 = self.v_curve.evaluate(v_min)
    v_point = self.v_curve.evaluate(v)
    if self.origin == EXTRUSION:
        result = u_point + v_point
    else:
        result = u_point + (v_point - v0)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    u_points = self.u_curve.evaluate_array(us)
    u_min, u_max = self.u_curve.get_u_bounds()
    v_min, v_max = self.v_curve.get_u_bounds()
    v0 = self.v_curve.evaluate(v_min)
    v_points = self.v_curve.evaluate_array(vs)
    if self.origin == EXTRUSION:
        result = u_points + v_points
    else:
        result = u_points + (v_points - v0)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.u_curve.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.u_curve.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.v_curve.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.v_curve.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurveFrenetSurface</span></span>
<span>(</span><span>profile, extrusion, origin='profile')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurveFrenetSurface(SvSurface):
    def __init__(self, profile, extrusion, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start
        frenet, _ , _ = self.extrusion.frame_array(vs)
        profile_vectors = (frenet @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

    @property
    def u_size(self):
        m,M = self.profile.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        m,M = self.extrusion.get_u_bounds()
        return M - m</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    m,M = self.profile.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    m,M = self.extrusion.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    profile_points = self.profile.evaluate_array(us)
    u_min, u_max = self.profile.get_u_bounds()
    v_min, v_max = self.extrusion.get_u_bounds()
    profile_vectors = profile_points
    profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
    extrusion_start = self.extrusion.evaluate(v_min)
    extrusion_points = self.extrusion.evaluate_array(vs)
    extrusion_vectors = extrusion_points - extrusion_start
    frenet, _ , _ = self.extrusion.frame_array(vs)
    profile_vectors = (frenet @ profile_vectors)[:,:,0]
    result = extrusion_vectors + profile_vectors
    if self.origin == EXTRUSION:
        result = result + self.extrusion.evaluate(v_min)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.profile.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.profile.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.extrusion.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.extrusion.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurveMathutilsSurface</span></span>
<span>(</span><span>profile, extrusion, algorithm, orient_axis='Z', up_axis='X', origin='profile')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurveMathutilsSurface(SvSurface):
    def __init__(self, profile, extrusion, algorithm, orient_axis=&#39;Z&#39;, up_axis=&#39;X&#39;, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.algorithm = algorithm
        self.orient_axis = orient_axis
        self.up_axis = up_axis
        self.origin = origin
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def get_matrix(self, tangent):
        x = Vector((1.0, 0.0, 0.0))
        y = Vector((0.0, 1.0, 0.0))
        z = Vector((0.0, 0.0, 1.0))

        if self.orient_axis == &#39;X&#39;:
            ax1, ax2, ax3 = x, y, z
        elif self.orient_axis == &#39;Y&#39;:
            ax1, ax2, ax3 = y, x, z
        else:
            ax1, ax2, ax3 = z, x, y

        if self.algorithm == &#39;householder&#39;:
            rot = autorotate_householder(ax1, tangent).inverted()
        elif self.algorithm == &#39;track&#39;:
            rot = autorotate_track(self.orient_axis, tangent, self.up_axis)
        elif self.algorithm == &#39;diff&#39;:
            rot = autorotate_diff(tangent, ax1)
        else:
            raise Exception(&#34;Unsupported algorithm&#34;)

        return rot

    def get_matrices(self, vs):
        tangents = self.extrusion.tangent_array(vs)
        matrices = []
        for tangent in tangents:
            matrix = self.get_matrix(Vector(tangent)).to_3x3()
            matrices.append(matrix)
        return np.array(matrices)

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        matrices = self.get_matrices(vs)

        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    profile_points = self.profile.evaluate_array(us)
    u_min, u_max = self.profile.get_u_bounds()
    v_min, v_max = self.extrusion.get_u_bounds()
    profile_vectors = profile_points
    profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
    extrusion_start = self.extrusion.evaluate(v_min)
    extrusion_points = self.extrusion.evaluate_array(vs)
    extrusion_vectors = extrusion_points - extrusion_start

    matrices = self.get_matrices(vs)

    profile_vectors = (matrices @ profile_vectors)[:,:,0]
    result = extrusion_vectors + profile_vectors
    if self.origin == EXTRUSION:
        result = result + self.extrusion.evaluate(v_min)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_matrices"><code class="name flex">
<span>def <span class="ident">get_matrices</span></span>(<span>self, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrices(self, vs):
    tangents = self.extrusion.tangent_array(vs)
    matrices = []
    for tangent in tangents:
        matrix = self.get_matrix(Vector(tangent)).to_3x3()
        matrices.append(matrix)
    return np.array(matrices)</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_matrix"><code class="name flex">
<span>def <span class="ident">get_matrix</span></span>(<span>self, tangent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrix(self, tangent):
    x = Vector((1.0, 0.0, 0.0))
    y = Vector((0.0, 1.0, 0.0))
    z = Vector((0.0, 0.0, 1.0))

    if self.orient_axis == &#39;X&#39;:
        ax1, ax2, ax3 = x, y, z
    elif self.orient_axis == &#39;Y&#39;:
        ax1, ax2, ax3 = y, x, z
    else:
        ax1, ax2, ax3 = z, x, y

    if self.algorithm == &#39;householder&#39;:
        rot = autorotate_householder(ax1, tangent).inverted()
    elif self.algorithm == &#39;track&#39;:
        rot = autorotate_track(self.orient_axis, tangent, self.up_axis)
    elif self.algorithm == &#39;diff&#39;:
        rot = autorotate_diff(tangent, ax1)
    else:
        raise Exception(&#34;Unsupported algorithm&#34;)

    return rot</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.profile.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.profile.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.extrusion.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.extrusion.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurveNormalDirSurface</span></span>
<span>(</span><span>profile, extrusion, plane_normal, origin='profile')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurveNormalDirSurface(SvSurface):
    def __init__(self, profile, extrusion, plane_normal, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.plane_normal = np.array(plane_normal)
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start
        matrices, _ , _ = self.extrusion.frame_by_plane_array(vs, self.plane_normal)
        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

    @property
    def u_size(self):
        m,M = self.profile.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        m,M = self.extrusion.get_u_bounds()
        return M - m</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    m,M = self.profile.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    m,M = self.extrusion.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    profile_points = self.profile.evaluate_array(us)
    u_min, u_max = self.profile.get_u_bounds()
    v_min, v_max = self.extrusion.get_u_bounds()
    profile_vectors = profile_points
    profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
    extrusion_start = self.extrusion.evaluate(v_min)
    extrusion_points = self.extrusion.evaluate_array(vs)
    extrusion_vectors = extrusion_points - extrusion_start
    matrices, _ , _ = self.extrusion.frame_by_plane_array(vs, self.plane_normal)
    profile_vectors = (matrices @ profile_vectors)[:,:,0]
    result = extrusion_vectors + profile_vectors
    if self.origin == EXTRUSION:
        result = result + self.extrusion.evaluate(v_min)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.profile.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.profile.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.extrusion.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.extrusion.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurvePointSurface</span></span>
<span>(</span><span>curve, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurvePointSurface(SvSurface):
    def __init__(self, curve, point):
        self.curve = curve
        self.point = point
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(curve)

    @staticmethod
    def build(curve, point):
        if hasattr(curve, &#39;extrude_to_point&#39;):
            try:
                return curve.extrude_to_point(point)
            except UnsupportedCurveTypeException:
                pass
        return SvExtrudeCurvePointSurface(curve, point)

    def evaluate(self, u, v):
        point_on_curve = self.curve.evaluate(u)
        return (1.0 - v) * point_on_curve + v * self.point

    def evaluate_array(self, us, vs):
        points_on_curve = self.curve.evaluate_array(us)
        vs = vs[np.newaxis].T
        return (1.0 - vs) * points_on_curve + vs * self.point

    def get_u_min(self):
        return self.curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.curve.get_u_bounds()[1]

    def get_v_min(self):
        return 0.0

    def get_v_max(self):
        return 1.0

    @property
    def u_size(self):
        m,M = self.curve.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        return 1.0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>curve, point)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build(curve, point):
    if hasattr(curve, &#39;extrude_to_point&#39;):
        try:
            return curve.extrude_to_point(point)
        except UnsupportedCurveTypeException:
            pass
    return SvExtrudeCurvePointSurface(curve, point)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    m,M = self.curve.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    return 1.0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    point_on_curve = self.curve.evaluate(u)
    return (1.0 - v) * point_on_curve + v * self.point</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    points_on_curve = self.curve.evaluate_array(us)
    vs = vs[np.newaxis].T
    return (1.0 - vs) * points_on_curve + vs * self.point</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.curve.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.curve.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return 1.0</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return 0.0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurveTrackNormalSurface</span></span>
<span>(</span><span>profile, extrusion, resolution, origin='profile')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurveTrackNormalSurface(SvSurface):
    def __init__(self, profile, extrusion, resolution, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.normal_delta = 0.0001
        self.tracker = SvNormalTrack(extrusion, resolution)
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_vectors = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        matrices = self.tracker.evaluate_array(vs)
        profile_vectors = (matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + extrusion_start
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    profile_vectors = self.profile.evaluate_array(us)
    u_min, u_max = self.profile.get_u_bounds()
    v_min, v_max = self.extrusion.get_u_bounds()
    profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
    extrusion_start = self.extrusion.evaluate(v_min)
    extrusion_points = self.extrusion.evaluate_array(vs)
    extrusion_vectors = extrusion_points - extrusion_start

    matrices = self.tracker.evaluate_array(vs)
    profile_vectors = (matrices @ profile_vectors)[:,:,0]
    result = extrusion_vectors + profile_vectors
    if self.origin == EXTRUSION:
        result = result + extrusion_start
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.profile.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.profile.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.extrusion.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.extrusion.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurveVectorSurface</span></span>
<span>(</span><span>curve, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurveVectorSurface(SvSurface):
    def __init__(self, curve, vector):
        self.curve = curve
        self.vector = np.array(vector)
        self.normal_delta = 0.0001
        self.__description__ = &#34;Extrusion of {}&#34;.format(curve)

    @classmethod
    def build(cls, curve, vector):
        if hasattr(curve, &#39;extrude_along_vector&#39;):
            try:
                return curve.extrude_along_vector(vector)
            except UnsupportedCurveTypeException:
                pass
        return SvExtrudeCurveVectorSurface(curve, vector)

    def evaluate(self, u, v):
        point_on_curve = self.curve.evaluate(u)
        return point_on_curve + v * self.vector

    def evaluate_array(self, us, vs):
        points_on_curve = self.curve.evaluate_array(us)
        return points_on_curve + vs[np.newaxis].T * self.vector

    def get_u_min(self):
        return self.curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.curve.get_u_bounds()[1]

    def get_v_min(self):
        return 0.0

    def get_v_max(self):
        return 1.0

    @property
    def u_size(self):
        m,M = self.curve.get_u_bounds()
        return M - m

    @property
    def v_size(self):
        return 1.0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>curve, vector)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, curve, vector):
    if hasattr(curve, &#39;extrude_along_vector&#39;):
        try:
            return curve.extrude_along_vector(vector)
        except UnsupportedCurveTypeException:
            pass
    return SvExtrudeCurveVectorSurface(curve, vector)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    m,M = self.curve.get_u_bounds()
    return M - m</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    return 1.0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    point_on_curve = self.curve.evaluate(u)
    return point_on_curve + v * self.vector</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    points_on_curve = self.curve.evaluate_array(us)
    return points_on_curve + vs[np.newaxis].T * self.vector</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.curve.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.curve.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return 1.0</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return 0.0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface"><code class="flex name class">
<span>class <span class="ident">SvExtrudeCurveZeroTwistSurface</span></span>
<span>(</span><span>profile, extrusion, resolution, origin='profile')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvExtrudeCurveZeroTwistSurface(SvSurface):
    def __init__(self, profile, extrusion, resolution, origin = PROFILE):
        self.profile = profile
        self.extrusion = extrusion
        self.origin = origin
        self.normal_delta = 0.0001
        self.extrusion.pre_calc_torsion_integral(resolution)
        self.__description__ = &#34;Extrusion of {}&#34;.format(profile)

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]

    def evaluate_array(self, us, vs):
        profile_points = self.profile.evaluate_array(us)
        u_min, u_max = self.profile.get_u_bounds()
        v_min, v_max = self.extrusion.get_u_bounds()
        profile_vectors = profile_points
        profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
        extrusion_start = self.extrusion.evaluate(v_min)
        extrusion_points = self.extrusion.evaluate_array(vs)
        extrusion_vectors = extrusion_points - extrusion_start

        frenet, _ , _ = self.extrusion.frame_array(vs)

        angles = - self.extrusion.torsion_integral(vs)
        n = len(us)
        zeros = np.zeros((n,))
        ones = np.ones((n,))
        row1 = np.stack((np.cos(angles), np.sin(angles), zeros)).T # (n, 3)
        row2 = np.stack((-np.sin(angles), np.cos(angles), zeros)).T # (n, 3)
        row3 = np.stack((zeros, zeros, ones)).T # (n, 3)
        rotation_matrices = np.dstack((row1, row2, row3))

        profile_vectors = (frenet @ rotation_matrices @ profile_vectors)[:,:,0]
        result = extrusion_vectors + profile_vectors
        if self.origin == EXTRUSION:
            result = result + self.extrusion.evaluate(v_min)
        return result

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.extrusion.get_u_bounds()[0]

    def get_v_max(self):
        return self.extrusion.get_u_bounds()[1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    profile_points = self.profile.evaluate_array(us)
    u_min, u_max = self.profile.get_u_bounds()
    v_min, v_max = self.extrusion.get_u_bounds()
    profile_vectors = profile_points
    profile_vectors = np.transpose(profile_vectors[np.newaxis], axes=(1, 2, 0))
    extrusion_start = self.extrusion.evaluate(v_min)
    extrusion_points = self.extrusion.evaluate_array(vs)
    extrusion_vectors = extrusion_points - extrusion_start

    frenet, _ , _ = self.extrusion.frame_array(vs)

    angles = - self.extrusion.torsion_integral(vs)
    n = len(us)
    zeros = np.zeros((n,))
    ones = np.ones((n,))
    row1 = np.stack((np.cos(angles), np.sin(angles), zeros)).T # (n, 3)
    row2 = np.stack((-np.sin(angles), np.cos(angles), zeros)).T # (n, 3)
    row3 = np.stack((zeros, zeros, ones)).T # (n, 3)
    rotation_matrices = np.dstack((row1, row2, row3))

    profile_vectors = (frenet @ rotation_matrices @ profile_vectors)[:,:,0]
    result = extrusion_vectors + profile_vectors
    if self.origin == EXTRUSION:
        result = result + self.extrusion.evaluate(v_min)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.profile.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.profile.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.extrusion.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.extrusion.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface"><code class="flex name class">
<span>class <span class="ident">SvInterpolatingSurface</span></span>
<span>(</span><span>u_bounds, v_bounds, u_spline_constructor, v_splines, reparametrize_v_splines=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvInterpolatingSurface(SvSurface):
    __description__ = &#34;Interpolating&#34;

    def __init__(self, u_bounds, v_bounds, u_spline_constructor, v_splines, reparametrize_v_splines=True):
        if reparametrize_v_splines:
            self.v_splines = [reparametrize_curve(spline) for spline in v_splines]
        else:
            for spline in v_splines:
                m,M = spline.get_u_bounds()
                if m != 0.0 or M != 1.0:
                    raise Exception(&#34;one of splines has to be reparametrized&#34;)
            self.v_splines = v_splines
        self.u_spline_constructor = u_spline_constructor
        self.u_bounds = u_bounds
        self.v_bounds = v_bounds

        # Caches
        # v -&gt; Spline
        self._u_splines = {}
        # (u,v) -&gt; vertex
        self._eval_cache = {}
        # (u,v) -&gt; normal
        self._normal_cache = {}

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]
        #v = 0.0
        #verts = [spline.evaluate(v) for spline in self.v_splines]
        #return self.get_u_spline(v, verts).u_size

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]
        #return self.v_splines[0].v_size

    def get_u_spline(self, v, vertices):
        &#34;&#34;&#34;Get a spline along U direction for specified value of V coordinate&#34;&#34;&#34;
        spline = self._u_splines.get(v, None)
        if spline is not None:
            return spline
        else:
            spline = self.u_spline_constructor(vertices)
            self._u_splines[v] = spline
            return spline

    def _evaluate(self, u, v):
        spline_vertices = []
        for spline in self.v_splines:
            point = spline.evaluate(v)
            spline_vertices.append(point)
        #spline_vertices = [spline.evaluate(v) for spline in self.v_splines]
        u_spline = self.get_u_spline(v, spline_vertices)
        result = u_spline.evaluate(u)
        return result

    def evaluate(self, u, v):
        result = self._eval_cache.get((u,v), None)
        if result is not None:
            return result
        else:
            result = self._evaluate(u, v)
            self._eval_cache[(u,v)] = result
            return result

#     def evaluate_array(self, us, vs):
#         # FIXME: To be optimized!
#         normals = [self._evaluate(u, v) for u,v in zip(us, vs)]
#         return np.array(normals)

    def evaluate_array(self, us, vs):
        result = np.empty((len(us), 3))
        v_to_u = defaultdict(list)
        v_to_i = defaultdict(list)
        for i, (u, v) in enumerate(zip(us, vs)):
            v_to_u[v].append(u)
            v_to_i[v].append(i)

        # here we rely on fact that in Python 3.7+ dicts are ordered.
        all_vs = np.array(list(v_to_u.keys()))
        v_spline_points = np.array([spline.evaluate_array(all_vs) for spline in self.v_splines])

        for v_idx, (v, us_by_v) in enumerate(v_to_u.items()):
            is_by_v = v_to_i[v]
            spline_vertices = []
            for spline_idx, spline in enumerate(self.v_splines):
                point = v_spline_points[spline_idx,v_idx]
                #point = spline.evaluate(v)
                spline_vertices.append(point)
            u_spline = self.get_u_spline(v, spline_vertices)
            points = u_spline.evaluate_array(np.array(us_by_v))
            idxs = np.array(is_by_v)[np.newaxis].T
            np.put_along_axis(result, idxs, points, axis=0)
        return result

    def _normal(self, u, v):
        h = 0.001
        point = self.evaluate(u, v)
        # we know this exists because it was filled in evaluate()
        u_spline = self._u_splines[v]
        u_tangent = u_spline.tangent(u)
        point_v = self.evaluate(u, v+h)
        dv = (point_v - point)/h
        n = np.cross(u_tangent, dv)
        norm = np.linalg.norm(n)
        if norm != 0:
            n = n / norm
        return n

    def normal(self, u, v):
        result = self._normal_cache.get((u,v), None)
        if result is not None:
            return result
        else:
            result = self._normal(u, v)
            self._normal_cache[(u,v)] = result
            return result

#     def normal_array(self, us, vs):
#         # FIXME: To be optimized!
#         normals = [self._normal(u, v) for u,v in zip(us, vs)]
#         return np.array(normals)

    def normal_vertices_array(self, us, vs):
        h = 1e-4 # (np.array([1], dtype=np.float64)/100000000)[0] # 0.0001 One can use float64 of numpy. Blender float relax now. ))) 1e-8 is a diameter of hydrogen atom.
        _points         = np.empty( (0, 3), dtype=np.float64)
        _points_u_h     = np.empty( (0, 3), dtype=np.float64)
        _points_v_h     = np.empty( (0, 3), dtype=np.float64)
        v_to_u = defaultdict(list)
        v_to_i = defaultdict(list)
        for i, (u, v) in enumerate(zip(us, vs)):
            v_to_u[v].append(u)
            v_to_i[v].append(i)
        v_to_i_flatten = np.hstack(np.array( list(v_to_i.values())).flatten())

        list_spline_v = []
        list_spline_h = []
        _v = np.array( list(v_to_u.keys()), dtype=np.float64 )
        # A remark about a reverse. Algorithm cannot calc vectors out of a surface.
        # So calc that vectors in a reverse direction into the surface then reverse that vectors.
        # TODO: need attention for case - may be do %uv_bounds if uv coords are circled?
        # Here is no params about this for a while. So use reverse.
        for i_spline, v_spline in enumerate(self.v_splines):
            v_min, v_max = v_spline.get_u_bounds()
            _vx = (v_max-v_min)*_v+v_min
            _list_v_i = _vx
            _list_h_i = np.where( _vx+h&lt;=v_max, _vx+h, _vx-h ) # if need point out of surface then do step in reverse direction
            list_spline_v.append( _list_v_i )
            list_spline_h.append( _list_h_i )

        r_v = []
        r_h = []
        for i, v_spline in enumerate(self.v_splines):
            _r_v, _r_h = v_spline.evaluate_array( np.concatenate( (list_spline_v[i], list_spline_h[i]) )).reshape(2,-1,3) # to increase performance for one call
            r_v.append( _r_v )
            r_h.append( _r_h )

        u_min, u_max = 0.0, 1.0
        
        for i_on_spline, (v, _us_by_v) in enumerate(v_to_u.items()):
            us_by_v = np.array(_us_by_v)
            spline_vertices = []
            spline_vertices_h = []

            for i_spline, v_spline in enumerate(self.v_splines):
                point_v = r_v[i_spline][i_on_spline]
                point_h = r_h[i_spline][i_on_spline]
                spline_vertices.append(point_v)
                spline_vertices_h.append(point_h)

            u_spline   = self.get_u_spline(v  , spline_vertices  )
            if v+h &lt;= v_max:
                u_spline_h = self.get_u_spline(v+h, spline_vertices_h)
            else:
                # curve for reversed vertices
                u_spline_h = self.get_u_spline(v-h, spline_vertices_h)

            us_v = us_by_v
            not_reversed_us = us_by_v + h &lt;= u_max
            us_h_gb = np.where( not_reversed_us, us_by_v+h, us_by_v-h )

            points, points_u_h = u_spline.evaluate_array( np.concatenate( (us_v, us_h_gb) ) ).reshape(2,-1,3) # to increase performance for one call
            points_u_h = np.where( not_reversed_us.T[:,np.newaxis], points_u_h, -(points_u_h-points)+points) # reverse some vectors in u direction
            points_v_h = u_spline_h.evaluate_array(us_by_v)
            _points     = np.concatenate( (_points, points) )
            _points_u_h = np.concatenate( (_points_u_h, points_u_h) )
            if v+h &lt;= v_max:
                _points_v_h = np.concatenate( (_points_v_h, points_v_h) )
            else:
                # reverse points if curve is reversed
                _points_v_h = np.concatenate( (_points_v_h, -(points_v_h-points)+points) ) # reverse some vectors in v direction

        _dvs = (_points_v_h - _points)/h
        _dus = (_points_u_h - _points)/h
        _normals = np.cross(_dus, _dvs)
        _norms = np.linalg.norm(_normals, axis=1, keepdims=True)
        _normals = _normals / _norms
        _result_normals = _normals[np.argsort(v_to_i_flatten)]
        _result_point = _points[np.argsort(v_to_i_flatten)]
        return _result_normals, _result_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    return self.u_bounds[1] - self.u_bounds[0]
    #v = 0.0
    #verts = [spline.evaluate(v) for spline in self.v_splines]
    #return self.get_u_spline(v, verts).u_size</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    return self.v_bounds[1] - self.v_bounds[0]
    #return self.v_splines[0].v_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    result = self._eval_cache.get((u,v), None)
    if result is not None:
        return result
    else:
        result = self._evaluate(u, v)
        self._eval_cache[(u,v)] = result
        return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    result = np.empty((len(us), 3))
    v_to_u = defaultdict(list)
    v_to_i = defaultdict(list)
    for i, (u, v) in enumerate(zip(us, vs)):
        v_to_u[v].append(u)
        v_to_i[v].append(i)

    # here we rely on fact that in Python 3.7+ dicts are ordered.
    all_vs = np.array(list(v_to_u.keys()))
    v_spline_points = np.array([spline.evaluate_array(all_vs) for spline in self.v_splines])

    for v_idx, (v, us_by_v) in enumerate(v_to_u.items()):
        is_by_v = v_to_i[v]
        spline_vertices = []
        for spline_idx, spline in enumerate(self.v_splines):
            point = v_spline_points[spline_idx,v_idx]
            #point = spline.evaluate(v)
            spline_vertices.append(point)
        u_spline = self.get_u_spline(v, spline_vertices)
        points = u_spline.evaluate_array(np.array(us_by_v))
        idxs = np.array(is_by_v)[np.newaxis].T
        np.put_along_axis(result, idxs, points, axis=0)
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface.get_u_spline"><code class="name flex">
<span>def <span class="ident">get_u_spline</span></span>(<span>self, v, vertices)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a spline along U direction for specified value of V coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_spline(self, v, vertices):
    &#34;&#34;&#34;Get a spline along U direction for specified value of V coordinate&#34;&#34;&#34;
    spline = self._u_splines.get(v, None)
    if spline is not None:
        return spline
    else:
        spline = self.u_spline_constructor(vertices)
        self._u_splines[v] = spline
        return spline</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal(self, u, v):
    result = self._normal_cache.get((u,v), None)
    if result is not None:
        return result
    else:
        result = self._normal(u, v)
        self._normal_cache[(u,v)] = result
        return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvInterpolatingSurface.normal_vertices_array"><code class="name flex">
<span>def <span class="ident">normal_vertices_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal_vertices_array(self, us, vs):
    h = 1e-4 # (np.array([1], dtype=np.float64)/100000000)[0] # 0.0001 One can use float64 of numpy. Blender float relax now. ))) 1e-8 is a diameter of hydrogen atom.
    _points         = np.empty( (0, 3), dtype=np.float64)
    _points_u_h     = np.empty( (0, 3), dtype=np.float64)
    _points_v_h     = np.empty( (0, 3), dtype=np.float64)
    v_to_u = defaultdict(list)
    v_to_i = defaultdict(list)
    for i, (u, v) in enumerate(zip(us, vs)):
        v_to_u[v].append(u)
        v_to_i[v].append(i)
    v_to_i_flatten = np.hstack(np.array( list(v_to_i.values())).flatten())

    list_spline_v = []
    list_spline_h = []
    _v = np.array( list(v_to_u.keys()), dtype=np.float64 )
    # A remark about a reverse. Algorithm cannot calc vectors out of a surface.
    # So calc that vectors in a reverse direction into the surface then reverse that vectors.
    # TODO: need attention for case - may be do %uv_bounds if uv coords are circled?
    # Here is no params about this for a while. So use reverse.
    for i_spline, v_spline in enumerate(self.v_splines):
        v_min, v_max = v_spline.get_u_bounds()
        _vx = (v_max-v_min)*_v+v_min
        _list_v_i = _vx
        _list_h_i = np.where( _vx+h&lt;=v_max, _vx+h, _vx-h ) # if need point out of surface then do step in reverse direction
        list_spline_v.append( _list_v_i )
        list_spline_h.append( _list_h_i )

    r_v = []
    r_h = []
    for i, v_spline in enumerate(self.v_splines):
        _r_v, _r_h = v_spline.evaluate_array( np.concatenate( (list_spline_v[i], list_spline_h[i]) )).reshape(2,-1,3) # to increase performance for one call
        r_v.append( _r_v )
        r_h.append( _r_h )

    u_min, u_max = 0.0, 1.0
    
    for i_on_spline, (v, _us_by_v) in enumerate(v_to_u.items()):
        us_by_v = np.array(_us_by_v)
        spline_vertices = []
        spline_vertices_h = []

        for i_spline, v_spline in enumerate(self.v_splines):
            point_v = r_v[i_spline][i_on_spline]
            point_h = r_h[i_spline][i_on_spline]
            spline_vertices.append(point_v)
            spline_vertices_h.append(point_h)

        u_spline   = self.get_u_spline(v  , spline_vertices  )
        if v+h &lt;= v_max:
            u_spline_h = self.get_u_spline(v+h, spline_vertices_h)
        else:
            # curve for reversed vertices
            u_spline_h = self.get_u_spline(v-h, spline_vertices_h)

        us_v = us_by_v
        not_reversed_us = us_by_v + h &lt;= u_max
        us_h_gb = np.where( not_reversed_us, us_by_v+h, us_by_v-h )

        points, points_u_h = u_spline.evaluate_array( np.concatenate( (us_v, us_h_gb) ) ).reshape(2,-1,3) # to increase performance for one call
        points_u_h = np.where( not_reversed_us.T[:,np.newaxis], points_u_h, -(points_u_h-points)+points) # reverse some vectors in u direction
        points_v_h = u_spline_h.evaluate_array(us_by_v)
        _points     = np.concatenate( (_points, points) )
        _points_u_h = np.concatenate( (_points_u_h, points_u_h) )
        if v+h &lt;= v_max:
            _points_v_h = np.concatenate( (_points_v_h, points_v_h) )
        else:
            # reverse points if curve is reversed
            _points_v_h = np.concatenate( (_points_v_h, -(points_v_h-points)+points) ) # reverse some vectors in v direction

    _dvs = (_points_v_h - _points)/h
    _dus = (_points_u_h - _points)/h
    _normals = np.cross(_dus, _dvs)
    _norms = np.linalg.norm(_normals, axis=1, keepdims=True)
    _normals = _normals / _norms
    _result_normals = _normals[np.argsort(v_to_i_flatten)]
    _result_point = _points[np.argsort(v_to_i_flatten)]
    return _result_normals, _result_point</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface"><code class="flex name class">
<span>class <span class="ident">SvRevolutionSurface</span></span>
<span>(</span><span>curve, point, direction, global_origin=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvRevolutionSurface(SvSurface):
    __description__ = &#34;Revolution&#34;

    def __init__(self, curve, point, direction, global_origin=True):
        self.curve = curve
        self.point = point
        self.direction = direction
        self.global_origin = global_origin
        self.normal_delta = 0.0001
        self.v_bounds = (0.0, 2*pi)

    @classmethod
    def build(cls, curve, point, direction, v_min=0, v_max=2*pi, global_origin=True):
        if hasattr(curve, &#39;make_revolution_surface&#39;):
            try:
                return curve.make_revolution_surface(point, direction, v_min, v_max, global_origin)
            except UnsupportedCurveTypeException:
                pass
        surface = SvRevolutionSurface(curve, point, direction, global_origin)
        surface.v_bounds = (v_min, v_max)
        return surface

    def evaluate(self, u, v):
        point_on_curve = self.curve.evaluate(u)
        dv = point_on_curve - self.point
        result = np.array(rotate_vector_around_vector(dv, self.direction, v))
        if not self.global_origin:
            result = result + self.point
        return result

    def evaluate_array(self, us, vs):
        points_on_curve = self.curve.evaluate_array(us)
        dvs = points_on_curve - self.point
        result = rotate_vector_around_vector_np(dvs, self.direction, vs)
        if not self.global_origin:
            result = result + self.point
        return result

    def get_u_min(self):
        return self.curve.get_u_bounds()[0]

    def get_u_max(self):
        return self.curve.get_u_bounds()[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>curve, point, direction, v_min=0, v_max=6.283185307179586, global_origin=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build(cls, curve, point, direction, v_min=0, v_max=2*pi, global_origin=True):
    if hasattr(curve, &#39;make_revolution_surface&#39;):
        try:
            return curve.make_revolution_surface(point, direction, v_min, v_max, global_origin)
        except UnsupportedCurveTypeException:
            pass
    surface = SvRevolutionSurface(curve, point, direction, global_origin)
    surface.v_bounds = (v_min, v_max)
    return surface</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    point_on_curve = self.curve.evaluate(u)
    dv = point_on_curve - self.point
    result = np.array(rotate_vector_around_vector(dv, self.direction, v))
    if not self.global_origin:
        result = result + self.point
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    points_on_curve = self.curve.evaluate_array(us)
    dvs = points_on_curve - self.point
    result = rotate_vector_around_vector_np(dvs, self.direction, vs)
    if not self.global_origin:
        result = result + self.point
    return result</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.curve.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.curve.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.v_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.v_bounds[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface"><code class="flex name class">
<span>class <span class="ident">SvSurfaceLerpSurface</span></span>
<span>(</span><span>surface1, surface2, coefficient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvSurfaceLerpSurface(SvSurface):
    __description__ = &#34;Lerp&#34;

    def __init__(self, surface1, surface2, coefficient):
        self.surface1 = surface1
        self.surface2 = surface2
        self.coefficient = coefficient
        self.normal_delta = 0.0001
        self.v_bounds = (0.0, 1.0)
        self.u_bounds = (0.0, 1.0)
        self.s1_u_min, self.s1_u_max = surface1.get_u_min(), surface1.get_u_max()
        self.s1_v_min, self.s1_v_max = surface1.get_v_min(), surface1.get_v_max()
        self.s2_u_min, self.s2_u_max = surface2.get_u_min(), surface2.get_u_max()
        self.s2_v_min, self.s2_v_max = surface2.get_v_min(), surface2.get_v_max()

    def get_u_min(self):
        return self.u_bounds[0]

    def get_u_max(self):
        return self.u_bounds[1]

    def get_v_min(self):
        return self.v_bounds[0]

    def get_v_max(self):
        return self.v_bounds[1]

    @property
    def u_size(self):
        return self.u_bounds[1] - self.u_bounds[0]

    @property
    def v_size(self):
        return self.v_bounds[1] - self.v_bounds[0]

    def evaluate(self, u, v):
        return self.evaluate_array(np.array([u]), np.array([v]))[0]
    
    def evaluate_array(self, us, vs):
        us1 = (self.s1_u_max - self.s1_u_min) * us + self.s1_u_min
        us2 = (self.s2_u_max - self.s2_u_min) * us + self.s2_u_min
        vs1 = (self.s1_v_max - self.s1_v_min) * vs + self.s1_v_min
        vs2 = (self.s2_v_max - self.s2_v_min) * vs + self.s2_v_min
        s1_points = self.surface1.evaluate_array(us1, vs1)
        s2_points = self.surface2.evaluate_array(us2, vs2)
        k = self.coefficient
        points = (1.0 - k) * s1_points + k * s2_points
        return points</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.u_size"><code class="name">var <span class="ident">u_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_size(self):
    return self.u_bounds[1] - self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.v_size"><code class="name">var <span class="ident">v_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_size(self):
    return self.v_bounds[1] - self.v_bounds[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    return self.evaluate_array(np.array([u]), np.array([v]))[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    us1 = (self.s1_u_max - self.s1_u_min) * us + self.s1_u_min
    us2 = (self.s2_u_max - self.s2_u_min) * us + self.s2_u_min
    vs1 = (self.s1_v_max - self.s1_v_min) * vs + self.s1_v_min
    vs2 = (self.s2_v_max - self.s2_v_min) * vs + self.s2_v_min
    s1_points = self.surface1.evaluate_array(us1, vs1)
    s2_points = self.surface2.evaluate_array(us2, vs2)
    k = self.coefficient
    points = (1.0 - k) * s1_points + k * s2_points
    return points</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.u_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.u_bounds[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.v_bounds[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.v_bounds[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface"><code class="flex name class">
<span>class <span class="ident">SvTaperSweepSurface</span></span>
<span>(</span><span>profile, taper, point, direction, scale_base='UNIT')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvTaperSweepSurface(SvSurface):
    __description__ = &#34;Taper &amp; Sweep&#34;

    UNIT = &#39;UNIT&#39;
    PROFILE = &#39;PROFILE&#39;
    TAPER = &#39;TAPER&#39;

    def __init__(self, profile, taper, point, direction, scale_base=UNIT):
        self.profile = profile
        self.taper = taper
        self.direction = direction
        self.point = point
        self.line = LineEquation.from_direction_and_point(direction, point)
        self.scale_base = scale_base
        self.normal_delta = 0.0001

    def get_u_min(self):
        return self.profile.get_u_bounds()[0]

    def get_u_max(self):
        return self.profile.get_u_bounds()[1]

    def get_v_min(self):
        return self.taper.get_u_bounds()[0]

    def get_v_max(self):
        return self.taper.get_u_bounds()[1]

    def _get_profile_scale(self):
        profile_u_min = self.profile.get_u_bounds()[0]
        profile_start = self.profile.evaluate(profile_u_min)
        profile_start_projection = self.line.projection_of_point(profile_start)
        dp = np.linalg.norm(profile_start - profile_start_projection)
        return dp

    def evaluate(self, u, v):
        taper_point = self.taper.evaluate(v)
        taper_projection = np.array( self.line.projection_of_point(taper_point) )
        scale = np.linalg.norm(taper_projection - taper_point)
        if self.scale_base == SvTaperSweepSurface.TAPER:
            dp = self._get_profile_scale()
            scale /= dp
        elif self.scale_base == SvTaperSweepSurface.PROFILE:
            taper_t_min = self.taper.get_u_bounds()[0]
            taper_start = self.taper.evaluate(taper_t_min)
            taper_start_projection = np.array(self.line.projection_of_point(taper_start))
            scale0 = np.linalg.norm(taper_start - taper_start_projection)
            scale /= scale0

        profile_point = self.profile.evaluate(u)
        return profile_point * scale + taper_projection

    def evaluate_array(self, us, vs):
        taper_points = self.taper.evaluate_array(vs)
        taper_projections = self.line.projection_of_points(taper_points)
        scale = np.linalg.norm(taper_projections - taper_points, axis=1, keepdims=True)

        if self.scale_base == SvTaperSweepSurface.TAPER:
            dp = self._get_profile_scale()
            scale /= dp
        elif self.scale_base == SvTaperSweepSurface.PROFILE:
            scale0 = scale[0]
            scale /= scale0

        profile_points = self.profile.evaluate_array(us)
        return profile_points * scale + taper_projections</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.surface.core.SvSurface" href="core.html#sverchok.utils.surface.core.SvSurface">SvSurface</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.PROFILE"><code class="name">var <span class="ident">PROFILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.TAPER"><code class="name">var <span class="ident">TAPER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.UNIT"><code class="name">var <span class="ident">UNIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, u, v):
    taper_point = self.taper.evaluate(v)
    taper_projection = np.array( self.line.projection_of_point(taper_point) )
    scale = np.linalg.norm(taper_projection - taper_point)
    if self.scale_base == SvTaperSweepSurface.TAPER:
        dp = self._get_profile_scale()
        scale /= dp
    elif self.scale_base == SvTaperSweepSurface.PROFILE:
        taper_t_min = self.taper.get_u_bounds()[0]
        taper_start = self.taper.evaluate(taper_t_min)
        taper_start_projection = np.array(self.line.projection_of_point(taper_start))
        scale0 = np.linalg.norm(taper_start - taper_start_projection)
        scale /= scale0

    profile_point = self.profile.evaluate(u)
    return profile_point * scale + taper_projection</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.evaluate_array"><code class="name flex">
<span>def <span class="ident">evaluate_array</span></span>(<span>self, us, vs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_array(self, us, vs):
    taper_points = self.taper.evaluate_array(vs)
    taper_projections = self.line.projection_of_points(taper_points)
    scale = np.linalg.norm(taper_projections - taper_points, axis=1, keepdims=True)

    if self.scale_base == SvTaperSweepSurface.TAPER:
        dp = self._get_profile_scale()
        scale /= dp
    elif self.scale_base == SvTaperSweepSurface.PROFILE:
        scale0 = scale[0]
        scale /= scale0

    profile_points = self.profile.evaluate_array(us)
    return profile_points * scale + taper_projections</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_u_max"><code class="name flex">
<span>def <span class="ident">get_u_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_max(self):
    return self.profile.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_u_min"><code class="name flex">
<span>def <span class="ident">get_u_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_u_min(self):
    return self.profile.get_u_bounds()[0]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_v_max"><code class="name flex">
<span>def <span class="ident">get_v_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_max(self):
    return self.taper.get_u_bounds()[1]</code></pre>
</details>
</dd>
<dt id="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_v_min"><code class="name flex">
<span>def <span class="ident">get_v_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_min(self):
    return self.taper.get_u_bounds()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.surface" href="index.html">sverchok.utils.surface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.surface.algorithms.build_nurbs_sphere" href="#sverchok.utils.surface.algorithms.build_nurbs_sphere">build_nurbs_sphere</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.concatenate_surfaces" href="#sverchok.utils.surface.algorithms.concatenate_surfaces">concatenate_surfaces</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.deform_nurbs_surface" href="#sverchok.utils.surface.algorithms.deform_nurbs_surface">deform_nurbs_surface</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.make_planar_surface" href="#sverchok.utils.surface.algorithms.make_planar_surface">make_planar_surface</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.nurbs_revolution_surface" href="#sverchok.utils.surface.algorithms.nurbs_revolution_surface">nurbs_revolution_surface</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.nurbs_surface_from_curve" href="#sverchok.utils.surface.algorithms.nurbs_surface_from_curve">nurbs_surface_from_curve</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.nurbs_surface_from_points" href="#sverchok.utils.surface.algorithms.nurbs_surface_from_points">nurbs_surface_from_points</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.remove_excessive_knots" href="#sverchok.utils.surface.algorithms.remove_excessive_knots">remove_excessive_knots</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.round_knotvectors" href="#sverchok.utils.surface.algorithms.round_knotvectors">round_knotvectors</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.unify_nurbs_surfaces" href="#sverchok.utils.surface.algorithms.unify_nurbs_surfaces">unify_nurbs_surfaces</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvBlendSurface" href="#sverchok.utils.surface.algorithms.SvBlendSurface">SvBlendSurface</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.surface.algorithms.SvBlendSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvBlendSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvBlendSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvBlendSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvBlendSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvBlendSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvBlendSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvBlendSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvBlendSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvBlendSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvConcatSurface" href="#sverchok.utils.surface.algorithms.SvConcatSurface">SvConcatSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvConcatSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvConcatSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConcatSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvConcatSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConcatSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvConcatSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConcatSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvConcatSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConcatSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvConcatSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConcatSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvConcatSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface">SvConstPipeSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_matrices" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.get_matrices">get_matrices</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_matrix" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.get_matrix">get_matrix</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvConstPipeSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvConstPipeSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface">SvCurveLerpSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.build" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.build">build</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.u_size" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvCurveLerpSurface.v_size" href="#sverchok.utils.surface.algorithms.SvCurveLerpSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface">SvDeformedByFieldSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_coord_mode" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_coord_mode">get_coord_mode</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_input_matrix" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_input_matrix">get_input_matrix</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.has_input_matrix" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.has_input_matrix">has_input_matrix</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.normal" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.normal">normal</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.u_size" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.v_size" href="#sverchok.utils.surface.algorithms.SvDeformedByFieldSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface">SvExtrudeCurveCurveSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.u_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.v_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveCurveSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface">SvExtrudeCurveFrenetSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.u_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.v_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveFrenetSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface">SvExtrudeCurveMathutilsSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_matrices" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_matrices">get_matrices</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_matrix" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_matrix">get_matrix</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveMathutilsSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface">SvExtrudeCurveNormalDirSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.u_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.v_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveNormalDirSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface">SvExtrudeCurvePointSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.build" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.build">build</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.u_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.v_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurvePointSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface">SvExtrudeCurveTrackNormalSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveTrackNormalSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface">SvExtrudeCurveVectorSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.build" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.build">build</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.u_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.v_size" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveVectorSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface">SvExtrudeCurveZeroTwistSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvExtrudeCurveZeroTwistSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface">SvInterpolatingSurface</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface.get_u_spline" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface.get_u_spline">get_u_spline</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface.normal" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface.normal">normal</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface.normal_vertices_array" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface.normal_vertices_array">normal_vertices_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface.u_size" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvInterpolatingSurface.v_size" href="#sverchok.utils.surface.algorithms.SvInterpolatingSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface">SvRevolutionSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface.build" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface.build">build</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvRevolutionSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvRevolutionSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface">SvSurfaceLerpSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.get_v_min">get_v_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.u_size" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.u_size">u_size</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.v_size" href="#sverchok.utils.surface.algorithms.SvSurfaceLerpSurface.v_size">v_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface">SvTaperSweepSurface</a></code></h4>
<ul class="two-column">
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.PROFILE" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.PROFILE">PROFILE</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.TAPER" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.TAPER">TAPER</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.UNIT" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.UNIT">UNIT</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.evaluate" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.evaluate">evaluate</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.evaluate_array" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.evaluate_array">evaluate_array</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_u_max" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_u_max">get_u_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_u_min" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_u_min">get_u_min</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_v_max" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_v_max">get_v_max</a></code></li>
<li><code><a title="sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_v_min" href="#sverchok.utils.surface.algorithms.SvTaperSweepSurface.get_v_min">get_v_min</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>