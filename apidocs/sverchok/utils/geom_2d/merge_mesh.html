<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sverchok.utils.geom_2d.merge_mesh API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.geom_2d.merge_mesh</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.geom_2d.merge_mesh.crop_edges"><code class="name flex">
<span>def <span class="ident">crop_edges</span></span>(<span>sv_verts, sv_edges, sv_verts_crop, sv_faces_crop, mode='inner', accuracy=1e-05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_edges(sv_verts, sv_edges, sv_verts_crop, sv_faces_crop, mode=&#39;inner&#39;, accuracy=1e-5):
    &#34;&#34;&#34;
    The function takes one SV mesh determined by edges and crop it by polygons of another SV mesh determined by faces.
    :param sv_verts: list of SV points
    :param sv_edges: list of SV edges
    :param sv_verts_crop: list of SV points
    :param sv_faces_crop: list of SV faces
    :param mode: inner or outer, switch between holes creation and feting into mesh
    :param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
    :return: list of SV vertices, list of SV faces
    &#34;&#34;&#34;
    mesh = DCELMesh(accuracy=accuracy)
    mesh.from_sv_edges(sv_verts, sv_edges)
    mesh.from_sv_faces(sv_verts_crop, sv_faces_crop)
    find_intersections(mesh, accuracy, face_overlapping=True)
    [hedge.flags.add(&#39;del&#39;) for hedge in mesh.hedges if hedge.face]
    if mode == &#39;inner&#39;:
        [hedge.flags.add(&#39;del&#39;) for hedge in mesh.hedges if not hedge.in_faces]
    else:
        [hedge.flags.add(&#39;del&#39;) for hedge in mesh.hedges if hedge.in_faces]
    return mesh.to_sv_mesh(faces=False, del_edge_flag=&#39;del&#39;)</code></pre>
</details>
<div class="desc"><p>The function takes one SV mesh determined by edges and crop it by polygons of another SV mesh determined by faces.
:param sv_verts: list of SV points
:param sv_edges: list of SV edges
:param sv_verts_crop: list of SV points
:param sv_faces_crop: list of SV faces
:param mode: inner or outer, switch between holes creation and feting into mesh
:param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
:return: list of SV vertices, list of SV faces</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.crop_mesh"><code class="name flex">
<span>def <span class="ident">crop_mesh</span></span>(<span>sv_verts, sv_faces, sv_verts_crop, sv_faces_crop, mode='inner', accuracy=1e-05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_mesh(sv_verts, sv_faces, sv_verts_crop, sv_faces_crop, mode=&#39;inner&#39;, accuracy=1e-5):
    &#34;&#34;&#34;
    The function takes one SV mesh determined by polygons and crop it by polygons of another SV mesh.
    It can as creates holes in mesh so fit mesh into boundary of another mesh
    :param sv_verts: list of SV points
    :param sv_faces: list of SV faces
    :param sv_verts_crop: list of SV points
    :param sv_faces_crop: list of SV faces
    :param mode: inner or outer, switch between holes creation and feting into mesh
    :param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
    :return: list of SV vertices, list of SV faces, index face mask (optionally)
    &#34;&#34;&#34;
    mesh = DCELMesh(accuracy=accuracy)
    mesh.from_sv_faces(sv_verts, sv_faces, face_flag=[&#39;base&#39; for _ in range(len(sv_faces))],
                       face_data={&#39;index&#39;: list(range(len(sv_faces)))})
    mesh.from_sv_faces(sv_verts_crop, sv_faces_crop, face_flag=[&#39;crop&#39; for _ in range(len(sv_faces_crop))])
    find_intersections(mesh, accuracy, face_overlapping=True)  # anyway should be true
    mesh.generate_faces_from_hedges()
    mark_not_in_faces(mesh)
    mark_crop_faces(mesh, mode)
    monotone_faces_with_holes(mesh)
    return list(mesh.to_sv_mesh(edges=False, del_face_flag=&#39;del&#39;)) + [get_min_face_indexes(mesh, &#39;index&#39;)]</code></pre>
</details>
<div class="desc"><p>The function takes one SV mesh determined by polygons and crop it by polygons of another SV mesh.
It can as creates holes in mesh so fit mesh into boundary of another mesh
:param sv_verts: list of SV points
:param sv_faces: list of SV faces
:param sv_verts_crop: list of SV points
:param sv_faces_crop: list of SV faces
:param mode: inner or outer, switch between holes creation and feting into mesh
:param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
:return: list of SV vertices, list of SV faces, index face mask (optionally)</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.crop_mesh_delaunay"><code class="name flex">
<span>def <span class="ident">crop_mesh_delaunay</span></span>(<span>verts, faces, verts_crop, faces_crop, mode, epsilon)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_mesh_delaunay(verts, faces, verts_crop, faces_crop, mode, epsilon):
    &#34;&#34;&#34;
    Crop given faces by another set of faces by Blender internal function
    :param verts: list of Sv vertices
    :param faces: list of faces which should be cropped
    :param verts_crop: list of Sv vertices
    :param faces_crop: list of faces by which mesh should be cropped
    :param mode: &#39;inner&#39; or &#39;outer&#39;
    :param epsilon: float, for nearness tests
    :return: list of Sv vertices, faces, indexes of old faces
    &#34;&#34;&#34;
    faces = [f if is_ccw_polygon([verts[i] for i in f], accuracy=epsilon) else f[::-1] for f in faces]
    faces_crop = [f if is_ccw_polygon([verts_crop[i] for i in f], accuracy=epsilon) else f[::-1] for f in faces_crop]
    merged_verts, merged_faces, faces_indexes, faces_crop_indexes = join_meshes(verts, faces, verts_crop, faces_crop)
    merged_verts = [Vector(co[:2]) for co in merged_verts]
    verts_new, _, faces_new, _, _, face_indexes = bl_crop_mesh(merged_verts, [], merged_faces, 3, epsilon)
    if mode == &#39;inner&#39;:
        faces_out = []
        faces_index_out = []
        for f, fi in zip(faces_new, face_indexes):
            if not fi:
                # it means new faces was generated
                continue
            in_1 = False
            in_2 = False
            for i in fi:
                if i in faces_indexes:
                    in_1 = True
                else:
                    in_2 = True
                if in_1 and in_2:
                    faces_out.append(f)
                    faces_index_out.append(min(fi))
                    break
        verts_out, faces_out = del_loose(verts_new, faces_out)
        return [v.to_3d()[:] for v in verts_out], faces_out, faces_index_out
    else:
        faces_out = []
        faces_index_out = []
        for f, fi in zip(faces_new, face_indexes):
            if not fi:
                # it means new faces was generated
                continue
            in_2 = False
            for i in fi:
                if i in faces_crop_indexes:
                    in_2 = True
                    break
            if not in_2:
                faces_out.append(f)
                faces_index_out.append(min(fi))
        verts_out, faces_out = del_loose(verts_new, faces_out)
        return [v.to_3d()[:] for v in verts_out], faces_out, faces_index_out</code></pre>
</details>
<div class="desc"><p>Crop given faces by another set of faces by Blender internal function
:param verts: list of Sv vertices
:param faces: list of faces which should be cropped
:param verts_crop: list of Sv vertices
:param faces_crop: list of faces by which mesh should be cropped
:param mode: 'inner' or 'outer'
:param epsilon: float, for nearness tests
:return: list of Sv vertices, faces, indexes of old faces</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.del_holes"><code class="name flex">
<span>def <span class="ident">del_holes</span></span>(<span>dcel_mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_holes(dcel_mesh):

    del_flag = &#39;del&#39;

    def del_hole(face):
        used_del = set()  # type: Set[&#39;Face&#39;]
        stack_del = [hedge.twin for hedge in face.inners]
        while stack_del:
            next_del_face = stack_del.pop().face
            if next_del_face in used_del:
                continue
            if id(next_del_face) == id(face):
                continue
            used_del.add(next_del_face)
            next_del_face.flags.add(del_flag)
            for loop_del_hedge in next_del_face.outer.loop_hedges:
                stack_del.append(loop_del_hedge.twin)
            if next_del_face.inners:
                add_hole(next_del_face)

    def add_hole(face):
        used = set()  # type: Set[&#39;Face&#39;]
        stack = [hedge.twin for hedge in face.inners]
        while stack:
            next_face = stack.pop().face
            if next_face in used:
                continue
            if id(face) == id(next_face):
                continue
            used.add(next_face)
            for loop_hedge in next_face.outer.loop_hedges:
                stack.append(loop_hedge.twin)
            if next_face.inners:
                del_hole(next_face)

    add_hole(dcel_mesh.unbounded)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.del_loose"><code class="name flex">
<span>def <span class="ident">del_loose</span></span>(<span>verts, poly_edge)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_loose(verts, poly_edge):
    indx = set(chain.from_iterable(poly_edge))
    verts_out = [v for i, v in enumerate(verts) if i in indx]
    v_index = dict([(j, i) for i, j in enumerate(sorted(indx))])
    poly_edge_out = [list(map(lambda n: v_index[n], p)) for p in poly_edge]
    return verts_out, poly_edge_out</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.edges_to_faces"><code class="name flex">
<span>def <span class="ident">edges_to_faces</span></span>(<span>sv_verts, sv_edges, do_intersect=True, fill_holes=True, accuracy=1e-05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edges_to_faces(sv_verts, sv_edges, do_intersect=True, fill_holes=True, accuracy=1e-5):
    &#34;&#34;&#34;
    Fill faces of Sverchok mesh determined by edges
    Optionally can be found self intersections and created holes
    Overlapping of edges and points are supported
    :param sv_verts: list of SV points
    :param sv_edges: list of SV edges
    :param do_intersect: if True self intersections will be taken in account
    :param fill_holes: if False can produce holes in case if
     there are such faces incise another face without intersections with one
    :param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
    :return: list of SV points, list of SV faces
    &#34;&#34;&#34;
    mesh = DCELMesh(accuracy=accuracy)
    mesh.from_sv_edges(sv_verts, sv_edges)
    if do_intersect:
        find_intersections(mesh, accuracy)
    mesh.generate_faces_from_hedges()
    if not fill_holes:
        del_holes(mesh)
    monotone_faces_with_holes(mesh)
    return mesh.to_sv_mesh(edges=False, del_face_flag=&#39;del&#39;)</code></pre>
</details>
<div class="desc"><p>Fill faces of Sverchok mesh determined by edges
Optionally can be found self intersections and created holes
Overlapping of edges and points are supported
:param sv_verts: list of SV points
:param sv_edges: list of SV edges
:param do_intersect: if True self intersections will be taken in account
:param fill_holes: if False can produce holes in case if
there are such faces incise another face without intersections with one
:param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
:return: list of SV points, list of SV faces</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.get_face_mask_by_flag"><code class="name flex">
<span>def <span class="ident">get_face_mask_by_flag</span></span>(<span>mesh, flag, del_flag='del')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_face_mask_by_flag(mesh, flag, del_flag=&#39;del&#39;):
    # returns mask of faces where 1 means that face has given flag
    out = [0 for face in mesh.faces if del_flag not in face.flags]
    for i, face in enumerate(mesh.faces):
        if del_flag in face.flags:
            continue
        for in_face in face.outer.in_faces:
            if flag in in_face.flags:
                out[i] = 1
                break
    return out</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.get_min_face_indexes"><code class="name flex">
<span>def <span class="ident">get_min_face_indexes</span></span>(<span>dcel_mesh, index_flag, filter_flag=None, del_flag='del')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_face_indexes(dcel_mesh, index_flag, filter_flag=None, del_flag=&#39;del&#39;):
    # returns list index per face where index is index of boundary face with lower index
    # assume that order of created face is the same to order of mesh.faces list
    # if flag is given the function takes in account faces with such flag
    # if there is no faces with such flag at all -1 index is added into output mask
    out = []
    if not filter_flag:
        for face in dcel_mesh.faces:
            if del_flag in face.flags:
                continue
            out.append(min([in_face.sv_data[index_flag] for in_face in face.outer.in_faces if
                            index_flag in in_face.sv_data]))
    else:
        for face in dcel_mesh.faces:
            if del_flag in face.flags:
                continue
            indexes = []
            for in_face in face.outer.in_faces:
                if filter_flag in in_face.flags:
                    indexes.append(in_face.sv_data[index_flag])
            if indexes:
                out.append(min(indexes))
            else:
                out.append(-1)
    return out</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.get_number_of_overlapping_mask"><code class="name flex">
<span>def <span class="ident">get_number_of_overlapping_mask</span></span>(<span>mesh, del_flag='del')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_number_of_overlapping_mask(mesh, del_flag=&#39;del&#39;):
    return [len(face.outer.in_faces) - 1 for face in mesh.faces if del_flag not in face.flags]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.join_meshes"><code class="name flex">
<span>def <span class="ident">join_meshes</span></span>(<span>verts1, faces1, verts2, faces2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_meshes(verts1, faces1, verts2, faces2):
    faces_out = faces1 + [[i + len(verts1) for i in f] for f in faces2]
    faces1_indexes = {i for i in range(len(faces1))}
    faces2_indexes = {i + len(faces1) for i in range(len(faces2))}
    return verts1 + verts2, faces_out, faces1_indexes, faces2_indexes</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.join_meshes2"><code class="name flex">
<span>def <span class="ident">join_meshes2</span></span>(<span>verts1, edges1, verts2, faces2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_meshes2(verts1, edges1, verts2, faces2):
    faces_out = [[i + len(verts1) for i in f] for f in faces2]
    return verts1 + verts2, edges1, faces_out</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.mark_crop_faces"><code class="name flex">
<span>def <span class="ident">mark_crop_faces</span></span>(<span>mesh, mode, crop_name='crop', del_flag='del')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_crop_faces(mesh, mode, crop_name=&#39;crop&#39;, del_flag=&#39;del&#39;):
    # mark face for deleting if they are in faces with flag crop_name or not
    for face in mesh.faces:
        inside_base = False
        inside_crop = False
        for in_face in face.outer.in_faces:
            if crop_name in in_face.flags:
                inside_crop = True
            else:
                inside_base = True
        if mode == &#39;inner&#39;:
            if not inside_base or not inside_crop:
                face.flags.add(del_flag)
        else:
            if inside_crop:
                face.flags.add(del_flag)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.mark_not_in_faces"><code class="name flex">
<span>def <span class="ident">mark_not_in_faces</span></span>(<span>mesh, del_flag='del')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_not_in_faces(mesh, del_flag=&#39;del&#39;):
    # mark faces which are not in any faces as for deleting
    for face in mesh.faces:
        if not face.outer.in_faces:
            face.flags.add(del_flag)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.merge_mesh"><code class="name flex">
<span>def <span class="ident">merge_mesh</span></span>(<span>sv_verts_a,<br>sv_faces_a,<br>sv_verts_b,<br>sv_faces_b,<br>is_mask=True,<br>is_index=False,<br>accuracy=1e-06)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_mesh(sv_verts_a, sv_faces_a, sv_verts_b, sv_faces_b, is_mask=True, is_index=False, accuracy=1e-6):
    &#34;&#34;&#34;
    Merge two Sverchok mesh objects into one mesh with finding intersections and all
    Overlapping of edges and points are supported
    Also polygons can have holes
    :param sv_verts_a: list of SV points
    :param sv_faces_a: list of SV faces
    :param sv_verts_b: list of SV points
    :param sv_faces_b: list of SV faces
    :param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
    :return: vertices in SV format, face in SV format
    &#34;&#34;&#34;
    mesh = DCELMesh()
    mesh.from_sv_faces(sv_verts_a, sv_faces_a, face_flag=[&#39;mesh a&#39; for _ in range(len(sv_faces_a))],
                       face_data={&#39;index&#39;: list(range(len(sv_faces_a)))})
    mesh.from_sv_faces(sv_verts_b, sv_faces_b, face_flag=[&#39;mesh b&#39; for _ in range(len(sv_faces_b))],
                       face_data={&#39;index&#39;: list(range(len(sv_faces_b)))})
    find_intersections(mesh, accuracy, face_overlapping=True)
    mesh.generate_faces_from_hedges()
    mark_not_in_faces(mesh)
    monotone_faces_with_holes(mesh)

    if is_mask and is_index:
        return list(mesh.to_sv_mesh(edges=False, del_face_flag=&#39;del&#39;)) + [get_face_mask_by_flag(mesh, &#39;mesh a&#39;)] + \
               [get_face_mask_by_flag(mesh, &#39;mesh b&#39;)] + [get_min_face_indexes(mesh, &#39;index&#39;, &#39;mesh a&#39;)] + \
               [get_face_mask_by_flag(mesh, &#39;index&#39;, &#39;mesh b&#39;)]
    elif is_mask:
        return list(mesh.to_sv_mesh(edges=False, del_face_flag=&#39;del&#39;)) + [get_face_mask_by_flag(mesh, &#39;mesh a&#39;)] + \
               [get_face_mask_by_flag(mesh, &#39;mesh b&#39;)]
    elif is_index:
        return list(mesh.to_sv_mesh(edges=False, del_face_flag=&#39;del&#39;)) + \
               [get_min_face_indexes(mesh, &#39;index&#39;, &#39;mesh a&#39;)] + [get_face_mask_by_flag(mesh, &#39;index&#39;, &#39;mesh b&#39;)]
    else:
        return mesh.to_sv_mesh(edges=False, del_face_flag=&#39;del&#39;)</code></pre>
</details>
<div class="desc"><p>Merge two Sverchok mesh objects into one mesh with finding intersections and all
Overlapping of edges and points are supported
Also polygons can have holes
:param sv_verts_a: list of SV points
:param sv_faces_a: list of SV faces
:param sv_verts_b: list of SV points
:param sv_faces_b: list of SV faces
:param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
:return: vertices in SV format, face in SV format</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.merge_mesh_light"><code class="name flex">
<span>def <span class="ident">merge_mesh_light</span></span>(<span>sv_verts, sv_faces, face_overlapping=False, is_overlap_number=False, accuracy=1e-05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_mesh_light(sv_verts, sv_faces, face_overlapping=False, is_overlap_number=False, accuracy=1e-5):
    &#34;&#34;&#34;
    Rebuild faces and vertices with taking in account intersections and holes
    Also produce indexes of old faces in which new faces are
    :param sv_verts: list of SV points
    :param sv_faces: list of SV faces
    :param face_overlapping: add index mask (new face : index old face) to the output of the function if True
    :param is_overlap_number: returns information about number of overlapping face by another faces
    :param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
    :return: list of SV vertices, list of SV faces, index face mask (optionally), list of overlap_number (optionally)
    &#34;&#34;&#34;
    mesh = DCELMesh(accuracy=accuracy)
    mesh.from_sv_faces(sv_verts, sv_faces, face_data={&#39;index&#39;: list(range(len(sv_faces)))})
    find_intersections(mesh, accuracy, face_overlapping=True)  # anyway should be true
    mesh.generate_faces_from_hedges()
    mark_not_in_faces(mesh)
    monotone_faces_with_holes(mesh)
    face_indexes = [get_min_face_indexes(mesh, &#39;index&#39;)] if face_overlapping else [[]]
    overlap_number = [get_number_of_overlapping_mask(mesh)] if is_overlap_number else [[]]
    return list(mesh.to_sv_mesh(edges=False, del_face_flag=&#39;del&#39;)) + face_indexes + overlap_number</code></pre>
</details>
<div class="desc"><p>Rebuild faces and vertices with taking in account intersections and holes
Also produce indexes of old faces in which new faces are
:param sv_verts: list of SV points
:param sv_faces: list of SV faces
:param face_overlapping: add index mask (new face : index old face) to the output of the function if True
:param is_overlap_number: returns information about number of overlapping face by another faces
:param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
:return: list of SV vertices, list of SV faces, index face mask (optionally), list of overlap_number (optionally)</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.geom_2d.merge_mesh.DCELMesh"><code class="flex name class">
<span>class <span class="ident">DCELMesh</span></span>
<span>(</span><span>accuracy=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DCELMesh(InterDCELMesh, MonDCELMesh):
    Point = Point
    HalfEdge = HalfEdge</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.intersections.DCELMesh" href="intersections.html#sverchok.utils.geom_2d.intersections.DCELMesh">DCELMesh</a></li>
<li><a title="sverchok.utils.geom_2d.make_monotone.DCELMesh" href="make_monotone.html#sverchok.utils.geom_2d.make_monotone.DCELMesh">DCELMesh</a></li>
<li><a title="sverchok.utils.geom_2d.dcel.DCELMesh" href="dcel.html#sverchok.utils.geom_2d.dcel.DCELMesh">DCELMesh</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.geom_2d.intersections.DCELMesh" href="intersections.html#sverchok.utils.geom_2d.intersections.DCELMesh">DCELMesh</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.geom_2d.intersections.DCELMesh.Point" href="intersections.html#sverchok.utils.geom_2d.intersections.DCELMesh.Point">Point</a></code></li>
</ul>
</li>
<li><code><b><a title="sverchok.utils.geom_2d.make_monotone.DCELMesh" href="make_monotone.html#sverchok.utils.geom_2d.make_monotone.DCELMesh">DCELMesh</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.geom_2d.make_monotone.DCELMesh.HalfEdge" href="make_monotone.html#sverchok.utils.geom_2d.make_monotone.DCELMesh.HalfEdge">HalfEdge</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.HalfEdge"><code class="flex name class">
<span>class <span class="ident">HalfEdge</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HalfEdge(InterHalfEdge, MonHalfEdge):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)</code></pre>
</details>
<div class="desc"><p>Half edges are sorting in counterclockwise direction from -X direction.
Should be used with HalfEdge class from dcel_mesh module</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.intersections.HalfEdge" href="intersections.html#sverchok.utils.geom_2d.intersections.HalfEdge">HalfEdge</a></li>
<li><a title="sverchok.utils.geom_2d.make_monotone.HalfEdge" href="make_monotone.html#sverchok.utils.geom_2d.make_monotone.HalfEdge">HalfEdge</a></li>
<li><a title="sverchok.utils.geom_2d.dcel.HalfEdge" href="dcel.html#sverchok.utils.geom_2d.dcel.HalfEdge">HalfEdge</a></li>
<li><a title="sverchok.utils.geom_2d.sort_mesh.SortHalfEdgesCCW" href="sort_mesh.html#sverchok.utils.geom_2d.sort_mesh.SortHalfEdgesCCW">SortHalfEdgesCCW</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.geom_2d.intersections.HalfEdge" href="intersections.html#sverchok.utils.geom_2d.intersections.HalfEdge">HalfEdge</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.geom_2d.intersections.HalfEdge.slop" href="dcel.html#sverchok.utils.geom_2d.dcel.HalfEdge.slop">slop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.geom_2d.merge_mesh.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(InterPoint, MonPoint):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)</code></pre>
</details>
<div class="desc"><p>This allowed sort points from upward to downward direction.
Besides points with equal Y coordinate are sorted from left to right.
(0, 1, 0) &lt; (0, 0, 0)
(0, 1, 0) &lt; (1, 1, 0)
(0, 1.001, 0) == (0, 1.002, 0) if accuracy &lt;= 1e-3</p>
<p>Should be used with another class with "co" - (x, y, z) and "accuracy" - (float) attributes</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.intersections.Point" href="intersections.html#sverchok.utils.geom_2d.intersections.Point">Point</a></li>
<li><a title="sverchok.utils.geom_2d.make_monotone.Point" href="make_monotone.html#sverchok.utils.geom_2d.make_monotone.Point">Point</a></li>
<li><a title="sverchok.utils.geom_2d.dcel.Point" href="dcel.html#sverchok.utils.geom_2d.dcel.Point">Point</a></li>
<li><a title="sverchok.utils.geom_2d.sort_mesh.SortPointsUpDown" href="sort_mesh.html#sverchok.utils.geom_2d.sort_mesh.SortPointsUpDown">SortPointsUpDown</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.geom_2d" href="index.html">sverchok.utils.geom_2d</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.crop_edges" href="#sverchok.utils.geom_2d.merge_mesh.crop_edges">crop_edges</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.crop_mesh" href="#sverchok.utils.geom_2d.merge_mesh.crop_mesh">crop_mesh</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.crop_mesh_delaunay" href="#sverchok.utils.geom_2d.merge_mesh.crop_mesh_delaunay">crop_mesh_delaunay</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.del_holes" href="#sverchok.utils.geom_2d.merge_mesh.del_holes">del_holes</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.del_loose" href="#sverchok.utils.geom_2d.merge_mesh.del_loose">del_loose</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.edges_to_faces" href="#sverchok.utils.geom_2d.merge_mesh.edges_to_faces">edges_to_faces</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.get_face_mask_by_flag" href="#sverchok.utils.geom_2d.merge_mesh.get_face_mask_by_flag">get_face_mask_by_flag</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.get_min_face_indexes" href="#sverchok.utils.geom_2d.merge_mesh.get_min_face_indexes">get_min_face_indexes</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.get_number_of_overlapping_mask" href="#sverchok.utils.geom_2d.merge_mesh.get_number_of_overlapping_mask">get_number_of_overlapping_mask</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.join_meshes" href="#sverchok.utils.geom_2d.merge_mesh.join_meshes">join_meshes</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.join_meshes2" href="#sverchok.utils.geom_2d.merge_mesh.join_meshes2">join_meshes2</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.mark_crop_faces" href="#sverchok.utils.geom_2d.merge_mesh.mark_crop_faces">mark_crop_faces</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.mark_not_in_faces" href="#sverchok.utils.geom_2d.merge_mesh.mark_not_in_faces">mark_not_in_faces</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.merge_mesh" href="#sverchok.utils.geom_2d.merge_mesh.merge_mesh">merge_mesh</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.merge_mesh.merge_mesh_light" href="#sverchok.utils.geom_2d.merge_mesh.merge_mesh_light">merge_mesh_light</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.geom_2d.merge_mesh.DCELMesh" href="#sverchok.utils.geom_2d.merge_mesh.DCELMesh">DCELMesh</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.geom_2d.merge_mesh.HalfEdge" href="#sverchok.utils.geom_2d.merge_mesh.HalfEdge">HalfEdge</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.geom_2d.merge_mesh.Point" href="#sverchok.utils.geom_2d.merge_mesh.Point">Point</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
