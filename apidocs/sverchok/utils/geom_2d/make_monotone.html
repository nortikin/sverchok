<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>sverchok.utils.geom_2d.make_monotone API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.utils.geom_2d.make_monotone</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.utils.geom_2d.make_monotone.build_points_list"><code class="name flex">
<span>def <span class="ident">build_points_list</span></span>(<span>face)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_points_list(face):
    # build list of points for partitioning algorithm, all point of outer and inners components
    verts = []
    for hedge in face.outer.loop_hedges:
        verts.append(hedge.origin)
    for inner_hedge in face.inners:
        for hedge in inner_hedge.loop_hedges:
            verts.append(hedge.origin)
    return verts</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.find_hedge"><code class="name flex">
<span>def <span class="ident">find_hedge</span></span>(<span>point)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_hedge(point):
    # find hedge with origin in current point and with partitioning face
    for hedge in point.hedge.ccw_hedges:
        if hedge.face == point.monotone_face:
            break
    return hedge</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.handle_end_point"><code class="name flex">
<span>def <span class="ident">handle_end_point</span></span>(<span>point, status, hedge)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_end_point(point, status, hedge):
    # Read Computational Geometry by Mark de Berg
    status.remove(hedge.last.edge)
    helper = hedge.last.edge.helper
    if helper.type == &#39;merge&#39;:
        insert_edge(helper, point)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.handle_merge_point"><code class="name flex">
<span>def <span class="ident">handle_merge_point</span></span>(<span>point, status, hedge)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_merge_point(point, status, hedge):
    # Read Computational Geometry by Mark de Berg
    right_helper = hedge.last.edge.helper
    last_hedge = hedge.last
    if right_helper.type == &#39;merge&#39;:
        insert_edge(right_helper, point)
    status.remove(last_hedge.edge)
    left_node = status.find_nearest_left(point.co[x])
    left_helper = left_node.key.helper
    if left_helper.type == &#39;merge&#39;:
        insert_edge(left_helper, point)
    left_node.key.helper = point</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.handle_regular_point"><code class="name flex">
<span>def <span class="ident">handle_regular_point</span></span>(<span>point, status, hedge)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_regular_point(point, status, hedge):
    # Read Computational Geometry by Mark de Berg
    if point &lt; hedge.twin.origin:
        right_helper = hedge.last.edge.helper
        status.remove(hedge.last.edge)
        edge = Edge(point, hedge.twin.origin)
        hedge.edge = edge
        hedge.twin.edge = edge
        edge.helper = point
        status.insert(edge)
        if right_helper.type == &#39;merge&#39;:
            insert_edge(right_helper, point)
    else:
        left_node = status.find_nearest_left(point.co[x])
        left_helper = left_node.key.helper
        left_node.key.helper = point
        if left_helper.type == &#39;merge&#39;:
            insert_edge(left_helper, point)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.handle_split_point"><code class="name flex">
<span>def <span class="ident">handle_split_point</span></span>(<span>point, status, hedge)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_split_point(point, status, hedge):
    # Read Computational Geometry by Mark de Berg
    left_node = status.find_nearest_left(point.co[x])
    insert_edge(left_node.key.helper, point)
    left_node.key.helper = point
    edge = Edge(point, hedge.twin.origin)
    hedge.edge = edge
    hedge.twin.edge = edge
    edge.helper = point
    status.insert(edge)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.handle_start_point"><code class="name flex">
<span>def <span class="ident">handle_start_point</span></span>(<span>point, status, hedge)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_start_point(point, status, hedge):
    # Read Computational Geometry by Mark de Berg
    edge = Edge(point, hedge.twin.origin)
    hedge.edge = edge
    hedge.twin.edge = edge
    edge.helper = point
    status.insert(edge)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.insert_edge"><code class="name flex">
<span>def <span class="ident">insert_edge</span></span>(<span>up_p, low_p)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_edge(up_p, low_p):
    # insert new edge into half edge data structure
    up_hedge = up_p.mesh.HalfEdge(up_p.mesh, up_p)
    up_p.mesh.hedges.append(up_hedge)
    low_hedge = up_p.mesh.HalfEdge(up_p.mesh, low_p)
    up_p.mesh.hedges.append(low_hedge)
    up_hedge.twin = low_hedge
    low_hedge.twin = up_hedge
    up_p_hedge = find_hedge(up_p)
    low_p_hedge = find_hedge(low_p)

    up_ccw_hedges = []
    status = 1
    for h in up_p_hedge.ccw_hedges:
        up_ccw_hedges.append(h)
        if h.twin.face and h.twin.face == up_p_hedge.face:
            status -= 1
            break
    if status != 0:
        raise Exception(&#39;Hedge ({}) does not have neighbour with the same face&#39;.format(up_p_hedge))

    if len(up_ccw_hedges) == 2:
        up_next = up_ccw_hedges[0]
    elif 2 &lt; len(up_ccw_hedges) &lt; 5:
        if up_ccw_hedges[0] &gt; up_hedge:
            if ((up_ccw_hedges[2] &lt; up_hedge and up_ccw_hedges[2] &lt; up_ccw_hedges[0]) or
                    (up_ccw_hedges[2] &gt; up_hedge and up_ccw_hedges[2] &gt; up_ccw_hedges[0])):
                up_next = up_ccw_hedges[2]
            elif ((up_ccw_hedges[1] &lt; up_hedge and up_ccw_hedges[1] &lt; up_ccw_hedges[0]) or
                    (up_ccw_hedges[1] &gt; up_hedge and up_ccw_hedges[1] &gt; up_ccw_hedges[0])):
                up_next = up_ccw_hedges[1]
            else:
                up_next = up_ccw_hedges[0]
        else:
            up_next = up_ccw_hedges[1] if up_ccw_hedges[0] &lt; up_ccw_hedges[1] &lt; up_hedge else up_ccw_hedges[0]
    else:
        raise Exception(&#39;Unexpected number of half edges in point {}&#39;.format(up_p))

    low_ccw_hedges = []
    status = 1
    for h in low_p_hedge.ccw_hedges:
        low_ccw_hedges.append(h)
        if h.twin.face and h.twin.face == low_p_hedge.face:
            status -= 1
            break
    if status != 0:
        raise Exception(&#39;Hedge ({}) does not have neighbour with the same face&#39;.format(low_p.hedge.i))

    if len(low_ccw_hedges) == 2:
        low_next = low_ccw_hedges[0]
    elif len(low_ccw_hedges) == 3:
        if low_ccw_hedges[0] &gt; low_hedge:
            if ((low_ccw_hedges[0] &gt; low_ccw_hedges[1] &lt; low_hedge) or
                    (low_ccw_hedges[0] &lt; low_ccw_hedges[1] &gt; low_hedge)):
                low_next = low_ccw_hedges[1]
            else:
                low_next = low_ccw_hedges[0]
        else:
            low_next = low_ccw_hedges[1] if low_ccw_hedges[0] &lt; low_ccw_hedges[1] &lt; low_hedge else low_ccw_hedges[0]
    else:
        raise Exception(&#39;Unexpected number of half edges in point {}&#39;.format(low_p))
    up_hedge.last = up_next.last
    up_hedge.next = low_next
    low_hedge.next = up_next
    low_hedge.last = low_next.last
    up_next.last.next = up_hedge
    up_next.last = low_hedge
    low_next.last.next = low_hedge
    low_next.last = up_hedge
    if hasattr(up_hedge, &#39;in_faces&#39;):
        # actually this part related with merge mesh algorithm only
        up_hedge.in_faces = set(up_hedge.next.in_faces)
        low_hedge.in_faces = set(low_hedge.next.in_faces)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.make_monotone"><code class="name flex">
<span>def <span class="ident">make_monotone</span></span>(<span>face)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_monotone(face):
    &#34;&#34;&#34;
    Splits polygon into monotone pieces optionally with holes
    :param face: face of half edge data structure
    :return new half edges
    Probably approach of implementation of monotone algorithm should be reconsidered according new DCEL data structure
    &#34;&#34;&#34;
    face.mesh.Point.monotone_current_face = face
    status = AVLTree()
    q = sorted(build_points_list(face))[::-1]
    _ = [p.type for p in q]  # not very cool but this will set type for all points before main algorithm
    while q:
        event_point = q.pop()
        Edge.global_event_point = event_point
        handle_functions[event_point.type](event_point, status, find_hedge(event_point))</code></pre>
</details>
<div class="desc"><p>Splits polygon into monotone pieces optionally with holes
:param face: face of half edge data structure
:return new half edges
Probably approach of implementation of monotone algorithm should be reconsidered according new DCEL data structure</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.monotone_faces_with_holes"><code class="name flex">
<span>def <span class="ident">monotone_faces_with_holes</span></span>(<span>dcel_mesh, del_flag='del')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def monotone_faces_with_holes(dcel_mesh, del_flag=&#39;del&#39;):
    &#34;&#34;&#34;
    Split polygons with holes into monotone pieces of DCEL mesh data structure
    Faces already should have actual information about inner component
    :param dcel_mesh: DCELMesh
    :param del_flag: faces with such flag just are just ignore by the algorithm
    :return: DCELMesh with split faces
    &#34;&#34;&#34;
    is_inners = False
    for face in dcel_mesh.faces:
        if del_flag in face.flags:
            continue
        elif face.outer and face.inners:
            is_inners = True
            make_monotone(face)
    if is_inners:
        rebuild_face_list(dcel_mesh)
    return dcel_mesh</code></pre>
</details>
<div class="desc"><p>Split polygons with holes into monotone pieces of DCEL mesh data structure
Faces already should have actual information about inner component
:param dcel_mesh: DCELMesh
:param del_flag: faces with such flag just are just ignore by the algorithm
:return: DCELMesh with split faces</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.monotone_sv_face_with_holes"><code class="name flex">
<span>def <span class="ident">monotone_sv_face_with_holes</span></span>(<span>vert_face, vert_holes=None, face_holes=None, accuracy=1e-05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def monotone_sv_face_with_holes(vert_face, vert_holes=None, face_holes=None, accuracy=1e-5):
    &#34;&#34;&#34;
    Get one face in Sverhok format and splitting it into monotone pieces
    Vertices of face should be given in ordered along face indexes order
    Also it is possible to create holes in input face
    Mesh of holes should be inside face without any intersection
    :param vert_face: 
    :param vert_holes: 
    :param face_holes: 
    :param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
    :return: vertices in Sverchok format, faces in Sverchok format
    &#34;&#34;&#34;
    mesh = DCELMesh(accuracy)
    mesh.from_sv_faces(vert_face, [list(range(len(vert_face)))])
    main_face = mesh.faces[0]  # once this will be broken
    if vert_holes and face_holes:
        main_face.insert_holes(vert_holes, face_holes)
    make_monotone(main_face)
    rebuild_face_list(mesh)
    return mesh.to_sv_mesh(edges=False, only_select=True)</code></pre>
</details>
<div class="desc"><p>Get one face in Sverhok format and splitting it into monotone pieces
Vertices of face should be given in ordered along face indexes order
Also it is possible to create holes in input face
Mesh of holes should be inside face without any intersection
:param vert_face:
:param vert_holes:
:param face_holes:
:param accuracy: two floats figures are equal if their difference is lower then accuracy value, float
:return: vertices in Sverchok format, faces in Sverchok format</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.rebuild_face_list"><code class="name flex">
<span>def <span class="ident">rebuild_face_list</span></span>(<span>dcel_mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rebuild_face_list(dcel_mesh):
    # rebuild face list after partition algorithm
    # this function should correct boundless face but it does not !!!!
    for hedge in dcel_mesh.hedges:
        if hedge.face:
            continue
        face = dcel_mesh.Face(dcel_mesh)
        face.select = True
        face.outer = hedge
        for h in hedge.loop_hedges:
            h.face = face
    used = set()
    faces = []
    for hedge in dcel_mesh.hedges:
        if hedge.face == dcel_mesh.unbounded:
            continue
        if hedge not in used:
            faces.append(hedge.face)
            [used.add(h) for h in hedge.loop_hedges]
    dcel_mesh.faces = faces</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.utils.geom_2d.make_monotone.DCELMesh"><code class="flex name class">
<span>class <span class="ident">DCELMesh</span></span>
<span>(</span><span>accuracy=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DCELMesh(DCELMesh_template):
    Point = Point
    HalfEdge = HalfEdge</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.dcel.DCELMesh" href="dcel.html#sverchok.utils.geom_2d.dcel.DCELMesh">DCELMesh</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.merge_mesh.DCELMesh" href="merge_mesh.html#sverchok.utils.geom_2d.merge_mesh.DCELMesh">DCELMesh</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.geom_2d.make_monotone.DCELMesh.HalfEdge"><code class="name">var <span class="ident">HalfEdge</span></code></dt>
<dd>
<div class="desc"><p>Half edges are sorting in counterclockwise direction from -X direction.
Should be used with HalfEdge class from dcel_mesh module</p></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.DCELMesh.Point"><code class="name">var <span class="ident">Point</span></code></dt>
<dd>
<div class="desc"><p>This allowed sort points from upward to downward direction.
Besides points with equal Y coordinate are sorted from left to right.
(0, 1, 0) &lt; (0, 0, 0)
(0, 1, 0) &lt; (1, 1, 0)
(0, 1.001, 0) == (0, 1.002, 0) if accuracy &lt;= 1e-3</p>
<p>Should be used with another class with "co" - (x, y, z) and "accuracy" - (float) attributes</p></div>
</dd>
</dl>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
<span>(</span><span>up_p, low_p)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(SortEdgeSweepingAlgorithm):

    def __init__(self, up_p, low_p):
        super().__init__(up_p, low_p)

        self.helper = None</code></pre>
</details>
<div class="desc"><p>Sorting edges for sweeping line algorithm.
Edges are sorted along horizontal sweeping line from left to right according their intersection with sweep line.
If Edges intersects in one points they are sorted in cww order from -X direction.</p>
<p>There is global event point parameter determining position of sweep line.
It should be updated each time when sweep line is changing its position.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.sort_mesh.SortEdgeSweepingAlgorithm" href="sort_mesh.html#sverchok.utils.geom_2d.sort_mesh.SortEdgeSweepingAlgorithm">SortEdgeSweepingAlgorithm</a></li>
</ul>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.HalfEdge"><code class="flex name class">
<span>class <span class="ident">HalfEdge</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HalfEdge(HalfEdge_template, SortHalfEdgesCCW):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.edge = None</code></pre>
</details>
<div class="desc"><p>Half edges are sorting in counterclockwise direction from -X direction.
Should be used with HalfEdge class from dcel_mesh module</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.dcel.HalfEdge" href="dcel.html#sverchok.utils.geom_2d.dcel.HalfEdge">HalfEdge</a></li>
<li><a title="sverchok.utils.geom_2d.sort_mesh.SortHalfEdgesCCW" href="sort_mesh.html#sverchok.utils.geom_2d.sort_mesh.SortHalfEdgesCCW">SortHalfEdgesCCW</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.merge_mesh.HalfEdge" href="merge_mesh.html#sverchok.utils.geom_2d.merge_mesh.HalfEdge">HalfEdge</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sverchok.utils.geom_2d.dcel.HalfEdge" href="dcel.html#sverchok.utils.geom_2d.dcel.HalfEdge">HalfEdge</a></b></code>:
<ul class="hlist">
<li><code><a title="sverchok.utils.geom_2d.dcel.HalfEdge.slop" href="dcel.html#sverchok.utils.geom_2d.dcel.HalfEdge.slop">slop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(Point_template, SortPointsUpDown):
    monotone_current_face = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._type = None
        self._monotone_face = None

    @property
    def type(self):
        # the type should be updated each time when polygon is changed in partitioning algorithm
        # during handle of polygon point does not change type
        face = self.monotone_face
        if not self._type:
            hedge = None  # is hedge with origin in the point and belonging to current monotone face
            for coin_hedge in self.hedge.ccw_hedges:
                if coin_hedge.face == face:
                    hedge = coin_hedge
                    break
            if not hedge:
                raise LookupError(&#34;This mean that either monotone face is marked incorrect or &#34;
                                  &#34;coincidence half edges are marked incorrect or something else&#34;)
            next_point = hedge.next.origin
            last_point = hedge.last.origin
            is_up_next = next_point &lt; self  # the less point the upper it is
            is_up_last = last_point &lt; self
            if not is_up_next and not is_up_last:
                self._type = &#39;start&#39; if hedge &lt; hedge.last.twin else &#39;split&#39;
            elif is_up_last and is_up_next:
                self._type = &#39;merge&#39; if hedge &gt; hedge.last.twin else &#39;end&#39;
            else:
                self._type = &#39;regular&#39;
        return self._type

    @property
    def monotone_face(self):
        # returns face coincidence to a point which is handling by the algorithm
        if not self.monotone_current_face:
            raise Exception(&#39;Which polygon is handling should be set before&#39;)
        elif self._monotone_face != self.monotone_current_face:
            self._monotone_face = self.monotone_current_face
            self._type = None
        return self._monotone_face</code></pre>
</details>
<div class="desc"><p>This allowed sort points from upward to downward direction.
Besides points with equal Y coordinate are sorted from left to right.
(0, 1, 0) &lt; (0, 0, 0)
(0, 1, 0) &lt; (1, 1, 0)
(0, 1.001, 0) == (0, 1.002, 0) if accuracy &lt;= 1e-3</p>
<p>Should be used with another class with "co" - (x, y, z) and "accuracy" - (float) attributes</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.dcel.Point" href="dcel.html#sverchok.utils.geom_2d.dcel.Point">Point</a></li>
<li><a title="sverchok.utils.geom_2d.sort_mesh.SortPointsUpDown" href="sort_mesh.html#sverchok.utils.geom_2d.sort_mesh.SortPointsUpDown">SortPointsUpDown</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sverchok.utils.geom_2d.merge_mesh.Point" href="merge_mesh.html#sverchok.utils.geom_2d.merge_mesh.Point">Point</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sverchok.utils.geom_2d.make_monotone.Point.monotone_current_face"><code class="name">var <span class="ident">monotone_current_face</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sverchok.utils.geom_2d.make_monotone.Point.monotone_face"><code class="name">prop <span class="ident">monotone_face</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def monotone_face(self):
    # returns face coincidence to a point which is handling by the algorithm
    if not self.monotone_current_face:
        raise Exception(&#39;Which polygon is handling should be set before&#39;)
    elif self._monotone_face != self.monotone_current_face:
        self._monotone_face = self.monotone_current_face
        self._type = None
    return self._monotone_face</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.utils.geom_2d.make_monotone.Point.type"><code class="name">prop <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self):
    # the type should be updated each time when polygon is changed in partitioning algorithm
    # during handle of polygon point does not change type
    face = self.monotone_face
    if not self._type:
        hedge = None  # is hedge with origin in the point and belonging to current monotone face
        for coin_hedge in self.hedge.ccw_hedges:
            if coin_hedge.face == face:
                hedge = coin_hedge
                break
        if not hedge:
            raise LookupError(&#34;This mean that either monotone face is marked incorrect or &#34;
                              &#34;coincidence half edges are marked incorrect or something else&#34;)
        next_point = hedge.next.origin
        last_point = hedge.last.origin
        is_up_next = next_point &lt; self  # the less point the upper it is
        is_up_last = last_point &lt; self
        if not is_up_next and not is_up_last:
            self._type = &#39;start&#39; if hedge &lt; hedge.last.twin else &#39;split&#39;
        elif is_up_last and is_up_next:
            self._type = &#39;merge&#39; if hedge &gt; hedge.last.twin else &#39;end&#39;
        else:
            self._type = &#39;regular&#39;
    return self._type</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sverchok.utils.geom_2d" href="index.html">sverchok.utils.geom_2d</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.utils.geom_2d.make_monotone.build_points_list" href="#sverchok.utils.geom_2d.make_monotone.build_points_list">build_points_list</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.find_hedge" href="#sverchok.utils.geom_2d.make_monotone.find_hedge">find_hedge</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.handle_end_point" href="#sverchok.utils.geom_2d.make_monotone.handle_end_point">handle_end_point</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.handle_merge_point" href="#sverchok.utils.geom_2d.make_monotone.handle_merge_point">handle_merge_point</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.handle_regular_point" href="#sverchok.utils.geom_2d.make_monotone.handle_regular_point">handle_regular_point</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.handle_split_point" href="#sverchok.utils.geom_2d.make_monotone.handle_split_point">handle_split_point</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.handle_start_point" href="#sverchok.utils.geom_2d.make_monotone.handle_start_point">handle_start_point</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.insert_edge" href="#sverchok.utils.geom_2d.make_monotone.insert_edge">insert_edge</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.make_monotone" href="#sverchok.utils.geom_2d.make_monotone.make_monotone">make_monotone</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.monotone_faces_with_holes" href="#sverchok.utils.geom_2d.make_monotone.monotone_faces_with_holes">monotone_faces_with_holes</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.monotone_sv_face_with_holes" href="#sverchok.utils.geom_2d.make_monotone.monotone_sv_face_with_holes">monotone_sv_face_with_holes</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.rebuild_face_list" href="#sverchok.utils.geom_2d.make_monotone.rebuild_face_list">rebuild_face_list</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.utils.geom_2d.make_monotone.DCELMesh" href="#sverchok.utils.geom_2d.make_monotone.DCELMesh">DCELMesh</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.geom_2d.make_monotone.DCELMesh.HalfEdge" href="#sverchok.utils.geom_2d.make_monotone.DCELMesh.HalfEdge">HalfEdge</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.DCELMesh.Point" href="#sverchok.utils.geom_2d.make_monotone.DCELMesh.Point">Point</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sverchok.utils.geom_2d.make_monotone.Edge" href="#sverchok.utils.geom_2d.make_monotone.Edge">Edge</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.geom_2d.make_monotone.HalfEdge" href="#sverchok.utils.geom_2d.make_monotone.HalfEdge">HalfEdge</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.utils.geom_2d.make_monotone.Point" href="#sverchok.utils.geom_2d.make_monotone.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="sverchok.utils.geom_2d.make_monotone.Point.monotone_current_face" href="#sverchok.utils.geom_2d.make_monotone.Point.monotone_current_face">monotone_current_face</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.Point.monotone_face" href="#sverchok.utils.geom_2d.make_monotone.Point.monotone_face">monotone_face</a></code></li>
<li><code><a title="sverchok.utils.geom_2d.make_monotone.Point.type" href="#sverchok.utils.geom_2d.make_monotone.Point.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
