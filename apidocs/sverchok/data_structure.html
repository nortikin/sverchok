<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>sverchok.data_structure API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sverchok.data_structure</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sverchok.data_structure.Edg_pol_generate"><code class="name flex">
<span>def <span class="ident">Edg_pol_generate</span></span>(<span>prop)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Edg_pol_generate(prop):
    edg_pol_out = []
    if len(prop[0][0]) == 2:
        e_type = &#39;edg&#39;
    elif len(prop[0]) &gt; 2:
        e_type = &#39;pol&#39;
    for ob in prop:
        list_out = []
        for p in ob:
            list_out.append(p)
        edg_pol_out.append(list_out)
    # [ [(n1,n2,n3), (n1,n7,n9), p, p, p, p...], [...],... ] n = vertexindex
    return e_type, edg_pol_out</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.Matrix_generate"><code class="name flex">
<span>def <span class="ident">Matrix_generate</span></span>(<span>prop)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Matrix_generate(prop):
    &#34;&#34;&#34;Generate Matrix() data from Sverchok data&#34;&#34;&#34;
    mat_out = []
    for matrix in prop:
        unit = Matrix()
        for k, m in enumerate(matrix):
            # [Matrix0, Matrix1, ... ]
            unit[k] = Vector(m)
        mat_out.append(unit)
    return mat_out</code></pre>
</details>
<div class="desc"><p>Generate Matrix() data from Sverchok data</p></div>
</dd>
<dt id="sverchok.data_structure.Matrix_listing"><code class="name flex">
<span>def <span class="ident">Matrix_listing</span></span>(<span>prop)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Matrix_listing(prop):
    &#34;&#34;&#34;Convert Matrix() into Sverchok data&#34;&#34;&#34;
    mat_out = []
    for matrix in prop:
        unit = []
        for m in matrix:
            # [Matrix0, Matrix1, ... ]
            unit.append(m[:])
        mat_out.append((unit))
    return mat_out</code></pre>
</details>
<div class="desc"><p>Convert Matrix() into Sverchok data</p></div>
</dd>
<dt id="sverchok.data_structure.Matrix_location"><code class="name flex">
<span>def <span class="ident">Matrix_location</span></span>(<span>prop, to_list=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Matrix_location(prop, to_list=False):
    &#34;&#34;&#34;return a list of locations representing the translation of the matrices&#34;&#34;&#34;
    Vectors = []
    for p in prop:
        if to_list:
            Vectors.append(p.translation[:])
        else:
            Vectors.append(p.translation)
    return [Vectors]</code></pre>
</details>
<div class="desc"><p>return a list of locations representing the translation of the matrices</p></div>
</dd>
<dt id="sverchok.data_structure.Matrix_rotation"><code class="name flex">
<span>def <span class="ident">Matrix_rotation</span></span>(<span>prop, to_list=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Matrix_rotation(prop, to_list=False):
    &#34;&#34;&#34;return (Vector, rotation) utility function for Matrix Destructor.
    if list is true the Vector() is decomposed into tuple format.
    &#34;&#34;&#34;
    Vectors = []
    for p in prop:
        q = p.to_quaternion()
        if to_list:
            vec, angle = q.to_axis_angle()
            Vectors.append((vec[:], angle))
        else:
            Vectors.append(q.to_axis_angle())
    return [Vectors]</code></pre>
</details>
<div class="desc"><p>return (Vector, rotation) utility function for Matrix Destructor.
if list is true the Vector() is decomposed into tuple format.</p></div>
</dd>
<dt id="sverchok.data_structure.Matrix_scale"><code class="name flex">
<span>def <span class="ident">Matrix_scale</span></span>(<span>prop, to_list=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Matrix_scale(prop, to_list=False):
    &#34;&#34;&#34;return a Vector()/list representing the scale factor of the matrices&#34;&#34;&#34;
    Vectors = []
    for p in prop:
        if to_list:
            Vectors.append(p.to_scale()[:])
        else:
            Vectors.append(p.to_scale())
    return [Vectors]</code></pre>
</details>
<div class="desc"><p>return a Vector()/list representing the scale factor of the matrices</p></div>
</dd>
<dt id="sverchok.data_structure.Vector_degenerate"><code class="name flex">
<span>def <span class="ident">Vector_degenerate</span></span>(<span>prop)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Vector_degenerate(prop):
    &#34;&#34;&#34;return a simple list of values instead of Vector() objects&#34;&#34;&#34;
    return [[v[0:3] for v in obj] for obj in prop]</code></pre>
</details>
<div class="desc"><p>return a simple list of values instead of Vector() objects</p></div>
</dd>
<dt id="sverchok.data_structure.Vector_generate"><code class="name flex">
<span>def <span class="ident">Vector_generate</span></span>(<span>prop)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Vector_generate(prop):
    &#34;&#34;&#34;return a list of Vector() objects from a standard Sverchok data&#34;&#34;&#34;
    return [[Vector(v) for v in obj] for obj in prop]</code></pre>
</details>
<div class="desc"><p>return a list of Vector() objects from a standard Sverchok data</p></div>
</dd>
<dt id="sverchok.data_structure.apply_mask"><code class="name flex">
<span>def <span class="ident">apply_mask</span></span>(<span>mask, lst)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mask(mask, lst):
    good, bad = [], []
    for m, item in zip(mask, lst):
        if m:
            good.append(item)
        else:
            bad.append(item)
    return good, bad</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.calc_mask"><code class="name flex">
<span>def <span class="ident">calc_mask</span></span>(<span>subset_data, set_data, level=0, negate=False, ignore_order=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_mask(subset_data, set_data, level=0, negate=False, ignore_order=True):
    &#34;&#34;&#34;
    Calculate mask: for each item in set_data, return True if it is present in subset_data.
    The function can work at any specified level.

    subset_data: subset, for example [1]
    set_data: set, for example [1, 2, 3]
    level: 0 to check immediate members of set and subset; 1 to work with lists of lists and so on.
    negate: if True, then result will be negated (True if item of set is not present in subset).
    ignore_order: when comparing lists, ignore items order.

    Raises an exception if nesting level of input sets is less than specified level parameter.

    calc_mask([1], [1,2,3]) == [True, False, False])
    calc_mask([1], [1,2,3], negate=True) == [False, True, True]
    &#34;&#34;&#34;
    if level == 0:
        if not isinstance(subset_data, (tuple, list)):
            raise Exception(&#34;Specified level is too high for given Subset&#34;)
        if not isinstance(set_data, (tuple, list)):
            raise Exception(&#34;Specified level is too high for given Set&#34;)

        if ignore_order and get_data_nesting_level(subset_data) &gt; 1:
            if negate:
                return [set(item) not in map(set, subset_data) for item in set_data]
            else:
                return [set(item) in map(set, subset_data) for item in set_data]
        else:
            if negate:
                return [item not in subset_data for item in set_data]
            else:
                return [item in subset_data for item in set_data]
    else:
        sub_objects = match_long_repeat([subset_data, set_data])
        return [calc_mask(subset_item, set_item, level - 1, negate, ignore_order) for subset_item, set_item in zip(*sub_objects)]</code></pre>
</details>
<div class="desc"><p>Calculate mask: for each item in set_data, return True if it is present in subset_data.
The function can work at any specified level.</p>
<p>subset_data: subset, for example [1]
set_data: set, for example [1, 2, 3]
level: 0 to check immediate members of set and subset; 1 to work with lists of lists and so on.
negate: if True, then result will be negated (True if item of set is not present in subset).
ignore_order: when comparing lists, ignore items order.</p>
<p>Raises an exception if nesting level of input sets is less than specified level parameter.</p>
<p>calc_mask([1], [1,2,3]) == [True, False, False])
calc_mask([1], [1,2,3], negate=True) == [False, True, True]</p></div>
</dd>
<dt id="sverchok.data_structure.changable_sockets"><code class="name flex">
<span>def <span class="ident">changable_sockets</span></span>(<span>node, inputsocketname, outputsocketname)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changable_sockets(node, inputsocketname, outputsocketname):
    &#34;&#34;&#34;
    It changes types of output sockets according to type of socket (other)
    connected to given input socket name
    !!! It does not work if the node have outputs with the same names !!!
    If input socket is not connected or its type is equal to type of
    first output socket it does nothing
    arguments: node, name of socket to follow, list of socket to change
    &#34;&#34;&#34;
    if not inputsocketname in node.inputs:
        # - node not initialized in sv_init yet,
        # - or socketname incorrect
        sv_logger.debug(f&#34;changable_socket was called on {node.name} with a socket named {inputsocketname}, this socket does not exist&#34;)
        return

    in_socket = node.inputs[inputsocketname]
    ng = node.id_data
    if in_socket.links:
        in_other = get_other_socket(in_socket)
        if not in_other:
            return
        outputs = node.outputs
        s_type = in_other.bl_idname
        if s_type == &#39;SvDummySocket&#39;:
            return #
        if outputs[outputsocketname[0]].bl_idname != s_type:
            to_links = {}
            idx = {}
            # gather info
            for n in outputsocketname:
                out_socket = outputs[n]
                idx[n] = out_socket.index
                to_links[n] = [l.to_socket for l in out_socket.links]
            # add sockets and copy options
            for n in outputsocketname:
                out_socket = outputs[n]
                new_out_socket = outputs.new(s_type, n)
                new_out_socket.copy_options(out_socket)
            # remove sockets
            for n in outputsocketname[::-1]:
                old_sock_ind = idx[n]
                outputs.remove(outputs[old_sock_ind])
            # place sockets and return links
            for i, n in enumerate(outputsocketname):
                static_num = len(outputs) - len(outputsocketname)
                new_sock_ind = static_num + i
                outputs.move(new_sock_ind, idx[n])
                for to_socket in to_links[n]:
                    ng.links.new(to_socket, outputs[n])</code></pre>
</details>
<div class="desc"><p>It changes types of output sockets according to type of socket (other)
connected to given input socket name
!!! It does not work if the node have outputs with the same names !!!
If input socket is not connected or its type is equal to type of
first output socket it does nothing
arguments: node, name of socket to follow, list of socket to change</p></div>
</dd>
<dt id="sverchok.data_structure.cross_indices_np"><code class="name flex">
<span>def <span class="ident">cross_indices_np</span></span>(<span>n)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross_indices_np(n):
    &#39;&#39;&#39;
    create list with all the indices pairs
    for n=3 outputs a numpy array with:
        [0,1]
        [0,2]
        [1,2]

    &#39;&#39;&#39;

    nu = np.sum(np.arange(n, dtype=np.int64))
    ind = np.zeros((nu, 2), dtype=np.int16)
    c = 0
    for i in range(n-1):
        l = n-i-1
        np_i = np.full(n-i-1, i, dtype=np.int32)
        np_j = np.arange(i+1, n, dtype=np.int32)
        np_a = np.stack((np_i, np_j), axis=-1)
        ind[c:c+l, :] = np_a
        c += l

    return ind</code></pre>
</details>
<div class="desc"><p>create list with all the indices pairs
for n=3 outputs a numpy array with:
[0,1]
[0,2]
[1,2]</p></div>
</dd>
<dt id="sverchok.data_structure.cycle_for_length"><code class="name flex">
<span>def <span class="ident">cycle_for_length</span></span>(<span>lst, count)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cycle_for_length(lst, count):
    return list(islice(cycle(lst), count))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.dataCorrect"><code class="name flex">
<span>def <span class="ident">dataCorrect</span></span>(<span>data, nominal_dept=2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataCorrect(data, nominal_dept=2):
    &#34;&#34;&#34;data from nesting to standard: TO container( objects( lists( floats, ), ), )
    &#34;&#34;&#34;
    dept = levelsOflist(data)
    output = []
    if not dept: # for empty lists
        return []
    if dept &lt; 2:
        return data #[dept, data]
    else:
        output = data_standard(data, dept, nominal_dept)
        return output</code></pre>
</details>
<div class="desc"><p>data from nesting to standard: TO container( objects( lists( floats, ), ), )</p></div>
</dd>
<dt id="sverchok.data_structure.dataCorrect_np"><code class="name flex">
<span>def <span class="ident">dataCorrect_np</span></span>(<span>data, nominal_dept=2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataCorrect_np(data, nominal_dept=2):
    &#34;&#34;&#34;data from nesting to standard: TO container( objects( lists( floats, ), ), )
    &#34;&#34;&#34;
    dept = levels_of_list_or_np(data)
    output = []
    if not dept: # for empty lists
        return []
    if dept &lt; 2:
        return data #[dept, data]
    else:
        output = data_standard(data, dept, nominal_dept)
        return output</code></pre>
</details>
<div class="desc"><p>data from nesting to standard: TO container( objects( lists( floats, ), ), )</p></div>
</dd>
<dt id="sverchok.data_structure.dataSpoil"><code class="name flex">
<span>def <span class="ident">dataSpoil</span></span>(<span>data, dept)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataSpoil(data, dept):
    &#34;&#34;&#34;from standard data to initial levels: to nested lists
     container( objects( lists( nested_lists( floats, ), ), ), ) это невозможно!
    &#34;&#34;&#34;
    __doc__ = &#39;preparing and making spoil&#39;

    def Spoil(dat, dep):
        __doc__ = &#39;making spoil&#39;
        out = []
        if dep:
            for d in dat:
                out.append([Spoil(d, dep-1)])
        else:
            out = dat
        return out
    lol = levelsOflist(data)
    if dept &gt; lol:
        out = Spoil(data, dept-lol)
    else:
        out = data
    return out</code></pre>
</details>
<div class="desc"><p>from standard data to initial levels: to nested lists
container( objects( lists( nested_lists( floats, ), ), ), ) это невозможно!</p></div>
</dd>
<dt id="sverchok.data_structure.data_standard"><code class="name flex">
<span>def <span class="ident">data_standard</span></span>(<span>data, dept, nominal_dept)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_standard(data, dept, nominal_dept):
    &#34;&#34;&#34;data from nesting to standard: TO container( objects( lists( floats, ), ), )&#34;&#34;&#34;
    deptl = dept - 1
    output = []
    for object in data:
        if deptl &gt;= nominal_dept:
            output.extend(data_standard(object, deptl, nominal_dept))
        else:
            output.append(data)
            return output
    return output</code></pre>
</details>
<div class="desc"><p>data from nesting to standard: TO container( objects( lists( floats, ), ), )</p></div>
</dd>
<dt id="sverchok.data_structure.describe_data_shape"><code class="name flex">
<span>def <span class="ident">describe_data_shape</span></span>(<span>data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_data_shape(data):
    &#34;&#34;&#34;
    Describe shape of data in human-readable form.
    Returns string.
    Can be used for debugging or for displaying information to user.
    Note: this method inspects only first element of each list/tuple,
    expecting they are all homogeneous (that is usually true in Sverchok).

    describe_data_shape(None) == &#39;Level 0: NoneType&#39;
    describe_data_shape(1) == &#39;Level 0: int&#39;
    describe_data_shape([]) == &#39;Level 1: list [0]&#39;
    describe_data_shape([1]) == &#39;Level 1: list [1] of int&#39;
    describe_data_shape([[(1,2,3)]]) == &#39;Level 3: list [1] of list [1] of tuple [3] of int&#39;
    &#34;&#34;&#34;

    nesting, descriptions = describe_data_shape_by_level(data)
    result = &#34; of &#34;.join(descriptions)
    return &#34;Level {}: {}&#34;.format(nesting, result)</code></pre>
</details>
<div class="desc"><p>Describe shape of data in human-readable form.
Returns string.
Can be used for debugging or for displaying information to user.
Note: this method inspects only first element of each list/tuple,
expecting they are all homogeneous (that is usually true in Sverchok).</p>
<p>describe_data_shape(None) == 'Level 0: NoneType'
describe_data_shape(1) == 'Level 0: int'
describe_data_shape([]) == 'Level 1: list [0]'
describe_data_shape([1]) == 'Level 1: list [1] of int'
describe_data_shape([[(1,2,3)]]) == 'Level 3: list [1] of list [1] of tuple [3] of int'</p></div>
</dd>
<dt id="sverchok.data_structure.describe_data_shape_by_level"><code class="name flex">
<span>def <span class="ident">describe_data_shape_by_level</span></span>(<span>data, include_numpy_nesting=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_data_shape_by_level(data, include_numpy_nesting=True):
    &#34;&#34;&#34;
    Describe shape of data in human-readable form.
    Returns tuple:
    * data nesting level
    * list of descriptions of data shapes at each nesting level
    &#34;&#34;&#34;
    def helper(data):
        if not isinstance(data, (list, tuple)):
            if isinstance(data, ndarray):
                if include_numpy_nesting:
                    nesting = len(data.shape)
                else:
                    nesting = 0
                return nesting, [type(data).__name__ + &#34; of &#34; + str(data.dtype) + &#34; with shape &#34; + str(data.shape)]
            return 0, [type(data).__name__]
        else:
            result = [f&#34;{type(data).__name__} [{len(data)}]&#34;]
            if len(data) &gt; 0:
                child = data[0]
                child_nesting, child_result = helper(child)
                result = result + child_result
            else:
                child_nesting = 0
            return (child_nesting + 1), result

    nesting, result = helper(data)
    return nesting, result</code></pre>
</details>
<div class="desc"><p>Describe shape of data in human-readable form.
Returns tuple:
* data nesting level
* list of descriptions of data shapes at each nesting level</p></div>
</dd>
<dt id="sverchok.data_structure.describe_data_structure"><code class="name flex">
<span>def <span class="ident">describe_data_structure</span></span>(<span>data,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_data_structure(data, data_types=SIMPLE_DATA_TYPES):
    if isinstance(data, data_types):
        return &#34;*&#34;
    elif isinstance(data, (list, tuple)):
        if isinstance(data[0], data_types):
            return str(len(data)) + &#34;*&#34;
        else:
            rs = []
            for item in data:
                r = describe_data_structure(item, data_types)
                rs.append(str(r))
            rs = str(len(data)) + &#34;[&#34; + &#34;, &#34;.join(rs) + &#34;]&#34;
            return rs
    else:
        raise TypeError(f&#34;Unexpected data type: {type(data)}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.ensure_min_nesting"><code class="name flex">
<span>def <span class="ident">ensure_min_nesting</span></span>(<span>data,<br>target_level,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;),<br>input_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_min_nesting(data, target_level, data_types=SIMPLE_DATA_TYPES, input_name=None):
    &#34;&#34;&#34;
    data: number, or list of numbers, or list of lists, etc.
    target_level: minimum data nesting level required for further processing.
    data_types: list or tuple of types.
    input_name: name of input socket data was taken from. Optional. If specified,
        used for error reporting.

    Wraps data in so many [] as required to achieve target nesting level.
    If data already has too high nesting level the same data will be returned

    ensure_min_nesting(17, 0) == 17
    ensure_min_nesting(17, 1) == [17]
    ensure_min_nesting([17], 1) == [17]
    ensure_min_nesting([17], 2) == [[17]]
    ensure_min_nesting([(1,2,3)], 3) == [[(1,2,3)]]
    ensure_min_nesting([[[17]]], 1) =&gt; [[[17]]]
    &#34;&#34;&#34;

    current_level = get_data_nesting_level(data, data_types)
    if current_level &gt;= target_level:
        return data
    result = data
    for i in range(target_level - current_level):
        result = [result]
    return result</code></pre>
</details>
<div class="desc"><p>data: number, or list of numbers, or list of lists, etc.
target_level: minimum data nesting level required for further processing.
data_types: list or tuple of types.
input_name: name of input socket data was taken from. Optional. If specified,
used for error reporting.</p>
<p>Wraps data in so many [] as required to achieve target nesting level.
If data already has too high nesting level the same data will be returned</p>
<p>ensure_min_nesting(17, 0) == 17
ensure_min_nesting(17, 1) == [17]
ensure_min_nesting([17], 1) == [17]
ensure_min_nesting([17], 2) == [[17]]
ensure_min_nesting([(1,2,3)], 3) == [[(1,2,3)]]
ensure_min_nesting([[[17]]], 1) =&gt; [[[17]]]</p></div>
</dd>
<dt id="sverchok.data_structure.ensure_nesting_level"><code class="name flex">
<span>def <span class="ident">ensure_nesting_level</span></span>(<span>data,<br>target_level,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;),<br>input_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_nesting_level(data, target_level, data_types=SIMPLE_DATA_TYPES, input_name=None):
    &#34;&#34;&#34;
    data: number, or list of numbers, or list of lists, etc.
    target_level: data nesting level required for further processing.
    data_types: list or tuple of types.
    input_name: name of input socket data was taken from. Optional. If specified,
        used for error reporting.

    Wraps data in so many [] as required to achieve target nesting level.
    Raises an exception, if data already has too high nesting level.

    ensure_nesting_level(17, 0) == 17
    ensure_nesting_level(17, 1) == [17]
    ensure_nesting_level([17], 1) == [17]
    ensure_nesting_level([17], 2) == [[17]]
    ensure_nesting_level([(1,2,3)], 3) == [[(1,2,3)]]
    ensure_nesting_level([[[17]]], 1) =&gt; exception
    &#34;&#34;&#34;

    current_level = get_data_nesting_level(data, data_types)
    if current_level &gt; target_level:
        if input_name is None:
            raise TypeError(&#34;ensure_nesting_level: input data already has nesting level of {}. Required level was {}.&#34;.format(current_level, target_level))
        else:
            raise TypeError(&#34;Input data in socket {} already has nesting level of {}. Required level was {}.&#34;.format(input_name, current_level, target_level))
    result = data
    for i in range(target_level - current_level):
        result = [result]
    return result</code></pre>
</details>
<div class="desc"><p>data: number, or list of numbers, or list of lists, etc.
target_level: data nesting level required for further processing.
data_types: list or tuple of types.
input_name: name of input socket data was taken from. Optional. If specified,
used for error reporting.</p>
<p>Wraps data in so many [] as required to achieve target nesting level.
Raises an exception, if data already has too high nesting level.</p>
<p>ensure_nesting_level(17, 0) == 17
ensure_nesting_level(17, 1) == [17]
ensure_nesting_level([17], 1) == [17]
ensure_nesting_level([17], 2) == [[17]]
ensure_nesting_level([(1,2,3)], 3) == [[(1,2,3)]]
ensure_nesting_level([[[17]]], 1) =&gt; exception</p></div>
</dd>
<dt id="sverchok.data_structure.enum_item"><code class="name flex">
<span>def <span class="ident">enum_item</span></span>(<span>s)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enum_item(s):
    &#34;&#34;&#34;return a list usable in enum property from a list with one value&#34;&#34;&#34;
    return [(no_space(i), i, &#34;&#34;) for i in s]</code></pre>
</details>
<div class="desc"><p>return a list usable in enum property from a list with one value</p></div>
</dd>
<dt id="sverchok.data_structure.enum_item_4"><code class="name flex">
<span>def <span class="ident">enum_item_4</span></span>(<span>s)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enum_item_4(s):
    &#34;&#34;&#34;return a 4*n list usable in enum property from a list with one value&#34;&#34;&#34;
    return [(no_space(n), n, &#39;&#39;, i) for i, n in enumerate(s)]</code></pre>
</details>
<div class="desc"><p>return a 4*n list usable in enum property from a list with one value</p></div>
</dd>
<dt id="sverchok.data_structure.enum_item_5"><code class="name flex">
<span>def <span class="ident">enum_item_5</span></span>(<span>s, icons)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enum_item_5(s, icons):
    &#34;&#34;&#34;return a 4*n list usable in enum property from a list with one value&#34;&#34;&#34;
    return [(no_space(n), n, &#39;&#39;, icon, i) for i, (n, icon) in enumerate(zip(s, icons))]</code></pre>
</details>
<div class="desc"><p>return a 4*n list usable in enum property from a list with one value</p></div>
</dd>
<dt id="sverchok.data_structure.extend_blender_class"><code class="name flex">
<span>def <span class="ident">extend_blender_class</span></span>(<span>cls)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_blender_class(cls):
    &#34;&#34;&#34;
    It is class decorator for adding extra logic into base Blender classes
    Decorated class should have the same name as Blender class
    Take into account that this decorator does not delete anything onto reload event
    &#34;&#34;&#34;
    bl_class = getattr(bpy.types, cls.__name__)
    for base_cls in chain([cls], cls.__bases__):
        # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older
        # avoiding getting inherited annotations
        if &#39;__annotations__&#39; in base_cls.__dict__:
            for name, prop in base_cls.__dict__[&#39;__annotations__&#39;].items():
                setattr(bl_class, name, prop)
        for key in (key for key in dir(base_cls) if not key.startswith(&#39;_&#39;)):
            setattr(bl_class, key, getattr(base_cls, key))
    return cls</code></pre>
</details>
<div class="desc"><p>It is class decorator for adding extra logic into base Blender classes
Decorated class should have the same name as Blender class
Take into account that this decorator does not delete anything onto reload event</p></div>
</dd>
<dt id="sverchok.data_structure.fixed_iter"><code class="name flex">
<span>def <span class="ident">fixed_iter</span></span>(<span>data, iter_number, fill_value=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixed_iter(data, iter_number, fill_value=0):
    &#34;&#34;&#34;
    Creates iterator for given data which will be yielded iter_number times
    If data is shorter then iter_number last element will be cycled
    If data is empty [fill_value] list will be used instead
    &#34;&#34;&#34;
    last_index = -1
    for i, item in zip(range(iter_number), data):
        yield item
        last_index = i
        fill_value = item

    if last_index + 1 &lt; iter_number:
        for i, item in zip(range(iter_number - (last_index + 1)), cycle([fill_value])):
            yield item</code></pre>
</details>
<div class="desc"><p>Creates iterator for given data which will be yielded iter_number times
If data is shorter then iter_number last element will be cycled
If data is empty [fill_value] list will be used instead</p></div>
</dd>
<dt id="sverchok.data_structure.flat_iter"><code class="name flex">
<span>def <span class="ident">flat_iter</span></span>(<span>data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flat_iter(data):
    &#34;&#34;&#34;[1, [2, 3, [4]], 5] -&gt; 1, 2, 3, 4, 5 &#34;&#34;&#34;
    if isinstance(data, str):
        yield data
        return
    try:
        for v in data:
            yield from flat_iter(v)
    except TypeError:
        yield data</code></pre>
</details>
<div class="desc"><p>[1, [2, 3, [4]], 5] -&gt; 1, 2, 3, 4, 5</p></div>
</dd>
<dt id="sverchok.data_structure.flatten_data"><code class="name flex">
<span>def <span class="ident">flatten_data</span></span>(<span>data,<br>target_level=1,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_data(data, target_level=1, data_types=SIMPLE_DATA_TYPES):
    &#34;&#34;&#34;
    Reduce nesting level of `data` to `target_level`, by concatenating nested sub-lists.
    Raises an exception if nesting level is already less than `target_level`.
    Refer to data_structure_tests.py for examples.
    &#34;&#34;&#34;
    current_level = get_data_nesting_level(data, data_types)
    if current_level &lt; target_level:
        raise TypeError(f&#34;Can&#39;t flatten data to level {target_level}: data already have level {current_level}&#34;)
    elif current_level == target_level:
        return data
    else:
        result = []
        for item in data:
            result.extend(flatten_data(item, target_level=target_level, data_types=data_types))
        return result</code></pre>
</details>
<div class="desc"><p>Reduce nesting level of <code>data</code> to <code>target_level</code>, by concatenating nested sub-lists.
Raises an exception if nesting level is already less than <code>target_level</code>.
Refer to data_structure_tests.py for examples.</p></div>
</dd>
<dt id="sverchok.data_structure.fullList"><code class="name flex">
<span>def <span class="ident">fullList</span></span>(<span>l, count)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullList(l, count):
    &#34;&#34;&#34;extends list l so len is at least count if needed with the
    last element of l&#34;&#34;&#34;
    n = len(l)
    if n == count:
        return
    d = count - n
    if d &gt; 0:
        l.extend([l[-1] for a in range(d)])
    return</code></pre>
</details>
<div class="desc"><p>extends list l so len is at least count if needed with the
last element of l</p></div>
</dd>
<dt id="sverchok.data_structure.fullList_deep_copy"><code class="name flex">
<span>def <span class="ident">fullList_deep_copy</span></span>(<span>l, count)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullList_deep_copy(l, count):
    &#34;&#34;&#34;the same that full list function but
    it have correct work with objects such as lists.&#34;&#34;&#34;
    d = count - len(l)
    if d &gt; 0:
        l.extend([copy.deepcopy(l[-1]) for _ in range(d)])
    return</code></pre>
</details>
<div class="desc"><p>the same that full list function but
it have correct work with objects such as lists.</p></div>
</dd>
<dt id="sverchok.data_structure.fullList_np"><code class="name flex">
<span>def <span class="ident">fullList_np</span></span>(<span>l, count)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullList_np(l, count):
    &#34;&#34;&#34;extends list l so len is at least count if needed with the
    last element of l&#34;&#34;&#34;
    n = len(l)
    if n == count:
        return
    d = count - n
    if d &gt; 0:
        try:
            l.extend([l[-1] for a in range(d)])
        except:
            l = numpy_full_list(l, n)
    else:
        l = l[:count]</code></pre>
</details>
<div class="desc"><p>extends list l so len is at least count if needed with the
last element of l</p></div>
</dd>
<dt id="sverchok.data_structure.get_data_nesting_level"><code class="name flex">
<span>def <span class="ident">get_data_nesting_level</span></span>(<span>data,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;),<br>search_first_data=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_nesting_level(data, data_types=SIMPLE_DATA_TYPES, search_first_data=False):
    &#34;&#34;&#34;
    data: number, or list of numbers, or list of lists, etc.
    data_types: list or tuple of types.

    Detect nesting level of actual data.
    &#34;Actual&#34; data is detected by belonging to one of data_types.
    This method searches only for first instance of &#34;actual data&#34;,
    so it does not support cases when different elements of source
    list have different nesting.
    Returns integer.
    Raises an exception if at some point it encounters element
    which is not a tuple, list, or one of data_types.

    get_data_nesting_level(1) == 0
    get_data_nesting_level([]) == 1
    get_data_nesting_level([1]) == 1
    get_data_nesting_level([[(1,2,3)]]) == 3
    &#34;&#34;&#34;

    def helper(data, recursion_depth):
        &#34;&#34;&#34; Needed only for better error reporting. &#34;&#34;&#34;
        if isinstance(data, data_types):
            return (0, 0)
        elif isinstance(data, (list, tuple, ndarray)):
            if len(data) == 0:
                return (1, -1)
            else:
                if search_first_data==False:
                    res = helper(data[0], recursion_depth+1)
                else:
                    for I, data_I in enumerate(data):
                        res = helper(data_I, recursion_depth+1)
                        if res[1]==0:
                            return (res[0]+1, res[1] )
                #return helper(data[0], recursion_depth+1) + 1
                return (res[0]+ 1, res[1] )
        elif data is None:
            raise TypeError(&#34;get_data_nesting_level: encountered None at nesting level {}&#34;.format(recursion_depth))
        else:
            #unknown class. Return 0 level
            return (0, -1)

    res = helper(data, 0)
    return res[0] </code></pre>
</details>
<div class="desc"><p>data: number, or list of numbers, or list of lists, etc.
data_types: list or tuple of types.</p>
<p>Detect nesting level of actual data.
"Actual" data is detected by belonging to one of data_types.
This method searches only for first instance of "actual data",
so it does not support cases when different elements of source
list have different nesting.
Returns integer.
Raises an exception if at some point it encounters element
which is not a tuple, list, or one of data_types.</p>
<p>get_data_nesting_level(1) == 0
get_data_nesting_level([]) == 1
get_data_nesting_level([1]) == 1
get_data_nesting_level([[(1,2,3)]]) == 3</p></div>
</dd>
<dt id="sverchok.data_structure.get_edge_list"><code class="name flex">
<span>def <span class="ident">get_edge_list</span></span>(<span>n)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_list(n):
    &#34;&#34;&#34;
    Get the list of n edges connecting n+1 vertices.

    e.g. [[0, 1], [1, 2], ... , [n-1, n]]

    NOTE: This uses an &#34;edge cache&#34; to accelerate the edge list generation.
    The cache is extended automatically as needed to satisfy the largest number
    of edges within the node tree and it is shared by all nodes using this method.
    &#34;&#34;&#34;
    update_edge_cache(n) # make sure the edge cache is large enough
    return _edgeCache[&#34;main&#34;][:n] # return a subset list of the edge cache</code></pre>
</details>
<div class="desc"><p>Get the list of n edges connecting n+1 vertices.</p>
<p>e.g. [[0, 1], [1, 2], &hellip; , [n-1, n]]</p>
<p>NOTE: This uses an "edge cache" to accelerate the edge list generation.
The cache is extended automatically as needed to satisfy the largest number
of edges within the node tree and it is shared by all nodes using this method.</p></div>
</dd>
<dt id="sverchok.data_structure.get_edge_loop"><code class="name flex">
<span>def <span class="ident">get_edge_loop</span></span>(<span>n)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edge_loop(n):
    &#34;&#34;&#34;
    Get the loop list of n edges connecting n vertices.

    e.g. [[0, 1], [1, 2], ... , [n-2, n-1], [n-1, 0]]

    NOTE: This uses an &#34;edge cache&#34; to accelerate the edge list generation.
    The cache is extended automatically as needed to satisfy the largest number
    of edges within the node tree and it is shared by all nodes using this method.
    &#34;&#34;&#34;
    nn = n - 1
    update_edge_cache(nn) # make sure the edge cache is large enough
    return _edgeCache[&#34;main&#34;][:nn] + [[nn, 0]]</code></pre>
</details>
<div class="desc"><p>Get the loop list of n edges connecting n vertices.</p>
<p>e.g. [[0, 1], [1, 2], &hellip; , [n-2, n-1], [n-1, 0]]</p>
<p>NOTE: This uses an "edge cache" to accelerate the edge list generation.
The cache is extended automatically as needed to satisfy the largest number
of edges within the node tree and it is shared by all nodes using this method.</p></div>
</dd>
<dt id="sverchok.data_structure.get_other_socket"><code class="name flex">
<span>def <span class="ident">get_other_socket</span></span>(<span>socket)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_other_socket(socket):
    &#34;&#34;&#34;
    Get next real upstream socket.
    This should be expanded to support wifi nodes also.
    Will return None if there isn&#39;t a another socket connect
    so no need to check socket.links
    &#34;&#34;&#34;
    if not socket.is_linked:
        return None
    if not socket.is_output:
        if socket.links:
            other = socket.links[0].from_socket
        else:
            return None
    else:
        other = socket.links[0].to_socket

    if other.node.bl_idname == &#39;NodeReroute&#39;:
        if not socket.is_output:
            return get_other_socket(other.node.inputs[0])
        else:
            return get_other_socket(other.node.outputs[0])
    else:  #other.node.bl_idname == &#39;WifiInputNode&#39;:
        return other</code></pre>
</details>
<div class="desc"><p>Get next real upstream socket.
This should be expanded to support wifi nodes also.
Will return None if there isn't a another socket connect
so no need to check socket.links</p></div>
</dd>
<dt id="sverchok.data_structure.graft_data"><code class="name flex">
<span>def <span class="ident">graft_data</span></span>(<span>data,<br>item_level=1,<br>wrap_level=1,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graft_data(data, item_level=1, wrap_level=1, data_types=SIMPLE_DATA_TYPES):
    &#34;&#34;&#34;
    For each nested item of the list, which has it&#39;s own nesting level of `target_level`,
    wrap that item into a pair of [].
    For example, with item_level==0, this means wrap each number in the nested list
    (however deep this number is nested) into pair of [].
    Refer to data_structure_tests.py for examples.
    &#34;&#34;&#34;
    def wrap(item):
        for i in range(wrap_level):
            item = [item]
        return item

    def helper(data):
        current_level = get_data_nesting_level(data, data_types)
        if current_level == item_level:
            return wrap(data)
        else:
            result = [helper(item) for item in data]
            return result

    return helper(data)</code></pre>
</details>
<div class="desc"><p>For each nested item of the list, which has it's own nesting level of <code>target_level</code>,
wrap that item into a pair of [].
For example, with item_level==0, this means wrap each number in the nested list
(however deep this number is nested) into pair of [].
Refer to data_structure_tests.py for examples.</p></div>
</dd>
<dt id="sverchok.data_structure.handle_check"><code class="name flex">
<span>def <span class="ident">handle_check</span></span>(<span>handle, prop)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_check(handle, prop):
    if handle in handle_check and \
            prop == handle_check[handle][&#39;prop&#39;]:
        return True
    return False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.handle_delete"><code class="name flex">
<span>def <span class="ident">handle_delete</span></span>(<span>handle)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_delete(handle):
    if handle in temp_handle:
        del temp_handle[handle]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.handle_read"><code class="name flex">
<span>def <span class="ident">handle_read</span></span>(<span>handle)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_read(handle):
    if not (handle in temp_handle):
        return (False, [])
    return (True, temp_handle[handle][&#39;prop&#39;])</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.handle_write"><code class="name flex">
<span>def <span class="ident">handle_write</span></span>(<span>handle, prop)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_write(handle, prop):
    handle_delete(handle)

    temp_handle[handle] = {&#34;prop&#34; : prop}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.has_element"><code class="name flex">
<span>def <span class="ident">has_element</span></span>(<span>pol_edge)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_element(pol_edge):
    if pol_edge is None:
        return False
    if len(pol_edge) &gt; 0 and hasattr(pol_edge[0], &#39;__len__&#39;) and len(pol_edge[0]) &gt; 0:
        return True
    return False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.invert_index_list"><code class="name flex">
<span>def <span class="ident">invert_index_list</span></span>(<span>indexes, length)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert_index_list(indexes, length):
    &#39;&#39;&#39;
    Inverts indexes list
    indexes: List[Int] of Ndarray flat numpy array
    length: Int. Length of the base list
    &#39;&#39;&#39;
    mask = np_ones(length, dtype=&#39;bool&#39;)
    mask[indexes] = False
    inverted_indexes = np_arange(length)[mask]
    return inverted_indexes</code></pre>
</details>
<div class="desc"><p>Inverts indexes list
indexes: List[Int] of Ndarray flat numpy array
length: Int. Length of the base list</p></div>
</dd>
<dt id="sverchok.data_structure.is_ultimately"><code class="name flex">
<span>def <span class="ident">is_ultimately</span></span>(<span>data, data_types)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ultimately(data, data_types):
    &#34;&#34;&#34;
    Check if data is a nested list / tuple / array
    which ultimately consists of items of data_types.
    &#34;&#34;&#34;
    if isinstance(data, (list, tuple, ndarray)):
        return is_ultimately(data[0], data_types)
    return isinstance(data, data_types)</code></pre>
</details>
<div class="desc"><p>Check if data is a nested list / tuple / array
which ultimately consists of items of data_types.</p></div>
</dd>
<dt id="sverchok.data_structure.levelsOflist"><code class="name flex">
<span>def <span class="ident">levelsOflist</span></span>(<span>lst)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def levelsOflist(lst):
    &#34;&#34;&#34;calc list nesting only in countainment level integer&#34;&#34;&#34;
    level = 1
    for n in lst:
        if n and isinstance(n, (list, tuple)):
            level += levelsOflist(n)
        return level
    return 0</code></pre>
</details>
<div class="desc"><p>calc list nesting only in countainment level integer</p></div>
</dd>
<dt id="sverchok.data_structure.levels_of_list_or_np"><code class="name flex">
<span>def <span class="ident">levels_of_list_or_np</span></span>(<span>lst)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def levels_of_list_or_np(lst):
    &#34;&#34;&#34;calc list nesting only in countainment level integer&#34;&#34;&#34;
    level = 1
    for n in lst:
        if isinstance(n, (list, tuple)):
            level += levels_of_list_or_np(n)
        elif isinstance(n, (ndarray)):
            level += len(n.shape)

        return level
    return 0</code></pre>
</details>
<div class="desc"><p>calc list nesting only in countainment level integer</p></div>
</dd>
<dt id="sverchok.data_structure.list_levels_adjust"><code class="name flex">
<span>def <span class="ident">list_levels_adjust</span></span>(<span>data,<br>instructions,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_levels_adjust(data, instructions, data_types=SIMPLE_DATA_TYPES):
    data_level = get_data_nesting_level(data, data_types + (ndarray,))
    if len(instructions) &lt; data_level+1:
        raise Exception(f&#34;Number of instructions ({len(instructions)}) is less than data nesting level {data_level} + 1&#34;)

    def process(data, instruction, level):
        result = data
        if level + 1 &lt; data_level and instruction.flatten:
            result = sum(result, [])
        if instruction.wrap:
            result = [result]
        #print(f&#34;II: {level}/{data_level}, {instruction}, {data} =&gt; {result}&#34;)
        return result

    def helper(data, instructions, level):
        if level == data_level:
            items = process(data, instructions[0], level)
        else:
            sub_items = [helper(item, instructions[1:], level+1) for item in data]
            items = process(sub_items, instructions[0], level)
            #print(f&#34;?? {level}/{data_level}, {data} =&gt; {sub_items} =&gt; {items}&#34;)
        return items

    return helper(data, instructions, 0)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.make_cyclers"><code class="name flex">
<span>def <span class="ident">make_cyclers</span></span>(<span>lists)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_cyclers(lists):

    cycle = itertools.cycle
    out =[]
    for l in lists:
        out.append(cycle(l))
    return out</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.make_repeaters"><code class="name flex">
<span>def <span class="ident">make_repeaters</span></span>(<span>lists)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_repeaters(lists):
    chain = itertools.chain
    repeat = itertools.repeat
    out =[]
    for l in lists:
        out.append(chain(l, repeat(l[-1])))

    return out</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.map_at_level"><code class="name flex">
<span>def <span class="ident">map_at_level</span></span>(<span>function,<br>data,<br>item_level=0,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_at_level(function, data, item_level=0, data_types=SIMPLE_DATA_TYPES):
    &#34;&#34;&#34;
    Given a nested list of object, apply `function` to each sub-list of items.
    Nesting structure of the result will be simpler than such of the input:
    most nested levels (`item_level` of them) will be eliminated.
    Refer to data_structure_tests.py for examples.
    &#34;&#34;&#34;
    current_level = get_data_nesting_level(data, data_types)
    if current_level == item_level:
        return function(data)
    else:
        return [map_at_level(function, item, item_level, data_types) for item in data]</code></pre>
</details>
<div class="desc"><p>Given a nested list of object, apply <code>function</code> to each sub-list of items.
Nesting structure of the result will be simpler than such of the input:
most nested levels (<code>item_level</code> of them) will be eliminated.
Refer to data_structure_tests.py for examples.</p></div>
</dd>
<dt id="sverchok.data_structure.map_recursive"><code class="name flex">
<span>def <span class="ident">map_recursive</span></span>(<span>fn,<br>data,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_recursive(fn, data, data_types=SIMPLE_DATA_TYPES):
    &#34;&#34;&#34;
    Given a nested list of items, apply `fn` to each of these items.
    Nesting structure of the result will be the same as in the input.
    &#34;&#34;&#34;
    def helper(data, level):
        if isinstance(data, data_types):
            return fn(data)
        elif isinstance(data, (list, tuple)):
            return [helper(item, level+1) for item in data]
        else:
            raise TypeError(f&#34;Encountered unknown data of type {type(data)} at nesting level #{level}&#34;)
    return helper(data, 0)</code></pre>
</details>
<div class="desc"><p>Given a nested list of items, apply <code>fn</code> to each of these items.
Nesting structure of the result will be the same as in the input.</p></div>
</dd>
<dt id="sverchok.data_structure.map_unzip_recursirve"><code class="name flex">
<span>def <span class="ident">map_unzip_recursirve</span></span>(<span>fn,<br>data,<br>data_types=(&lt;class &#x27;float&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, &lt;class &#x27;numpy.float64&#x27;&gt;, &lt;class &#x27;numpy.int32&#x27;&gt;, &lt;class &#x27;numpy.int64&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;Matrix&#x27;&gt;))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_unzip_recursirve(fn, data, data_types=SIMPLE_DATA_TYPES):
    &#34;&#34;&#34;
    Given a nested list of items, apply `fn` to each of these items.
    This method expects that `fn` will return a tuple (or list) of results.
    After applying `fn` to each of items of data, &#34;unzip&#34; the result, so that
    each item of result of `fn` would be in a separate nested list.
    Nesting structure of each of items of the result of this method will be
    the same as nesting structure of input data.
    Refer to data_structure_tests.py for examples.
    &#34;&#34;&#34;
    def helper(data, level):
        if isinstance(data, data_types):
            return fn(data)
        elif isinstance(data, (list, tuple)):
            results = [helper(item, level+1) for item in data]
            return transpose_list(results)
        else:
            raise TypeError(f&#34;Encountered unknown data of type {type(data)} at nesting level #{level}&#34;)
    return helper(data, 0)</code></pre>
</details>
<div class="desc"><p>Given a nested list of items, apply <code>fn</code> to each of these items.
This method expects that <code>fn</code> will return a tuple (or list) of results.
After applying <code>fn</code> to each of items of data, "unzip" the result, so that
each item of result of <code>fn</code> would be in a separate nested list.
Nesting structure of each of items of the result of this method will be
the same as nesting structure of input data.
Refer to data_structure_tests.py for examples.</p></div>
</dd>
<dt id="sverchok.data_structure.match_cross"><code class="name flex">
<span>def <span class="ident">match_cross</span></span>(<span>lsts)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_cross(lsts):
    &#34;&#34;&#34; return cross matched lists
    [[1,2], [5,6,7]] -&gt; [[1,1,1,2,2,2], [5,6,7,5,6,7]]
    &#34;&#34;&#34;
    return list(map(list, zip(*itertools.product(*lsts))))</code></pre>
</details>
<div class="desc"><p>return cross matched lists
[[1,2], [5,6,7]] -&gt; [[1,1,1,2,2,2], [5,6,7,5,6,7]]</p></div>
</dd>
<dt id="sverchok.data_structure.match_cross2"><code class="name flex">
<span>def <span class="ident">match_cross2</span></span>(<span>lsts)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_cross2(lsts):
    &#34;&#34;&#34; return cross matched lists
    [[1,2], [5,6,7]] -&gt;[[1, 2, 1, 2, 1, 2], [5, 5, 6, 6, 7, 7]]
    &#34;&#34;&#34;
    return list(reversed(list(map(list, zip(*itertools.product(*reversed(lsts)))))))</code></pre>
</details>
<div class="desc"><p>return cross matched lists
[[1,2], [5,6,7]] -&gt;[[1, 2, 1, 2, 1, 2], [5, 5, 6, 6, 7, 7]]</p></div>
</dd>
<dt id="sverchok.data_structure.match_long_cycle"><code class="name flex">
<span>def <span class="ident">match_long_cycle</span></span>(<span>lsts)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_long_cycle(lsts):
    &#34;&#34;&#34;return matched list, cycling the shorter lists
    longest list matching, cycle [[1,2,3,4,5] ,[10,11]] -&gt; [[1,2,3,4,5] ,[10,11,10,11,10]]
    &#34;&#34;&#34;
    max_l = 0
    tmp = []
    for l in lsts:
        max_l = max(max_l, len(l))
    for l in lsts:
        if len(l) == max_l:
            tmp.append(l)
        else:
            tmp.append(itertools.cycle(l))
    return list(map(list, zip(*zip(*tmp))))</code></pre>
</details>
<div class="desc"><p>return matched list, cycling the shorter lists
longest list matching, cycle [[1,2,3,4,5] ,[10,11]] -&gt; [[1,2,3,4,5] ,[10,11,10,11,10]]</p></div>
</dd>
<dt id="sverchok.data_structure.match_long_repeat"><code class="name flex">
<span>def <span class="ident">match_long_repeat</span></span>(<span>lsts)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_long_repeat(lsts):
    &#34;&#34;&#34;return matched list, using the last value to fill lists as needed
    longest list matching [[1,2,3,4,5], [10,11]] -&gt; [[1,2,3,4,5], [10,11,11,11,11]]
    
    lists passed into this function are not modified, it produces non-deep copies and extends those.
    &#34;&#34;&#34;
    max_l = 0
    tmp = []
    for l in lsts:
        if not hasattr(l, &#39;__len__&#39;):
            raise TypeError(f&#34;Cannot perform data matching: input of type {type(l)} is not a list or tuple, but an atomic object&#34;)
        max_l = max(max_l, len(l))
    for l in lsts:
        if len(l) == max_l:
            tmp.append(l)
        else:
            tmp.append(repeat_last(l))
    return list(map(list, zip(*zip(*tmp))))</code></pre>
</details>
<div class="desc"><p>return matched list, using the last value to fill lists as needed
longest list matching [[1,2,3,4,5], [10,11]] -&gt; [[1,2,3,4,5], [10,11,11,11,11]]</p>
<p>lists passed into this function are not modified, it produces non-deep copies and extends those.</p></div>
</dd>
<dt id="sverchok.data_structure.match_short"><code class="name flex">
<span>def <span class="ident">match_short</span></span>(<span>lsts)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_short(lsts):
    &#34;&#34;&#34;return lists of equal length using the Shortest list to decides length
    Shortest list decides output length [[1,2,3,4,5], [10,11]] -&gt; [[1,2], [10, 11]]
    &#34;&#34;&#34;
    return list(map(list, zip(*zip(*lsts))))</code></pre>
</details>
<div class="desc"><p>return lists of equal length using the Shortest list to decides length
Shortest list decides output length [[1,2,3,4,5], [10,11]] -&gt; [[1,2], [10, 11]]</p></div>
</dd>
<dt id="sverchok.data_structure.matrixdef"><code class="name flex">
<span>def <span class="ident">matrixdef</span></span>(<span>orig, loc, scale, rot, angle, vec_angle=[[]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrixdef(orig, loc, scale, rot, angle, vec_angle=[[]]):
    modif = []
    for i, de in enumerate(orig):
        ma = de.copy()

        if loc[0]:
            k = min(len(loc[0])-1, i)
            mat_tran = de.Translation(loc[0][k])
            ma = ma @ mat_tran

        if vec_angle[0] and rot[0]:
            k = min(len(rot[0])-1, i)
            a = min(len(vec_angle[0])-1, i)

            vec_a = vec_angle[0][a].normalized()
            vec_b = rot[0][k].normalized()

            mat_rot = vec_b.rotation_difference(vec_a).to_matrix().to_4x4()
            ma = ma @ mat_rot

        elif rot[0]:
            k = min(len(rot[0])-1, i)
            a = min(len(angle[0])-1, i)
            mat_rot = de.Rotation(radians(angle[0][a]), 4, rot[0][k].normalized())
            ma = ma @ mat_rot

        if scale[0]:
            k = min(len(scale[0])-1, i)
            scale2 = scale[0][k]
            id_m = Matrix.Identity(4)
            for j in range(3):
                id_m[j][j] = scale2[j]
            ma = ma @ id_m

        modif.append(ma)
    return modif</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.multi_socket"><code class="name flex">
<span>def <span class="ident">multi_socket</span></span>(<span>node, min=1, start=0, breck=False, out_count=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_socket(node, min=1, start=0, breck=False, out_count=None):
    &#39;&#39;&#39;
     min - integer, minimal number of sockets, at list 1 needed
     start - integer, starting socket.
     breck - boolean, adding bracket to name of socket x[0] x[1] x[2] etc
     output - integer, deal with output, if&gt;0 counts number of outputs multi sockets
     base name added in separated node in self.base_name = &#39;some_name&#39;, i.e. &#39;x&#39;, &#39;data&#39;
     node.multi_socket_type - type of socket, as .bl_idname

    &#39;&#39;&#39;
    #probably incorrect state due or init or change of inputs
    # do nothing
    ng = node.id_data

    if min &lt; 1:
        min = 1
    if out_count is None:
        if not node.inputs:
            return
        if node.inputs[-1].links:
            length = start + len(node.inputs)
            if breck:
                name = node.base_name + &#39;[&#39; + str(length) + &#39;]&#39;
            else:
                name = node.base_name + str(length)
            node.inputs.new(node.multi_socket_type, name)
        else:
            while len(node.inputs) &gt; min and not node.inputs[-2].links:
                node.inputs.remove(node.inputs[-1])
    elif isinstance(out_count, int):
        lenod = len(node.outputs)
        if out_count &gt; 30:
            out_count = 30
        if lenod &lt; out_count:
            while len(node.outputs) &lt; out_count:
                length = start + len(node.outputs)
                if breck:
                    name = node.base_name + &#39;[&#39; + str(length)+ &#39;]&#39;
                else:
                    name = node.base_name + str(length)
                node.outputs.new(node.multi_socket_type, name)
        else:
            while len(node.outputs) &gt; out_count:
                node.outputs.remove(node.outputs[-1])</code></pre>
</details>
<div class="desc"><p>min - integer, minimal number of sockets, at list 1 needed
start - integer, starting socket.
breck - boolean, adding bracket to name of socket x[0] x[1] x[2] etc
output - integer, deal with output, if&gt;0 counts number of outputs multi sockets
base name added in separated node in self.base_name = 'some_name', i.e. 'x', 'data'
node.multi_socket_type - type of socket, as .bl_idname</p></div>
</dd>
<dt id="sverchok.data_structure.no_space"><code class="name flex">
<span>def <span class="ident">no_space</span></span>(<span>s)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_space(s):
    return s.replace(&#39; &#39;, &#39;_&#39;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.node_id"><code class="name flex">
<span>def <span class="ident">node_id</span></span>(<span>node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_id(node):
    &#34;&#34;&#34;return a stable hash for the lifetime of the node
    needs StringProperty called n_id in the node
    &#34;&#34;&#34;
    return node.node_id</code></pre>
</details>
<div class="desc"><p>return a stable hash for the lifetime of the node
needs StringProperty called n_id in the node</p></div>
</dd>
<dt id="sverchok.data_structure.numpy_full_list"><code class="name flex">
<span>def <span class="ident">numpy_full_list</span></span>(<span>array, desired_length)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy_full_list(array, desired_length):
    &#39;&#39;&#39;retuns array with desired length by repeating last item&#39;&#39;&#39;
    if not isinstance(array, ndarray):
        array = np_array(array)

    length_diff = desired_length - array.shape[0]

    if length_diff &gt; 0:
        new_part = np_repeat(array[np_newaxis, -1], length_diff, axis=0)
        return np_concatenate((array, new_part))[:desired_length]
    return array[:desired_length]</code></pre>
</details>
<div class="desc"><p>retuns array with desired length by repeating last item</p></div>
</dd>
<dt id="sverchok.data_structure.numpy_full_list_cycle"><code class="name flex">
<span>def <span class="ident">numpy_full_list_cycle</span></span>(<span>array, desired_length)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy_full_list_cycle(array, desired_length):
    &#39;&#39;&#39;retuns array with desired length by cycling&#39;&#39;&#39;

    length_diff = desired_length - array.shape[0]
    if length_diff &gt; 0:
        if length_diff &lt; array.shape[0]:

            return np_concatenate((array, array[:length_diff]))

        new_part = np_repeat(array, ceil(length_diff / array.shape[0]), axis=0)
        if len(array.shape) &gt; 1:
            shape = (ceil(length_diff / array.shape[0]), 1)
        else:
            shape = ceil(length_diff / array.shape[0])
        new_part = np_tile(array, shape)
        return np_concatenate((array, new_part[:length_diff]))

    return array[:desired_length]</code></pre>
</details>
<div class="desc"><p>retuns array with desired length by cycling</p></div>
</dd>
<dt id="sverchok.data_structure.numpy_match_long_cycle"><code class="name flex">
<span>def <span class="ident">numpy_match_long_cycle</span></span>(<span>list_of_arrays)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy_match_long_cycle(list_of_arrays):
    &#39;&#39;&#39;match numpy arrays length by cycling over the array&#39;&#39;&#39;
    out = []
    maxl = 0
    for array in list_of_arrays:
        maxl = max(maxl, array.shape[0])
    for array in list_of_arrays:
        length_diff = maxl - array.shape[0]
        if length_diff &gt; 0:
            if length_diff &lt; array.shape[0]:

                array = np_concatenate((array, array[:length_diff]))
            else:
                new_part = np_repeat(array, ceil(length_diff / array.shape[0]), axis=0)
                if len(array.shape) &gt; 1:
                    shape = (ceil(length_diff / array.shape[0]), 1)
                else:
                    shape = ceil(length_diff / array.shape[0])
                new_part = np_tile(array, shape)
                array = np_concatenate((array, new_part[:length_diff]))
        out.append(array)
    return out</code></pre>
</details>
<div class="desc"><p>match numpy arrays length by cycling over the array</p></div>
</dd>
<dt id="sverchok.data_structure.numpy_match_long_repeat"><code class="name flex">
<span>def <span class="ident">numpy_match_long_repeat</span></span>(<span>list_of_arrays)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy_match_long_repeat(list_of_arrays):
    &#39;&#39;&#39;match numpy arrays length by repeating last one&#39;&#39;&#39;
    out = []
    maxl = 0
    for array in list_of_arrays:
        maxl = max(maxl, array.shape[0])
    for array in list_of_arrays:
        length_diff = maxl - array.shape[0]
        if length_diff &gt; 0:
            new_part = np_repeat(array[np_newaxis, -1], length_diff, axis=0)
            array = np_concatenate((array, new_part))
        out.append(array)
    return out</code></pre>
</details>
<div class="desc"><p>match numpy arrays length by repeating last one</p></div>
</dd>
<dt id="sverchok.data_structure.numpy_match_short"><code class="name flex">
<span>def <span class="ident">numpy_match_short</span></span>(<span>list_of_arrays)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numpy_match_short(list_of_arrays):
    &#39;&#39;&#39;match numpy arrays length by cutting the longer arrays&#39;&#39;&#39;
    out = []
    minl = list_of_arrays[0].shape[0]
    for array in list_of_arrays:
        minl = min(minl, array.shape[0])
    for array in list_of_arrays:
        length_diff = array.shape[0] - minl
        if length_diff &gt; 0:
            array = array[:minl]
        out.append(array)
    return out</code></pre>
</details>
<div class="desc"><p>match numpy arrays length by cutting the longer arrays</p></div>
</dd>
<dt id="sverchok.data_structure.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>p, lst)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(p, lst):
    good, bad = [], []
    for item in lst:
        if p(item):
            good.append(item)
        else:
            bad.append(item)
    return good, bad</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.post_load_call"><code class="name flex">
<span>def <span class="ident">post_load_call</span></span>(<span>function)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_load_call(function):  # better place would be in handlers module but import cyclic error
    &#34;&#34;&#34;
    Usage: if you need function which should be called each time when blender is lunched
    or new file is opened use this decorator
    Limitation: the function should not get any properties because it will be called by handler
    &#34;&#34;&#34;
    post_load_call.registered_functions.append(function)

    @wraps(function)
    def wrapper():
        return function()

    return wrapper</code></pre>
</details>
<div class="desc"><p>Usage: if you need function which should be called each time when blender is lunched
or new file is opened use this decorator
Limitation: the function should not get any properties because it will be called by handler</p></div>
</dd>
<dt id="sverchok.data_structure.repeat_last"><code class="name flex">
<span>def <span class="ident">repeat_last</span></span>(<span>lst)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat_last(lst):
    &#34;&#34;&#34;
    creates an infinite iterator the first each element in lst
    and then keep repeating the last element,
    use with terminating input
    &#34;&#34;&#34;
    last = [lst[-1]] if len(lst) else []  # len(lst) in case of numpy arrays
    yield from chain(lst, cycle(last))</code></pre>
</details>
<div class="desc"><p>creates an infinite iterator the first each element in lst
and then keep repeating the last element,
use with terminating input</p></div>
</dd>
<dt id="sverchok.data_structure.repeat_last_for_length"><code class="name flex">
<span>def <span class="ident">repeat_last_for_length</span></span>(<span>lst, count, deepcopy=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat_last_for_length(lst, count, deepcopy=False):
    &#34;&#34;&#34;
    Repeat last item of the list enough times
    for result&#39;s length to be equal to `count`.

    repeat_last_for_length(None, n) = None
    repeat_last_for_length([], n) = []
    repeat_last_for_length([1,2], 4) = [1, 2, 2, 2]
    &#34;&#34;&#34;
    if not lst:
        return lst
    if len(lst) &gt;= count:
        return lst[:count]
    n = len(lst)
    x = lst[-1]
    result = lst[:]
    if deepcopy:
        for i in range(count - n):
            result.append(copy.deepcopy(x))
    else:
        for i in range(count - n):
            result.append(x)

    return result</code></pre>
</details>
<div class="desc"><p>Repeat last item of the list enough times
for result's length to be equal to <code>count</code>.</p>
<p>repeat_last_for_length(None, n) = None
repeat_last_for_length([], n) = []
repeat_last_for_length([1,2], 4) = [1, 2, 2, 2]</p></div>
</dd>
<dt id="sverchok.data_structure.replace_socket"><code class="name flex">
<span>def <span class="ident">replace_socket</span></span>(<span>socket, new_type, new_name=None, new_pos=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_socket(socket, new_type, new_name=None, new_pos=None):
    &#34;&#34;&#34;
    Replace a socket with a socket of new_type and keep links

    is_linked attribute of replaced socket will be False
    whether it is connected or not - https://developer.blender.org/T82318
    &#34;&#34;&#34;
    # note: it seems impossible to replace one socket more efficient

    socket_name = new_name or socket.name
    socket_pos = new_pos or socket.index
    ng = socket.id_data

    if socket.is_output:
        outputs = socket.node.outputs
        to_sockets = [l.to_socket for l in socket.links]

        new_socket = outputs.new(new_type, socket_name)
        new_socket.copy_options(socket)
        outputs.remove(socket)
        outputs.move(len(outputs)-1, socket_pos)

        for to_socket in to_sockets:
            link = ng.links.new(new_socket, to_socket)
            link.is_valid = True

    else:
        inputs = socket.node.inputs
        from_socket = socket.links[0].from_socket if socket.is_linked else None

        identifier = socket.identifier  # It&#39;s important for Geo Nodes Viewer
        inputs.remove(socket)
        new_socket = inputs.new(new_type, socket_name, identifier=identifier)
        inputs.move(len(inputs)-1, socket_pos)

        if from_socket:
            link = ng.links.new(from_socket, new_socket)
            link.is_valid = True

    return new_socket</code></pre>
</details>
<div class="desc"><p>Replace a socket with a socket of new_type and keep links</p>
<p>is_linked attribute of replaced socket will be False
whether it is connected or not - <a href="https://developer.blender.org/T82318">https://developer.blender.org/T82318</a></p></div>
</dd>
<dt id="sverchok.data_structure.rotate_list"><code class="name flex">
<span>def <span class="ident">rotate_list</span></span>(<span>l, y=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_list(l, y=1):
    &#34;&#34;&#34;
    &#34;Rotate&#34; list by shifting it&#39;s items towards the end and putting last items to the beginning.
    For example,

    rotate_list([1, 2, 3]) = [2, 3, 1]
    rotate_list([1, 2, 3], y=2) = [3, 1, 2]
    &#34;&#34;&#34;
    if len(l) == 0:
        return l
    if y == 0:
        return l
    y = y % len(l)
    return list(l[y:]) + list(l[:y])</code></pre>
</details>
<div class="desc"><p>"Rotate" list by shifting it's items towards the end and putting last items to the beginning.
For example,</p>
<p>rotate_list([1, 2, 3]) = [2, 3, 1]
rotate_list([1, 2, 3], y=2) = [3, 1, 2]</p></div>
</dd>
<dt id="sverchok.data_structure.second_as_first_cycle"><code class="name flex">
<span>def <span class="ident">second_as_first_cycle</span></span>(<span>F, S)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_as_first_cycle(F, S):
    if len(F) &gt; len(S):
        return list(map(list, zip(*zip(*[F, itertools.cycle(S)]))))[1]
    else:
        return S</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.socket_id"><code class="name flex">
<span>def <span class="ident">socket_id</span></span>(<span>socket)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def socket_id(socket):
    &#34;&#34;&#34;return an usable and semi stable hash&#34;&#34;&#34;
    return socket.socket_id</code></pre>
</details>
<div class="desc"><p>return an usable and semi stable hash</p></div>
</dd>
<dt id="sverchok.data_structure.split_by_count"><code class="name flex">
<span>def <span class="ident">split_by_count</span></span>(<span>iterable, n, fillvalue=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_by_count(iterable, n, fillvalue=None):
    &#34;Collect data into fixed-length chunks or blocks&#34;
    # grouper(&#39;ABCDEFG&#39;, 3, &#39;x&#39;) --&gt; ABC DEF Gxx&#34;
    args = [iter(iterable)] * n
    return list(map(list, zip_longest(*args, fillvalue=fillvalue)))</code></pre>
</details>
<div class="desc"><p>Collect data into fixed-length chunks or blocks</p></div>
</dd>
<dt id="sverchok.data_structure.sv_lambda"><code class="name flex">
<span>def <span class="ident">sv_lambda</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sv_lambda(**kwargs):
    &#34;&#34;&#34;üsage: (like a named tuple)

    structure = sv_lambda(keys=20, color=(1,0,0,0))

    print(structure.keys)
    print(structure.color)

    useful for passing a parameter to a function that expects to be able to do a dot lookup
    on the parameter, for instance a function that normally accepts &#34;self&#34; or &#34;node&#34;, but the
    function only really looks up one or two..etc parameters.
    &#34;&#34;&#34;
    dummy = lambda: None
    for k, v in kwargs.items():
        setattr(dummy, k, v)
    return dummy</code></pre>
</details>
<div class="desc"><p>üsage: (like a named tuple)</p>
<p>structure = sv_lambda(keys=20, color=(1,0,0,0))</p>
<p>print(structure.keys)
print(structure.color)</p>
<p>useful for passing a parameter to a function that expects to be able to do a dot lookup
on the parameter, for instance a function that normally accepts "self" or "node", but the
function only really looks up one or two..etc parameters.</p></div>
</dd>
<dt id="sverchok.data_structure.sv_zip"><code class="name flex">
<span>def <span class="ident">sv_zip</span></span>(<span>*iterables)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sv_zip(*iterables):
    &#34;&#34;&#34;zip(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax By
    like standard zip but list instead of tuple
    &#34;&#34;&#34;
    iterators = [iter(it) for it in iterables]
    sentinel = object() # use internal sentinel
    while iterators:
        result = []
        for it in iterators:
            elem = next(it, sentinel)
            if elem is sentinel:
                return
            result.append(elem)
        yield result</code></pre>
</details>
<div class="desc"><p>zip('ABCD', 'xy') &ndash;&gt; Ax By
like standard zip but list instead of tuple</p></div>
</dd>
<dt id="sverchok.data_structure.transpose_list"><code class="name flex">
<span>def <span class="ident">transpose_list</span></span>(<span>lst)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose_list(lst):
    &#34;&#34;&#34;
    Transpose a list of lists.

    transpose_list([[1,2], [3,4]]) == [[1,3], [2, 4]]
    &#34;&#34;&#34;
    return list(map(list, zip(*lst)))</code></pre>
</details>
<div class="desc"><p>Transpose a list of lists.</p>
<p>transpose_list([[1,2], [3,4]]) == [[1,3], [2, 4]]</p></div>
</dd>
<dt id="sverchok.data_structure.unwrap_data"><code class="name flex">
<span>def <span class="ident">unwrap_data</span></span>(<span>data, unwrap_level=1, socket=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_data(data, unwrap_level=1, socket=None):
    socket_msg = &#34;&#34; if socket is None else f&#34; in socket {socket.label or socket.name}&#34;

    def unwrap(lst, level):
        if not isinstance(lst, (list, tuple, ndarray)):
            raise Exception(f&#34;Cannot unwrap data: Data at level {level} is an atomic object, not a list {socket_msg}&#34;)
        n = len(lst)
        if n == 0:
            raise Exception(f&#34;Cannot unwrap data: Data at level {level} is an empty list {socket_msg}&#34;)
        elif n &gt; 1:
            raise Exception(f&#34;Cannot unwrap data: Data at level {level} contains {n} objects instead of one {socket_msg}&#34;)
        else:
            return lst[0]

    for level in range(unwrap_level):
        data = unwrap(data, level)
    return data</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.unzip_dict_recursive"><code class="name flex">
<span>def <span class="ident">unzip_dict_recursive</span></span>(<span>data, item_type=builtins.dict, to_dict=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unzip_dict_recursive(data, item_type=dict, to_dict=None):
    &#34;&#34;&#34;
    Given a nested list of dictionaries, return a dictionary of nested lists.
    Nesting structure of each of values of resulting dictionary will be similar to
    nesting structure of input data, only at the deepest level, instead of dictionaries
    you will have their values.

    inputs:
    * data: nested list of dictionaries.
    * item_type: allows to use arbitrary class instead of standard python&#39;s dict.
    * to_dict: a function which translates data item into python&#39;s dict (or
      another class with the same interface). Identity by default.

    output: dictionary of nested lists.

    Refer to data_structure_tests.py for examples.
    &#34;&#34;&#34;

    if to_dict is None:
        to_dict = lambda d: d

    def helper(data):
        current_level = get_data_nesting_level(data, data_types=(item_type,))
        if current_level == 0:
            return to_dict(data)
        elif current_level == 1:
            result = defaultdict(list)
            for dct in data:
                dct = to_dict(dct)
                for key, value in dct.items():
                    result[key].append(value)
            return result
        else:
            result = defaultdict(list)
            for item in data:
                sub_result = helper(item)
                for key, value in sub_result.items():
                    result[key].append(value)
            return result

    return helper(data)</code></pre>
</details>
<div class="desc"><p>Given a nested list of dictionaries, return a dictionary of nested lists.
Nesting structure of each of values of resulting dictionary will be similar to
nesting structure of input data, only at the deepest level, instead of dictionaries
you will have their values.</p>
<p>inputs:
* data: nested list of dictionaries.
* item_type: allows to use arbitrary class instead of standard python's dict.
* to_dict: a function which translates data item into python's dict (or
another class with the same interface). Identity by default.</p>
<p>output: dictionary of nested lists.</p>
<p>Refer to data_structure_tests.py for examples.</p></div>
</dd>
<dt id="sverchok.data_structure.updateNode"><code class="name flex">
<span>def <span class="ident">updateNode</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateNode(self, context):
    &#34;&#34;&#34;
    When a node has changed state and need to call a partial update.
    For example a user exposed bpy.prop
    &#34;&#34;&#34;
    self.process_node(context)</code></pre>
</details>
<div class="desc"><p>When a node has changed state and need to call a partial update.
For example a user exposed bpy.prop</p></div>
</dd>
<dt id="sverchok.data_structure.update_edge_cache"><code class="name flex">
<span>def <span class="ident">update_edge_cache</span></span>(<span>n)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_edge_cache(n):
    &#34;&#34;&#34;
    Extend the edge list cache to contain at least n edges.

    NOTE: This is called by the get_edge_list to make sure the edge cache is large
    enough, but it can also be called preemptively by the nodes prior to making
    multiple calls to get_edge_list in order to pre-augment the cache to a known
    size and thus accellearate the subsequent calls to get_edge_list as they
    will not have to augment the cache with every call.
    &#34;&#34;&#34;
    m = len(_edgeCache[&#34;main&#34;])  # current number of edges in the edge cache
    if n &gt; m: # requested #edges &lt; cached #edges ? =&gt; extend the cache
        _edgeCache[&#34;main&#34;].extend([[m + i, m + i + 1] for i in range(n - m)])</code></pre>
</details>
<div class="desc"><p>Extend the edge list cache to contain at least n edges.</p>
<p>NOTE: This is called by the get_edge_list to make sure the edge cache is large
enough, but it can also be called preemptively by the nodes prior to making
multiple calls to get_edge_list in order to pre-augment the cache to a known
size and thus accellearate the subsequent calls to get_edge_list as they
will not have to augment the cache with every call.</p></div>
</dd>
<dt id="sverchok.data_structure.update_with_kwargs"><code class="name flex">
<span>def <span class="ident">update_with_kwargs</span></span>(<span>update_function, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_with_kwargs(update_function, **kwargs):
    &#34;&#34;&#34;
    You can wrap property update function for adding extra key arguments to it, like this:

    def update_prop(self, context, extra_arg=None):
        print(extra_arg)

    node_prop_name: bpy.props.BoolProperty(update=update_with_kwargs(update_prop, extra_arg=&#39;node_prop_name&#39;))
    &#34;&#34;&#34;

    # https://docs.python.org/3/library/functools.html#functools.partial
    @wraps(update_function)
    def handel_update_call(node, context):
        update_function(node, context, **handel_update_call.extra_args)

    handel_update_call.extra_args = dict()
    for attr_name, data in kwargs.items():
        handel_update_call.extra_args[attr_name] = data

    return handel_update_call</code></pre>
</details>
<div class="desc"><p>You can wrap property update function for adding extra key arguments to it, like this:</p>
<p>def update_prop(self, context, extra_arg=None):
print(extra_arg)</p>
<p>node_prop_name: bpy.props.BoolProperty(update=update_with_kwargs(update_prop, extra_arg='node_prop_name'))</p></div>
</dd>
<dt id="sverchok.data_structure.wrap_data"><code class="name flex">
<span>def <span class="ident">wrap_data</span></span>(<span>data, wrap_level=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_data(data, wrap_level=1):
    for i in range(wrap_level):
        data = [data]
    return data</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.zip_long_repeat"><code class="name flex">
<span>def <span class="ident">zip_long_repeat</span></span>(<span>*lists)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip_long_repeat(*lists):
    objects = match_long_repeat(lists)
    return zip(*objects)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sverchok.data_structure.SvListLevelAdjustment"><code class="flex name class">
<span>class <span class="ident">SvListLevelAdjustment</span></span>
<span>(</span><span>flatten=False, wrap=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SvListLevelAdjustment(object):
    def __init__(self, flatten=False, wrap=False):
        self.flatten = flatten
        self.wrap = wrap

    def __repr__(self):
        return f&#34;&lt;Flatten={self.flatten}, Wrap={self.wrap}&gt;&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sverchok.data_structure.classproperty"><code class="flex name class">
<span>class <span class="ident">classproperty</span></span>
<span>(</span><span>fget)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, owner_self, owner_cls):
    return self.fget(owner_cls)</code></pre>
</details>
<div class="desc"><p><a href="https://stackoverflow.com/a/13624858/10032221">https://stackoverflow.com/a/13624858/10032221</a></p></div>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sverchok.data_structure.Edg_pol_generate" href="#sverchok.data_structure.Edg_pol_generate">Edg_pol_generate</a></code></li>
<li><code><a title="sverchok.data_structure.Matrix_generate" href="#sverchok.data_structure.Matrix_generate">Matrix_generate</a></code></li>
<li><code><a title="sverchok.data_structure.Matrix_listing" href="#sverchok.data_structure.Matrix_listing">Matrix_listing</a></code></li>
<li><code><a title="sverchok.data_structure.Matrix_location" href="#sverchok.data_structure.Matrix_location">Matrix_location</a></code></li>
<li><code><a title="sverchok.data_structure.Matrix_rotation" href="#sverchok.data_structure.Matrix_rotation">Matrix_rotation</a></code></li>
<li><code><a title="sverchok.data_structure.Matrix_scale" href="#sverchok.data_structure.Matrix_scale">Matrix_scale</a></code></li>
<li><code><a title="sverchok.data_structure.Vector_degenerate" href="#sverchok.data_structure.Vector_degenerate">Vector_degenerate</a></code></li>
<li><code><a title="sverchok.data_structure.Vector_generate" href="#sverchok.data_structure.Vector_generate">Vector_generate</a></code></li>
<li><code><a title="sverchok.data_structure.apply_mask" href="#sverchok.data_structure.apply_mask">apply_mask</a></code></li>
<li><code><a title="sverchok.data_structure.calc_mask" href="#sverchok.data_structure.calc_mask">calc_mask</a></code></li>
<li><code><a title="sverchok.data_structure.changable_sockets" href="#sverchok.data_structure.changable_sockets">changable_sockets</a></code></li>
<li><code><a title="sverchok.data_structure.cross_indices_np" href="#sverchok.data_structure.cross_indices_np">cross_indices_np</a></code></li>
<li><code><a title="sverchok.data_structure.cycle_for_length" href="#sverchok.data_structure.cycle_for_length">cycle_for_length</a></code></li>
<li><code><a title="sverchok.data_structure.dataCorrect" href="#sverchok.data_structure.dataCorrect">dataCorrect</a></code></li>
<li><code><a title="sverchok.data_structure.dataCorrect_np" href="#sverchok.data_structure.dataCorrect_np">dataCorrect_np</a></code></li>
<li><code><a title="sverchok.data_structure.dataSpoil" href="#sverchok.data_structure.dataSpoil">dataSpoil</a></code></li>
<li><code><a title="sverchok.data_structure.data_standard" href="#sverchok.data_structure.data_standard">data_standard</a></code></li>
<li><code><a title="sverchok.data_structure.describe_data_shape" href="#sverchok.data_structure.describe_data_shape">describe_data_shape</a></code></li>
<li><code><a title="sverchok.data_structure.describe_data_shape_by_level" href="#sverchok.data_structure.describe_data_shape_by_level">describe_data_shape_by_level</a></code></li>
<li><code><a title="sverchok.data_structure.describe_data_structure" href="#sverchok.data_structure.describe_data_structure">describe_data_structure</a></code></li>
<li><code><a title="sverchok.data_structure.ensure_min_nesting" href="#sverchok.data_structure.ensure_min_nesting">ensure_min_nesting</a></code></li>
<li><code><a title="sverchok.data_structure.ensure_nesting_level" href="#sverchok.data_structure.ensure_nesting_level">ensure_nesting_level</a></code></li>
<li><code><a title="sverchok.data_structure.enum_item" href="#sverchok.data_structure.enum_item">enum_item</a></code></li>
<li><code><a title="sverchok.data_structure.enum_item_4" href="#sverchok.data_structure.enum_item_4">enum_item_4</a></code></li>
<li><code><a title="sverchok.data_structure.enum_item_5" href="#sverchok.data_structure.enum_item_5">enum_item_5</a></code></li>
<li><code><a title="sverchok.data_structure.extend_blender_class" href="#sverchok.data_structure.extend_blender_class">extend_blender_class</a></code></li>
<li><code><a title="sverchok.data_structure.fixed_iter" href="#sverchok.data_structure.fixed_iter">fixed_iter</a></code></li>
<li><code><a title="sverchok.data_structure.flat_iter" href="#sverchok.data_structure.flat_iter">flat_iter</a></code></li>
<li><code><a title="sverchok.data_structure.flatten_data" href="#sverchok.data_structure.flatten_data">flatten_data</a></code></li>
<li><code><a title="sverchok.data_structure.fullList" href="#sverchok.data_structure.fullList">fullList</a></code></li>
<li><code><a title="sverchok.data_structure.fullList_deep_copy" href="#sverchok.data_structure.fullList_deep_copy">fullList_deep_copy</a></code></li>
<li><code><a title="sverchok.data_structure.fullList_np" href="#sverchok.data_structure.fullList_np">fullList_np</a></code></li>
<li><code><a title="sverchok.data_structure.get_data_nesting_level" href="#sverchok.data_structure.get_data_nesting_level">get_data_nesting_level</a></code></li>
<li><code><a title="sverchok.data_structure.get_edge_list" href="#sverchok.data_structure.get_edge_list">get_edge_list</a></code></li>
<li><code><a title="sverchok.data_structure.get_edge_loop" href="#sverchok.data_structure.get_edge_loop">get_edge_loop</a></code></li>
<li><code><a title="sverchok.data_structure.get_other_socket" href="#sverchok.data_structure.get_other_socket">get_other_socket</a></code></li>
<li><code><a title="sverchok.data_structure.graft_data" href="#sverchok.data_structure.graft_data">graft_data</a></code></li>
<li><code><a title="sverchok.data_structure.handle_check" href="#sverchok.data_structure.handle_check">handle_check</a></code></li>
<li><code><a title="sverchok.data_structure.handle_delete" href="#sverchok.data_structure.handle_delete">handle_delete</a></code></li>
<li><code><a title="sverchok.data_structure.handle_read" href="#sverchok.data_structure.handle_read">handle_read</a></code></li>
<li><code><a title="sverchok.data_structure.handle_write" href="#sverchok.data_structure.handle_write">handle_write</a></code></li>
<li><code><a title="sverchok.data_structure.has_element" href="#sverchok.data_structure.has_element">has_element</a></code></li>
<li><code><a title="sverchok.data_structure.invert_index_list" href="#sverchok.data_structure.invert_index_list">invert_index_list</a></code></li>
<li><code><a title="sverchok.data_structure.is_ultimately" href="#sverchok.data_structure.is_ultimately">is_ultimately</a></code></li>
<li><code><a title="sverchok.data_structure.levelsOflist" href="#sverchok.data_structure.levelsOflist">levelsOflist</a></code></li>
<li><code><a title="sverchok.data_structure.levels_of_list_or_np" href="#sverchok.data_structure.levels_of_list_or_np">levels_of_list_or_np</a></code></li>
<li><code><a title="sverchok.data_structure.list_levels_adjust" href="#sverchok.data_structure.list_levels_adjust">list_levels_adjust</a></code></li>
<li><code><a title="sverchok.data_structure.make_cyclers" href="#sverchok.data_structure.make_cyclers">make_cyclers</a></code></li>
<li><code><a title="sverchok.data_structure.make_repeaters" href="#sverchok.data_structure.make_repeaters">make_repeaters</a></code></li>
<li><code><a title="sverchok.data_structure.map_at_level" href="#sverchok.data_structure.map_at_level">map_at_level</a></code></li>
<li><code><a title="sverchok.data_structure.map_recursive" href="#sverchok.data_structure.map_recursive">map_recursive</a></code></li>
<li><code><a title="sverchok.data_structure.map_unzip_recursirve" href="#sverchok.data_structure.map_unzip_recursirve">map_unzip_recursirve</a></code></li>
<li><code><a title="sverchok.data_structure.match_cross" href="#sverchok.data_structure.match_cross">match_cross</a></code></li>
<li><code><a title="sverchok.data_structure.match_cross2" href="#sverchok.data_structure.match_cross2">match_cross2</a></code></li>
<li><code><a title="sverchok.data_structure.match_long_cycle" href="#sverchok.data_structure.match_long_cycle">match_long_cycle</a></code></li>
<li><code><a title="sverchok.data_structure.match_long_repeat" href="#sverchok.data_structure.match_long_repeat">match_long_repeat</a></code></li>
<li><code><a title="sverchok.data_structure.match_short" href="#sverchok.data_structure.match_short">match_short</a></code></li>
<li><code><a title="sverchok.data_structure.matrixdef" href="#sverchok.data_structure.matrixdef">matrixdef</a></code></li>
<li><code><a title="sverchok.data_structure.multi_socket" href="#sverchok.data_structure.multi_socket">multi_socket</a></code></li>
<li><code><a title="sverchok.data_structure.no_space" href="#sverchok.data_structure.no_space">no_space</a></code></li>
<li><code><a title="sverchok.data_structure.node_id" href="#sverchok.data_structure.node_id">node_id</a></code></li>
<li><code><a title="sverchok.data_structure.numpy_full_list" href="#sverchok.data_structure.numpy_full_list">numpy_full_list</a></code></li>
<li><code><a title="sverchok.data_structure.numpy_full_list_cycle" href="#sverchok.data_structure.numpy_full_list_cycle">numpy_full_list_cycle</a></code></li>
<li><code><a title="sverchok.data_structure.numpy_match_long_cycle" href="#sverchok.data_structure.numpy_match_long_cycle">numpy_match_long_cycle</a></code></li>
<li><code><a title="sverchok.data_structure.numpy_match_long_repeat" href="#sverchok.data_structure.numpy_match_long_repeat">numpy_match_long_repeat</a></code></li>
<li><code><a title="sverchok.data_structure.numpy_match_short" href="#sverchok.data_structure.numpy_match_short">numpy_match_short</a></code></li>
<li><code><a title="sverchok.data_structure.partition" href="#sverchok.data_structure.partition">partition</a></code></li>
<li><code><a title="sverchok.data_structure.post_load_call" href="#sverchok.data_structure.post_load_call">post_load_call</a></code></li>
<li><code><a title="sverchok.data_structure.repeat_last" href="#sverchok.data_structure.repeat_last">repeat_last</a></code></li>
<li><code><a title="sverchok.data_structure.repeat_last_for_length" href="#sverchok.data_structure.repeat_last_for_length">repeat_last_for_length</a></code></li>
<li><code><a title="sverchok.data_structure.replace_socket" href="#sverchok.data_structure.replace_socket">replace_socket</a></code></li>
<li><code><a title="sverchok.data_structure.rotate_list" href="#sverchok.data_structure.rotate_list">rotate_list</a></code></li>
<li><code><a title="sverchok.data_structure.second_as_first_cycle" href="#sverchok.data_structure.second_as_first_cycle">second_as_first_cycle</a></code></li>
<li><code><a title="sverchok.data_structure.socket_id" href="#sverchok.data_structure.socket_id">socket_id</a></code></li>
<li><code><a title="sverchok.data_structure.split_by_count" href="#sverchok.data_structure.split_by_count">split_by_count</a></code></li>
<li><code><a title="sverchok.data_structure.sv_lambda" href="#sverchok.data_structure.sv_lambda">sv_lambda</a></code></li>
<li><code><a title="sverchok.data_structure.sv_zip" href="#sverchok.data_structure.sv_zip">sv_zip</a></code></li>
<li><code><a title="sverchok.data_structure.transpose_list" href="#sverchok.data_structure.transpose_list">transpose_list</a></code></li>
<li><code><a title="sverchok.data_structure.unwrap_data" href="#sverchok.data_structure.unwrap_data">unwrap_data</a></code></li>
<li><code><a title="sverchok.data_structure.unzip_dict_recursive" href="#sverchok.data_structure.unzip_dict_recursive">unzip_dict_recursive</a></code></li>
<li><code><a title="sverchok.data_structure.updateNode" href="#sverchok.data_structure.updateNode">updateNode</a></code></li>
<li><code><a title="sverchok.data_structure.update_edge_cache" href="#sverchok.data_structure.update_edge_cache">update_edge_cache</a></code></li>
<li><code><a title="sverchok.data_structure.update_with_kwargs" href="#sverchok.data_structure.update_with_kwargs">update_with_kwargs</a></code></li>
<li><code><a title="sverchok.data_structure.wrap_data" href="#sverchok.data_structure.wrap_data">wrap_data</a></code></li>
<li><code><a title="sverchok.data_structure.zip_long_repeat" href="#sverchok.data_structure.zip_long_repeat">zip_long_repeat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sverchok.data_structure.SvListLevelAdjustment" href="#sverchok.data_structure.SvListLevelAdjustment">SvListLevelAdjustment</a></code></h4>
</li>
<li>
<h4><code><a title="sverchok.data_structure.classproperty" href="#sverchok.data_structure.classproperty">classproperty</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
