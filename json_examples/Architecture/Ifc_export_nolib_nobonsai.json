{"export_version": "1.0", "main_tree": {"nodes": {"Scripted Node Lite": {"attributes": {"location": [1800.0, 400.0], "width": 220.0, "color": [0.0, 0.6000000238418579, 0.800000011920929], "use_custom_color": true}, "properties": {"menu_index": "4.9. ", "full_script_name": "/home/ololo/.config/blender/4.2/scripts/addons/sverchok/node_scripts/SNLite_templates/utils/ifc_export_nolib.py", "script_name": "ifc_export_nolib.py.001", "script_str": "'''\nin vertices    v d=[[]] n=0\nin polygons    s d=[[]] n=0\nin filepath    FP d=[[]] n=0\nin object_name   s d=\"IFC_Export\" n=2\nenum = BREP MESH\nin max_faces     s d=10000 n=2\nin area_threshold s d=0.00001 n=2\n'''\n\nimport bpy\n\nself.make_operator('make')\n\n\ndef ui(self, context, layout):\n    cb_str = 'node.scriptlite_custom_callback'\n    layout.operator(cb_str, text='E X P O R T').cb_name='make'\n    layout.prop(self, 'custom_enum', expand=True)\n\ndef make(self, context):\n    \"\"\"\n    \u0413\u043b\u0430\u0432\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u044d\u043a\u0441\u043f\u043e\u0440\u0442\u0430 \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u0438 \u0432 IFC \u0444\u043e\u0440\u043c\u0430\u0442\n    \u0418\u043c\u043f\u043e\u0440\u0442\u044b \u043a\u0440\u043e\u043c\u0435 bpy \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0432\u043d\u0443\u0442\u0440\u0438 \u044d\u0442\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n    \"\"\"\n    # \u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u043c\u043e\u0434\u0443\u043b\u0438\n    import os\n    import uuid\n    from datetime import datetime\n    import math\n    import numpy as np\n    \n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u0432\u0445\u043e\u0434\u043e\u0432 \u043d\u043e\u0434\u044b - \u0422\u0415\u041f\u0415\u0420\u042c \u0421\u041f\u0418\u0421\u041a\u0418 \u0421\u041f\u0418\u0421\u041a\u041e\u0412\n    vertices_list = self.inputs['vertices'].sv_get()  # [[\u0432\u0435\u0440\u0448\u0438\u043d\u044b1], [\u0432\u0435\u0440\u0448\u0438\u043d\u044b2], ...]\n    polygons_list = self.inputs['polygons'].sv_get()  # [[\u043f\u043e\u043b\u0438\u0433\u043e\u043d\u044b1], [\u043f\u043e\u043b\u0438\u0433\u043e\u043d\u044b2], ...]\n    max_faces = max(self.inputs['max_faces'].sv_get()[0][0],100)\n    area_threshold = self.inputs['area_threshold'].sv_get()[0][0]\n    geometry_type = self.custom_enum\n    \n    # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0435\u0441\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435\n    if not vertices_list or not polygons_list:\n        print(\"\u2717 \u041d\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u043b\u044f \u044d\u043a\u0441\u043f\u043e\u0440\u0442\u0430\")\n        return False\n    \n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    num_objects = min(len(vertices_list), len(polygons_list))\n    \n    if num_objects == 0:\n        print(\"\u2717 \u041d\u0435\u0442 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0434\u043b\u044f \u044d\u043a\u0441\u043f\u043e\u0440\u0442\u0430\")\n        return False\n    \n    # \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c filepath\n    filepath_input = self.inputs['filepath'].sv_get()\n    base_filepath = \"\"\n    if filepath_input and filepath_input[0]:\n        base_filepath = filepath_input[0][0]\n    else:\n        base_filepath = os.path.join(os.path.expanduser(\"~\"), \"exported_model\")\n    \n    # \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u043c\u0435\u043d\u0430 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    if self.inputs['object_name'].is_linked:        \n        object_name_input = self.inputs['object_name'].sv_get()\n    else:\n        object_name_input = [['Sverchok_object']]\n    base_object_name = \"IFC_Export\"\n    \n    def clean_ascii_string(text):\n        \"\"\"\u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u043d\u0435-ASCII \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0438\u0437 \u0441\u0442\u0440\u043e\u043a\u0438\"\"\"\n        if not text:\n            return \"\"\n        # \u041e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e ASCII \u0441\u0438\u043c\u0432\u043e\u043b\u044b\n        cleaned = ''.join(char for char in str(text) if ord(char) < 128)\n        # \u0423\u0434\u0430\u043b\u044f\u0435\u043c \u043a\u0430\u0432\u044b\u0447\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u043d\u044b\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b\n        cleaned = cleaned.replace('\"', '').replace(\"'\", '').replace('\\n', ' ').replace('\\r', '')\n        return cleaned.strip() or \"Unknown\"\n\n    if object_name_input and object_name_input[0]:\n        base_object_name = object_name_input[0][0]\n        base_object_name = clean_ascii_string(base_object_name)\n    \n    # \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f GUID \u0434\u043b\u044f IFC \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    def create_guid(num=32):\n        \"\"\"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 GUID \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 IFC (32 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0431\u0435\u0437 \u0434\u0435\u0444\u0438\u0441\u043e\u0432)\"\"\"\n        if num == 36:\n            guid = str(uuid.uuid4()).upper()\n        else:\n            guid = str(uuid.uuid4()).replace('-', '').upper()\n        # \u0414\u041e\u0411\u0410\u0412\u042c\u0422\u0415 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443:\n        if guid == '00000000000000000000000000000000':\n            # \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c \u0437\u0430\u043d\u043e\u0432\u043e \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u0438 \u043d\u0443\u043b\u0435\u0432\u043e\u0439 GUID\n            guid = str(uuid.uuid4()).replace('-', '').upper()\n        print(guid)\n        if num == 32:\n            return guid\n        elif num == 36:\n            return guid\n        else:\n            return guid[:22]\n\n    def ensure_area(points, indices):\n        p1 = np.array(points[indices[0]])\n        p2 = np.array(points[indices[1]])\n        p3 = np.array(points[indices[2]])\n\n        # \u0412\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u0432\u0435\u043a\u0442\u043e\u0440\u043d\u043e\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435\n        v1 = p2 - p1\n        v2 = p3 - p1\n        cross = np.cross(v1, v2)\n        area = np.linalg.norm(cross) / 2\n        if area < area_threshold:  # \u041f\u043e\u0440\u043e\u0433 \u0434\u043b\u044f \u0432\u044b\u0440\u043e\u0436\u0434\u0435\u043d\u043d\u043e\u0441\u0442\u0438\n            return False\n        else:\n            return True\n\n    def ensure_counter_clockwise(points, indices):\n        \"\"\"\u041e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0435\u0442 \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u0432\u0435\u0440\u0448\u0438\u043d \u043f\u0440\u043e\u0442\u0438\u0432 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u0441\u0442\u0440\u0435\u043b\u043a\u0438\"\"\"\n        return indices\n        # \u043d\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442, \u0445\u043e\u0442\u044f \u0432\u0441\u0435 \u043f\u0435\u0440\u0435\u0432\u0435\u043b\u0438 \u0432 \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0438, \u043d\u0430\u0432\u0435\u0440\u043d\u043e\u0435 \u0437\u0440\u044f\n        if len(indices) < 3:\n            return indices\n        \n        # \u0411\u0435\u0440\u0435\u043c \u043f\u0435\u0440\u0432\u044b\u0435 \u0442\u0440\u0438 \u0442\u043e\u0447\u043a\u0438\n        p0 = points[indices[0]]\n        p1 = points[indices[1]]\n        p2 = points[indices[2]]\n        \n        # \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043d\u043e\u0440\u043c\u0430\u043b\u044c\n        v1 = [p1[0]-p0[0], p1[1]-p0[1], p1[2]-p0[2]]\n        v2 = [p2[0]-p0[0], p2[1]-p0[1], p2[2]-p0[2]]\n        \n        # \u0412\u0435\u043a\u0442\u043e\u0440\u043d\u043e\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435\n        normal = [\n            v1[1]*v2[2] - v1[2]*v2[1],\n            v1[2]*v2[0] - v1[0]*v2[2],\n            v1[0]*v2[1] - v1[1]*v2[0]\n        ]\n        # \u0415\u0441\u043b\u0438 \u043d\u043e\u0440\u043c\u0430\u043b\u044c \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0430 \u0432\u043d\u0438\u0437 (Z \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439), \u0440\u0430\u0437\u0432\u043e\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u043c \u043f\u043e\u0440\u044f\u0434\u043e\u043a\n        if normal[2] < 0:\n            return list(reversed(indices))\n        \n        return indices\n\n    def are_points_collinear(points, epsilon=1e-6):\n        \"\"\"\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442, \u043a\u043e\u043b\u043b\u0438\u043d\u0435\u0430\u0440\u043d\u044b \u043b\u0438 \u0442\u043e\u0447\u043a\u0438\"\"\"\n        if len(points) < 3:\n            return True\n            \n        p0, p1, p2 = points[:3]\n        \n        # \u0412\u0435\u043a\u0442\u043e\u0440\u044b\n        v1 = [p1[0]-p0[0], p1[1]-p0[1], p1[2]-p0[2]]\n        v2 = [p2[0]-p0[0], p2[1]-p0[1], p2[2]-p0[2]]\n        \n        # \u0412\u0435\u043a\u0442\u043e\u0440\u043d\u043e\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435\n        cross = [\n            v1[1]*v2[2] - v1[2]*v2[1],\n            v1[2]*v2[0] - v1[0]*v2[2],\n            v1[0]*v2[1] - v1[1]*v2[0]\n        ]\n        \n        # \u0415\u0441\u043b\u0438 \u0432\u0435\u043a\u0442\u043e\u0440\u043d\u043e\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0431\u043b\u0438\u0437\u043a\u043e \u043a \u043d\u0443\u043b\u044e\n        length = (cross[0]**2 + cross[1]**2 + cross[2]**2)**0.5\n        return length < epsilon\n        #return abs(cross[0]) < epsilon and abs(cross[1]) < epsilon and abs(cross[2]) < epsilon\n\n    def triangulate_polygon_simple(points, indices):\n        \"\"\"\u041f\u0440\u043e\u0441\u0442\u0430\u044f \u0442\u0440\u0438\u0430\u043d\u0433\u0443\u043b\u044f\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u043f\u0443\u043a\u043b\u044b\u0445 \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432\"\"\"\n        triangles = []\n        n = len(indices)\n        \n        if n < 3:\n            return triangles\n            \n        for i in range(1, n-1):\n            area = ensure_area(points, [indices[0], indices[i], indices[i+1]])\n            if area:\n                triangles.append([indices[0], indices[i], indices[i+1]])\n\n        return triangles\n\n    # \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0435\u0439 \u0434\u043b\u044f \u043e\u0434\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n    def create_geometry_entities_for_object(verts, polys, start_index, obj_index, max_faces, geometry_type=\"BREP\"):\n        \"\"\"\n        \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0435\u0439 IFC \u0434\u043b\u044f \u043e\u0434\u043d\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n        \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 geometry_type: \"BREP\" \u0438\u043b\u0438 \"MESH\"\n        \"\"\"\n        entities = []\n        current_index = start_index\n        \n        obj_data = {\n            'point_indices': [],\n            'face_indices': [],\n            'shell_index': None,\n            'brep_index': None,\n            'shape_rep_index': None,\n            'next_index': current_index,\n            'mesh_indices': [],\n            'geom_set_indices': []\n        }\n        \n        # 1. \u041e\u0427\u0418\u0421\u0422\u041a\u0410 \u0432\u0435\u0440\u0448\u0438\u043d: \u0443\u0434\u0430\u043b\u044f\u0435\u043c \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u044b \u0438 NaN\n        unique_verts = []\n        unique_indices = {}\n        \n        for i, vert in enumerate(verts):\n            if i >= max_faces:\n                break\n                \n            try:\n                x, y, z = float(vert[0]), float(vert[1]), float(vert[2])\n                if not (math.isfinite(x) and math.isfinite(y) and math.isfinite(z)):\n                    continue\n                    \n                key = (round(x*1000, 3), round(y*1000, 3), round(z*1000, 3))\n                \n                if key not in unique_indices:\n                    unique_indices[key] = len(unique_verts)\n                    unique_verts.append((x, y, z))\n                    \n            except (ValueError, IndexError):\n                continue\n        \n        # 2. \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0442\u043e\u0447\u043a\u0438 \n        to_triangle = []\n        for x, y, z in unique_verts:\n            x_mm = x * 1000.0\n            y_mm = y * 1000.0\n            z_mm = z * 1000.0\n            entities.append(f\"#{current_index}=IFCCARTESIANPOINT(({x_mm:.3f},{y_mm:.3f},{z_mm:.3f}));\")\n            if geometry_type != \"BREP\":\n                to_triangle.append((round(x_mm,3),round(y_mm,3),round(z_mm,3)))\n            obj_data['point_indices'].append(current_index)\n            current_index += 1\n        \n        # 3. \u0412\u0430\u043b\u0438\u0434\u0430\u0446\u0438\u044f \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432 (\u0431\u0435\u0437 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439)\n        valid_polys = []\n        for poly in polys[:max_faces]:\n            if len(poly) < 3:\n                continue\n                \n            valid_poly = []\n            for idx in poly:\n                if idx < len(verts):\n                    vert = verts[idx]\n                    key = (round(vert[0]*1000, 3), round(vert[1]*1000, 3), round(vert[2]*1000, 3))\n                    if key in unique_indices:\n                        new_idx = unique_indices[key]\n                        if new_idx not in valid_poly:\n                            valid_poly.append(new_idx)\n            \n            if len(valid_poly) >= 3:\n                if not are_points_collinear([unique_verts[i] for i in valid_poly[:3]]):\n                    valid_poly = ensure_counter_clockwise(verts, valid_poly)\n                    valid_polys.append(valid_poly)\n        \n        # 4. \u0412\u044b\u0431\u043e\u0440 \u0442\u0438\u043f\u0430 \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u0438\n        if geometry_type == \"BREP\":\n            entities_part, obj_data = create_brep_geometry(entities, obj_data, unique_verts, valid_polys, current_index)\n        else:  # MESH\n            entities_part, obj_data = create_triangulated_mesh_geometry(entities, obj_data, unique_verts, valid_polys, to_triangle, current_index)\n        \n        entities = entities_part\n        current_index = obj_data['next_index']\n        \n        return \"\\n\".join(entities) + \"\\n\", obj_data\n\n\n    def create_brep_geometry(entities, obj_data, unique_verts, valid_polys, current_index):\n        \"\"\"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u0438 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 FacetedBrep (\u043e\u0431\u043e\u043b\u043e\u0447\u043a\u0438 \u0438\u0437 \u0433\u0440\u0430\u043d\u0435\u0439)\"\"\"\n        \n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0438 \u0434\u043b\u044f FacetedBrep\n        for poly in valid_polys:\n            triangles = triangulate_polygon_simple(unique_verts, poly)\n            \n            for tri in triangles:\n                if len(tri) != 3:\n                    continue\n                    \n                # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0432\u0441\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u044b \u0432\u0430\u043b\u0438\u0434\u043d\u044b\n                if all(idx < len(obj_data['point_indices']) for idx in tri):\n                    point_refs = \",\".join([f\"#{obj_data['point_indices'][idx]}\" for idx in tri])\n                    entities.append(f\"#{current_index}=IFCPOLYLOOP(({point_refs}));\")\n                    poly_index = current_index\n                    current_index += 1\n                    \n                    entities.append(f\"#{current_index}=IFCFACEOUTERBOUND(#{poly_index},.U.);\")\n                    face_bound_index = current_index\n                    current_index += 1\n                    \n                    entities.append(f\"#{current_index}=IFCFACE((#{face_bound_index}));\")\n                    obj_data['face_indices'].append(current_index)\n                    current_index += 1\n        \n        # \u0415\u0441\u043b\u0438 \u043d\u0435\u0442 \u0433\u0440\u0430\u043d\u0435\u0439, \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0442\u0435\u0442\u0440\u0430\u044d\u0434\u0440\n        if not obj_data['face_indices'] and len(obj_data['point_indices']) >= 4:\n            tetra_faces = [\n                [0, 1, 2],\n                [0, 2, 3],\n                [0, 3, 1],\n                [1, 3, 2]\n            ]\n            \n            for face in tetra_faces:\n                if all(idx < len(obj_data['point_indices']) for idx in face):\n                    point_refs = \",\".join([f\"#{obj_data['point_indices'][idx]}\" for idx in face])\n                    entities.append(f\"#{current_index}=IFCPOLYLOOP(({point_refs}));\")\n                    poly_index = current_index\n                    current_index += 1\n                    \n                    entities.append(f\"#{current_index}=IFCFACEOUTERBOUND(#{poly_index},.U.);\")\n                    face_bound_index = current_index\n                    current_index += 1\n                    \n                    entities.append(f\"#{current_index}=IFCFACE((#{face_bound_index}));\")\n                    obj_data['face_indices'].append(current_index)\n                    current_index += 1\n        \n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u0434\u043b\u044f BREP\n        if obj_data['face_indices']:\n            if len(obj_data['face_indices']) >= 4:\n                face_refs = \",\".join([f\"#{idx}\" for idx in obj_data['face_indices']])\n                entities.append(f\"#{current_index}=IFCCLOSEDSHELL(({face_refs}));\")\n                obj_data['shell_index'] = current_index\n                current_index += 1\n                \n                entities.append(f\"#{current_index}=IFCFACETEDBREP(#{obj_data['shell_index']});\")\n                obj_data['brep_index'] = current_index\n                current_index += 1\n                \n                entities.append(f\"#{current_index}=IFCSHAPEREPRESENTATION(#12,'Body','Brep',(#{obj_data['brep_index']}));\")\n                obj_data['shape_rep_index'] = current_index\n                current_index += 1\n        \n        obj_data['next_index'] = current_index\n        return entities, obj_data\n\n    def create_triangulated_mesh_geometry(entities, obj_data, unique_verts, valid_polys, to_triangle, current_index):\n        \"\"\"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u0438 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 TriangulatedFaceSet (IFC4)\"\"\"\n        \n        # \u0421\u043e\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0438\n        all_triangles = []\n        \n        for poly in valid_polys:\n            triangles = triangulate_polygon_simple(unique_verts, poly)\n            for tri in triangles:\n                if len(tri) == 3 and all(idx < len(obj_data['point_indices']) for idx in tri):\n                    all_triangles.append(tri)\n        \n        # \u0415\u0441\u043b\u0438 \u043d\u0435\u0442 \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432, \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0442\u0435\u0442\u0440\u0430\u044d\u0434\u0440\n        if not all_triangles and len(obj_data['point_indices']) >= 4:\n            tetra_faces = [\n                [0, 1, 2],\n                [0, 2, 3],\n                [0, 3, 1],\n                [1, 3, 2]\n            ]\n            for face in tetra_faces:\n                if all(idx < len(obj_data['point_indices']) for idx in face):\n                    all_triangles.append(face)\n        \n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c IfcTriangulatedFaceSet\n        if all_triangles:\n            # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0432\u0441\u0435 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u044b \u0442\u043e\u0447\u0435\u043a, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0435 \u0432 \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\u0445\n            used_indices = set()\n            for tri in all_triangles:\n                used_indices.update(tri)\n            sorted_indices = sorted(used_indices)\n            \n            # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u0430\u0440\u0442\u0443 \u043f\u0435\u0440\u0435\u0438\u043d\u0434\u0435\u043a\u0441\u0430\u0446\u0438\u0438 (\u0441\u0442\u0430\u0440\u044b\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 -> \u043d\u043e\u0432\u044b\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 \u0432 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u043d\u043e\u043c \u0441\u043f\u0438\u0441\u043a\u0435)\n            remap = {old_idx: new_idx for new_idx, old_idx in enumerate(sorted_indices)}\n            \n            # 1. \u0421\u043e\u0437\u0434\u0430\u0435\u043c IfcCartesianPointList3D \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438 \u0432 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435\n            coord_refs = []\n            for idx in sorted_indices:\n                coord_refs.append(f\"#{obj_data['point_indices'][idx]}\")\n            \n            #entities.append(f\"#{current_index}=IFCCARTESIANPOINTLIST3D(({','.join(coord_refs)}));\")\n            entities.append(f\"#{current_index}=IFCCARTESIANPOINTLIST3D({tuple(to_triangle)});\")\n            point_list_idx = current_index\n            current_index += 1\n            \n            # 2. \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0441\u043f\u0438\u0441\u043e\u043a \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432 \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 ((i1,i2,i3),...)\n            tri_indices_list = []\n            for tri in all_triangles:\n                # \u041f\u0435\u0440\u0435\u0438\u043d\u0434\u0435\u043a\u0441\u0438\u0440\u0443\u0435\u043c \u0442\u043e\u0447\u043a\u0438\n                t1, t2, t3 = remap[tri[0]], remap[tri[1]], remap[tri[2]]\n                tri_indices_list.append(f\"({t1},{t2},{t3})\")\n            \n            tri_indices_str = \",\".join(tri_indices_list)\n            \n            # 3. \u0421\u043e\u0437\u0434\u0430\u0435\u043c IfcTriangulatedFaceSet\n            # \u0412\u0410\u0416\u041d\u041e: \u0414\u043b\u044f IFC4 TriangulatedFaceSet \u043d\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442 IfcFace, \u044d\u0442\u043e \u043f\u0440\u044f\u043c\u043e\u0439 GeometricRepresentationItem tri_indices_str\n            entities.append(f\"#{current_index}=IFCTRIANGULATEDFACESET(#{point_list_idx},$,$,({tri_indices_str}),$,$);\")\n            mesh_idx = current_index\n            obj_data['mesh_indices'].append(mesh_idx)\n            current_index += 1\n            \n            # 4. \u0421\u043e\u0437\u0434\u0430\u0435\u043c IfcShapeRepresentation \u0441 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u043c \u0442\u0438\u043f\u043e\u043c 'Tessellation'\n            entities.append(f\"#{current_index}=IFCSHAPEREPRESENTATION(#12,'Body','Tessellation',(#{mesh_idx}));\")\n            obj_data['shape_rep_index'] = current_index\n            current_index += 1\n        \n        obj_data['next_index'] = current_index\n        return entities, obj_data\n\n\n    # \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043f\u043e\u043b\u043d\u043e\u0433\u043e IFC \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u0430 \u0434\u043b\u044f \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    def generate_ifc_content_multiple(objects_data, base_obj_name,max_faces):\n        \"\"\"\u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043f\u043e\u043b\u043d\u043e\u0433\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e IFC \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\"\"\"\n        timestamp = int(datetime.now().timestamp())\n        iso_date = datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\")\n        \n        # \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c GUID \u0434\u043b\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0445 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n        project_guid = create_guid(num=22)\n        site_guid = create_guid(num=22)\n        building_guid = create_guid(num=22)\n        storey_guid = create_guid(num=22)\n\n        # \u0421\u043e\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0438\n        all_entities = []\n        element_data = []  # \u0414\u0430\u043d\u043d\u044b\u0435 \u043e\u0431 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u0445 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u0439\n        current_index = 16  # \u041d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u043f\u043e\u0441\u043b\u0435 \u0431\u0430\u0437\u043e\u0432\u044b\u0445 \u0441\u0443\u0449\u043d\u043e\u0441\u0442\u0435\u0439\n        \n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u044e \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n        for obj_idx, obj_data in enumerate(objects_data):\n            verts = obj_data['vertices']\n            polys = obj_data['polygons']\n            obj_name = f\"{base_obj_name}_{obj_idx + 1}\"\n            \n            # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0433\u0435\u043e\u043c\u0435\u0442\u0440\u0438\u044e \u0434\u043b\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n            geometry_str, obj_geometry_data = create_geometry_entities_for_object(\n                verts, polys, current_index, obj_idx,max_faces, geometry_type\n            )\n            \n            all_entities.append(geometry_str)\n            \n            # \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n            if obj_geometry_data.get('shape_rep_index'):\n                element_data.append({\n                    'name': obj_name,\n                    'guid': create_guid(num=22),\n                    'shape_rep_index': obj_geometry_data['shape_rep_index'],\n                    'next_index': obj_geometry_data['next_index']\n                })\n                current_index = obj_geometry_data['next_index']\n        \n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b (IfcBuildingElementProxy)\n        element_entities = []\n        index_IFCBUILDINGSTOREY = current_index+2+len(element_data)*2\n        for elem in element_data:\n            # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0444\u043e\u0440\u043c\u044b\n            elem_guid = create_guid(num=22)\n            additional_guid = create_guid(num=36)\n            shape_def_index = current_index\n            element_entities.append(f\"#{shape_def_index}=IFCPRODUCTDEFINITIONSHAPE($,$,(#{elem['shape_rep_index']}));\")\n            current_index += 1\n            # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n            element_entities.append(f\"#{current_index}=IFCBUILDINGELEMENTPROXY('{elem_guid}',#5,'{elem['name']}',$,$,$,#{shape_def_index},'{additional_guid}',$);\")\n            elem['element_index'] = current_index\n            elem['guid'] = elem_guid  # \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c GUID\n            current_index += 1\n        #print(len(element_entities))\n        # \u0424\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u043c \u043f\u043e\u043b\u043d\u044b\u0439 IFC \u0444\u0430\u0439\u043b\n        filename = f\"{base_obj_name}.ifc\"\n        site_name = clean_ascii_string(f\"Site_{base_obj_name}\")\n        building_name = clean_ascii_string(f\"Building_{base_obj_name}\")\n        storey_name = \"Level_0\"\n        allen = \"\\n\".join(all_entities)\n        elen = \"\\n\".join(element_entities)\n        \n        ifc_content = f\"\"\"ISO-10303-21;\nHEADER;\nFILE_DESCRIPTION(('ViewDefinition [CoordinationView]'),'2;1');\nFILE_NAME('{filename}','{iso_date}',(''),(''),'Sverchok IFC Export','','');\nFILE_SCHEMA(('IFC4'));\nENDSEC;\nDATA;\n#1=IFCPERSON($,'Sverchok User',$,$,$,$,$,$);\n#2=IFCORGANIZATION($,'Sverchok BIM Export',$,$,$);\n#3=IFCPERSONANDORGANIZATION(#1,#2,$);\n#4=IFCAPPLICATION(#2,'1.0','Sverchok IFC Exporter','Sverchok');\n#5=IFCOWNERHISTORY(#3,#4,$,.ADDED.,$,$,$,{timestamp});\n#6=IFCCARTESIANPOINT((0.,0.,0.));\n#7=IFCDIRECTION((0.,0.,1.));\n#8=IFCDIRECTION((1.,0.,0.));\n#9=IFCAXIS2PLACEMENT3D(#6,#7,#8);\n#10=IFCDIRECTION((0.,1.));\n#11=IFCAXIS2PLACEMENT2D(#6,#10);\n#12=IFCGEOMETRICREPRESENTATIONCONTEXT($,'Model',3,1.E-05,#9,$);\n#13=IFCGEOMETRICREPRESENTATIONCONTEXT($,'Plan',2,1.E-05,#11,$);\n#14=IFCPROJECT('{project_guid}',#5,'{base_obj_name} Project',$,$,$,$,(#12,#13),$);\n\n\n{allen}\n\n{elen}\n\n#{current_index+0}=IFCSITE('{site_guid}',#5,'{site_name}',$,$,$,$,$,.ELEMENT.,$,$,$,$,$);\n#{current_index+1}=IFCBUILDING('{building_guid}',#5,'{building_name}',$,$,$,$,$,.ELEMENT.,$,$,$);\n#{current_index+2}=IFCBUILDINGSTOREY('{storey_guid}',#5,'{storey_name}',$,$,$,$,$,.ELEMENT.,0.);\"\"\"\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u044f\n        element_indices = \",\".join([f\"#{elem['element_index']}\" for elem in element_data])\n        rel_guid1 = create_guid(num=22)\n        rel_guid2 = create_guid(num=22)\n        rel_guid3 = create_guid(num=22)\n        rel_guid4 = create_guid(num=22)\n\n        relations = f\"\"\"\n        #{current_index+3}=IFCRELAGGREGATES('{rel_guid1}',#5,$,$,#14,(#{current_index+0}));\n        #{current_index+4}=IFCRELAGGREGATES('{rel_guid2}',#5,$,$,#{current_index+0},(#{current_index+1}));\n        #{current_index+5}=IFCRELAGGREGATES('{rel_guid3}',#5,$,$,#{current_index+1},(#{current_index+2}));\n        #{current_index+6}=IFCRELCONTAINEDINSPATIALSTRUCTURE('{rel_guid4}',#5,$,$,({element_indices}),#{current_index+2});\"\"\"\n        \n        ifc_content += relations + \"\\nENDSEC;\\nEND-ISO-10303-21;\"\n        \n        return ifc_content\n    \n    # \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\n    try:\n        # \u041f\u043e\u0434\u0433\u043e\u0442\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n        objects_data = []\n        for i in range(num_objects):\n            # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0443 \u043d\u0430\u0441 \u0435\u0441\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n            if i < len(vertices_list) and i < len(polygons_list):\n                objects_data.append({\n                    'vertices': vertices_list[i],\n                    'polygons': polygons_list[i]\n                })\n            else:\n                print(f\"\u26a0 \u041f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435: \u043d\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u043b\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u0430 {i}\")\n\n        \n        # \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0443\u0442\u044c \u0434\u043b\u044f \u0444\u0430\u0439\u043b\u0430\n        if not base_filepath.lower().endswith('.ifc'):\n            final_filepath = base_filepath + '.ifc'\n        else:\n            final_filepath = base_filepath\n        \n        # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044e\n        os.makedirs(os.path.dirname(os.path.abspath(final_filepath)), exist_ok=True)\n        # \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 IFC\n        ifc_content = generate_ifc_content_multiple(objects_data, base_object_name,max_faces)\n        \n        # \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0444\u0430\u0439\u043b\n        with open(final_filepath, 'w', encoding='utf-8') as f:\n            f.write(ifc_content)\n        \n        # \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e\n        print(f\"\u2713 IFC \u0444\u0430\u0439\u043b \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0441\u043e\u0437\u0434\u0430\u043d:\")\n        print(f\"  \u041f\u0443\u0442\u044c: {final_filepath}\")\n        print(f\"  \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432: {num_objects}\")\n        print(f\"  \u0411\u0430\u0437\u043e\u0432\u043e\u0435 \u0438\u043c\u044f: {base_object_name}\")\n        \n        # \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043f\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430\u043c\n        for i, obj_data in enumerate(objects_data):\n            print(f\"  \u041e\u0431\u044a\u0435\u043a\u0442 {i+1}: {len(obj_data['vertices'])} \u0432\u0435\u0440\u0448\u0438\u043d, {len(obj_data['polygons'])} \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"\u2717 \u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 IFC \u0444\u0430\u0439\u043b\u0430:\")\n        print(f\"  \u041e\u0448\u0438\u0431\u043a\u0430: {str(e)}\")\n        import traceback\n        traceback.print_exc()\n        return False\n"}, "inputs": {"vertices": {"bl_idname": "SvVerticesSocket", "name": "vertices"}, "polygons": {"bl_idname": "SvStringsSocket", "name": "polygons"}, "filepath": {"bl_idname": "SvFilePathSocket", "name": "filepath"}, "object_name": {"bl_idname": "SvStringsSocket", "name": "object_name"}, "max_faces": {"bl_idname": "SvStringsSocket", "name": "max_faces", "properties": {"use_prop": true, "default_property_type": "int", "default_int_property": 10000}}, "area_threshold": {"bl_idname": "SvStringsSocket", "name": "area_threshold", "properties": {"use_prop": true, "default_float_property": 9.999999747378752e-06}}}, "bl_idname": "SvScriptNodeLite"}, "File Path": {"attributes": {"location": [1600.0, 280.0], "label": "filepath"}, "properties": {"files": [{"name": "SVERCHOK.ifc"}], "directory": "\\", "files_num": 1}, "outputs": {"File Path": {"bl_idname": "SvFilePathSocket", "name": "File Path"}}, "bl_idname": "SvFilePathNode"}, "Simple Text": {"attributes": {"location": [1600.0, 160.0], "color": [1.0, 0.8993440270423889, 0.9742509722709656], "use_custom_color": true}, "properties": {"text_prop": "Chair"}, "inputs": {"Text": {"bl_idname": "SvStringsSocket", "name": "Text", "properties": {"prop_name": "text_prop"}}}, "outputs": {"Text": {"bl_idname": "SvStringsSocket", "name": "Text"}}, "bl_idname": "SvSimpleTextNodeMK2"}, "Viewer Draw": {"attributes": {"location": [2060.0, 400.0], "color": [0.6284880042076111, 0.931007981300354, 1.0], "use_custom_color": true}, "inputs": {"Vertices": {"bl_idname": "SvVerticesSocket", "name": "Vertices", "properties": {"custom_draw": "draw_property_socket"}}, "Edges": {"bl_idname": "SvStringsSocket", "name": "Edges", "properties": {"custom_draw": "draw_property_socket"}}, "Polygons": {"bl_idname": "SvStringsSocket", "name": "Polygons"}, "Matrix": {"bl_idname": "SvMatrixSocket", "name": "Matrix"}, "Vector Color": {"bl_idname": "SvColorSocket", "name": "Vector Color", "properties": {"custom_draw": "draw_color_socket", "prop_name": "vector_color"}}, "Edge Color": {"bl_idname": "SvColorSocket", "name": "Edge Color", "properties": {"custom_draw": "draw_color_socket", "prop_name": "edge_color"}}, "Polygon Color": {"bl_idname": "SvColorSocket", "name": "Polygon Color", "properties": {"custom_draw": "draw_color_socket", "prop_name": "polygon_color"}}, "attrs": {"bl_idname": "SvStringsSocket", "name": "attrs", "attributes": {"hide": true}, "properties": {"quick_link_to_node": "SvVDAttrsNodeMk2"}}}, "bl_idname": "SvViewerDrawMk4"}, "Cricket": {"attributes": {"location": [1600.0, 400.0], "color": [0.9200000166893005, 0.9200000166893005, 0.9200000166893005], "use_custom_color": true}, "inputs": {"Scale": {"bl_idname": "SvStringsSocket", "name": "Scale", "properties": {"prop_name": "cricket_scale"}}}, "outputs": {"Vertices": {"bl_idname": "SvVerticesSocket", "name": "Vertices"}, "Faces": {"bl_idname": "SvStringsSocket", "name": "Faces"}}, "bl_idname": "SvCricketNode"}}, "links": [{"from_node": "Cricket", "from_socket": "Vertices", "to_node": "Scripted Node Lite", "to_socket": "vertices"}, {"from_node": "Cricket", "from_socket": "Faces", "to_node": "Scripted Node Lite", "to_socket": "polygons"}, {"from_node": "File Path", "from_socket": "File Path", "to_node": "Scripted Node Lite", "to_socket": "filepath"}, {"from_node": "Simple Text", "from_socket": "Text", "to_node": "Scripted Node Lite", "to_socket": "object_name"}, {"from_node": "Cricket", "from_socket": "Vertices", "to_node": "Viewer Draw", "to_socket": "Vertices"}, {"from_node": "Cricket", "from_socket": "Faces", "to_node": "Viewer Draw", "to_socket": "Polygons"}]}}